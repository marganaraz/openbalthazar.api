[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/* Open, ESQ LLC \r\n\r\nThis Ethereum smart contract mints 1 CYPHR token for 0.001 ether -- up to 1000 tokens (1 ether \u039E).\r\n\r\nNo warranties are made with regard to these scarce digital artifacts (other than intrinsic radness).\r\n\r\nCYPHR generated hereby reference the IPFS hash of \u0022A Cypherpunk\u0027s Manifesto,\u0022\r\nincluded below:\r\n\r\n/*\r\n                   A Cypherpunk\u0027s Manifesto\r\n\r\n                        by Eric Hughes\r\n\r\nPrivacy is necessary for an open society in the electronic age.\r\nPrivacy is not secrecy.  A private matter is something one doesn\u0027t\r\nwant the whole world to know, but a secret matter is something one\r\ndoesn\u0027t want anybody to know. Privacy is the power to selectively\r\nreveal oneself to the world.  \r\n\r\nIf two parties have some sort of dealings, then each has a memory of\r\ntheir interaction.  Each party can speak about their own memory of\r\nthis; how could anyone prevent it?  One could pass laws against it,\r\nbut the freedom of speech, even more than privacy, is fundamental to\r\nan open society; we seek not to restrict any speech at all.  If many\r\nparties speak together in the same forum, each can speak to all the\r\nothers and aggregate together knowledge about individuals and other\r\nparties.  The power of electronic communications has enabled such\r\ngroup speech, and it will not go away merely because we might want it\r\nto.\r\n\r\nSince we desire privacy, we must ensure that each party to a\r\ntransaction have knowledge only of that which is directly necessary\r\nfor that transaction.  Since any information can be spoken of, we\r\nmust ensure that we reveal as little as possible.  In most cases\r\npersonal identity is not salient. When I purchase a magazine at a\r\nstore and hand cash to the clerk, there is no need to know who I am. \r\nWhen I ask my electronic mail provider to send and receive messages,\r\nmy provider need not know to whom I am speaking or what I am saying\r\nor what others are saying to me;  my provider only need know how to\r\nget the message there and how much I owe them in fees.  When my\r\nidentity is revealed by the underlying mechanism of the transaction,\r\nI have no privacy.  I cannot here selectively reveal myself; I must\r\n_always_ reveal myself.\r\n\r\nTherefore, privacy in an open society requires anonymous transaction\r\nsystems.  Until now, cash has been the primary such system.  An\r\nanonymous transaction system is not a secret transaction system.  An\r\nanonymous system empowers individuals to reveal their identity when\r\ndesired and only when desired; this is the essence of privacy.\r\n\r\nPrivacy in an open society also requires cryptography.  If I say\r\nsomething, I want it heard only by those for whom I intend it.  If \r\nthe content of my speech is available to the world, I have no\r\nprivacy.  To encrypt is to indicate the desire for privacy, and to\r\nencrypt with weak cryptography is to indicate not too much desire for\r\nprivacy.  Furthermore, to reveal one\u0027s identity with assurance when\r\nthe default is anonymity requires the cryptographic signature.\r\n\r\nWe cannot expect governments, corporations, or other large, faceless\r\norganizations to grant us privacy out of their beneficence.  It is to\r\ntheir advantage to speak of us, and  we should expect that they will\r\nspeak.  To try to prevent their speech is to fight against the\r\nrealities of information. Information does not just want to be free,\r\nit longs to be free.  Information expands to fill the available\r\nstorage space.  Information is Rumor\u0027s younger, stronger cousin;\r\nInformation is fleeter of foot, has more eyes, knows more, and\r\nunderstands less than Rumor.\r\n\r\nWe must defend our own privacy if we expect to have any.  We must\r\ncome together and create systems which allow anonymous transactions\r\nto take place.  People have been defending their own privacy for\r\ncenturies with whispers, darkness, envelopes, closed doors, secret\r\nhandshakes, and couriers.  The technologies of the past did not allow\r\nfor strong privacy, but electronic technologies do.\r\n\r\nWe the Cypherpunks are dedicated to building anonymous systems.  We\r\nare defending our privacy with cryptography, with anonymous mail\r\nforwarding systems, with digital signatures, and with electronic\r\nmoney.\r\n\r\nCypherpunks write code.  We know that someone has to write software\r\nto defend privacy, and since we can\u0027t get privacy unless we all do,\r\nwe\u0027re going to write it. We publish our code so that our fellow\r\nCypherpunks may practice and play with it. Our code is free for all\r\nto use, worldwide.  We don\u0027t much care if you don\u0027t approve of the\r\nsoftware we write.  We know that software can\u0027t be destroyed and that\r\na widely dispersed system can\u0027t be shut down. \r\n\r\nCypherpunks deplore regulations on cryptography, for encryption is\r\nfundamentally a private act.  The act of encryption, in fact, removes\r\ninformation from the public realm.  Even laws against cryptography\r\nreach only so far as a nation\u0027s border and the arm of its violence.\r\nCryptography will ineluctably spread over the whole globe, and with\r\nit the anonymous transactions systems that it makes possible. \r\n\r\nFor privacy to be widespread it must be part of a social contract.\r\nPeople must come and together deploy these systems for the common\r\ngood.  Privacy only extends so far as the cooperation of one\u0027s\r\nfellows in society.  We the Cypherpunks seek your questions and your\r\nconcerns and hope we may engage you so that we do not deceive\r\nourselves.  We will not, however, be moved out of our course because\r\nsome may disagree with our goals.\r\n\r\nThe Cypherpunks are actively engaged in making the networks safer for\r\nprivacy.  Let us proceed together apace.\r\n\r\nOnward.\r\n\r\nEric Hughes\r\n\u003Chughes@soda.berkeley.edu\u003E\r\n\r\n9 March 1993\r\n*/\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor () internal { }\r\n\t// solhint-disable-previous-line no-empty-blocks\r\n\r\n\tfunction _msgSender() internal view returns (address payable) {\r\n    \treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view returns (bytes memory) {\r\n    \tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    \treturn msg.data;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n \t* @dev Returns the addition of two unsigned integers, reverting on\r\n \t* overflow.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n \t*\r\n \t* Requirements:\r\n \t* - Addition cannot overflow.\r\n \t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \tuint256 c = a \u002B b;\r\n    \trequire(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n    \treturn c;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the subtraction of two unsigned integers, reverting on\r\n \t* overflow (when the result is negative).\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n \t*\r\n \t* Requirements:\r\n \t* - Subtraction cannot overflow.\r\n \t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \treturn sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n \t* overflow (when the result is negative).\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n \t*\r\n \t* Requirements:\r\n \t* - Subtraction cannot overflow.\r\n \t*\r\n \t* NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n \t* @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n \t*/\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    \trequire(b \u003C= a, errorMessage);\r\n    \tuint256 c = a - b;\r\n\r\n    \treturn c;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the multiplication of two unsigned integers, reverting on\r\n \t* overflow.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n \t*\r\n \t* Requirements:\r\n \t* - Multiplication cannot overflow.\r\n \t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \t// Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n    \t// benefit is lost if \u0027b\u0027 is also tested.\r\n    \t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    \tif (a == 0) {\r\n        \treturn 0;\r\n    \t}\r\n\r\n    \tuint256 c = a * b;\r\n    \trequire(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n    \treturn c;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the integer division of two unsigned integers. Reverts on\r\n \t* division by zero. The result is rounded towards zero.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n \t* \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n \t* uses an invalid opcode to revert (consuming all remaining gas).\r\n \t*\r\n \t* Requirements:\r\n \t* - The divisor cannot be zero.\r\n \t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \treturn div(a, b, \u0022SafeMath: division by zero\u0022);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n \t* division by zero. The result is rounded towards zero.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n \t* \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n \t* uses an invalid opcode to revert (consuming all remaining gas).\r\n \t*\r\n \t* Requirements:\r\n \t* - The divisor cannot be zero.\r\n \t* NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n \t* @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n \t*/\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    \t// Solidity only automatically asserts when dividing by 0\r\n    \trequire(b \u003E 0, errorMessage);\r\n    \tuint256 c = a / b;\r\n    \t// assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n    \treturn c;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n \t* Reverts when dividing by zero.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n \t* opcode (which leaves remaining gas untouched) while Solidity uses an\r\n \t* invalid opcode to revert (consuming all remaining gas).\r\n \t*\r\n \t* Requirements:\r\n \t* - The divisor cannot be zero.\r\n \t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \treturn mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n \t* Reverts with custom message when dividing by zero.\r\n \t*\r\n \t* Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n \t* opcode (which leaves remaining gas untouched) while Solidity uses an\r\n \t* invalid opcode to revert (consuming all remaining gas).\r\n \t*\r\n \t* Requirements:\r\n \t* - The divisor cannot be zero.\r\n \t*\r\n \t* NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n \t* @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n \t*/\r\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    \trequire(b != 0, errorMessage);\r\n    \treturn a % b;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n \t* @dev Returns the amount of tokens in existence.\r\n \t*/\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n \t* @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n \t*/\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n \t* @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n \t*\r\n \t* Returns a boolean value indicating whether the operation succeeded.\r\n \t*\r\n \t* Emits a {Transfer} event.\r\n \t*/\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n \t* @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n \t* allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n \t* zero by default.\r\n \t*\r\n \t* This value changes when {approve} or {transferFrom} are called.\r\n \t*/\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t/**\r\n \t* @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n \t*\r\n \t* Returns a boolean value indicating whether the operation succeeded.\r\n \t*\r\n \t* IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n \t* that someone may use both the old and the new allowance by unfortunate\r\n \t* transaction ordering. One possible solution to mitigate this race\r\n \t* condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n \t* desired value afterwards:\r\n \t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n \t*\r\n \t* Emits an {Approval} event.\r\n \t*/\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n \t* @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n \t* allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n \t* allowance.\r\n \t*\r\n \t* Returns a boolean value indicating whether the operation succeeded.\r\n \t*\r\n \t* Emits a {Transfer} event.\r\n \t*/\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n \t* @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n \t* another (\u0060to\u0060).\r\n \t*\r\n \t* Note that \u0060value\u0060 may be zero.\r\n \t*/\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n \t* @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n \t* a call to {approve}. \u0060value\u0060 is the new allowance.\r\n \t*/\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping (address =\u003E uint256) private _balances;\r\n\r\n\tmapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n\tuint256 private _totalSupply;\r\n\r\n\t/**\r\n \t* @dev See {IERC20-totalSupply}.\r\n \t*/\r\n\tfunction totalSupply() public view returns (uint256) {\r\n    \treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {IERC20-balanceOf}.\r\n \t*/\r\n\tfunction balanceOf(address account) public view returns (uint256) {\r\n    \treturn _balances[account];\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {IERC20-transfer}.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060recipient\u0060 cannot be the zero address.\r\n \t* - the caller must have a balance of at least \u0060amount\u0060.\r\n \t*/\r\n\tfunction transfer(address recipient, uint256 amount) public returns (bool) {\r\n    \t_transfer(_msgSender(), recipient, amount);\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {IERC20-allowance}.\r\n \t*/\r\n\tfunction allowance(address owner, address spender) public view returns (uint256) {\r\n    \treturn _allowances[owner][spender];\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {IERC20-approve}.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060spender\u0060 cannot be the zero address.\r\n \t*/\r\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\r\n    \t_approve(_msgSender(), spender, amount);\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {IERC20-transferFrom}.\r\n \t*\r\n \t* Emits an {Approval} event indicating the updated allowance. This is not\r\n \t* required by the EIP. See the note at the beginning of {ERC20};\r\n \t*\r\n \t* Requirements:\r\n \t* - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\r\n \t* - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n \t* - the caller must have allowance for \u0060sender\u0060\u0027s tokens of at least\r\n \t* \u0060amount\u0060.\r\n \t*/\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n    \t_transfer(sender, recipient, amount);\r\n    \t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \u0022ERC20: transfer amount exceeds allowance\u0022));\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\r\n \t*\r\n \t* This is an alternative to {approve} that can be used as a mitigation for\r\n \t* problems described in {IERC20-approve}.\r\n \t*\r\n \t* Emits an {Approval} event indicating the updated allowance.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060spender\u0060 cannot be the zero address.\r\n \t*/\r\n\tfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    \t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\r\n \t*\r\n \t* This is an alternative to {approve} that can be used as a mitigation for\r\n \t* problems described in {IERC20-approve}.\r\n \t*\r\n \t* Emits an {Approval} event indicating the updated allowance.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060spender\u0060 cannot be the zero address.\r\n \t* - \u0060spender\u0060 must have allowance for the caller of at least\r\n \t* \u0060subtractedValue\u0060.\r\n \t*/\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    \t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \u0022ERC20: decreased allowance below zero\u0022));\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\r\n \t*\r\n \t* This is internal function is equivalent to {transfer}, and can be used to\r\n \t* e.g. implement automatic token fees, slashing mechanisms, etc.\r\n \t*\r\n \t* Emits a {Transfer} event.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060sender\u0060 cannot be the zero address.\r\n \t* - \u0060recipient\u0060 cannot be the zero address.\r\n \t* - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n \t*/\r\n\tfunction _transfer(address sender, address recipient, uint256 amount) internal {\r\n    \trequire(sender != address(0), \u0022ERC20: transfer from the zero address\u0022);\r\n    \trequire(recipient != address(0), \u0022ERC20: transfer to the zero address\u0022);\r\n\r\n    \t_balances[sender] = _balances[sender].sub(amount, \u0022ERC20: transfer amount exceeds balance\u0022);\r\n    \t_balances[recipient] = _balances[recipient].add(amount);\r\n    \temit Transfer(sender, recipient, amount);\r\n\t}\r\n\r\n\t/** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n \t* the total supply.\r\n \t*\r\n \t* Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\r\n \t*\r\n \t* Requirements\r\n \t*\r\n \t* - \u0060to\u0060 cannot be the zero address.\r\n \t*/\r\n\tfunction _mint(address account, uint256 amount) internal {\r\n    \trequire(account != address(0), \u0022ERC20: mint to the zero address\u0022);\r\n\r\n    \t_totalSupply = _totalSupply.add(amount);\r\n    \t_balances[account] = _balances[account].add(amount);\r\n    \temit Transfer(address(0), account, amount);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\r\n \t* total supply.\r\n \t*\r\n \t* Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\r\n \t*\r\n \t* Requirements\r\n \t*\r\n \t* - \u0060account\u0060 cannot be the zero address.\r\n \t* - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n \t*/\r\n\tfunction _burn(address account, uint256 amount) internal {\r\n    \trequire(account != address(0), \u0022ERC20: burn from the zero address\u0022);\r\n\r\n    \t_balances[account] = _balances[account].sub(amount, \u0022ERC20: burn amount exceeds balance\u0022);\r\n    \t_totalSupply = _totalSupply.sub(amount);\r\n    \temit Transfer(account, address(0), amount);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\r\n \t*\r\n \t* This is internal function is equivalent to \u0060approve\u0060, and can be used to\r\n \t* e.g. set automatic allowances for certain subsystems, etc.\r\n \t*\r\n \t* Emits an {Approval} event.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060owner\u0060 cannot be the zero address.\r\n \t* - \u0060spender\u0060 cannot be the zero address.\r\n \t*/\r\n\tfunction _approve(address owner, address spender, uint256 amount) internal {\r\n    \trequire(owner != address(0), \u0022ERC20: approve from the zero address\u0022);\r\n    \trequire(spender != address(0), \u0022ERC20: approve to the zero address\u0022);\r\n\r\n    \t_allowances[owner][spender] = amount;\r\n    \temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\r\n \t* from the caller\u0027s allowance.\r\n \t*\r\n \t* See {_burn} and {_approve}.\r\n \t*/\r\n\tfunction _burnFrom(address account, uint256 amount) internal {\r\n    \t_burn(account, amount);\r\n    \t_approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \u0022ERC20: burn amount exceeds allowance\u0022));\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\ncontract ERC20Burnable is Context, ERC20 {\r\n\t/**\r\n \t* @dev Destroys \u0060amount\u0060 tokens from the caller.\r\n \t*\r\n \t* See {ERC20-_burn}.\r\n \t*/\r\n\tfunction burn(uint256 amount) public {\r\n    \t_burn(_msgSender(), amount);\r\n\t}\r\n\r\n\t/**\r\n \t* @dev See {ERC20-_burnFrom}.\r\n \t*/\r\n\tfunction burnFrom(address account, uint256 amount) public {\r\n    \t_burnFrom(account, amount);\r\n\t}\r\n}\r\n\r\n/*\r\n * ERC20 Token representing signatures to Cypherpunk Manifesto\r\n */\r\ncontract CYPHRtoken is ERC20Burnable {\r\n\tstring public name = \u0022QmRKvmFWDGE4tAf9Xa4HVLZ5FVpxNmtaUcP5dwg2h6XqPM\u0022; // IPFS Hash for Manifesto Copy\r\n\tstring public symbol = \u0022CYPHR\u0022;\r\n\tuint8 public decimals = 0;\r\n\tuint256 public cap = 1000; // \u00221000\u0022 CYPHR Cap Limit\r\n\tuint256 public fee = 1000000000000000; // \u00220.001\u0022 ether (\u039E) rate for 1 CYPHR\r\n\taddress payable public beneficiary = 0xBBE222Ef97076b786f661246232E41BE0DFf6cc4; // address to receive contributed ether (\u039E)\r\n\r\n\t/**\r\n\t* @dev See \u0060ERC20._mint\u0060.\r\n \t* \r\n \t* Public function to contribute ether (\u039E) and receive CYPHR\r\n \t*/\r\n\tfunction mint() public payable returns (bool) {\r\n    \trequire(msg.value == fee);\r\n    \tbeneficiary.transfer(msg.value);\r\n    \t_mint(msg.sender, 1);\r\n    \treturn true;\r\n\t}\r\n    \r\n\t/**\r\n \t* @dev See \u0060ERC20Mintable.mint\u0060.\r\n \t*\r\n \t* Requirements:\r\n \t*\r\n \t* - \u0060value\u0060 must not cause the total supply to go over the cap.\r\n \t*/\r\n\tfunction _mint(address account, uint256 value) internal {\r\n    \trequire(totalSupply().add(value) \u003C= cap, \u0022ERC20Capped: cap exceeded\u0022);\r\n    \tsuper._mint(account, value);\r\n\t}\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022mint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cap\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022beneficiary\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022addedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseAllowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022burn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022burnFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022subtractedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseAllowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022fee\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"CYPHRtoken","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a8e4a71b1201548fd629df7ffe82165ac3c08a4fd050e8daed68a1c4024c95a7"}]