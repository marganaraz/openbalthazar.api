[{"SourceCode":"{\u0022BlackJack.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\u0022./CroupierRole.sol\\\u0022;\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\n\\r\\ncontract BlackJack is CroupierRole {\\r\\n    using SafeMath for *;\\r\\n\\r\\n    uint constant THIS_DIVISOR = 1000;\\r\\n    uint constant LOCK_RATIO = 2500;\\r\\n    uint8 constant MAX_CUT_CARD = 15;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e uint256) private _locked;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _last_apply_time;\\r\\n    mapping (address =\\u003e uint256) private _apply_amount;\\r\\n\\r\\n    uint256 private _totalBalance = 0;\\r\\n\\r\\n    uint256 public expireBlocks = 255;\\r\\n    uint256 public statedPeriod = 30 minutes;\\r\\n    uint256 public maxBet = 1 ether;\\r\\n    uint256 public minBet = 0.1 ether;\\r\\n    uint256 public feeRatio = 10;\\r\\n\\r\\n    struct Bet {\\r\\n        // gambler\\u0027s address, 20 bytes.\\r\\n        address gambler;\\r\\n        // cut card position, the number range is 0-15.\\r\\n        uint8 cutCard;\\r\\n        // gambler\\u0027s action list, per 4-bit representing an action, push-down storage.\\r\\n        /**\\r\\n        * action encoding rules:\\r\\n        * 0 - reserved\\r\\n        * 1 - Get\\r\\n        * 2 - Hit\\r\\n        * 3 - Stand\\r\\n        * 4 - Double\\r\\n        * 5 - Split\\r\\n        * 6 - Insurance\\r\\n        * 7 - Surrender\\r\\n        * 8 - timeout\\r\\n         */\\r\\n        bytes11 actions;\\r\\n        // betting amount, 128 bits number is enough.\\r\\n        uint128 amount;\\r\\n        // block number of deal.\\r\\n        uint128 dealBlockNumber;\\r\\n    }\\r\\n\\r\\n    mapping (uint256 =\\u003e Bet) public bets;\\r\\n\\r\\n    event Deposit(address indexed from, uint256 value);\\r\\n    event Withdraw(address indexed from, uint256 value);\\r\\n    event Apply(address indexed from, uint256 value);\\r\\n    event Deal(uint256 indexed commit);\\r\\n    event Settle(uint256 indexed commit);\\r\\n    event Refund(uint256 indexed commit, uint128 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev constructor\\r\\n     */\\r\\n    constructor() public payable{        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Fallback function. It\\u0027s another entry for deposit. While owner transfer ether to \\r\\n    *      this contract, it means increase the pot.\\r\\n     */\\r\\n    function () public payable {\\r\\n        if(!isOwner(msg.sender)){\\r\\n            _deposit(msg.sender, msg.value);\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Total number of tokens deposit by gamblers.\\r\\n    * @return An uint256 representing the total amount owned by gamblers.\\r\\n    */\\r\\n    function totalBalance() public view returns (uint256) {\\r\\n        return _totalBalance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the balance of specified address.\\r\\n    * @param owner The address to query the balance of.\\r\\n    * @return An uint256 representing the amount owned by the passed address.\\r\\n    */\\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        return _balances[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the locked value of specified address.\\r\\n    * @param owner The address to query the locked amount of.\\r\\n    * @return An uint256 representing the amount locked by the passed address.\\r\\n    */\\r\\n    function lockedOf(address owner) public view returns (uint256) {\\r\\n        return _locked[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the last apply-withdraw time of specified address.\\r\\n    * @param owner The address to query the last apply time of.\\r\\n    * @return An uint256 representing the last apply time by the passed address.\\r\\n    */\\r\\n    function lastApplyTime(address owner) public view returns (uint256) {\\r\\n        return _last_apply_time[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the apply-withdraw amount of specified address.\\r\\n    * @param owner The address to query the apply amount of.\\r\\n    * @return An uint256 representing the apply amount by the passed address.\\r\\n    */\\r\\n    function applyAmount(address owner) public view returns (uint256) {\\r\\n        return _apply_amount[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deal action to start a new game with proxy mode, submit by croupier bot.\\r\\n    * @param gambler gambler\\u0027s address.\\r\\n    * @param commit generated by keccak of 2 256-bit reveals, used to unique identify a deck.\\r\\n    *               gambler get commit but don\\u0027t know the deck, dealer can\\u0027t change the deck because of keccak is one-way irreversible.\\r\\n    * @param amount 128-bit number of bet amount.\\r\\n    * @param cutCard cut card position, gambler set it after receive the commit, so this process can guarantee fairness.\\r\\n    * @param v \\r\\n    * @param r \\r\\n    * @param s v, r,s are components of ECDSA signature. Ensure the deck is signed by the gambler himself.\\r\\n     */\\r\\n    function deal(address gambler, uint256 commit, uint128 amount, uint8 cutCard, uint8 v, bytes32 r, bytes32 s) \\r\\n        public \\r\\n        onlyCroupier\\r\\n    {\\r\\n        // verify signature.\\r\\n        bytes32 signatureHash = keccak256(abi.encodePacked(amount, cutCard, commit));        \\r\\n        require (gambler == ecrecover(signatureHash, v, r, s), \\\u0022ECDSA signature is not valid.\\\u0022);\\r\\n\\r\\n        _dealCore(gambler, commit, amount, cutCard);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Settle a deck by croupier.\\r\\n    * @param reveal_1 Per byte of 1-26 bytes in reveal_1, reveal_2 representing a single card, 2 256-bit reveal combine a 52 cards deck. \\r\\n    * Single card coding rules:\\r\\n    * low 4-bit : 0001-1010 points of single card(1-10).\\r\\n    * 5-6 bit   : suit, 00 - spades, 01 - hearts, 10 - clubs, 11 - diamonds.\\r\\n    * 7-8 bit   : face cards, 00 - 10, 01 - Jack, 10 - Queen, 11 - King.\\r\\n    * @param reveal_2 same as reveal_1.\\r\\n    * @param actions gambler\\u0027s actions.\\r\\n    * @param win true - gambler win, false - lose.\\r\\n    * @param amount winnings or losses amount.\\r\\n     */\\r\\n    function settle(uint256 reveal_1, uint256 reveal_2, bytes11 actions, bool win, uint128 amount) \\r\\n        public \\r\\n        onlyCroupier \\r\\n    {\\r\\n        uint commit = uint(keccak256(abi.encodePacked(reveal_1, reveal_2)));\\r\\n        Bet storage bet = bets[commit];\\r\\n\\r\\n        // verify commit.\\r\\n        address gambler = bet.gambler;\\r\\n        uint256 value = uint256(bet.amount);\\r\\n        require(gambler != address(0) \\u0026\\u0026 value \\u003e 0, \\\u0022Bet should be in \\u0027active\\u0027 state.\\\u0022);\\r\\n\\r\\n        // verify bet is not expired.\\r\\n        require(block.number \\u003e bet.dealBlockNumber, \\\u0022Settle in the same block as placeBet, or before.\\\u0022);\\r\\n        require(block.number \\u003c= uint256(bet.dealBlockNumber).add(expireBlocks), \\\u0022Bet expired.\\\u0022);        \\r\\n\\r\\n        // Store actions.\\r\\n        bet.actions = actions;\\r\\n        bet.amount = 0;\\r\\n\\r\\n        // unlock.\\r\\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);\\r\\n        _locked[gambler] = _locked[gambler].sub(lockValue);\\r\\n\\r\\n        // calculate balance.\\r\\n        if(win) {\\r\\n            _balances[gambler] = _balances[gambler].add(uint256(amount));\\r\\n            _totalBalance = _totalBalance.add(uint256(amount));\\r\\n        }\\r\\n        else{\\r\\n            _balances[gambler] = _balances[gambler].sub(uint256(amount));\\r\\n            _totalBalance = _totalBalance.sub(uint256(amount));\\r\\n        }\\r\\n\\r\\n        emit Settle(commit);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Refund a commit while it\\u0027s expired.\\r\\n    * @param commit which one bet been refunded.\\r\\n     */\\r\\n    function refund(uint256 commit) public onlyCroupier {\\r\\n        // Verify that bet is in \\u0027active\\u0027 state.\\r\\n        Bet storage bet = bets[commit];\\r\\n        uint256 value = uint256(bet.amount);\\r\\n        address gambler = bet.gambler;\\r\\n        require(gambler != address(0) \\u0026\\u0026 value \\u003e 0, \\\u0022Bet should be in \\u0027active\\u0027 state.\\\u0022);\\r\\n\\r\\n        // Verify that bet has already expired.\\r\\n        require (block.number \\u003e uint256(bet.dealBlockNumber).add(expireBlocks), \\\u0022Bet not yet expired.\\\u0022);\\r\\n\\r\\n        //unlock.\\r\\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);  \\r\\n        _locked[gambler] = _locked[gambler].sub(lockValue);\\r\\n\\r\\n        bet.amount = 0;\\r\\n\\r\\n        emit Refund(commit, uint128(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deposit in this contract.\\r\\n     */\\r\\n    function deposit() public payable returns (bool){\\r\\n        _deposit(msg.sender, msg.value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev apply for withdrawal.\\r\\n    * @param amount the amount to apply for withdrawal, should be less than balance subtract locked.\\r\\n     */\\r\\n    function apply(uint256 amount) public returns (bool){\\r\\n        require(amount \\u003c= _balances[msg.sender].sub(_locked[msg.sender]), \\\u0022Not enough balance.\\\u0022);\\r\\n\\r\\n        _last_apply_time[msg.sender] = now;\\r\\n        _apply_amount[msg.sender] = amount;\\r\\n\\r\\n        emit Apply(msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Withdraw from this contract. Should apply at first, and withdraw after the stated apply period.\\r\\n     */\\r\\n    function withdraw() public returns (bool){\\r\\n        require(_apply_amount[msg.sender] \\u003e 0, \\\u0022\\\u0022);\\r\\n        require(now \\u003e= _last_apply_time[msg.sender].add(statedPeriod), \\\u0022\\\u0022);\\r\\n\\r\\n        _withdraw(msg.sender, _apply_amount[msg.sender]);\\r\\n\\r\\n        _apply_amount[msg.sender] = 0;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Withdraw all by croupier in special cases, such as contract upgrade.\\r\\n    * @param from The address to withdraw.\\r\\n     */\\r\\n    function withdrawProxy(address from) public onlyCroupier returns(bool) {        \\r\\n        uint256 amount = balanceOf(from);\\r\\n        _withdraw(from, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deposit for a specified address, internal function.\\r\\n    * @param from The address to deposit.\\r\\n    * @param value The amount to be deposited. \\r\\n     */\\r\\n    function _deposit(address from, uint256 value) internal {\\r\\n        require(from != address(0), \\\u0022Invalid address.\\\u0022);\\r\\n\\r\\n        _balances[from] = _balances[from].add(value);\\r\\n        _totalBalance = _totalBalance.add(value);\\r\\n        emit Deposit(from, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Withdraw for a specified address, internal function. Due to house edge of blackjack can\\u0027t cover the cost of gas, \\r\\n    *      platform charges 1% fee while withdraw.  \\r\\n    * @param from The address to withdraw.\\r\\n    * @param value The amount to be withdrawed, should be less than balance subtract locked, and this contract can afford. \\r\\n     */\\r\\n    function _withdraw(address from, uint256 value) internal {\\r\\n        require(from != address(0), \\\u0022Invalid address.\\\u0022);\\r\\n        require(value \\u003c= _balances[from].sub(_locked[from]), \\\u0022Not enough balance.\\\u0022);\\r\\n\\r\\n        _balances[from] = _balances[from].sub(value);\\r\\n        _totalBalance = _totalBalance.sub(value);        \\r\\n        \\r\\n        uint256 fee = value.mul(feeRatio).div(THIS_DIVISOR);\\r\\n        require(value.sub(fee) \\u003c= address(this).balance, \\\u0022Can\\u0027t afford.\\\u0022);\\r\\n        from.transfer(value.sub(fee));\\r\\n        \\r\\n        emit Withdraw(from, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Check uint256-uint128 type conversion is safe\\r\\n     */\\r\\n    function _safeTypeConversion(uint256 a, uint128 b) internal pure returns(bool) {\\r\\n        require(a == uint256(b) \\u0026\\u0026 uint128(a) == b, \\\u0022Not safe type conversion.\\\u0022);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deal action core.\\r\\n     */\\r\\n    function _dealCore(address gambler, uint256 commit, uint128 amount, uint8 cutCard) internal {\\r\\n        // verify commit is \\\u0022Clean\\\u0022.\\r\\n        Bet storage bet = bets[commit];\\r\\n        require(bet.gambler == address(0), \\\u0022Bet should be in \\u0027clean\\u0027 state.\\\u0022);\\r\\n\\r\\n        // verify cut card position.\\r\\n        require(cutCard \\u003c= MAX_CUT_CARD, \\\u0022Cut card position is not valid.\\\u0022);\\r\\n    \\r\\n        //verify bet amount range.\\r\\n        uint256 value = uint256(amount);\\r\\n        require(_safeTypeConversion(value, amount), \\\u0022Not safe type conversion\\\u0022);\\r\\n\\r\\n        require(value \\u003e= minBet \\u0026\\u0026 value \\u003c= maxBet, \\\u0022Bet amount is out of range.\\\u0022);\\r\\n\\r\\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);        \\r\\n        require(lockValue \\u003c= balanceOf(gambler).sub(lockedOf(gambler)), \\\u0022Balance is not enough for locked.\\\u0022);\\r\\n\\r\\n        // Store bet parameters on blockchain.\\r\\n        _locked[gambler] = _locked[gambler].add(lockValue);\\r\\n\\r\\n        bet.gambler = gambler;\\r\\n        bet.cutCard = cutCard;\\r\\n        bet.amount = amount;\\r\\n        bet.dealBlockNumber = uint128(block.number);\\r\\n\\r\\n        emit Deal(commit);        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Set max bet amount.\\r\\n    * @param input in wei.\\r\\n     */\\r\\n    function setMaxBet(uint256 input) public onlyOwner {\\r\\n        maxBet = input;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Set min bet amount.\\r\\n    * @param input in wei.\\r\\n     */\\r\\n    function setMinBet(uint256 input) public onlyOwner {\\r\\n        minBet = input;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Set fee ratio.\\r\\n    * @param input new fee ratio, div by 1000.\\r\\n     */\\r\\n    function setFeeRatio(uint256 input) public onlyOwner {\\r\\n        feeRatio = input;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Set expiration blocks.\\r\\n    * @param input new number of expiration blocks.\\r\\n     */\\r\\n    function setExpireBlocks(uint256 input) public onlyOwner {\\r\\n        expireBlocks = input;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Set stated apply period.\\r\\n    * @param input new number of stated apply period.\\r\\n     */\\r\\n    function setStatedPeriod(uint256 input) public onlyOwner {\\r\\n        statedPeriod = input;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Withdraw funds to cover costs of operation.\\r\\n    * @param amount should ensure the total balances of palyers.\\r\\n     */\\r\\n    function withdrawFunds(uint256 amount) public onlyOwner {\\r\\n        require(amount \\u003c= address(this).balance.sub(_totalBalance), \\\u0022Not enough funds.\\\u0022);\\r\\n        msg.sender.transfer(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev kill this contract while upgraded.\\r\\n     */\\r\\n    function kill() public onlyOwner {\\r\\n        require(_totalBalance == 0, \\\u0022All of gambler\\u0027s balances need to be withdrawn.\\\u0022);\\r\\n        selfdestruct(msg.sender);\\r\\n    }\\r\\n}\u0022},\u0022CroupierRole.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\u0022./OwnerRole.sol\\\u0022;\\r\\n\\r\\ncontract CroupierRole is OwnerRole{\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event CroupierAdded(address indexed account);\\r\\n    event CroupierRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _croupiers;\\r\\n\\r\\n    constructor () internal {\\r\\n    }\\r\\n\\r\\n    modifier onlyCroupier() {\\r\\n        require(isCroupier(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isCroupier(address account) public view returns (bool) {\\r\\n        return _croupiers.has(account);\\r\\n    }\\r\\n\\r\\n    function addCroupier(address account) public onlyOwner {\\r\\n        _addCroupier(account);\\r\\n    }\\r\\n\\r\\n    function removeCroupier(address account) public onlyOwner {\\r\\n        _removeCroupier(account);\\r\\n    }\\r\\n\\r\\n    function _addCroupier(address account) internal {\\r\\n        _croupiers.add(account);\\r\\n        emit CroupierAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removeCroupier(address account) internal {\\r\\n        _croupiers.remove(account);\\r\\n        emit CroupierRemoved(account);\\r\\n    }\\r\\n}\u0022},\u0022OwnerRole.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\u0022./Roles.sol\\\u0022;\\r\\n\\r\\ncontract OwnerRole {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event OwnerAdded(address indexed account);\\r\\n    event OwnerRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _owners;\\r\\n\\r\\n    constructor () internal {\\r\\n        _addOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return _owners.has(account);\\r\\n    }\\r\\n\\r\\n    function addOwner(address account) public onlyOwner {\\r\\n        _addOwner(account);\\r\\n    }\\r\\n\\r\\n    function removeOwner(address account) public onlyOwner{\\r\\n        _removeOwner(account);\\r\\n    }\\r\\n\\r\\n    function _addOwner(address account) internal {\\r\\n        _owners.add(account);\\r\\n        emit OwnerAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removeOwner(address account) internal {\\r\\n        _owners.remove(account);\\r\\n        emit OwnerRemoved(account);\\r\\n    }\\r\\n}\u0022},\u0022Roles.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an account access to this role\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an account\\u0027s access to this role\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an account has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account) internal view returns (bool) {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\u0022},\u0022SafeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n    * @dev Multiplies two numbers, reverts on overflow.\\r\\n    */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n    */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two numbers, reverts on overflow.\\r\\n    */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a \u002B b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\r\\n    * reverts when dividing by zero.\\r\\n    */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\u0022}}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdrawFunds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setFeeRatio\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022bets\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022gambler\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022cutCard\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022actions\u0022,\u0022type\u0022:\u0022bytes11\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dealBlockNumber\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022commit\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022refund\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022maxBet\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022withdrawProxy\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022feeRatio\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022kill\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addCroupier\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setStatedPeriod\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022gambler\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022commit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022cutCard\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022deal\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022statedPeriod\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMaxBet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMinBet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minBet\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeCroupier\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isCroupier\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022reveal_1\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022reveal_2\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022actions\u0022,\u0022type\u0022:\u0022bytes11\u0022},{\u0022name\u0022:\u0022win\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022settle\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022lockedOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022lastApplyTime\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022applyAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setExpireBlocks\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022apply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022expireBlocks\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Deposit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Withdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Apply\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022commit\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Deal\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022commit\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Settle\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022commit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022Refund\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CroupierAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CroupierRemoved\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnerAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnerRemoved\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"BlackJack","CompilerVersion":"v0.4.24\u002Bcommit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7b9bf810da93ef3d525a8a06e5612d77954fb890d503036e1433feef473bdd58"}]