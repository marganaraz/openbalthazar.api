[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\ncontract CryptoKingdoms\r\n{\r\n    uint public constant gameNumber = 8;\r\n    \r\n    address public constant previousGameAddress = 0x2c8dc01FB73c7079cC8A9e7a339C172Bbf2d3EbC;\r\n    \r\n    address public nextGameAddress;\r\n    \r\n    enum Race\r\n    {\r\n        None,\r\n        Humane\r\n    }\r\n\r\n    struct Kingdom\r\n    {\r\n        Race race;\r\n\r\n        string name;\r\n\r\n        uint actions;\r\n        \r\n        uint gold;\r\n        \r\n        uint soldiers;\r\n        uint spies;\r\n        uint wizards;\r\n        uint dragons;\r\n        \r\n        uint hovels;\r\n        uint miningCamps;\r\n        uint banks;\r\n        uint barracks;\r\n        uint castles;\r\n    }\r\n    \r\n    Kingdom public winner;\r\n    uint winnerPrize;\r\n    \r\n    uint constant defaultJoinDuration = 26 days;\r\n    uint constant defaultGameDuration = 33 days;\r\n    uint constant defaultTurnTime = 11 hours;\r\n    \r\n    uint constant joinGameCost = 0.0225 ether;\r\n    \r\n    uint constant soldierCost = 3;\r\n    uint constant spyCost = 100;\r\n    uint constant wizardCost = 250;\r\n    uint constant dragonCost = 3000;\r\n    uint constant hovelCost = 100;\r\n    uint constant miningCampCost = 1000;\r\n    uint constant bankCost = 1500;\r\n    uint constant barracksCost = 300;\r\n    uint constant castleCost = 15000;\r\n    \r\n    uint constant soldierAttack = 1;\r\n    uint constant spyAttack = 5;\r\n    uint constant wizardAttack = 100;\r\n    uint constant dragonAttack = 500;\r\n    \r\n    uint constant barracksDefence = 5;\r\n    uint constant castleDefence = 1000;\r\n    \r\n    uint constant wizardGoldPerTurn = 20;\r\n    uint constant hovelGoldPerTurn = 5;\r\n    uint constant miningCampGoldPerTurn = 150;\r\n\r\n    uint constant bankedGoldPerUnitGoldPerTurn = 50;\r\n    uint constant bankLimit = 15;\r\n    \r\n    uint constant barracksSoldiersPerTurn = 25;\r\n    uint constant castleSoldiersPerTurn = 50;\r\n    \r\n    uint constant hovelCapacity = 3;\r\n    \r\n    uint constant espionageCost = 25;\r\n    \r\n    address payable[] private players;\r\n    address payable private host;\r\n    \r\n    mapping (address =\u003E Kingdom) private kingdoms;\r\n    \r\n    uint gameTurnTime = defaultTurnTime;\r\n    uint gameDuration = defaultGameDuration;\r\n    uint gameJoinDuration = defaultJoinDuration;\r\n    uint gameTotalTurns;\r\n    uint gameStartTime;\r\n    uint gameEndTime;\r\n    \r\n    uint hostFees;\r\n    \r\n    uint currentTurnNumber;\r\n    uint leaderPlayerIndex;\r\n    uint espionageInformationType;\r\n    \r\n    event turnCompleted();\r\n    event newPlayerJoined(string playerName);\r\n    event attackCompleted(uint goldExchanged, uint soldierDeaths, uint wizardDeaths, uint dragonDeaths);\r\n    event spyReported(string name, uint detail, uint info, uint moreInfo);\r\n    event sabotaged(uint sabotagedGold, uint sabotagedDragons, uint sabotagedHovels, uint sabotagedMiningCamps, uint sabotagedBanks, uint dragonsKilled);\r\n    event hostMessage(string message);\r\n    event gameEnded();\r\n    \r\n    constructor (uint joinTimeSeconds, uint gameTimeSeconds, uint turnTimeSeconds) public\r\n    {\r\n        if (joinTimeSeconds \u003E 0)\r\n        {\r\n            gameJoinDuration = joinTimeSeconds;\r\n        }\r\n        \r\n        if (gameTimeSeconds \u003E 0)\r\n        {\r\n            gameDuration = gameTimeSeconds;\r\n        }\r\n        \r\n        if (turnTimeSeconds \u003E 0)\r\n        {\r\n            gameTurnTime = turnTimeSeconds;\r\n        }\r\n        \r\n        gameStartTime = block.timestamp \u002B gameJoinDuration;\r\n        gameEndTime = gameStartTime \u002B gameDuration;\r\n        gameTotalTurns = (gameDuration / gameTurnTime) \u002B 1; // \u002B1 for the last turn\r\n        host = msg.sender;\r\n    }\r\n    \r\n    function gameStats() public view returns (uint version,\r\n                                              uint numberPlayers,\r\n                                              uint totalGold,\r\n                                              uint totalPrizePool,\r\n                                              uint gameStartTimeSeconds,\r\n                                              uint gameDurationSeconds,\r\n                                              uint gameTurns,\r\n                                              uint gameTurnTimeSeconds,\r\n                                              uint gameCurrentTurn,\r\n                                              uint gameLeaderIndex)\r\n    {\r\n        for (uint playerIndex = 0; playerIndex \u003C players.length; playerIndex\u002B\u002B)\r\n        {\r\n            address playerAddress = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[playerAddress];\r\n            totalGold \u002B= kingdom.gold;\r\n        }\r\n        return (gameNumber, players.length, totalGold, winnerPrize,\r\n                gameStartTime, gameDuration,\r\n                gameTotalTurns, gameTurnTime,\r\n                currentTurnNumber,\r\n                leaderPlayerIndex);\r\n    }\r\n    \r\n    \r\n    //  === Host Functions ===\r\n    \r\n    modifier onlyHost()\r\n    {\r\n        require(msg.sender == host);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfGameStarted()\r\n    {\r\n        require(block.timestamp \u003E gameStartTime);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfTurnTime()\r\n    {\r\n        if (block.timestamp \u003C gameEndTime)\r\n        {\r\n            uint time = block.timestamp;\r\n            uint turnsRemaining = ((gameEndTime - time) / gameTurnTime) \u002B 1; // For game start turn.\r\n            uint blocktimeTurnNumber = gameTotalTurns - turnsRemaining;\r\n            require(currentTurnNumber \u003C blocktimeTurnNumber);\r\n        }\r\n        else\r\n        {\r\n            require(currentTurnNumber \u003C gameTotalTurns);\r\n        }\r\n        _;\r\n    }\r\n    \r\n    // Called by the game host (at most) every gameTurnTime to update the game state and to allow players to progress.\r\n    function turn() public onlyIfGameStarted() onlyIfTurnTime()\r\n    {\r\n        uint turnsToUpdate = 0;\r\n        if (block.timestamp \u003C gameEndTime)\r\n        {\r\n            uint turnsRemaining = ((gameEndTime - block.timestamp) / gameTurnTime) \u002B 1;\r\n            uint blocktimeTurnNumber = gameTotalTurns - turnsRemaining;\r\n            turnsToUpdate = blocktimeTurnNumber - currentTurnNumber;\r\n        }\r\n        else\r\n        {\r\n            turnsToUpdate = gameTotalTurns - currentTurnNumber;\r\n        }\r\n        \r\n        leaderPlayerIndex = 0;\r\n        uint maxPlayerRank = 0;\r\n        \r\n        for (uint playerIndex = 0; playerIndex \u003C players.length; playerIndex\u002B\u002B)\r\n        {\r\n            address player = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[player];\r\n            kingdom.actions \u002B= turnsToUpdate;\r\n            kingdom.gold \u002B= (kingdom.hovels * hovelGoldPerTurn\r\n                           \u002B kingdom.miningCamps * miningCampGoldPerTurn\r\n                           \u002B kingdom.wizards * wizardGoldPerTurn\r\n                           \u002B (kingdom.banks * (kingdom.gold / bankedGoldPerUnitGoldPerTurn))) * turnsToUpdate;\r\n            kingdom.soldiers \u002B= (kingdom.barracks * barracksSoldiersPerTurn \u002B kingdom.castles * castleSoldiersPerTurn) * turnsToUpdate;\r\n            \r\n            uint estimatedPlayerRank = kingdom.gold * ((currentTurnNumber * 100) / (gameTotalTurns * 100))\r\n                                   \u002B ((kingdom.soldiers * soldierCost) \u002B (kingdom.wizards * wizardCost) \u002B (kingdom.dragons * dragonCost)\r\n                                    \u002B (kingdom.hovels * hovelCost) \u002B (kingdom.miningCamps * miningCampCost) \u002B (kingdom.banks * bankCost)\r\n                                    \u002B (kingdom.barracks * barracksCost)) * (gameTotalTurns / 4);\r\n            if (estimatedPlayerRank \u003E maxPlayerRank)\r\n            {\r\n                maxPlayerRank = estimatedPlayerRank;\r\n                leaderPlayerIndex = playerIndex;\r\n            }\r\n        }\r\n        \r\n        currentTurnNumber \u002B= turnsToUpdate;\r\n        \r\n        if (currentTurnNumber == gameTotalTurns)\r\n        {\r\n            endGame();\r\n        }\r\n        \r\n        emit turnCompleted();\r\n    }\r\n    \r\n    function endGame() private\r\n    {\r\n        uint largestGoldAmount = 0;\r\n        address payable winnerAddress;\r\n        for (uint playerIndex = 0; playerIndex \u003C players.length; playerIndex\u002B\u002B)\r\n        {\r\n            address payable playerAddress = players[playerIndex];\r\n            Kingdom storage kingdom = kingdoms[playerAddress];\r\n            if (kingdom.gold \u003E largestGoldAmount)\r\n            {\r\n                largestGoldAmount = kingdom.gold;\r\n                winnerAddress = playerAddress;\r\n            }\r\n        }\r\n        \r\n        winner = kingdoms[winnerAddress];\r\n        winnerAddress.transfer(winnerPrize);\r\n        host.transfer(hostFees);\r\n    }\r\n    \r\n    function setNextGame(address gameAddress) public onlyHost()\r\n    {\r\n        nextGameAddress = gameAddress;\r\n    }\r\n    \r\n    // The game host reserves the right to modify abusive kingdom names.\r\n    function changeKingdomName(uint kingdomIndex, string memory newName) public onlyHost()\r\n    {\r\n        address payable playerAddress = players[kingdomIndex];\r\n        Kingdom storage kingdom = kingdoms[playerAddress];\r\n        kingdom.name = newName;\r\n    }\r\n    \r\n    function message(string memory s) public onlyHost()\r\n    {\r\n        emit hostMessage(s);\r\n    }\r\n    \r\n    \r\n    //  === Player Functions ===\r\n\r\n    modifier onlyIfNewPlayer()\r\n    {\r\n        // No existing kingdom for sender address.\r\n        require(kingdoms[msg.sender].race == Race.None);\r\n        require(currentTurnNumber \u003C gameTotalTurns);\r\n        require(msg.value == joinGameCost);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfTurnsRemaining()\r\n    {\r\n        require(currentTurnNumber \u003C gameTotalTurns);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfValidPlayerIndex(uint playerIndex)\r\n    {\r\n        require(playerIndex \u003C players.length);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfOtherPlayerIndex(uint otherPlayerIndex)\r\n    {\r\n        address otherPlayer = players[otherPlayerIndex];\r\n        require(msg.sender != otherPlayer);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfActions()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.actions \u003E 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfGold(uint goldCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.gold \u003E= goldCost);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfHovels(uint amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.hovels \u003E= ((kingdom.spies \u002B kingdom.wizards \u002B amount) / hovelCapacity));\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfUnderBankLimit(uint amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require((kingdom.banks \u002B amount) \u003C= bankLimit);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfSpies()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.spies \u003E 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfWizards(uint number)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.wizards \u003E 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfDragons()\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        require(kingdom.dragons \u003E 0);\r\n        _;\r\n    }\r\n    \r\n    function joinGame(string memory playerName) public payable onlyIfNewPlayer() onlyIfTurnsRemaining()\r\n    {\r\n        winnerPrize \u002B= (msg.value * 7) / 10;\r\n        hostFees \u002B= (msg.value * 3) / 10;\r\n        \r\n        kingdoms[msg.sender] = Kingdom({\r\n            race: Race.Humane,\r\n            name: playerName,\r\n            actions: currentTurnNumber,\r\n            gold: 1320 \u002B (currentTurnNumber * hovelGoldPerTurn * 5),\r\n            soldiers: 25,\r\n            spies: 0,\r\n            wizards: 0,\r\n            dragons: 0,\r\n            hovels: 3,\r\n            miningCamps: 1,\r\n            banks: 0,\r\n            barracks: 0,\r\n            castles: 0\r\n        });\r\n        \r\n        players.push(msg.sender);\r\n        \r\n        emit newPlayerJoined(playerName);\r\n    }\r\n\r\n    function playerStats() public view\r\n             returns (Race race, string memory kingdomName, uint actions, uint gold,\r\n                      uint soldiers, uint spies, uint wizards, uint dragons,\r\n                      uint hovels, uint miningCamps, uint banks, uint barracks, uint castles)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        return (kingdom.race, kingdom.name, kingdom.actions, kingdom.gold,\r\n                kingdom.soldiers, kingdom.spies, kingdom.wizards, kingdom.dragons,\r\n                kingdom.hovels, kingdom.miningCamps, kingdom.banks, kingdom.barracks, kingdom.castles);\r\n    }\r\n    \r\n    function playerAtIndex(uint playerIndex) public view\r\n             onlyIfValidPlayerIndex(playerIndex)\r\n             returns (string memory playerName)\r\n    {\r\n        address playerAddress = players[playerIndex];\r\n        Kingdom storage kingdom = kingdoms[playerAddress];\r\n        return kingdom.name;\r\n    }\r\n    \r\n    // === Player Actions ===\r\n\r\n    function recruitSoldiers(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * soldierCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * soldierCost;\r\n        kingdom.soldiers \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function recruitSpies(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * spyCost) onlyIfHovels(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * spyCost;\r\n        kingdom.spies \u002B= amount;\r\n    }\r\n    \r\n    function summonWizards(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * wizardCost) onlyIfHovels(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * wizardCost;\r\n        kingdom.wizards \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n    \r\n    function trainDragons(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * dragonCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * dragonCost;\r\n        kingdom.dragons \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildHovels(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * hovelCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * hovelCost;\r\n        kingdom.hovels \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildBarracks(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * barracksCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * barracksCost;\r\n        kingdom.barracks \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildMiningCamps(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * miningCampCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * miningCampCost;\r\n        kingdom.miningCamps \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n    \r\n    function buildBanks(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * bankCost) onlyIfUnderBankLimit(amount)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * bankCost;\r\n        kingdom.banks \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function buildCastles(uint amount) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfGold(amount * castleCost)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= amount * castleCost;\r\n        kingdom.castles \u002B= amount;\r\n        kingdom.actions -= 1;\r\n    }\r\n\r\n    function attack(uint targetPlayerIndex, uint numberOfSoldiers) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage attackingKingdom = kingdoms[msg.sender];\r\n        require(attackingKingdom.soldiers \u003E= numberOfSoldiers);\r\n        \r\n        address targetPlayer = players[targetPlayerIndex];        \r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        uint goldExchanged = 0;\r\n        \r\n        uint randomValue = (uint(keccak256(abi.encodePacked(block.timestamp))) \u003C\u003C 2) \u003E\u003E ((block.timestamp / 9753) % 7);\r\n\r\n        uint attackForce = numberOfSoldiers         * soldierAttack\r\n                         \u002B attackingKingdom.spies   * spyAttack\r\n                         \u002B attackingKingdom.wizards * wizardAttack\r\n                         \u002B attackingKingdom.dragons * dragonAttack\r\n                         \u002B 1;\r\n        attackForce *= 100 \u002B (randomValue % 10);\r\n        attackForce /= 100;\r\n\r\n        uint defenceForce = defendingKingdom.soldiers * soldierAttack\r\n                          \u002B defendingKingdom.spies    * spyAttack\r\n                          \u002B defendingKingdom.wizards  * wizardAttack\r\n                          \u002B defendingKingdom.dragons  * dragonAttack\r\n                          \u002B defendingKingdom.barracks * barracksDefence\r\n                          \u002B defendingKingdom.castles  * castleDefence\r\n                          \u002B 1;\r\n        \r\n        uint attackingArmySoldierDeaths = 0;\r\n        uint attackingArmyWizardDeaths = 0;\r\n        uint attackingArmyDragonsDeaths = 0;\r\n        \r\n        if (attackForce \u003E defenceForce)\r\n        {\r\n            // Victory\r\n            \r\n            goldExchanged = (defenceForce * defendingKingdom.gold * 1000000) / (attackForce * 2000000);\r\n            \r\n            attackingArmySoldierDeaths = (defenceForce * numberOfSoldiers * 1000000) / (attackForce * 3000000);\r\n            \r\n            if (defendingKingdom.gold \u003C goldExchanged)\r\n            {\r\n                goldExchanged = defendingKingdom.gold;\r\n            }\r\n            defendingKingdom.gold -= goldExchanged;\r\n            defendingKingdom.soldiers -= (defenceForce * defendingKingdom.soldiers * 1000000) / (attackForce * 4000000);\r\n            \r\n            goldExchanged \u002B= randomValue % (currentTurnNumber * 3); // We found this along the way!\r\n            attackingKingdom.gold \u002B= goldExchanged;\r\n            attackingKingdom.soldiers -= attackingArmySoldierDeaths;\r\n        }\r\n        else\r\n        {\r\n            // Defeat\r\n            \r\n            defendingKingdom.soldiers -= (attackForce * defendingKingdom.soldiers * 250000) / (defenceForce * 1000000);\r\n            \r\n            if (numberOfSoldiers \u003E 0)\r\n            {\r\n                attackingArmySoldierDeaths = randomValue % numberOfSoldiers;\r\n                attackingKingdom.soldiers -= attackingArmySoldierDeaths;\r\n            }\r\n        }\r\n        \r\n        if (goldExchanged \u003E 0 || attackingArmySoldierDeaths \u003E 0)\r\n        {\r\n            if ((numberOfSoldiers * soldierAttack) \u003C // Whirlwind Attack\r\n                ((attackingKingdom.spies * spyAttack) \u002B (attackingKingdom.wizards * wizardAttack) \u002B (attackingKingdom.dragons * dragonAttack)))\r\n            {\r\n                attackingArmyWizardDeaths = attackingKingdom.wizards / ((randomValue % 5) \u002B 4);\r\n                attackingArmyDragonsDeaths = attackingKingdom.dragons / ((randomValue % 3) \u002B 3);\r\n            }\r\n            else\r\n            {\r\n                attackingArmyWizardDeaths = attackingKingdom.wizards / ((randomValue % 6) \u002B 6);\r\n                attackingArmyDragonsDeaths = attackingKingdom.dragons / ((randomValue % 9) \u002B 7);\r\n            }\r\n            attackingKingdom.wizards -= attackingArmyWizardDeaths;\r\n            attackingKingdom.dragons -= attackingArmyDragonsDeaths;\r\n        \r\n            defendingKingdom.wizards -= defendingKingdom.wizards  / ((randomValue % 7) \u002B 6);\r\n            defendingKingdom.dragons -= defendingKingdom.dragons / ((randomValue % 9) \u002B 9);\r\n        }\r\n        \r\n        attackingKingdom.actions -= 1;\r\n        \r\n        emit attackCompleted(goldExchanged, attackingArmySoldierDeaths, attackingArmyWizardDeaths, attackingArmyDragonsDeaths);\r\n    }\r\n\r\n    function espionage(uint targetPlayerIndex) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfSpies() onlyIfActions() onlyIfGold(espionageCost) onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage kingdom = kingdoms[msg.sender];\r\n        kingdom.gold -= espionageCost;\r\n        \r\n        address targetPlayer = players[targetPlayerIndex];        \r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        if (kingdom.spies * 2 \u003E defendingKingdom.spies)\r\n        {\r\n            // Success\r\n            \r\n            uint infoType = (currentTurnNumber \u002B espionageInformationType) % 3;\r\n            if (infoType == 0)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 1, defendingKingdom.gold, defendingKingdom.dragons);\r\n            }\r\n            else if (infoType == 1)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 2, defendingKingdom.soldiers, defendingKingdom.banks);\r\n            }\r\n            else if (infoType == 2)\r\n            {\r\n                emit spyReported(defendingKingdom.name, 3, defendingKingdom.miningCamps, defendingKingdom.castles);\r\n            }\r\n            \r\n            espionageInformationType\u002B\u002B;\r\n        }\r\n        else\r\n        {\r\n            // Failure\r\n            \r\n            emit spyReported(defendingKingdom.name, 0, kingdom.spies, 0);\r\n        }\r\n    }\r\n\r\n    function sabotage(uint targetPlayerIndex) public\r\n             onlyIfGameStarted() onlyIfTurnsRemaining() onlyIfActions() onlyIfDragons() onlyIfOtherPlayerIndex(targetPlayerIndex)\r\n    {\r\n        Kingdom storage attackingKingdom = kingdoms[msg.sender];\r\n\r\n        address targetPlayer = players[targetPlayerIndex];\r\n        Kingdom storage defendingKingdom = kingdoms[targetPlayer];\r\n        \r\n        uint attackForce = attackingKingdom.dragons;\r\n        uint defenceForce = defendingKingdom.dragons \u002B defendingKingdom.castles;\r\n        if (attackForce \u003E defenceForce)\r\n        {\r\n            // Victory\r\n            \r\n            uint sabotagedFraction = ((attackForce * 3) / (defenceForce \u002B 1)) \u002B 2;\r\n            uint sabotagedGold = defendingKingdom.gold / (sabotagedFraction * 3);\r\n            uint sabotagedDragons = defendingKingdom.dragons / (sabotagedFraction * 4);\r\n            uint sabotagedHovels = defendingKingdom.hovels / (sabotagedFraction * 5);\r\n            uint sabotagedMiningCamps = defendingKingdom.miningCamps / sabotagedFraction;\r\n            uint sabotagedBanks = defendingKingdom.banks / (sabotagedFraction * 5);\r\n            defendingKingdom.gold -= sabotagedGold;\r\n            defendingKingdom.dragons -= sabotagedDragons;\r\n            defendingKingdom.hovels -= sabotagedHovels;\r\n            defendingKingdom.miningCamps -= sabotagedMiningCamps;\r\n            defendingKingdom.banks -= sabotagedBanks;\r\n            \r\n            uint dragonsKilled = sabotagedDragons * 3 \u002B 2;\r\n            if (dragonsKilled \u003E attackingKingdom.dragons)\r\n            {\r\n                dragonsKilled = attackingKingdom.dragons;\r\n            }\r\n            attackingKingdom.dragons -= dragonsKilled;\r\n            \r\n            emit sabotaged(sabotagedGold, sabotagedDragons, sabotagedHovels, sabotagedMiningCamps, sabotagedBanks, dragonsKilled);\r\n        }\r\n        else\r\n        {\r\n            // Defeat\r\n            \r\n            uint dragonsKilled = attackingKingdom.dragons / 20 \u002B 1;\r\n            attackingKingdom.dragons -= dragonsKilled;\r\n            \r\n            if (defendingKingdom.dragons \u003C dragonsKilled)\r\n            {\r\n                defendingKingdom.dragons = 0;\r\n            }\r\n            else\r\n            {\r\n                defendingKingdom.dragons -= dragonsKilled;\r\n            }\r\n            \r\n            emit sabotaged(0, dragonsKilled, 0, 0, 0, dragonsKilled);\r\n        }\r\n        \r\n        attackingKingdom.actions -= 1;\r\n    }\r\n}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022joinTimeSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameTimeSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022turnTimeSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022goldExchanged\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022soldierDeaths\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022wizardDeaths\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dragonDeaths\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022attackCompleted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gameEnded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022hostMessage\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022playerName\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022newPlayerJoined\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sabotagedGold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sabotagedDragons\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sabotagedHovels\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sabotagedMiningCamps\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sabotagedBanks\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dragonsKilled\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022sabotaged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022detail\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022info\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022moreInfo\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022spyReported\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022turnCompleted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022targetPlayerIndex\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numberOfSoldiers\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022attack\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buildBanks\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buildBarracks\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buildCastles\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buildHovels\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buildMiningCamps\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022kingdomIndex\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022newName\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022changeKingdomName\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022targetPlayerIndex\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022espionage\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gameNumber\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gameStats\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022version\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numberPlayers\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalGold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalPrizePool\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameStartTimeSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameDurationSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameTurns\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameTurnTimeSeconds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameCurrentTurn\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gameLeaderIndex\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022playerName\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022joinGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022message\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022nextGameAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022playerIndex\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022playerAtIndex\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022playerName\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022playerStats\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022enum CryptoKingdoms.Race\u0022,\u0022name\u0022:\u0022race\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022kingdomName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022actions\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022soldiers\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022spies\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022wizards\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dragons\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hovels\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022miningCamps\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022banks\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022barracks\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022castles\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022previousGameAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022recruitSoldiers\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022recruitSpies\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022targetPlayerIndex\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022sabotage\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022gameAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setNextGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022summonWizards\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022trainDragons\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022turn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022winner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022enum CryptoKingdoms.Race\u0022,\u0022name\u0022:\u0022race\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022actions\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022gold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022soldiers\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022spies\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022wizards\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dragons\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hovels\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022miningCamps\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022banks\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022barracks\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022castles\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"CryptoKingdoms","CompilerVersion":"v0.5.16\u002Bcommit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://983f5d101a7e6e279d4cf4e6ff0db71c2e5b33dfe3259fcfbe82cb1f98a719be"}]