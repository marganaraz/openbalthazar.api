[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Auth {\r\n\r\n  address internal admin;\r\n\r\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n  constructor(address _admin) internal {\r\n    admin = _admin;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \u0022onlyAdmin\u0022);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) onlyAdmin internal {\r\n    require(_newOwner != address(0x0), \u0022Invalid admin address\u0022);\r\n    admin = _newOwner;\r\n    emit OwnershipTransferred(msg.sender, _newOwner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n    // benefit is lost if \u0027b\u0027 is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b \u003E 0);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003C= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    require(c \u003E= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract DABANKING_SWAP is Auth {\r\n  using SafeMath for uint;\r\n\r\n  IERC20 public daaBounty = IERC20(0x4D566B0b911756C77A327152b862327ff719bFfF);\r\n  IERC20 public daBanking = IERC20(0x5E7Ebea68ab05198F771d77a875480314f1d0aae);\r\n  uint8 public rate = 100;\r\n\r\n  event TokenSwapped(address indexed user, uint daaAmount, uint dabAmount);\r\n\r\n  constructor(address _admin) Auth(_admin) public {}\r\n\r\n  function swap(uint _daaAmount) public {\r\n    require(daaBounty.balanceOf(msg.sender) \u003E= _daaAmount, \u0022You have not enough balance\u0022);\r\n    require(daaBounty.allowance(msg.sender, address(this)) \u003E= _daaAmount, \u0022You must call approve() first\u0022);\r\n    uint dabAmount = _daaAmount.div(rate);\r\n    require(daBanking.balanceOf(address(this)) \u003E= dabAmount, \u0022Contract have not enough DAB\u0022);\r\n    require(daaBounty.transferFrom(msg.sender, address(this), _daaAmount), \u0022Transfer token failed\u0022);\r\n    require(daBanking.transfer(msg.sender, dabAmount), \u0022Transfer DAB to user failed\u0022);\r\n    emit TokenSwapped(msg.sender, _daaAmount, dabAmount);\r\n  }\r\n\r\n  function setRate(uint8 _rate) onlyAdmin public {\r\n    require(_rate \u003E 0 \u0026\u0026 _rate != rate, \u0022Rate is invalid\u0022);\r\n    rate = _rate;\r\n  }\r\n\r\n  function updateAdmin(address _newAdmin) public {\r\n    transferOwnership(_newAdmin);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022rate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_rate\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022setRate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022daaBounty\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_daaAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022swap\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022daBanking\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_newAdmin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022updateAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_admin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022daaAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dabAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TokenSwapped\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"DABANKING_SWAP","CompilerVersion":"v0.4.25\u002Bcommit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a06cd23aa37c39095d8cfe3a0fd2654331e63123","Library":"","SwarmSource":"bzzr://cdcd201980cd794d46ecf70b0357c847b980a594328a282c6fa66af19e4a5210"}]