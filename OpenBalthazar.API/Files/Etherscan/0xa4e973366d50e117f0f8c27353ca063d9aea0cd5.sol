[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address =\u003E uint[]) lotteryMap;\r\n\r\n            mapping(uint =\u003E address) numToAddr;\r\n\r\n            mapping(address =\u003E uint) personalAmount;\r\n\r\n            mapping(uint =\u003E uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n        \r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number \u002B 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i\u002B\u002B;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract GODLottery {\r\n        address owner;\r\n\r\n        address gameAddr;\r\n\r\n        uint[] numArr = new uint[](0);\r\n\r\n        uint public lotterySession;\r\n\r\n        GODThemis themis;\r\n\r\n        GODToken godToken;\r\n\r\n        GODGame game;\r\n\r\n        mapping(uint =\u003E DappDatasets.Lottery) lotteryGame;\r\n\r\n        constructor(\r\n                address _owner,\r\n                address _themisAddr,\r\n                address _godAddr\r\n        )  public {\r\n            owner = _owner;\r\n            themis = GODThemis(_themisAddr);\r\n            godToken = GODToken(_godAddr);\r\n            \r\n        }\r\n\r\n        function initGame(address gAddr) external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            game = GODGame(gAddr);\r\n            gameAddr = gAddr;\r\n        }\r\n\r\n        function exchange(uint usdtVal, address addr) external {\r\n            require(gameAddr == msg.sender, \u0022Insufficient permissions\u0022);\r\n            require(usdtVal \u003E= 10 ** 6, \u0022Redeem at least 1USDT\u0022);\r\n            \r\n            themis.addStaticPrizePool(usdtVal);\r\n\r\n            uint usdtPrice = godToken.usdtPrice();\r\n            uint godCount = SafeMath.div(usdtVal * 10 ** 8, usdtPrice);\r\n\r\n            godToken.gainGODToken(godCount, true);\r\n            godToken.transfer(addr, godCount);\r\n\r\n            godDividend(usdtVal, usdtPrice, addr);\r\n\r\n            uint usdt = SafeMath.div(SafeMath.mul(usdtVal, 4), 100);\r\n            uint vGod = SafeMath.div(usdt * 10 ** 8, usdtPrice);\r\n            uint usdt4 = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            uint vGod4 = SafeMath.div(usdt4 * 10 ** 8, usdtPrice);\r\n            themis.addGodtPool(vGod, vGod4);\r\n        }\r\n\r\n        function godDividend(uint usdtVal, uint usdtPrice, address addr) internal {\r\n            address playerAddr = addr;\r\n            uint num = 9;\r\n            address superiorAddr;\r\n            for(uint i = 0; i \u003C 3; i\u002B\u002B) {\r\n                (, , , superiorAddr, ) = game.getPlayer(playerAddr);\r\n                if(superiorAddr != address(0x0)) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    uint god = SafeMath.div(usdt * 10 ** 8, usdtPrice);\r\n                    godToken.gainGODToken(god, false);\r\n                    godToken.transfer(superiorAddr, god);\r\n                    uint reward = SafeMath.div(god, 10);\r\n                    interactive(superiorAddr, reward);\r\n                    (, , , superiorAddr, ) = game.getPlayer(superiorAddr);\r\n                    if(superiorAddr != address(0x0)) {\r\n                        godToken.gainGODToken(reward, false);\r\n                        godToken.transfer(superiorAddr, reward);\r\n                        num -= 3;\r\n                        playerAddr = superiorAddr;\r\n                    }else {\r\n                        break;\r\n                    }\r\n                    \r\n                }else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function interactive(address addr, uint amount) internal {\r\n            address[] memory subordinates;\r\n            (, , , , subordinates) = game.getPlayer(addr);\r\n            if(subordinates.length \u003E 0) {\r\n                uint length = subordinates.length;\r\n                if(subordinates.length \u003E 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(amount, length);\r\n                for(uint i = 0; i \u003C length; i\u002B\u002B) {\r\n                    godToken.gainGODToken(splitEqually, false);\r\n                    godToken.transfer(subordinates[i], splitEqually);            \r\n                }\r\n            }\r\n        }\r\n\r\n        function startLottery() external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            lotterySession\u002B\u002B;\r\n            if(lotterySession \u003E 1) {\r\n                require(lotteryGame[lotterySession - 1].whetherToEnd == true, \u0022The game is not over yet\u0022);\r\n            }\r\n            lotteryGame[lotterySession] = DappDatasets.Lottery(\r\n                {\r\n                    whetherToEnd : false,\r\n                    lotteryPool : 0,\r\n                    unopenedBonus : lotteryGame[lotterySession - 1].unopenedBonus,\r\n                    number : 1,\r\n                    todayAmountTotal : 0,\r\n                    totayLotteryAmountTotal : 0,\r\n                    grandPrizeNum : 0,\r\n                    firstPrizeNum : numArr,\r\n                    secondPrizeNum : numArr,\r\n                    thirdPrizeNum : numArr\r\n                }\r\n            );\r\n        }\r\n\r\n        function participateLottery(uint usdtVal, address addr) external {\r\n            require(gameAddr == msg.sender, \u0022Insufficient permissions\u0022);\r\n            require(usdtVal \u003C= 300 * 10 ** 6 \u0026\u0026 usdtVal \u003E= 10 ** 6, \u0022Purchase value between 1-300\u0022);\r\n            require(lotterySession \u003E 0, \u0022The game has not started\u0022);\r\n            require(lotteryGame[lotterySession].whetherToEnd == false,\u0022Game over\u0022);\r\n            uint count = SafeMath.div(usdtVal, 10 ** 6);\r\n            getLottoCode(addr, count);\r\n        }\r\n\r\n        function getLottoCodeByGameAddr(address addr, uint count) external {\r\n            require(gameAddr == msg.sender, \u0022Insufficient permissions\u0022);\r\n            getLottoCode(addr, count);\r\n        }\r\n\r\n        function getLottoCode(address addr, uint count) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.lotteryMap[addr].push(lottery.number);\r\n            if(count \u003E 1) {\r\n                lottery.lotteryMap[addr].push(SafeMath.add(lottery.number, count - 1));\r\n            }\r\n            lottery.lotteryMap[addr].push(0);\r\n            for(uint i = 0; i \u003C count; i\u002B\u002B) {\r\n                lottery.numToAddr[lottery.number] = addr;\r\n                lottery.number\u002B\u002B;\r\n            }\r\n            themis.addStaticPrizePool(count * 10 ** 6);\r\n            lottery.totayLotteryAmountTotal = SafeMath.add(lottery.totayLotteryAmountTotal, count * 10 ** 6);\r\n        }\r\n\r\n        function endLottery()\r\n            external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            require(lotterySession \u003E 0, \u0022The game has not started\u0022);\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            require(lottery.whetherToEnd == false,\u0022Game over\u0022);\r\n            lottery.whetherToEnd = true;\r\n            if(lottery.lotteryPool \u003C= 0) {\r\n                return;\r\n            }\r\n            uint lotteryNumber = lottery.number;\r\n            if(lotteryNumber \u003C 2) {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, lottery.lotteryPool);\r\n                return;\r\n            }\r\n            uint grandPrizeNum = 0;\r\n            uint[] memory firstPrizeNum;\r\n            uint[] memory secondPrizeNum;\r\n            uint[] memory thirdPrizeNum;\r\n\r\n            bool flag = lottery.totayLotteryAmountTotal \u003E= SafeMath.mul(lottery.todayAmountTotal, 3);\r\n            if(flag) {\r\n                grandPrizeNum = DappDatasets.rand(lotteryNumber, 7);\r\n                lottery.grandPrizeNum = grandPrizeNum;\r\n            }\r\n            grandPrizeDistribution(grandPrizeNum, flag);\r\n\r\n            uint number = 2;\r\n            flag = lottery.totayLotteryAmountTotal \u003E= lottery.todayAmountTotal;\r\n            if(flag) {\r\n                if(lotteryNumber \u003C 3) {\r\n                    number = lotteryNumber - 1;\r\n                }\r\n                firstPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 17);\r\n                lottery.firstPrizeNum = firstPrizeNum;\r\n            }\r\n            prizeDistribution(firstPrizeNum, 2, 1, flag);\r\n\r\n            number = 5;\r\n            flag = lottery.totayLotteryAmountTotal \u003E= SafeMath.div(SafeMath.mul(lottery.todayAmountTotal, 3), 10);\r\n            if(flag) {\r\n                if(lotteryNumber \u003C 6) {\r\n                    number = lotteryNumber - 1;\r\n                }\r\n                secondPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 27);\r\n                lottery.secondPrizeNum = secondPrizeNum;\r\n            }\r\n            prizeDistribution(secondPrizeNum, 2, 2, flag);\r\n\r\n            number = 10;\r\n            if(lotteryNumber \u003C 11) {\r\n                number = lotteryNumber - 1;\r\n            }\r\n            thirdPrizeNum = DappDatasets.returnArray(number, lotteryNumber, 37);\r\n            lottery.thirdPrizeNum = thirdPrizeNum;\r\n            prizeDistribution(thirdPrizeNum, 3, 3, true);\r\n        }\r\n\r\n        function grandPrizeDistribution(uint grandPrizeNum, bool flag) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            uint grandPrize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, 3), 10);\r\n            if(flag) {\r\n                grandPrize = SafeMath.add(grandPrize, lottery.unopenedBonus);\r\n                game.updatePlayer(lottery.numToAddr[grandPrizeNum], grandPrize);\r\n                \r\n                lottery.personalAmount[lottery.numToAddr[grandPrizeNum]] = SafeMath.add(\r\n                    lottery.personalAmount[lottery.numToAddr[grandPrizeNum]],\r\n                    grandPrize\r\n                );\r\n                lottery.awardAmount[0] = grandPrize;\r\n                lottery.unopenedBonus = 0;\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, grandPrize);\r\n            }\r\n        }\r\n\r\n        function prizeDistribution(uint[] winningNumber, uint divide, uint num, bool flag) internal {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            uint prize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, divide), 10);\r\n            if(flag) {\r\n                uint personal = SafeMath.div(prize, winningNumber.length);\r\n                for(uint i = 0; i \u003C winningNumber.length; i\u002B\u002B) {\r\n                    game.updatePlayer(lottery.numToAddr[winningNumber[i]], personal);\r\n                    \r\n                    lottery.personalAmount[lottery.numToAddr[winningNumber[i]]] = SafeMath.add(\r\n                        lottery.personalAmount[lottery.numToAddr[winningNumber[i]]],\r\n                        personal\r\n                    );\r\n                    lottery.awardAmount[num] = personal;\r\n                }\r\n            }else {\r\n                lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, prize);\r\n            }\r\n        }\r\n\r\n        function getLotteryInfo() external view returns(uint session, uint pool, uint unopenedBonus, bool isEnd, uint[]) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            return (\r\n                lotterySession,\r\n                lottery.lotteryPool,\r\n                lottery.unopenedBonus,\r\n                lottery.whetherToEnd,\r\n                lottery.lotteryMap[msg.sender]\r\n                );\r\n        }\r\n\r\n        function getHistoryLottery(uint num) external view returns(uint, uint, uint[], uint[], uint[], uint[], uint[]) {\r\n                DappDatasets.Lottery storage lottery = lotteryGame[num];\r\n                uint[] memory awardArray = new uint[](4);\r\n                for(uint i = 0; i \u003C 4; i\u002B\u002B) {\r\n                    awardArray[i] = lottery.awardAmount[i];\r\n                }\r\n            return (\r\n                lottery.grandPrizeNum,\r\n                lottery.personalAmount[msg.sender],\r\n                lottery.firstPrizeNum,\r\n                lottery.secondPrizeNum,\r\n                lottery.thirdPrizeNum,\r\n                lottery.lotteryMap[msg.sender],\r\n                awardArray\r\n            );\r\n        }\r\n\r\n        function getLotteryIsEnd() external view returns(bool) {\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            return lottery.whetherToEnd;\r\n        }\r\n\r\n        function updateLotteryPoolAndTodayAmountTotal(uint usdtVal, uint lotteryPool) external {\r\n            require(msg.sender == gameAddr, \u0022Insufficient permissions\u0022);\r\n            DappDatasets.Lottery storage lottery = lotteryGame[lotterySession];\r\n            lottery.todayAmountTotal = SafeMath.add(lottery.todayAmountTotal, usdtVal);\r\n            lottery.lotteryPool = SafeMath.add(lottery.lotteryPool, lotteryPool);\r\n        }\r\n    }\r\n\r\n    contract GODThemis {\r\n        function addStaticPrizePool(uint usdtVal) external;\r\n        function addGodtPool(uint vGod, uint vGod4) external;\r\n    }\r\n\r\n    contract GODToken {\r\n        function usdtPrice() public view returns(uint);\r\n        function gainGODToken(uint value, bool isCovert) external;\r\n        function transfer(address to, uint value) public;\r\n    }\r\n\r\n    contract GODGame {\r\n        function updatePlayer(address addr, uint amount) external;\r\n        function getPlayer(address addr) external returns(uint, uint, uint, address, address[]);\r\n    }","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLotteryIsEnd\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022exchange\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLotteryInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022session\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022pool\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022unopenedBonus\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022isEnd\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022endLottery\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022startLottery\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022lotterySession\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022count\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getLottoCodeByGameAddr\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022participateLottery\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022gAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022initGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lotteryPool\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updateLotteryPoolAndTodayAmountTotal\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022num\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getHistoryLottery\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_themisAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_godAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"GODLottery","CompilerVersion":"v0.4.25\u002Bcommit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003b2c68f61a2c98bb0a4cf2ddc8cb0bec3957e1c10000000000000000000000008e3f5172cc10f0f920f3677625056f43d47e4aea0000000000000000000000004dc90fa739385848340349cf5c9efd123655a7e3","Library":"","SwarmSource":"bzzr://41000741481280b496d8f09c5e1b7e209ebbdc882144a560c306e800811f6af5"}]