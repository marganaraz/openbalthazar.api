[{"SourceCode":"/**\r\n *  The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see \u003Chttps://www.gnu.org/licenses/\u003E.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\ncontract Ownable {\r\n    event TransferredOwnership(address _from, address _to);\r\n    event LockedOwnership(address _locked);\r\n\r\n    address payable private _owner;\r\n    bool private _isTransferable;\r\n\r\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\r\n    constructor(address payable _account_, bool _transferable_) internal {\r\n        _owner = _account_;\r\n        _isTransferable = _transferable_;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_isTransferable) {\r\n            emit LockedOwnership(_account_);\r\n        }\r\n        emit TransferredOwnership(address(0), _account_);\r\n    }\r\n\r\n    /// @notice Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(_isOwner(msg.sender), \u0022sender is not an owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\r\n    /// @param _account address to transfer ownership to.\r\n    /// @param _transferable indicates whether to keep the ownership transferable.\r\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \u0022ownership is not transferable\u0022);\r\n        // Require that the new owner is not the zero address.\r\n        require(_account != address(0), \u0022owner cannot be set to zero address\u0022);\r\n        // Set the transferable flag to the value _transferable passed in.\r\n        _isTransferable = _transferable;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_transferable) {\r\n            emit LockedOwnership(_account);\r\n        }\r\n        // Emit the ownership transfer event.\r\n        emit TransferredOwnership(_owner, _account);\r\n        // Set the owner to the provided address.\r\n        _owner = _account;\r\n    }\r\n\r\n    /// @notice check if the ownership is transferable.\r\n    /// @return true if the ownership is transferable.\r\n    function isTransferable() external view returns (bool) {\r\n        return _isTransferable;\r\n    }\r\n\r\n    /// @notice Allows the current owner to relinquish control of the contract.\r\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\r\n    /// @dev It will not be possible to call the functions with the \u0060onlyOwner\u0060 modifier anymore.\r\n    function renounceOwnership() external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \u0022ownership is not transferable\u0022);\r\n        // note that this could be terminal\r\n        _owner = address(0);\r\n\r\n        emit TransferredOwnership(_owner, address(0));\r\n    }\r\n\r\n    /// @notice Find out owner address\r\n    /// @return address of the owner.\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @notice Check if owner address\r\n    /// @return true if sender is the owner of the contract.\r\n    function _isOwner(address _address) internal view returns (bool) {\r\n        return _address == _owner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003E= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest \u002B= 32;\r\n            src \u002B= 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint(self) \u0026 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret \u002B= 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint(self) \u0026 0xffffffffffffffff == 0) {\r\n            ret \u002B= 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint(self) \u0026 0xffffffff == 0) {\r\n            ret \u002B= 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint(self) \u0026 0xffff == 0) {\r\n            ret \u002B= 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint(self) \u0026 0xff == 0) {\r\n            ret \u002B= 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for \u0060self\u0060 in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as \u0060self\u0060.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice\u0027s text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call \u0060slice.empty()\u0060 if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr \u002B self._len;\r\n        for (l = 0; ptr \u003C end; l\u002B\u002B) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b \u003C 0x80) {\r\n                ptr \u002B= 1;\r\n            } else if (b \u003C 0xE0) {\r\n                ptr \u002B= 2;\r\n            } else if (b \u003C 0xF0) {\r\n                ptr \u002B= 3;\r\n            } else if (b \u003C 0xF8) {\r\n                ptr \u002B= 4;\r\n            } else if (b \u003C 0xFC) {\r\n                ptr \u002B= 5;\r\n            } else {\r\n                ptr \u002B= 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if \u0060other\u0060 comes lexicographically after\r\n     *      \u0060self\u0060, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len \u003C self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx \u003C shortest; idx \u002B= 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if (shortest \u003C 32) {\r\n                    mask = ~(2 ** (8 * (32 - shortest \u002B idx)) - 1);\r\n                }\r\n                uint256 diff = (a \u0026 mask) - (b \u0026 mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr \u002B= 32;\r\n            otherptr \u002B= 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into \u0060rune\u0060, advancing the\r\n     *      slice to point to the next rune and returning \u0060self\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return \u0060rune\u0060.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b \u003C 0x80) {\r\n            l = 1;\r\n        } else if (b \u003C 0xE0) {\r\n            l = 2;\r\n        } else if (b \u003C 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l \u003E self._len) {\r\n            rune._len = self._len;\r\n            self._ptr \u002B= self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr \u002B= l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from \u0060self\u0060.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b \u003C 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if (b \u003C 0xE0) {\r\n            ret = b \u0026 0x1F;\r\n            length = 2;\r\n        } else if (b \u003C 0xF0) {\r\n            ret = b \u0026 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b \u0026 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length \u003E self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i \u003C length; i\u002B\u002B) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) \u0026 0xFF;\r\n            if (b \u0026 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b \u0026 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if \u0060self\u0060 starts with \u0060needle\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len \u003C needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If \u0060self\u0060 starts with \u0060needle\u0060, \u0060needle\u0060 is removed from the\r\n     *      beginning of \u0060self\u0060. Otherwise, \u0060self\u0060 is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return \u0060self\u0060\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len \u003C needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr \u002B= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with \u0060needle\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len \u003C needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr \u002B self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If \u0060self\u0060 ends with \u0060needle\u0060, \u0060needle\u0060 is removed from the\r\n     *      end of \u0060self\u0060. Otherwise, \u0060self\u0060 is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return \u0060self\u0060\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len \u003C needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr \u002B self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // \u0060needle\u0060 in \u0060self\u0060, or the first byte after \u0060self\u0060 if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen \u003C= selflen) {\r\n            if (needlelen \u003C= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr \u002B selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr \u003E= end)\r\n                        return selfptr \u002B selflen;\r\n                    ptr\u002B\u002B;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx \u003C= selflen - needlelen; idx\u002B\u002B) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr \u002B= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr \u002B selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // \u0060needle\u0060 in \u0060self\u0060, or the address of \u0060self\u0060 if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen \u003C= selflen) {\r\n            if (needlelen \u003C= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr \u002B selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr \u003C= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr \u002B needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr \u002B (selflen - needlelen);\r\n                while (ptr \u003E= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr \u002B needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies \u0060self\u0060 to contain everything from the first occurrence of\r\n     *      \u0060needle\u0060 to the end of the slice. \u0060self\u0060 is set to the empty slice\r\n     *      if \u0060needle\u0060 is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return \u0060self\u0060.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies \u0060self\u0060 to contain the part of the string from the start of\r\n     *      \u0060self\u0060 to the end of the first occurrence of \u0060needle\u0060. If \u0060needle\u0060\r\n     *      is not found, \u0060self\u0060 is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return \u0060self\u0060.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything after the first\r\n     *      occurrence of \u0060needle\u0060, and \u0060token\u0060 to everything before it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and \u0060token\u0060 is set to the entirety of \u0060self\u0060.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return \u0060token\u0060.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr \u002B self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len \u002B needle._len;\r\n            self._ptr = ptr \u002B needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything after the first\r\n     *      occurrence of \u0060needle\u0060, and returning everything before it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and the entirety of \u0060self\u0060 is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The part of \u0060self\u0060 up to the first occurrence of \u0060delim\u0060.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything before the last\r\n     *      occurrence of \u0060needle\u0060, and \u0060token\u0060 to everything after it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and \u0060token\u0060 is set to the entirety of \u0060self\u0060.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return \u0060token\u0060.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len \u002B needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything before the last\r\n     *      occurrence of \u0060needle\u0060, and returning everything after it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and the entirety of \u0060self\u0060 is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The part of \u0060self\u0060 after the last occurrence of \u0060delim\u0060.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of \u0060needle\u0060 in \u0060self\u0060.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The number of occurrences of \u0060needle\u0060 found in \u0060self\u0060.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) \u002B needle._len;\r\n        while (ptr \u003C= self._ptr \u002B self._len) {\r\n            cnt\u002B\u002B;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) \u002B needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if \u0060self\u0060 contains \u0060needle\u0060.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return True if \u0060needle\u0060 is found in \u0060self\u0060, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      \u0060self\u0060 and \u0060other\u0060.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len \u002B other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr \u002B self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using \u0060self\u0060 as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in \u0060parts\u0060,\r\n     *         joined with \u0060self\u0060.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \u0022\u0022;\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for (uint i = 0; i \u003C parts.length; i\u002B\u002B) {\r\n            length \u002B= parts[i]._len;\r\n        }\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for (uint i = 0; i \u003C parts.length; i\u002B\u002B) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr \u002B= parts[i]._len;\r\n            if (i \u003C parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr \u002B= self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4) external view returns (bool);\r\n}\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract\u0027s constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * \u003E It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003E 0;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\ncontract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    mapping(bytes32=\u003Eaddress) addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) external authorised(node) {\r\n        addresses[node] = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return addresses[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract ContentHashResolver is ResolverBase {\r\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    mapping(bytes32=\u003Ebytes) hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        hashes[node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return hashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract NameResolver is ResolverBase {\r\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\r\n\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    mapping(bytes32=\u003Estring) names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string calldata name) external authorised(node) {\r\n        names[node] = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory) {\r\n        return names[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract ABIResolver is ResolverBase {\r\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\r\n\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    mapping(bytes32=\u003Emapping(uint256=\u003Ebytes)) abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) \u0026 contentType) == 0);\r\n\r\n        abis[node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\r\n        mapping(uint256=\u003Ebytes) storage abiset = abis[node];\r\n\r\n        for (uint256 contentType = 1; contentType \u003C= contentTypes; contentType \u003C\u003C= 1) {\r\n            if ((contentType \u0026 contentTypes) != 0 \u0026\u0026 abiset[contentType].length \u003E 0) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\u0022\u0022));\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \u0022SafeERC20: approve from non-zero to non-zero allowance\u0022\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \u0022SafeERC20: call to non-contract\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \u0022SafeERC20: low-level call failed\u0022);\r\n\r\n        if (returndata.length \u003E 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \u0022SafeERC20: ERC20 operation did not succeed\u0022);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BytesUtils {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev This function converts to an address\r\n    /// @param _bts bytes\r\n    /// @param _from start position\r\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\r\n\r\n        require(_bts.length \u003E= _from.add(20), \u0022slicing out of range\u0022);\r\n\r\n        bytes20 convertedAddress;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            convertedAddress := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return address(convertedAddress);\r\n    }\r\n\r\n    /// @dev This function slices bytes into bytes4\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\r\n        require(_bts.length \u003E= _from.add(4), \u0022slicing out of range\u0022);\r\n\r\n        bytes4 slicedBytes4;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            slicedBytes4 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return slicedBytes4;\r\n\r\n    }\r\n\r\n    /// @dev This function slices a uint\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\r\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\r\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\r\n        require(_bts.length \u003E= _from.add(32), \u0022slicing out of range\u0022);\r\n\r\n        uint convertedUint256;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n        \r\n        assembly {\r\n            convertedUint256 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return convertedUint256;\r\n    }\r\n}\r\n\r\ncontract Balanceable {\r\n\r\n    /// @dev This function is used to get a balance\r\n    /// @param _address of which balance we are trying to ascertain\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @return balance associated with an address, for any token, in the wei equivalent\r\n    function _balance(address _address, address _asset) internal view returns (uint) {\r\n        if (_asset != address(0)) {\r\n            return ERC20(_asset).balanceOf(_address);\r\n        } else {\r\n            return _address.balance;\r\n        }\r\n    }\r\n}\r\n\r\ncontract PubkeyResolver is ResolverBase {\r\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\r\n\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(bytes32=\u003EPublicKey) pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\r\n        pubkeys[node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\r\n        return (pubkeys[node].x, pubkeys[node].y);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract TextResolver is ResolverBase {\r\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    mapping(bytes32=\u003Emapping(string=\u003Estring)) texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\r\n        texts[node][key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\r\n        return texts[node][key];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract Transferrable {\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n\r\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\r\n    /// @dev The owner can chose the new destination address\r\n    /// @param _to is the recipient\u0027s address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount to be transferred in base units.\r\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\r\n        // address(0) is used to denote ETH\r\n        if (_asset == address(0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            ERC20(_asset).safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n\r\ncontract InterfaceResolver is ResolverBase, AddrResolver {\r\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\u0022interfaceImplementer(bytes32,bytes4)\u0022));\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    mapping(bytes32=\u003Emapping(bytes4=\u003Eaddress)) interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at \u0060addr()\u0060 for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 168 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\r\n        interfaces[node][interfaceID] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at \u0060addr()\u0060. If \u0060addr()\u0060 is set, a contract exists at that address, and that\r\n     * contract implements EIP168 and returns \u0060true\u0060 for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 168 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\r\n        address implementer = interfaces[node][interfaceID];\r\n        if(implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if(a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\u0022supportsInterface(bytes4)\u0022, INTERFACE_META_ID));\r\n        if(!success || returnData.length \u003C 32 || returnData[31] == 0) {\r\n            // EIP 168 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\u0022supportsInterface(bytes4)\u0022, interfaceID));\r\n        if(!success || returnData.length \u003C 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ninterface IController {\r\n    function isController(address) external view returns (bool);\r\n    function isAdmin(address) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\r\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\r\n/// @dev Owner can change the Admins\r\n/// @dev Admins and can the Controllers\r\n/// @dev Controllers are used by the application.\r\ncontract Controller is IController, Ownable, Transferrable {\r\n\r\n    event AddedController(address _sender, address _controller);\r\n    event RemovedController(address _sender, address _controller);\r\n\r\n    event AddedAdmin(address _sender, address _admin);\r\n    event RemovedAdmin(address _sender, address _admin);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    event Stopped(address _sender);\r\n    event Started(address _sender);\r\n\r\n    mapping (address =\u003E bool) private _isAdmin;\r\n    uint private _adminCount;\r\n\r\n    mapping (address =\u003E bool) private _isController;\r\n    uint private _controllerCount;\r\n\r\n    bool private _stopped;\r\n\r\n    /// @notice Constructor initializes the owner with the provided address.\r\n    /// @param _ownerAddress_ address of the owner.\r\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if Owner or Admin\r\n    modifier onlyAdminOrOwner() {\r\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if controller is stopped\r\n    modifier notStopped() {\r\n        require(!isStopped(), \u0022controller is stopped\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Add a new admin to the list of admins.\r\n    /// @param _account address to add to the list of admins.\r\n    function addAdmin(address _account) external onlyOwner notStopped {\r\n        _addAdmin(_account);\r\n    }\r\n\r\n    /// @notice Remove a admin from the list of admins.\r\n    /// @param _account address to remove from the list of admins.\r\n    function removeAdmin(address _account) external onlyOwner {\r\n        _removeAdmin(_account);\r\n    }\r\n\r\n    /// @return the current number of admins.\r\n    function adminCount() external view returns (uint) {\r\n        return _adminCount;\r\n    }\r\n\r\n    /// @notice Add a new controller to the list of controllers.\r\n    /// @param _account address to add to the list of controllers.\r\n    function addController(address _account) external onlyAdminOrOwner notStopped {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @notice Remove a controller from the list of controllers.\r\n    /// @param _account address to remove from the list of controllers.\r\n    function removeController(address _account) external onlyAdminOrOwner {\r\n        _removeController(_account);\r\n    }\r\n\r\n    /// @notice count the Controllers\r\n    /// @return the current number of controllers.\r\n    function controllerCount() external view returns (uint) {\r\n        return _controllerCount;\r\n    }\r\n\r\n    /// @notice is an address an Admin?\r\n    /// @return true if the provided account is an admin.\r\n    function isAdmin(address _account) public view notStopped returns (bool) {\r\n        return _isAdmin[_account];\r\n    }\r\n\r\n    /// @notice is an address a Controller?\r\n    /// @return true if the provided account is a controller.\r\n    function isController(address _account) public view notStopped returns (bool) {\r\n        return _isController[_account];\r\n    }\r\n\r\n    /// @notice this function can be used to see if the controller has been stopped\r\n    /// @return true is the Controller has been stopped\r\n    function isStopped() public view returns (bool) {\r\n        return _stopped;\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new admin.\r\n    function _addAdmin(address _account) private {\r\n        require(!_isAdmin[_account], \u0022provided account is already an admin\u0022);\r\n        require(!_isController[_account], \u0022provided account is already a controller\u0022);\r\n        require(!_isOwner(_account), \u0022provided account is already the owner\u0022);\r\n        require(_account != address(0), \u0022provided account is the zero address\u0022);\r\n        _isAdmin[_account] = true;\r\n        _adminCount\u002B\u002B;\r\n        emit AddedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing admin.\r\n    function _removeAdmin(address _account) private {\r\n        require(_isAdmin[_account], \u0022provided account is not an admin\u0022);\r\n        _isAdmin[_account] = false;\r\n        _adminCount--;\r\n        emit RemovedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new controller.\r\n    function _addController(address _account) private {\r\n        require(!_isAdmin[_account], \u0022provided account is already an admin\u0022);\r\n        require(!_isController[_account], \u0022provided account is already a controller\u0022);\r\n        require(!_isOwner(_account), \u0022provided account is already the owner\u0022);\r\n        require(_account != address(0), \u0022provided account is the zero address\u0022);\r\n        _isController[_account] = true;\r\n        _controllerCount\u002B\u002B;\r\n        emit AddedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing controller.\r\n    function _removeController(address _account) private {\r\n        require(_isController[_account], \u0022provided account is not a controller\u0022);\r\n        _isController[_account] = false;\r\n        _controllerCount--;\r\n        emit RemovedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice stop our controllers and admins from being useable\r\n    function stop() external onlyAdminOrOwner {\r\n        _stopped = true;\r\n        emit Stopped(msg.sender);\r\n    }\r\n\r\n    /// @notice start our controller again\r\n    function start() external onlyOwner {\r\n        _stopped = false;\r\n        emit Started(msg.sender);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n}\r\n\r\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    ENS ens;\r\n\r\n    /**\r\n     * A mapping of authorisations. An address that is authorised for a name\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (node, owner, caller) =\u003E isAuthorised\r\n     */\r\n    mapping(bytes32=\u003Emapping(address=\u003Emapping(address=\u003Ebool))) public authorisations;\r\n\r\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or clears an authorisation.\r\n     * Authorisations are specific to the caller. Any account can set an authorisation\r\n     * for any name, but the authorisation that is checked will be that of the\r\n     * current owner of a name. Thus, transferring a name effectively clears any\r\n     * existing authorisations, and new authorisations can be set in advance of\r\n     * an ownership transfer if desired.\r\n     *\r\n     * @param node The name to change the authorisation on.\r\n     * @param target The address that is to be authorised or deauthorised.\r\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\r\n     */\r\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\r\n        authorisations[node][msg.sender][target] = isAuthorised;\r\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool) {\r\n        address owner = ens.owner(node);\r\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\r\n    }\r\n}\r\n\r\ncontract ENSResolvable {\r\n    /// @notice _ens is an instance of ENS\r\n    ENS private _ens;\r\n\r\n    /// @notice _ensRegistry points to the ENS registry smart contract.\r\n    address private _ensRegistry;\r\n\r\n    /// @param _ensReg_ is the ENS registry used\r\n    constructor(address _ensReg_) internal {\r\n        _ensRegistry = _ensReg_;\r\n        _ens = ENS(_ensRegistry);\r\n    }\r\n\r\n    /// @notice this is used to that one can observe which ENS registry is being used\r\n    function ensRegistry() external view returns (address) {\r\n        return _ensRegistry;\r\n    }\r\n\r\n    /// @notice helper function used to get the address of a node\r\n    /// @param _node of the ENS entry that needs resolving\r\n    /// @return the address of the said node\r\n    function _ensResolve(bytes32 _node) internal view returns (address) {\r\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is ENSResolvable {\r\n    /// @dev Is the registered ENS node identifying the controller contract.\r\n    bytes32 private _controllerNode;\r\n\r\n    /// @notice Constructor initializes the controller contract object.\r\n    /// @param _controllerNode_ is the ENS node of the Controller.\r\n    constructor(bytes32 _controllerNode_) internal {\r\n        _controllerNode = _controllerNode_;\r\n    }\r\n\r\n    /// @notice Checks if message sender is a controller.\r\n    modifier onlyController() {\r\n        require(_isController(msg.sender), \u0022sender is not a controller\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @return the controller node registered in ENS.\r\n    function controllerNode() external view returns (bytes32) {\r\n        return _controllerNode;\r\n    }\r\n\r\n    /// @return true if the provided account is a controller.\r\n    function _isController(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isController(_account);\r\n    }\r\n\r\n    /// @return true if the provided account is an admin.\r\n    function _isAdmin(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\r\n    }\r\n\r\n}\r\n\r\ninterface ILicence {\r\n    function load(address, uint) external payable;\r\n    function updateLicenceAmount(uint) external;\r\n}\r\n\r\n\r\n/// @title Licence loads the TokenCard and transfers the licence amout to the TKN Holder Contract.\r\n/// @notice the rest of the amount gets sent to the CryptoFloat\r\ncontract Licence is Transferrable, ENSResolvable, Controllable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    /*******************/\r\n    /*     Events     */\r\n    /*****************/\r\n\r\n    event UpdatedLicenceDAO(address _newDAO);\r\n    event UpdatedCryptoFloat(address _newFloat);\r\n    event UpdatedTokenHolder(address _newHolder);\r\n    event UpdatedTKNContractAddress(address _newTKN);\r\n    event UpdatedLicenceAmount(uint _newAmount);\r\n\r\n    event TransferredToTokenHolder(address _from, address _to, address _asset, uint _amount);\r\n    event TransferredToCryptoFloat(address _from, address _to, address _asset, uint _amount);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @notice This is 100% scaled up by a factor of 10 to give us an extra 1 decimal place of precision\r\n    uint constant public MAX_AMOUNT_SCALE = 1000;\r\n    uint constant public MIN_AMOUNT_SCALE = 1;\r\n\r\n    address private _tknContractAddress = 0xaAAf91D9b90dF800Df4F55c205fd6989c977E73a; // solium-disable-line uppercase\r\n\r\n    address payable private _cryptoFloat;\r\n    address payable private _tokenHolder;\r\n    address private _licenceDAO;\r\n\r\n    bool private _lockedCryptoFloat;\r\n    bool private _lockedTokenHolder;\r\n    bool private _lockedLicenceDAO;\r\n    bool private _lockedTKNContractAddress;\r\n\r\n    /// @notice This is the _licenceAmountScaled by a factor of 10\r\n    /// @dev i.e. 1% is 10 _licenceAmountScaled, 0.1% is 1 _licenceAmountScaled\r\n    uint private _licenceAmountScaled;\r\n\r\n    /// @notice Reverts if called by any address other than the DAO contract.\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _licenceDAO, \u0022the sender isn\u0027t the DAO\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor initializes the card licence contract.\r\n    /// @param _licence_ is the initial card licence amount. this number is scaled 10 = 1%, 9 = 0.9%\r\n    /// @param _float_ is the address of the multi-sig cryptocurrency float contract.\r\n    /// @param _holder_ is the address of the token holder contract\r\n    /// @param _tknAddress_ is the address of the TKN ERC20 contract\r\n    /// @param _ens_ is the address of the ENS Registry\r\n    /// @param _controllerNode_ is the ENS node corresponding to the controller\r\n    constructor(uint _licence_, address payable _float_, address payable _holder_, address _tknAddress_, address _ens_, bytes32 _controllerNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\r\n        require(MIN_AMOUNT_SCALE \u003C= _licence_ \u0026\u0026 _licence_ \u003C= MAX_AMOUNT_SCALE, \u0022licence amount out of range\u0022);\r\n        _licenceAmountScaled = _licence_;\r\n        _cryptoFloat = _float_;\r\n        _tokenHolder = _holder_;\r\n        if (_tknAddress_ != address(0)) {\r\n            _tknContractAddress = _tknAddress_;\r\n        }\r\n    }\r\n\r\n    /// @notice Ether can be deposited from any source, so this contract should be payable by anyone.\r\n    function() external payable {}\r\n\r\n    /// @notice this allows for people to see the scaled licence amount\r\n    /// @return the scaled licence amount, used to calculate the split when loading.\r\n    function licenceAmountScaled() external view returns (uint) {\r\n        return _licenceAmountScaled;\r\n    }\r\n\r\n    /// @notice allows one to see the address of the CryptoFloat\r\n    /// @return the address of the multi-sig cryptocurrency float contract.\r\n    function cryptoFloat() external view returns (address) {\r\n        return _cryptoFloat;\r\n    }\r\n\r\n    /// @notice allows one to see the address TKN holder contract\r\n    /// @return the address of the token holder contract.\r\n    function tokenHolder() external view returns (address) {\r\n        return _tokenHolder;\r\n    }\r\n\r\n    /// @notice allows one to see the address of the DAO\r\n    /// @return the address of the DAO contract.\r\n    function licenceDAO() external view returns (address) {\r\n        return _licenceDAO;\r\n    }\r\n\r\n    /// @notice The address of the TKN token\r\n    /// @return the address of the TKN contract.\r\n    function tknContractAddress() external view returns (address) {\r\n        return _tknContractAddress;\r\n    }\r\n\r\n    /// @notice This locks the cryptoFloat address\r\n    /// @dev so that it can no longer be updated\r\n    function lockFloat() external onlyAdmin {\r\n        _lockedCryptoFloat = true;\r\n    }\r\n\r\n    /// @notice This locks the TokenHolder address\r\n    /// @dev so that it can no longer be updated\r\n    function lockHolder() external onlyAdmin {\r\n        _lockedTokenHolder = true;\r\n    }\r\n\r\n    /// @notice This locks the DAO address\r\n    /// @dev so that it can no longer be updated\r\n    function lockLicenceDAO() external onlyAdmin {\r\n        _lockedLicenceDAO = true;\r\n    }\r\n\r\n    /// @notice This locks the TKN address\r\n    /// @dev so that it can no longer be updated\r\n    function lockTKNContractAddress() external onlyAdmin {\r\n        _lockedTKNContractAddress = true;\r\n    }\r\n\r\n    /// @notice Updates the address of the cyptoFloat.\r\n    /// @param _newFloat This is the new address for the CryptoFloat\r\n    function updateFloat(address payable _newFloat) external onlyAdmin {\r\n        require(!floatLocked(), \u0022float is locked\u0022);\r\n        _cryptoFloat = _newFloat;\r\n        emit UpdatedCryptoFloat(_newFloat);\r\n    }\r\n\r\n    /// @notice Updates the address of the Holder contract.\r\n    /// @param _newHolder This is the new address for the TokenHolder\r\n    function updateHolder(address payable _newHolder) external onlyAdmin {\r\n        require(!holderLocked(), \u0022holder contract is locked\u0022);\r\n        _tokenHolder = _newHolder;\r\n        emit UpdatedTokenHolder(_newHolder);\r\n    }\r\n\r\n    /// @notice Updates the address of the DAO contract.\r\n    /// @param _newDAO This is the new address for the Licence DAO\r\n    function updateLicenceDAO(address _newDAO) external onlyAdmin {\r\n        require(!licenceDAOLocked(), \u0022DAO is locked\u0022);\r\n        _licenceDAO = _newDAO;\r\n        emit UpdatedLicenceDAO(_newDAO);\r\n    }\r\n\r\n    /// @notice Updates the address of the TKN contract.\r\n    /// @param _newTKN This is the new address for the TKN contract\r\n    function updateTKNContractAddress(address _newTKN) external onlyAdmin {\r\n        require(!tknContractAddressLocked(), \u0022TKN is locked\u0022);\r\n        _tknContractAddress = _newTKN;\r\n        emit UpdatedTKNContractAddress(_newTKN);\r\n    }\r\n\r\n    /// @notice Updates the TKN licence amount\r\n    /// @param _newAmount is a number between MIN_AMOUNT_SCALE (1) and MAX_AMOUNT_SCALE\r\n    function updateLicenceAmount(uint _newAmount) external onlyDAO {\r\n        require(MIN_AMOUNT_SCALE \u003C= _newAmount \u0026\u0026 _newAmount \u003C= MAX_AMOUNT_SCALE, \u0022licence amount out of range\u0022);\r\n        _licenceAmountScaled = _newAmount;\r\n        emit UpdatedLicenceAmount(_newAmount);\r\n    }\r\n\r\n    /// @notice Load the holder and float contracts based on the licence amount and asset amount.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount of assets to be transferred including the licence amount.\r\n    function load(address _asset, uint _amount) external payable {\r\n        uint loadAmount = _amount;\r\n        // If TKN then no licence to be paid\r\n        if (_asset == _tknContractAddress) {\r\n            ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\r\n        } else {\r\n            loadAmount = _amount.mul(MAX_AMOUNT_SCALE).div(_licenceAmountScaled \u002B MAX_AMOUNT_SCALE);\r\n            uint licenceAmount = _amount.sub(loadAmount);\r\n\r\n            if (_asset != address(0)) {\r\n                ERC20(_asset).safeTransferFrom(msg.sender, _tokenHolder, licenceAmount);\r\n                ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\r\n            } else {\r\n                require(msg.value == _amount, \u0022ETH sent is not equal to amount\u0022);\r\n                _tokenHolder.transfer(licenceAmount);\r\n                _cryptoFloat.transfer(loadAmount);\r\n            }\r\n\r\n            emit TransferredToTokenHolder(msg.sender, _tokenHolder, _asset, licenceAmount);\r\n        }\r\n\r\n        emit TransferredToCryptoFloat(msg.sender, _cryptoFloat, _asset, loadAmount);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice returns whether or not the CryptoFloat address is locked\r\n    function floatLocked() public view returns (bool) {\r\n        return _lockedCryptoFloat;\r\n    }\r\n\r\n    /// @notice returns whether or not the TokenHolder address is locked\r\n    function holderLocked() public view returns (bool) {\r\n        return _lockedTokenHolder;\r\n    }\r\n\r\n    /// @notice returns whether or not the Licence DAO address is locked\r\n    function licenceDAOLocked() public view returns (bool) {\r\n        return _lockedLicenceDAO;\r\n    }\r\n\r\n    /// @notice returns whether or not the TKN address is locked\r\n    function tknContractAddressLocked() public view returns (bool) {\r\n        return _lockedTKNContractAddress;\r\n    }\r\n}\r\n\r\ninterface ITokenWhitelist {\r\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function tokenAddressArray() external view returns (address[] memory);\r\n    function redeemableTokens() external view returns (address[] memory);\r\n    function methodIdWhitelist(bytes4) external view returns (bool);\r\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\r\n    function stablecoin() external view returns (address);\r\n    function updateTokenRate(address, uint, uint) external;\r\n}\r\n\r\n\r\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\r\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\r\n    using strings for *;\r\n    using SafeMath for uint256;\r\n    using BytesUtils for bytes;\r\n\r\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\r\n\r\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\r\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\r\n\r\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\r\n    event RemovedToken(address _sender, address _token);\r\n\r\n    event AddedMethodId(bytes4 _methodId);\r\n    event RemovedMethodId(bytes4 _methodId);\r\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\r\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\r\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) =\u003E 0x095ea7b3\r\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) =\u003E 0x42966c68\r\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) =\u003E 0xa9059cbb\r\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) =\u003E 0x23b872dd\r\n\r\n    struct Token {\r\n        string symbol;    // Token symbol\r\n        uint magnitude;   // 10^decimals\r\n        uint rate;        // Token exchange rate in wei\r\n        bool available;   // Flags if the token is available or not\r\n        bool loadable;    // Flags if token is loadable to the TokenCard\r\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\r\n        uint lastUpdate;  // Time of the last rate update\r\n    }\r\n\r\n    mapping(address =\u003E Token) private _tokenInfoMap;\r\n\r\n    // @notice specifies whitelisted methodIds for protected tokens in wallet\u0027s excuteTranaction() e.g. keccak256(transfer(address,uint256)) =\u003E 0xa9059cbb\r\n    mapping(bytes4 =\u003E bool) private _methodIdWhitelist;\r\n\r\n    address[] private _tokenAddressArray;\r\n\r\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\r\n    uint private _redeemableCounter;\r\n\r\n    /// @notice Address of the stablecoin.\r\n    address private _stablecoin;\r\n\r\n    /// @notice is registered ENS node identifying the oracle contract.\r\n    bytes32 private _oracleNode;\r\n\r\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\r\n    /// @param _ens_ is the ENS registry address.\r\n    /// @param _oracleNode_ is the ENS node of the Oracle.\r\n    /// @param _controllerNode_ is our Controllers node.\r\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\r\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\r\n        _oracleNode = _oracleNode_;\r\n        _stablecoin = _stablecoinAddress_;\r\n        //a priori ERC20 whitelisted methods\r\n        _methodIdWhitelist[_APPROVE] = true;\r\n        _methodIdWhitelist[_BURN] = true;\r\n        _methodIdWhitelist[_TRANSFER] = true;\r\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\r\n    }\r\n\r\n    modifier onlyAdminOrOracle() {\r\n        address oracleAddress = _ensResolve(_oracleNode);\r\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \u0022either oracle or admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    /// @param _symbols ERC20 token names.\r\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\r\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\r\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\r\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\r\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\r\n        // Require that all parameters have the same length.\r\n        require(_tokens.length == _symbols.length \u0026\u0026 _tokens.length == _magnitude.length \u0026\u0026 _tokens.length == _loadable.length \u0026\u0026 _tokens.length == _loadable.length, \u0022parameter lengths do not match\u0022);\r\n        // Add each token to the list of supported tokens.\r\n        for (uint i = 0; i \u003C _tokens.length; i\u002B\u002B) {\r\n            // Require that the token isn\u0027t already available.\r\n            require(!_tokenInfoMap[_tokens[i]].available, \u0022token already available\u0022);\r\n            // Store the intermediate values.\r\n            string memory symbol = _symbols[i].toSliceB32().toString();\r\n            // Add the token to the token list.\r\n            _tokenInfoMap[_tokens[i]] = Token({\r\n                symbol : symbol,\r\n                magnitude : _magnitude[i],\r\n                rate : 0,\r\n                available : true,\r\n                loadable : _loadable[i],\r\n                redeemable: _redeemable[i],\r\n                lastUpdate : _lastUpdate\r\n                });\r\n            // Add the token address to the address list.\r\n            _tokenAddressArray.push(_tokens[i]);\r\n            //if the token is redeemable increase the redeemableCounter\r\n            if (_redeemable[i]){\r\n                _redeemableCounter = _redeemableCounter.add(1);\r\n            }\r\n            // Emit token addition event.\r\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\r\n        // Delete each token object from the list of supported tokens based on the addresses provided.\r\n        for (uint i = 0; i \u003C _tokens.length; i\u002B\u002B) {\r\n            // Store the token address.\r\n            address token = _tokens[i];\r\n            //token must be available, reverts on duplicates as well\r\n            require(_tokenInfoMap[token].available, \u0022token is not available\u0022);\r\n            //if the token is redeemable decrease the redeemableCounter\r\n            if (_tokenInfoMap[token].redeemable){\r\n                _redeemableCounter = _redeemableCounter.sub(1);\r\n            }\r\n            // Delete the token object.\r\n            delete _tokenInfoMap[token];\r\n            // Remove the token address from the address list.\r\n            for (uint j = 0; j \u003C _tokenAddressArray.length.sub(1); j\u002B\u002B) {\r\n                if (_tokenAddressArray[j] == token) {\r\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\r\n                    break;\r\n                }\r\n            }\r\n            _tokenAddressArray.length--;\r\n            // Emit token removal event.\r\n            emit RemovedToken(msg.sender, token);\r\n        }\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\r\n        // Require that there exist enough bytes for encoding at least a method signature \u002B data in the transaction payload:\r\n        // 4 (signature)  \u002B 32(address or uint256)\r\n        require(_data.length \u003E= 4 \u002B 32, \u0022not enough method-encoding bytes\u0022);\r\n        // Get the method signature\r\n        bytes4 signature = _data._bytesToBytes4(0);\r\n        // Check if method Id is supported\r\n        require(isERC20MethodSupported(_token, signature), \u0022unsupported method\u0022);\r\n        // returns the recipient\u0027s address and amount is the value to be transferred\r\n        if (signature == _BURN) {\r\n            // 4 (signature) \u002B 32(uint256)\r\n            return (_token, _data._bytesToUint256(4));\r\n        } else if (signature == _TRANSFER_FROM) {\r\n            // 4 (signature) \u002B 32(address) \u002B 32(address) \u002B 32(uint256)\r\n            require(_data.length \u003E= 4 \u002B 32 \u002B 32 \u002B 32, \u0022not enough data for transferFrom\u0022);\r\n            return ( _data._bytesToAddress(4 \u002B 32 \u002B 12), _data._bytesToUint256(4 \u002B 32 \u002B 32));\r\n        } else { //transfer or approve\r\n            // 4 (signature) \u002B 32(address) \u002B 32(uint)\r\n            require(_data.length \u003E= 4 \u002B 32 \u002B 32, \u0022not enough data for transfer/appprove\u0022);\r\n            return (_data._bytesToAddress(4 \u002B 12), _data._bytesToUint256(4 \u002B 32));\r\n        }\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is loadable or not.\r\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n\r\n        // this sets the loadable flag to the value passed in\r\n        _tokenInfoMap[_token].loadable = _loadable;\r\n\r\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is redeemable or not.\r\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n\r\n        // this sets the redeemable flag to the value passed in\r\n        _tokenInfoMap[_token].redeemable = _redeemable;\r\n\r\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n        // Update the token\u0027s rate.\r\n        _tokenInfoMap[_token].rate = _rate;\r\n        // Update the token\u0027s last update timestamp.\r\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\r\n        // Emit the rate update event.\r\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage tokenInfo = _tokenInfoMap[_a];\r\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our StableCoin.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\r\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns an array of all whitelisted token addresses.\r\n    /// @return address[] of whitelisted tokens.\r\n    function tokenAddressArray() external view returns (address[] memory) {\r\n        return _tokenAddressArray;\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function redeemableTokens() external view returns (address[] memory) {\r\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\r\n        uint redeemableIndex = 0;\r\n        for (uint i = 0; i \u003C _tokenAddressArray.length; i\u002B\u002B) {\r\n            address token = _tokenAddressArray[i];\r\n            if (_tokenInfoMap[token].redeemable){\r\n                redeemableAddresses[redeemableIndex] = token;\r\n                redeemableIndex \u002B= 1;\r\n            }\r\n        }\r\n        return redeemableAddresses;\r\n    }\r\n\r\n\r\n    /// @notice This returns true if a method Id is supported for the specific token.\r\n    /// @return true if _methodId is supported in general or just for the specific token.\r\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\r\n        require(_tokenInfoMap[_token].available, \u0022non-existing token\u0022);\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns true if the method is supported for all protected tokens.\r\n    /// @return true if _methodId is in the method whitelist.\r\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns the number of redeemable tokens.\r\n    /// @return current # of redeemables.\r\n    function redeemableCounter() external view returns (uint) {\r\n        return _redeemableCounter;\r\n    }\r\n\r\n    /// @notice This returns the address of our stablecoin of choice.\r\n    /// @return the address of the stablecoin contract.\r\n    function stablecoin() external view returns (address) {\r\n        return _stablecoin;\r\n    }\r\n\r\n    /// @notice this returns the node hash of our Oracle.\r\n    /// @return the oracle node registered in ENS.\r\n    function oracleNode() external view returns (bytes32) {\r\n        return _oracleNode;\r\n    }\r\n}\r\n\r\ncontract TokenWhitelistable is ENSResolvable {\r\n\r\n    /// @notice Is the registered ENS node identifying the tokenWhitelist contract\r\n    bytes32 private _tokenWhitelistNode;\r\n\r\n    /// @notice Constructor initializes the TokenWhitelistable object.\r\n    /// @param _tokenWhitelistNode_ is the ENS node of the TokenWhitelist.\r\n    constructor(bytes32 _tokenWhitelistNode_) internal {\r\n        _tokenWhitelistNode = _tokenWhitelistNode_;\r\n    }\r\n\r\n    /// @notice This shows what TokenWhitelist is being used\r\n    /// @return TokenWhitelist\u0027s node registered in ENS.\r\n    function tokenWhitelistNode() external view returns (bytes32) {\r\n        return _tokenWhitelistNode;\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function _getTokenInfo(address _a) internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our stablecoin token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function _getStablecoinInfo() internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\r\n    }\r\n\r\n    /// @notice This returns an array of our whitelisted addresses.\r\n    /// @return address[] of our whitelisted tokens.\r\n    function _tokenAddressArray() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function _redeemableTokens() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).redeemableTokens();\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\r\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function _getERC20RecipientAndAmount(address _destination, bytes memory _data) internal view returns (address, uint) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getERC20RecipientAndAmount(_destination, _data);\r\n    }\r\n\r\n    /// @notice Checks whether a token is available.\r\n    /// @return bool available or not.\r\n    function _isTokenAvailable(address _a) internal view returns (bool) {\r\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\r\n        return available;\r\n    }\r\n\r\n    /// @notice Checks whether a token is redeemable.\r\n    /// @return bool redeemable or not.\r\n    function _isTokenRedeemable(address _a) internal view returns (bool) {\r\n        ( , , , , , bool redeemable, ) = _getTokenInfo(_a);\r\n        return redeemable;\r\n    }\r\n\r\n    /// @notice Checks whether a token is loadable.\r\n    /// @return bool loadable or not.\r\n    function _isTokenLoadable(address _a) internal view returns (bool) {\r\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\r\n        return loadable;\r\n    }\r\n\r\n    /// @notice This gets the address of the stablecoin.\r\n    /// @return the address of the stablecoin contract.\r\n    function _stablecoin() internal view returns (address) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\r\n    }\r\n\r\n}\r\n\r\ncontract ControllableOwnable is Controllable, Ownable {\r\n    /// @dev Check if the sender is the Owner or one of the Controllers\r\n    modifier onlyOwnerOrController() {\r\n        require (_isOwner(msg.sender) || _isController(msg.sender), \u0022either owner or controller\u0022);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/// @title AddressWhitelist provides payee-whitelist functionality.\r\n/// @dev This contract will allow the user to maintain a whitelist of addresses\r\n/// @dev These addresses will live outside of the various spend limits\r\ncontract AddressWhitelist is ControllableOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    event AddedToWhitelist(address _sender, address[] _addresses);\r\n    event SubmittedWhitelistAddition(address[] _addresses, bytes32 _hash);\r\n    event CancelledWhitelistAddition(address _sender, bytes32 _hash);\r\n\r\n    event RemovedFromWhitelist(address _sender, address[] _addresses);\r\n    event SubmittedWhitelistRemoval(address[] _addresses, bytes32 _hash);\r\n    event CancelledWhitelistRemoval(address _sender, bytes32 _hash);\r\n\r\n    mapping(address =\u003E bool) public whitelistMap;\r\n    address[] public whitelistArray;\r\n    address[] private _pendingWhitelistAddition;\r\n    address[] private _pendingWhitelistRemoval;\r\n    bool public submittedWhitelistAddition;\r\n    bool public submittedWhitelistRemoval;\r\n    bool public isSetWhitelist;\r\n\r\n    /// @dev Check if the provided addresses contain the owner or the zero-address address.\r\n    modifier hasNoOwnerOrZeroAddress(address[] memory _addresses) {\r\n        for (uint i = 0; i \u003C _addresses.length; i\u002B\u002B) {\r\n            require(!_isOwner(_addresses[i]), \u0022provided whitelist contains the owner address\u0022);\r\n            require(_addresses[i] != address(0), \u0022provided whitelist contains the zero address\u0022);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Check that neither addition nor removal operations have already been submitted.\r\n    modifier noActiveSubmission() {\r\n        require(!submittedWhitelistAddition \u0026\u0026 !submittedWhitelistRemoval, \u0022whitelist operation has already been submitted\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @dev Getter for pending addition array.\r\n    function pendingWhitelistAddition() external view returns (address[] memory) {\r\n        return _pendingWhitelistAddition;\r\n    }\r\n\r\n    /// @dev Getter for pending removal array.\r\n    function pendingWhitelistRemoval() external view returns (address[] memory) {\r\n        return _pendingWhitelistRemoval;\r\n    }\r\n\r\n    /// @dev Add initial addresses to the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\r\n    function setWhitelist(address[] calldata _addresses) external onlyOwner hasNoOwnerOrZeroAddress(_addresses) {\r\n        // Require that the whitelist has not been initialized.\r\n        require(!isSetWhitelist, \u0022whitelist has already been initialized\u0022);\r\n        // Add each of the provided addresses to the whitelist.\r\n        for (uint i = 0; i \u003C _addresses.length; i\u002B\u002B) {\r\n            // adds to the whitelist mapping\r\n            whitelistMap[_addresses[i]] = true;\r\n            // adds to the whitelist array\r\n            whitelistArray.push(_addresses[i]);\r\n        }\r\n        isSetWhitelist = true;\r\n        // Emit the addition event.\r\n        emit AddedToWhitelist(msg.sender, _addresses);\r\n    }\r\n\r\n    /// @dev Add addresses to the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\r\n    function submitWhitelistAddition(address[] calldata _addresses) external onlyOwner noActiveSubmission hasNoOwnerOrZeroAddress(_addresses) {\r\n        // Require that the whitelist has been initialized.\r\n        require(isSetWhitelist, \u0022whitelist has not been initialized\u0022);\r\n        // Require this array of addresses not empty\r\n        require(_addresses.length \u003E 0, \u0022pending whitelist addition is empty\u0022);\r\n        // Set the provided addresses to the pending addition addresses.\r\n        _pendingWhitelistAddition = _addresses;\r\n        // Flag the operation as submitted.\r\n        submittedWhitelistAddition = true;\r\n        // Emit the submission event.\r\n        emit SubmittedWhitelistAddition(_addresses, calculateHash(_addresses));\r\n    }\r\n\r\n    /// @dev Confirm pending whitelist addition.\r\n    /// @dev This will only ever be applied post 2FA, by one of the Controllers\r\n    /// @param _hash is the hash of the pending whitelist array, a form of lamport lock\r\n    function confirmWhitelistAddition(bytes32 _hash) external onlyController {\r\n        // Require that the whitelist addition has been submitted.\r\n        require(submittedWhitelistAddition, \u0022whitelist addition has not been submitted\u0022);\r\n        // Require that confirmation hash and the hash of the pending whitelist addition match\r\n        require(_hash == calculateHash(_pendingWhitelistAddition), \u0022hash of the pending whitelist addition do not match\u0022);\r\n        // Whitelist pending addresses.\r\n        for (uint i = 0; i \u003C _pendingWhitelistAddition.length; i\u002B\u002B) {\r\n            // check if it doesn\u0027t exist already.\r\n            if (!whitelistMap[_pendingWhitelistAddition[i]]) {\r\n                // add to the Map and the Array\r\n                whitelistMap[_pendingWhitelistAddition[i]] = true;\r\n                whitelistArray.push(_pendingWhitelistAddition[i]);\r\n            }\r\n        }\r\n        // Emit the addition event.\r\n        emit AddedToWhitelist(msg.sender, _pendingWhitelistAddition);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistAddition;\r\n        // Reset the submission flag.\r\n        submittedWhitelistAddition = false;\r\n    }\r\n\r\n    /// @dev Cancel pending whitelist addition.\r\n    function cancelWhitelistAddition(bytes32 _hash) external onlyOwnerOrController {\r\n        // Check if operation has been submitted.\r\n        require(submittedWhitelistAddition, \u0022whitelist addition has not been submitted\u0022);\r\n        // Require that confirmation hash and the hash of the pending whitelist addition match\r\n        require(_hash == calculateHash(_pendingWhitelistAddition), \u0022hash of the pending whitelist addition does not match\u0022);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistAddition;\r\n        // Reset the submitted operation flag.\r\n        submittedWhitelistAddition = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledWhitelistAddition(msg.sender, _hash);\r\n    }\r\n\r\n    /// @dev Remove addresses from the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be removed.\r\n    function submitWhitelistRemoval(address[] calldata _addresses) external onlyOwner noActiveSubmission {\r\n        // Require that the whitelist has been initialized.\r\n        require(isSetWhitelist, \u0022whitelist has not been initialized\u0022);\r\n        // Require that the array of addresses is not empty\r\n        require(_addresses.length \u003E 0, \u0022pending whitelist removal is empty\u0022);\r\n        // Add the provided addresses to the pending addition list.\r\n        _pendingWhitelistRemoval = _addresses;\r\n        // Flag the operation as submitted.\r\n        submittedWhitelistRemoval = true;\r\n        // Emit the submission event.\r\n        emit SubmittedWhitelistRemoval(_addresses, calculateHash(_addresses));\r\n    }\r\n\r\n    /// @dev Confirm pending removal of whitelisted addresses.\r\n    function confirmWhitelistRemoval(bytes32 _hash) external onlyController {\r\n        // Require that the pending whitelist is not empty and the operation has been submitted.\r\n        require(submittedWhitelistRemoval, \u0022whitelist removal has not been submitted\u0022);\r\n        // Require that confirmation hash and the hash of the pending whitelist removal match\r\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \u0022hash of the pending whitelist removal does not match the confirmed hash\u0022);\r\n        // Remove pending addresses.\r\n        for (uint i = 0; i \u003C _pendingWhitelistRemoval.length; i\u002B\u002B) {\r\n            // check if it exists\r\n            if (whitelistMap[_pendingWhitelistRemoval[i]]) {\r\n                whitelistMap[_pendingWhitelistRemoval[i]] = false;\r\n                for (uint j = 0; j \u003C whitelistArray.length.sub(1); j\u002B\u002B) {\r\n                    if (whitelistArray[j] == _pendingWhitelistRemoval[i]) {\r\n                        whitelistArray[j] = whitelistArray[whitelistArray.length - 1];\r\n                        break;\r\n                    }\r\n                }\r\n                whitelistArray.length--;\r\n            }\r\n        }\r\n        // Emit the removal event.\r\n        emit RemovedFromWhitelist(msg.sender, _pendingWhitelistRemoval);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistRemoval;\r\n        // Reset the submission flag.\r\n        submittedWhitelistRemoval = false;\r\n    }\r\n\r\n    /// @dev Cancel pending removal of whitelisted addresses.\r\n    function cancelWhitelistRemoval(bytes32 _hash) external onlyOwnerOrController {\r\n        // Check if operation has been submitted.\r\n        require(submittedWhitelistRemoval, \u0022whitelist removal has not been submitted\u0022);\r\n        // Require that confirmation hash and the hash of the pending whitelist removal match\r\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \u0022hash of the pending whitelist removal do not match\u0022);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistRemoval;\r\n        // Reset pending addresses.\r\n        submittedWhitelistRemoval = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledWhitelistRemoval(msg.sender, _hash);\r\n    }\r\n\r\n    /// @dev Method used to hash our whitelist address arrays.\r\n    function calculateHash(address[] memory _addresses) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_addresses));\r\n    }\r\n}\r\n\r\n/// @title DailyLimitTrait This trait allows for daily limits to be included in other contracts.\r\n/// This contract will allow for a DailyLimit object to be instantiated and used.\r\nlibrary DailyLimitTrait {\r\n    using SafeMath for uint256;\r\n\r\n    event UpdatedAvailableLimit();\r\n\r\n    struct DailyLimit {\r\n        uint value;\r\n        uint available;\r\n        uint limitTimestamp;\r\n        uint pending;\r\n        bool updateable;\r\n    }\r\n\r\n    /// @dev Returns the available daily balance - accounts for daily limit reset.\r\n    /// @return amount of available to spend within the current day in base units.\r\n    function _getAvailableLimit(DailyLimit storage self) internal view returns (uint) {\r\n        if (now \u003E self.limitTimestamp.add(24 hours)) {\r\n            return self.value;\r\n        } else {\r\n            return self.available;\r\n        }\r\n    }\r\n\r\n    /// @dev Use up amount within the daily limit. Will fail if amount is larger than daily limit.\r\n    function _enforceLimit(DailyLimit storage self, uint _amount) internal {\r\n        // Account for the spend limit daily reset.\r\n        _updateAvailableLimit(self);\r\n        require(self.available \u003E= _amount, \u0022available has to be greater or equal to use amount\u0022);\r\n        self.available = self.available.sub(_amount);\r\n    }\r\n\r\n    /// @dev Set the daily limit.\r\n    /// @param _amount is the daily limit amount in base units.\r\n    function _setLimit(DailyLimit storage self, uint _amount) internal {\r\n        // Require that the spend limit has not been set yet.\r\n        require(!self.updateable, \u0022daily limit not updateable\u0022);\r\n        // Modify spend limit based on the provided value.\r\n        _modifyLimit(self, _amount);\r\n        // Flag the operation as set.\r\n        self.updateable = true;\r\n    }\r\n\r\n    /// @dev Submit a daily limit update, needs to be confirmed.\r\n    /// @param _amount is the daily limit amount in base units.\r\n    function _submitLimitUpdate(DailyLimit storage self, uint _amount) internal {\r\n        // Require that the spend limit has been set.\r\n        require(self.updateable, \u0022daily limit is still updateable\u0022);\r\n        // Assign the provided amount to pending daily limit.\r\n        self.pending = _amount;\r\n    }\r\n\r\n    /// @dev Confirm pending set daily limit operation.\r\n    function _confirmLimitUpdate(DailyLimit storage self, uint _amount) internal {\r\n        // Require that pending and confirmed spend limit are the same\r\n        require(self.pending == _amount, \u0022confirmed and submitted limits dont match\u0022);\r\n        // Modify spend limit based on the pending value.\r\n        _modifyLimit(self, self.pending);\r\n    }\r\n\r\n    /// @dev Update available spend limit based on the daily reset.\r\n    function _updateAvailableLimit(DailyLimit storage self) private {\r\n        if (now \u003E self.limitTimestamp.add(24 hours)) {\r\n            // Update the current timestamp.\r\n            self.limitTimestamp = now;\r\n            // Set the available limit to the current spend limit.\r\n            self.available = self.value;\r\n            emit UpdatedAvailableLimit();\r\n        }\r\n    }\r\n\r\n    /// @dev Modify the spend limit and spend available based on the provided value.\r\n    /// @dev _amount is the daily limit amount in wei.\r\n    function _modifyLimit(DailyLimit storage self, uint _amount) private {\r\n        // Account for the spend limit daily reset.\r\n        _updateAvailableLimit(self);\r\n        // Set the daily limit to the provided amount.\r\n        self.value = _amount;\r\n        // Lower the available limit if it\u0027s higher than the new daily limit.\r\n        if (self.available \u003E self.value) {\r\n            self.available = self.value;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title  it provides daily spend limit functionality.\r\ncontract SpendLimit is ControllableOwnable {\r\n    event SetSpendLimit(address _sender, uint _amount);\r\n    event SubmittedSpendLimitUpdate(uint _amount);\r\n\r\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\r\n\r\n    DailyLimitTrait.DailyLimit internal _spendLimit;\r\n\r\n    /// @dev Constructor initializes the daily spend limit in wei.\r\n    constructor(uint _limit_) internal {\r\n        _spendLimit = DailyLimitTrait.DailyLimit(_limit_, _limit_, now, 0, false);\r\n    }\r\n\r\n    /// @dev Sets the initial daily spend (aka transfer) limit for non-whitelisted addresses.\r\n    /// @param _amount is the daily limit amount in wei.\r\n    function setSpendLimit(uint _amount) external onlyOwner {\r\n        _spendLimit._setLimit(_amount);\r\n        emit SetSpendLimit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Submit a daily transfer limit update for non-whitelisted addresses.\r\n    /// @param _amount is the daily limit amount in wei.\r\n    function submitSpendLimitUpdate(uint _amount) external onlyOwner {\r\n        _spendLimit._submitLimitUpdate(_amount);\r\n        emit SubmittedSpendLimitUpdate(_amount);\r\n    }\r\n\r\n    /// @dev Confirm pending set daily limit operation.\r\n    function confirmSpendLimitUpdate(uint _amount) external onlyController {\r\n        _spendLimit._confirmLimitUpdate(_amount);\r\n        emit SetSpendLimit(msg.sender, _amount);\r\n    }\r\n\r\n    function spendLimitAvailable() external view returns (uint) {\r\n        return _spendLimit._getAvailableLimit();\r\n    }\r\n\r\n    function spendLimitValue() external view returns (uint) {\r\n        return _spendLimit.value;\r\n    }\r\n\r\n    function spendLimitUpdateable() external view returns (bool) {\r\n        return _spendLimit.updateable;\r\n    }\r\n\r\n    function spendLimitPending() external view returns (uint) {\r\n        return _spendLimit.pending;\r\n    }\r\n}\r\n\r\n\r\n//// @title GasTopUpLimit provides daily limit functionality.\r\ncontract GasTopUpLimit is ControllableOwnable {\r\n\r\n    event SetGasTopUpLimit(address _sender, uint _amount);\r\n    event SubmittedGasTopUpLimitUpdate(uint _amount);\r\n\r\n    uint constant private _MINIMUM_GAS_TOPUP_LIMIT = 1 finney;\r\n    uint constant private _MAXIMUM_GAS_TOPUP_LIMIT = 500 finney;\r\n\r\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\r\n\r\n    DailyLimitTrait.DailyLimit internal _gasTopUpLimit;\r\n\r\n    /// @dev Constructor initializes the daily gas topup limit in wei.\r\n    constructor() internal {\r\n        _gasTopUpLimit = DailyLimitTrait.DailyLimit(_MAXIMUM_GAS_TOPUP_LIMIT, _MAXIMUM_GAS_TOPUP_LIMIT, now, 0, false);\r\n    }\r\n\r\n    /// @dev Sets the daily gas top up limit.\r\n    /// @param _amount is the gas top up amount in wei.\r\n    function setGasTopUpLimit(uint _amount) external onlyOwner {\r\n        require(_MINIMUM_GAS_TOPUP_LIMIT \u003C= _amount \u0026\u0026 _amount \u003C= _MAXIMUM_GAS_TOPUP_LIMIT, \u0022gas top up amount is outside the min/max range\u0022);\r\n        _gasTopUpLimit._setLimit(_amount);\r\n        emit SetGasTopUpLimit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Submit a daily gas top up limit update.\r\n    /// @param _amount is the daily top up gas limit amount in wei.\r\n    function submitGasTopUpLimitUpdate(uint _amount) external onlyOwner {\r\n        require(_MINIMUM_GAS_TOPUP_LIMIT \u003C= _amount \u0026\u0026 _amount \u003C= _MAXIMUM_GAS_TOPUP_LIMIT, \u0022gas top up amount is outside the min/max range\u0022);\r\n        _gasTopUpLimit._submitLimitUpdate(_amount);\r\n        emit SubmittedGasTopUpLimitUpdate(_amount);\r\n    }\r\n\r\n    /// @dev Confirm pending set top up gas limit operation.\r\n    function confirmGasTopUpLimitUpdate(uint _amount) external onlyController {\r\n        _gasTopUpLimit._confirmLimitUpdate(_amount);\r\n        emit SetGasTopUpLimit(msg.sender, _amount);\r\n    }\r\n\r\n    function gasTopUpLimitAvailable() external view returns (uint) {\r\n        return _gasTopUpLimit._getAvailableLimit();\r\n    }\r\n\r\n    function gasTopUpLimitValue() external view returns (uint) {\r\n        return _gasTopUpLimit.value;\r\n    }\r\n\r\n    function gasTopUpLimitUpdateable() external view returns (bool) {\r\n        return _gasTopUpLimit.updateable;\r\n    }\r\n\r\n    function gasTopUpLimitPending() external view returns (uint) {\r\n        return _gasTopUpLimit.pending;\r\n    }\r\n}\r\n\r\n\r\n/// @title LoadLimit provides daily load limit functionality.\r\ncontract LoadLimit is ControllableOwnable {\r\n\r\n    event SetLoadLimit(address _sender, uint _amount);\r\n    event SubmittedLoadLimitUpdate(uint _amount);\r\n\r\n    uint constant private _MINIMUM_LOAD_LIMIT = 1 finney;\r\n    uint private _maximumLoadLimit;\r\n\r\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\r\n\r\n    DailyLimitTrait.DailyLimit internal _loadLimit;\r\n\r\n    /// @dev Sets a daily card load limit.\r\n    /// @param _amount is the card load amount in current stablecoin base units.\r\n    function setLoadLimit(uint _amount) external onlyOwner {\r\n        require(_MINIMUM_LOAD_LIMIT \u003C= _amount \u0026\u0026 _amount \u003C= _maximumLoadLimit, \u0022card load amount is outside the min/max range\u0022);\r\n        _loadLimit._setLimit(_amount);\r\n        emit SetLoadLimit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Submit a daily load limit update.\r\n    /// @param _amount is the daily load limit amount in wei.\r\n    function submitLoadLimitUpdate(uint _amount) external onlyOwner {\r\n        require(_MINIMUM_LOAD_LIMIT \u003C= _amount \u0026\u0026 _amount \u003C= _maximumLoadLimit, \u0022card load amount is outside the min/max range\u0022);\r\n        _loadLimit._submitLimitUpdate(_amount);\r\n        emit SubmittedLoadLimitUpdate(_amount);\r\n    }\r\n\r\n    /// @dev Confirm pending set load limit operation.\r\n    function confirmLoadLimitUpdate(uint _amount) external onlyController {\r\n        _loadLimit._confirmLimitUpdate(_amount);\r\n        emit SetLoadLimit(msg.sender, _amount);\r\n    }\r\n\r\n    function loadLimitAvailable() external view returns (uint) {\r\n        return _loadLimit._getAvailableLimit();\r\n    }\r\n\r\n    function loadLimitValue() external view returns (uint) {\r\n        return _loadLimit.value;\r\n    }\r\n\r\n    function loadLimitUpdateable() external view returns (bool) {\r\n        return _loadLimit.updateable;\r\n    }\r\n\r\n    function loadLimitPending() external view returns (uint) {\r\n        return _loadLimit.pending;\r\n    }\r\n\r\n    /// @dev initializes the daily load limit.\r\n    /// @param _maxLimit is the maximum load limit amount in stablecoin base units.\r\n    function _initializeLoadLimit(uint _maxLimit) internal {\r\n        _maximumLoadLimit = _maxLimit;\r\n        _loadLimit = DailyLimitTrait.DailyLimit(_maximumLoadLimit, _maximumLoadLimit, now, 0, false);\r\n    }\r\n}\r\n\r\n\r\n//// @title Asset store with extra security features.\r\ncontract Vault is AddressWhitelist, SpendLimit, ERC165, Transferrable, Balanceable, TokenWhitelistable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    event Received(address _from, uint _amount);\r\n    event Transferred(address _to, address _asset, uint _amount);\r\n    event BulkTransferred(address _to, address[] _assets);\r\n\r\n    /// @dev Supported ERC165 interface ID.\r\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7; // solium-disable-line uppercase\r\n\r\n    /// @dev Constructor initializes the vault with an owner address and spend limit. It also sets up the controllable and tokenWhitelist contracts with the right name registered in ENS.\r\n    /// @param _owner_ is the owner account of the wallet contract.\r\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\r\n    /// @param _tokenWhitelistNode_ is the ENS node of the Token whitelist.\r\n    /// @param _controllerNode_ is the ENS name node of the controller.\r\n    /// @param _spendLimit_ is the initial spend limit.\r\n    constructor(address payable _owner_, bool _transferable_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, uint _spendLimit_) SpendLimit(_spendLimit_) Ownable(_owner_, _transferable_) Controllable(_controllerNode_) TokenWhitelistable(_tokenWhitelistNode_) public {}\r\n\r\n    /// @dev Checks if the value is not zero.\r\n    modifier isNotZero(uint _value) {\r\n        require(_value != 0, \u0022provided value cannot be zero\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @dev Ether can be deposited from any source, so this contract must be payable by anyone.\r\n    function() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Checks for interface support based on ERC165.\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return _interfaceID == _ERC165_INTERFACE_ID;\r\n    }\r\n\r\n    /// @dev This is a bulk transfer convenience function, used to migrate contracts.\r\n    /// @notice If any of the transfers fail, this will revert.\r\n    /// @param _to is the recipient\u0027s address, can\u0027t be the zero (0x0) address: transfer() will revert.\r\n    /// @param _assets is an array of addresses of ERC20 tokens or 0x0 for ether.\r\n    function bulkTransfer(address payable _to, address[] calldata _assets) external onlyOwner {\r\n        // check to make sure that _assets isn\u0027t empty\r\n        require(_assets.length != 0, \u0022asset array should be non-empty\u0022);\r\n        // This loops through all of the transfers to be made\r\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\r\n            uint amount = _balance(address(this), _assets[i]);\r\n            // use our safe, daily limit protected transfer\r\n            transfer(_to, _assets[i], amount);\r\n        }\r\n\r\n        emit BulkTransferred(_to, _assets);\r\n    }\r\n\r\n    /// @dev Transfers the specified asset to the recipient\u0027s address.\r\n    /// @param _to is the recipient\u0027s address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount of assets to be transferred in base units.\r\n    function transfer(address payable _to, address _asset, uint _amount) public onlyOwner isNotZero(_amount) {\r\n        // Checks if the _to address is not the zero-address\r\n        require(_to != address(0), \u0022_to address cannot be set to 0x0\u0022);\r\n\r\n        // If address is not whitelisted, take daily limit into account.\r\n        if (!whitelistMap[_to]) {\r\n            // initialize ether value in case the asset is ETH\r\n            uint etherValue = _amount;\r\n            // Convert token amount to ether value if asset is an ERC20 token.\r\n            if (_asset != address(0)) {\r\n                etherValue = convertToEther(_asset, _amount);\r\n            }\r\n            // Check against the daily spent limit and update accordingly\r\n            // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\r\n            _spendLimit._enforceLimit(etherValue);\r\n        }\r\n        // Transfer token or ether based on the provided address.\r\n        _safeTransfer(_to, _asset, _amount);\r\n        // Emit the transfer event.\r\n        emit Transferred(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @dev Convert ERC20 token amount to the corresponding ether amount.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _amount amount of token in base units.\r\n    function convertToEther(address _token, uint _amount) public view returns (uint) {\r\n        // Store the token in memory to save map entry lookup gas.\r\n        (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\r\n        // If the token exists require that its rate is not zero.\r\n        if (available) {\r\n            require(rate != 0, \u0022token rate is 0\u0022);\r\n            // Safely convert the token amount to ether based on the exchange rate.\r\n            return _amount.mul(rate).div(magnitude);\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n//// @title Asset wallet with extra security features, gas top up management and card integration.\r\ncontract Wallet is ENSResolvable, Vault, GasTopUpLimit, LoadLimit {\r\n\r\n    using SafeERC20 for ERC20;\r\n    using Address for address;\r\n\r\n    event ToppedUpGas(address _sender, address _owner, uint _amount);\r\n    event LoadedTokenCard(address _asset, uint _amount);\r\n    event ExecutedTransaction(address _destination, uint _value, bytes _data, bytes _returndata);\r\n    event UpdatedAvailableLimit();\r\n\r\n    string constant public WALLET_VERSION = \u00222.2.0\u0022;\r\n    uint constant private _DEFAULT_MAX_STABLECOIN_LOAD_LIMIT = 10000; //10,000 USD\r\n\r\n    /// @dev Is the registered ENS node identifying the licence contract.\r\n    bytes32 private _licenceNode;\r\n\r\n    /// @dev Constructor initializes the wallet top up limit and the vault contract.\r\n    /// @param _owner_ is the owner account of the wallet contract.\r\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\r\n    /// @param _ens_ is the address of the ENS registry.\r\n    /// @param _tokenWhitelistNode_ is the ENS name node of the Token whitelist.\r\n    /// @param _controllerNode_ is the ENS name node of the Controller contract.\r\n    /// @param _licenceNode_ is the ENS name node of the Licence contract.\r\n    /// @param _spendLimit_ is the initial spend limit.\r\n    constructor(address payable _owner_, bool _transferable_, address _ens_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, bytes32 _licenceNode_, uint _spendLimit_) ENSResolvable(_ens_) Vault(_owner_, _transferable_, _tokenWhitelistNode_, _controllerNode_, _spendLimit_) public {\r\n        // Get the stablecoin\u0027s magnitude.\r\n        ( ,uint256 stablecoinMagnitude, , , , , ) = _getStablecoinInfo();\r\n        require(stablecoinMagnitude \u003E 0, \u0022stablecoin not set\u0022);\r\n        _initializeLoadLimit(_DEFAULT_MAX_STABLECOIN_LOAD_LIMIT * stablecoinMagnitude);\r\n        _licenceNode = _licenceNode_;\r\n    }\r\n\r\n    /// @dev Refill owner\u0027s gas balance, revert if the transaction amount is too large\r\n    /// @param _amount is the amount of ether to transfer to the owner account in wei.\r\n    function topUpGas(uint _amount) external isNotZero(_amount) onlyOwnerOrController {\r\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\r\n        _gasTopUpLimit._enforceLimit(_amount);\r\n        // Then perform the transfer\r\n        owner().transfer(_amount);\r\n        // Emit the gas top up event.\r\n        emit ToppedUpGas(msg.sender, owner(), _amount);\r\n    }\r\n\r\n    /// @dev Load a token card with the specified asset amount.\r\n    /// @dev the amount send should be inclusive of the percent licence.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount of assets to be transferred in base units.\r\n    function loadTokenCard(address _asset, uint _amount) external payable onlyOwner {\r\n        // check if token is allowed to be used for loading the card\r\n        require(_isTokenLoadable(_asset), \u0022token not loadable\u0022);\r\n        // Convert token amount to stablecoin value.\r\n        uint stablecoinValue = convertToStablecoin(_asset, _amount);\r\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\r\n        _loadLimit._enforceLimit(stablecoinValue);\r\n        // Get the TKN licenceAddress from ENS\r\n        address licenceAddress = _ensResolve(_licenceNode);\r\n        if (_asset != address(0)) {\r\n            ERC20(_asset).safeApprove(licenceAddress, _amount);\r\n            ILicence(licenceAddress).load(_asset, _amount);\r\n        } else {\r\n            ILicence(licenceAddress).load.value(_amount)(_asset, _amount);\r\n        }\r\n\r\n        emit LoadedTokenCard(_asset, _amount);\r\n\r\n    }\r\n\r\n    /// @dev This function allows for the owner to send transaction from the Wallet to arbitrary addresses\r\n    /// @param _destination address of the transaction\r\n    /// @param _value ETH amount in wei\r\n    /// @param _data transaction payload binary\r\n    function executeTransaction(address _destination, uint _value, bytes calldata _data) external onlyOwner returns (bytes memory) {\r\n        // If value is send across as a part of this executeTransaction, this will be sent to any payable\r\n        // destination. As a result enforceLimit if destination is not whitelisted.\r\n        if (!whitelistMap[_destination]) {\r\n            _spendLimit._enforceLimit(_value);\r\n        }\r\n        // Check if the destination is a Contract and it is one of our supported tokens\r\n        if (address(_destination).isContract() \u0026\u0026 _isTokenAvailable(_destination)) {\r\n            // to is the recipient\u0027s address and amount is the value to be transferred\r\n            address to;\r\n            uint amount;\r\n            (to, amount) = _getERC20RecipientAndAmount(_destination, _data);\r\n            if (!whitelistMap[to]) {\r\n                // If the address (of the token contract, e.g) is not in the TokenWhitelist used by the convert method...\r\n                // ...then etherValue will be zero\r\n                uint etherValue = convertToEther(_destination, amount);\r\n                _spendLimit._enforceLimit(etherValue);\r\n            }\r\n            // use callOptionalReturn provided in SafeERC20 in case the ERC20 method\r\n            // returns flase instead of reverting!\r\n            ERC20(_destination).callOptionalReturn(_data);\r\n\r\n            // if ERC20 call completes, return a boolean \u0022true\u0022 as bytes emulating ERC20\r\n            bytes memory b = new bytes(32);\r\n            b[31] = 0x01;\r\n\r\n            emit ExecutedTransaction(_destination, _value, _data, b);\r\n            return b;\r\n        }\r\n\r\n        (bool success, bytes memory returndata) = _destination.call.value(_value)(_data);\r\n        require(success, \u0022low-level call failed\u0022);\r\n\r\n        emit ExecutedTransaction(_destination, _value, _data, returndata);\r\n        // returns all of the bytes returned by _destination contract\r\n        return returndata;\r\n    }\r\n\r\n    /// @return licence contract node registered in ENS.\r\n    function licenceNode() external view returns (bytes32) {\r\n        return _licenceNode;\r\n    }\r\n\r\n    /// @dev Convert ether or ERC20 token amount to the corresponding stablecoin amount.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _amount amount of token in base units.\r\n    function convertToStablecoin(address _token, uint _amount) public view returns (uint) {\r\n        // avoid the unnecessary calculations if the token to be loaded is the stablecoin itself\r\n        if (_token == _stablecoin()) {\r\n            return _amount;\r\n        }\r\n        uint amountToSend = _amount;\r\n\r\n        // 0x0 represents ether\r\n        if (_token != address(0)) {\r\n            // convert to eth first, same as convertToEther()\r\n            // Store the token in memory to save map entry lookup gas.\r\n            (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\r\n            // require that token both exists in the whitelist and its rate is not zero.\r\n            require(available, \u0022token is not available\u0022);\r\n            require(rate != 0, \u0022token rate is 0\u0022);\r\n            // Safely convert the token amount to ether based on the exchange rate.\r\n            amountToSend = _amount.mul(rate).div(magnitude);\r\n        }\r\n        // _amountToSend now is in ether\r\n        // Get the stablecoin\u0027s magnitude and its current rate.\r\n        ( ,uint256 stablecoinMagnitude, uint256 stablecoinRate, bool stablecoinAvailable, , , ) = _getStablecoinInfo();\r\n        // Check if the stablecoin rate is set.\r\n        require(stablecoinAvailable, \u0022token is not available\u0022);\r\n        require(stablecoinRate != 0, \u0022stablecoin rate is 0\u0022);\r\n        // Safely convert the token amount to stablecoin based on its exchange rate and the stablecoin exchange rate.\r\n        return amountToSend.mul(stablecoinMagnitude).div(stablecoinRate);\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_interfaceID\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022supportsInterface\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spendLimitPending\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setGasTopUpLimit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022cancelWhitelistAddition\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022WALLET_VERSION\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_assets\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022bulkTransfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022loadLimitAvailable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isTransferable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022submitSpendLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022loadLimitUpdateable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gasTopUpLimitValue\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022submittedWhitelistAddition\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pendingWhitelistRemoval\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022whitelistMap\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022loadTokenCard\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setLoadLimit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setSpendLimit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_destination\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022executeTransaction\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pendingWhitelistAddition\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spendLimitUpdateable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022confirmWhitelistAddition\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spendLimitAvailable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022submitWhitelistRemoval\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022submitGasTopUpLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022licenceNode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ensRegistry\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gasTopUpLimitAvailable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022submitWhitelistAddition\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenWhitelistNode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spendLimitValue\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022submitLoadLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_transferable\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022convertToEther\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isSetWhitelist\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022loadLimitPending\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gasTopUpLimitUpdateable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022confirmWhitelistRemoval\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022gasTopUpLimitPending\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022calculateHash\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022cancelWhitelistRemoval\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022whitelistArray\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022loadLimitValue\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022submittedWhitelistRemoval\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022controllerNode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022topUpGas\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022confirmSpendLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022convertToStablecoin\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022confirmLoadLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022confirmGasTopUpLimitUpdate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022setWhitelist\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_transferable_\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022_ens_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenWhitelistNode_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_controllerNode_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_licenceNode_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_spendLimit_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ToppedUpGas\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LoadedTokenCard\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_destination\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_returndata\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022ExecutedTransaction\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022UpdatedAvailableLimit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SetLoadLimit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SubmittedLoadLimitUpdate\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SetGasTopUpLimit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SubmittedGasTopUpLimitUpdate\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Received\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_assets\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022BulkTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SetSpendLimit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SubmittedSpendLimitUpdate\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022AddedToWhitelist\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022SubmittedWhitelistAddition\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022CancelledWhitelistAddition\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022RemovedFromWhitelist\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_addresses\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022SubmittedWhitelistRemoval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_hash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022CancelledWhitelistRemoval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TransferredOwnership\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_locked\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LockedOwnership\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Wallet","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000085bb8a852c29d8f100cb97ecdf4589086d1be2dd0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000314159265dd8dbb310642f98f50c066173c1259be84f90570f13fe09f288f2411ff9cf50da611ed0c7db7f73d48053ffc974d3967f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697d0ff8bd67f6e25e4e4b010df582a36a0ee9b78e49afe6cc1cff5dd5a830403300000000000000000000000000000000000000000000000008ac7230489e80000","Library":"","SwarmSource":"bzzr://39d1a7c207df4e9874dc1b1a8be5453ec2db2d73fab93e6dc8a826b323ac4592"}]