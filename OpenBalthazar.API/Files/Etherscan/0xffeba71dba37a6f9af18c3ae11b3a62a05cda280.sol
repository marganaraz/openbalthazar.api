[{"SourceCode":"MIN_DEPOSIT_AMOUNT: constant(uint256) = 1000000000  # Gwei\r\nDEPOSIT_CONTRACT_TREE_DEPTH: constant(uint256) = 32\r\nMAX_DEPOSIT_COUNT: constant(uint256) = 4294967295 # 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1\r\nPUBKEY_LENGTH: constant(uint256) = 48  # bytes\r\nWITHDRAWAL_CREDENTIALS_LENGTH: constant(uint256) = 32  # bytes\r\nAMOUNT_LENGTH: constant(uint256) = 8  # bytes\r\nSIGNATURE_LENGTH: constant(uint256) = 96  # bytes\r\n\r\nDepositEvent: event({\r\n    pubkey: bytes[48],\r\n    withdrawal_credentials: bytes[32],\r\n    amount: bytes[8],\r\n    signature: bytes[96],\r\n    index: bytes[8],\r\n})\r\n\r\nbranch: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]\r\ndeposit_count: uint256\r\n\r\n# Compute hashes in empty sparse Merkle tree\r\nzero_hashes: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]\r\n@public\r\ndef __init__():\r\n    for i in range(DEPOSIT_CONTRACT_TREE_DEPTH - 1):\r\n        self.zero_hashes[i \u002B 1] = sha256(concat(self.zero_hashes[i], self.zero_hashes[i]))\r\n\r\n\r\n@private\r\n@constant\r\ndef to_little_endian_64(value: uint256) -\u003E bytes[8]:\r\n    # Reversing bytes using bitwise uint256 manipulations\r\n    # Note: array accesses of bytes[] are not currently supported in Vyper\r\n    # Note: this function is only called when \u0060value \u003C 2**64\u0060\r\n    y: uint256 = 0\r\n    x: uint256 = value\r\n    for _ in range(8):\r\n        y = shift(y, 8)\r\n        y = y \u002B bitwise_and(x, 255)\r\n        x = shift(x, -8)\r\n    return slice(convert(y, bytes32), start=24, len=8)\r\n\r\n\r\n@public\r\n@constant\r\ndef get_hash_tree_root() -\u003E bytes32:\r\n    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    node: bytes32 = zero_bytes32\r\n    size: uint256 = self.deposit_count\r\n    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):\r\n        if bitwise_and(size, 1) == 1:  # More gas efficient than \u0060size % 2 == 1\u0060\r\n            node = sha256(concat(self.branch[height], node))\r\n        else:\r\n            node = sha256(concat(node, self.zero_hashes[height]))\r\n        size /= 2\r\n    return sha256(concat(node, self.to_little_endian_64(self.deposit_count), slice(zero_bytes32, start=0, len=24)))\r\n\r\n\r\n@public\r\n@constant\r\ndef get_deposit_count() -\u003E bytes[8]:\r\n    return self.to_little_endian_64(self.deposit_count)\r\n\r\n\r\n@payable\r\n@public\r\ndef deposit(pubkey: bytes[PUBKEY_LENGTH],\r\n            withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],\r\n            signature: bytes[SIGNATURE_LENGTH]):\r\n    # Avoid overflowing the Merkle tree (and prevent edge case in computing \u0060self.branch\u0060)\r\n    assert self.deposit_count \u003C MAX_DEPOSIT_COUNT\r\n\r\n    # Validate deposit data\r\n    deposit_amount: uint256 = msg.value / as_wei_value(1, \u0022gwei\u0022)\r\n    assert deposit_amount \u003E= MIN_DEPOSIT_AMOUNT\r\n    assert len(pubkey) == PUBKEY_LENGTH\r\n    assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH\r\n    assert len(signature) == SIGNATURE_LENGTH\r\n\r\n    # Emit \u0060DepositEvent\u0060 log\r\n    amount: bytes[8] = self.to_little_endian_64(deposit_amount)\r\n    log.DepositEvent(pubkey, withdrawal_credentials, amount, signature, self.to_little_endian_64(self.deposit_count))\r\n\r\n    # Compute \u0060DepositData\u0060 hash tree root\r\n    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH)))\r\n    signature_root: bytes32 = sha256(concat(\r\n        sha256(slice(signature, start=0, len=64)),\r\n        sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)),\r\n    ))\r\n    node: bytes32 = sha256(concat(\r\n        sha256(concat(pubkey_root, withdrawal_credentials)),\r\n        sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)),\r\n    ))\r\n\r\n    # Add \u0060DepositData\u0060 hash tree root to Merkle tree (update a single \u0060branch\u0060 node)\r\n    self.deposit_count \u002B= 1\r\n    size: uint256 = self.deposit_count\r\n    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):\r\n        if bitwise_and(size, 1) == 1:  # More gas efficient than \u0060size % 2 == 1\u0060\r\n            self.branch[height] = node\r\n            break\r\n        node = sha256(concat(self.branch[height], node))\r\n        size /= 2","ABI":"[{\u0022name\u0022:\u0022DepositEvent\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022pubkey\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022withdrawal_credentials\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022index\u0022,\u0022indexed\u0022:false}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022outputs\u0022:[],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022constructor\u0022},{\u0022name\u0022:\u0022get_hash_tree_root\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:91674},{\u0022name\u0022:\u0022get_deposit_count\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:10433},{\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022pubkey\u0022},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022withdrawal_credentials\u0022},{\u0022type\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:true,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1334417}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b9","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":""}]