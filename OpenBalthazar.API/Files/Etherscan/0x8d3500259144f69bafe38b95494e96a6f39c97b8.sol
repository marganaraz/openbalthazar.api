[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/DivideContract.sol\r\n\r\npragma solidity \u003E=0.5.10 \u003C0.6.0;\r\n\r\n\r\n\r\ncontract DivideContract {\r\n  using SafeMath for uint256;\r\n\r\n  address owner;\r\n  mapping(address =\u003E bool) operators;\r\n  uint256 public NUM_RECIPIENTS = 2;\r\n  uint256 public PRECISION = 10000;\r\n  RecipientList recipientList;\r\n  address public nftAddress;\r\n\r\n  struct RecipientList {\r\n    address payable[] available_recipients;\r\n    uint256[] ratios;\r\n  }\r\n\r\n  event OperatorChanged(\r\n    address indexed operator,\r\n    bool action\r\n  );\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 amount,\r\n    uint256 totalAmount\r\n  );\r\n\r\n  event RecipientsInfoChanged(\r\n    bool action,\r\n    address payable[] recipients,\r\n    uint256[] ratios\r\n  );\r\n\r\n  modifier isOwner() {\r\n    require(msg.sender == owner, \u0027No permissions\u0027);\r\n    _;\r\n  }\r\n\r\n  modifier isOperator() {\r\n    require(operators[msg.sender] || msg.sender == owner, \u0027No permissions\u0027);\r\n    _;\r\n  }\r\n\r\n  constructor(address _nftAddress) public {\r\n    require(_nftAddress != address(0)); // Do not allow 0 addresses\r\n    owner = msg.sender;\r\n    nftAddress = _nftAddress;\r\n  }\r\n\r\n  // Calculate the sum of an array\r\n  function arraySum(uint256[] memory data) private pure returns (uint256) {\r\n    uint256 res;\r\n    for (uint256 i; i \u003C data.length; i\u002B\u002B) {\r\n      res = res.add(data[i]);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function getOwner() public view returns (address) {\r\n    return owner;\r\n  }\r\n\r\n  // Check if operator is in mapping for js tests\r\n  function operatorExists (address entity) public view returns (bool) {\r\n    return operators[entity];\r\n  }\r\n\r\n  function assignOperator (address entity) public isOwner() {\r\n    require(entity != address(0), \u0027Target is invalid addresses\u0027);\r\n    require(!operatorExists(entity), \u0027Target is already an operator\u0027);\r\n    emit OperatorChanged(entity, true);\r\n    operators[entity] = true;\r\n  }\r\n\r\n  function removeOperator (address entity) public isOwner() {\r\n    require(entity != address(0), \u0027Target is invalid addresses\u0027);\r\n    require(operatorExists(entity), \u0027Target is not an operator\u0027);\r\n    emit OperatorChanged(entity, false);\r\n    operators[entity] = false;\r\n  }\r\n\r\n  // Save all recipients and their corresponding ratios\r\n  // In: array of recipients, integer array of ratios\r\n  function registerRecipientsInfo (address payable[] memory recipients, uint256[] memory ratio) public isOperator() returns (bool) {\r\n    require(arraySum(ratio) == PRECISION, \u0027Total sum of ratio must be 100%\u0027);\r\n    require(recipients.length == ratio.length, \u0027Incorrect data size\u0027);\r\n    require(recipients.length == NUM_RECIPIENTS, \u0027Incorrect number of recipients\u0027);\r\n\r\n    recipientList = RecipientList(recipients, ratio);\r\n    emit RecipientsInfoChanged(true, recipients, ratio);\r\n    return true;\r\n  }\r\n\r\n  // Get info about nft platform recipients\r\n  // Out: nft platfor address, available recipients, ratios\r\n  function getRecipientsInfo() public view isOperator() returns (address, address payable[] memory, uint256[] memory) {\r\n    return (nftAddress, recipientList.available_recipients, recipientList.ratios);\r\n  }\r\n\r\n  function deleteRecipientsInfo () public isOperator() {\r\n    require(recipientList.available_recipients.length \u003E 0, \u0027No recipients registered\u0027);\r\n    emit RecipientsInfoChanged(false, recipientList.available_recipients, recipientList.ratios);\r\n    delete recipientList;\r\n  }\r\n\r\n  function calculateAmount(uint256 fee_received, uint256 ratio) private view returns (uint256) {\r\n    return (fee_received.mul(ratio).div(PRECISION));\r\n  }\r\n\r\n\r\n  // Divides any ether coming to this contract by their ratios and send the amounts to each recipient.\r\n  // Last recipient gets also everything that was left by division errors\r\n  function () external payable {\r\n    require(recipientList.available_recipients.length == NUM_RECIPIENTS, \u0027No recipients registered\u0027);\r\n\r\n    uint256 amount1 = calculateAmount(msg.value, recipientList.ratios[0]);\r\n    address payable toWallet1 = recipientList.available_recipients[0];\r\n    toWallet1.transfer(amount1);\r\n    emit Transfer(msg.sender, toWallet1, amount1, msg.value);\r\n\r\n    // Send all what is left to last recipient to avoid stuck ether\r\n    uint256 amount2 = address(this).balance;\r\n    address payable toWallet2 = recipientList.available_recipients[1];\r\n    toWallet2.transfer(amount2);\r\n    emit Transfer(msg.sender, toWallet2, amount2, msg.value);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022entity\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022operatorExists\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deleteRecipientsInfo\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022NUM_RECIPIENTS\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022nftAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022entity\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022assignOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022PRECISION\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022entity\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getRecipientsInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ratio\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022registerRecipientsInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_nftAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022operator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022action\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022OperatorChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022action\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address payable[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ratios\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022RecipientsInfoChanged\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"DivideContract","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000273f7f8e6489682df756151f5525576e322d51a3","Library":"","SwarmSource":"bzzr://c9c6b5dc1aa0e1e4a51188ff90b05a2ef5912c447737fbd866bc65cdaecebb4e"}]