[{"SourceCode":"pragma solidity \u003E=0.5.0;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a \u002B b;\r\n        require(c \u003E= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LitionPool {\r\n    using SafeMath for uint256;\r\n    \r\n    event StakingStarted(address indexed staker, uint256 amount, uint8 lockupPeriod, bool compound);\r\n    event StakingFinished(address indexed staker, uint256 amount);\r\n    event StakerRemoved(address indexed staker, uint256 amount);\r\n    event RewardSent(uint256 amount);\r\n    event CompoundChanged(address indexed staker);\r\n    event RewardsWithdrawn(address indexed staker, uint256 amount);\r\n\r\n    address public owner;\r\n    IERC20 litionToken;\r\n    uint256 public lastRewardedBlock = 0;\r\n\r\n    struct Stake {\r\n        bool valid;\r\n        uint256 amount;\r\n        uint8 lockupPeriod;\r\n        bool compound;\r\n        uint256 timestamp;\r\n        uint256 rewards;\r\n    }\r\n\r\n    address[] stakers;\r\n    mapping (address =\u003E Stake) public stakesBySender;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _litionToken) public {\r\n        owner = msg.sender;\r\n        litionToken = _litionToken;\r\n    }\r\n    \r\n    function stakeTokens(uint8 _lockupPeriod, bool _compound, uint256 _amount) public {\r\n        require(!stakesBySender[msg.sender].valid, \u0022You can\u0027t increase your stake\u0022);\r\n        require(_isValidLockupPeriod(_lockupPeriod), \u0022The lockup period is invalid\u0022);\r\n        require(_amount \u003E= 5000000000000000000000, \u0022You must stake at least 5000 LIT\u0022);\r\n\r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), _amount));\r\n        \r\n        stakesBySender[msg.sender].valid = true;\r\n        stakesBySender[msg.sender].amount = _amount;\r\n        stakesBySender[msg.sender].lockupPeriod = _lockupPeriod;\r\n        stakesBySender[msg.sender].compound = _compound;\r\n        stakesBySender[msg.sender].timestamp = now;\r\n        \r\n        stakers.push(msg.sender);\r\n        \r\n        emit StakingStarted(msg.sender, _amount, _lockupPeriod, _compound);\r\n    }\r\n    \r\n    function rewardStakers(uint256 _rewardedBlock, uint256 _amount) public onlyOwner {\r\n        lastRewardedBlock = _rewardedBlock;\r\n        \r\n        uint256 fees = _amount.mul(5) / 100;\r\n        uint256 totalParts = _calculateParts();\r\n        uint256 totalTransferred = 0;\r\n        \r\n        for (uint256 i = 0; i \u003C stakers.length; i\u002B\u002B) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            \r\n            if (!_isValidAndNotExpired(stakers[i])) {\r\n                continue;\r\n            }\r\n            \r\n            uint256 amountToTransfer = _getAmountToTransfer(totalParts, _amount.sub(fees), stake.lockupPeriod, stake.amount);\r\n            totalTransferred = totalTransferred.add(amountToTransfer);\r\n            \r\n            if (stake.compound) {\r\n                stakesBySender[stakers[i]].amount = stakesBySender[stakers[i]].amount.add(amountToTransfer);\r\n            }\r\n            else {\r\n                stakesBySender[stakers[i]].rewards = stakesBySender[stakers[i]].rewards.add(amountToTransfer);\r\n            }\r\n        }\r\n        \r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), totalTransferred));\r\n\r\n        emit RewardSent(_amount);\r\n    }\r\n    \r\n    function switchCompound() public {\r\n        require(stakesBySender[msg.sender].valid, \u0022You are not staking\u0022);\r\n        stakesBySender[msg.sender].compound = !stakesBySender[msg.sender].compound;\r\n        emit CompoundChanged(msg.sender);\r\n    }\r\n    \r\n    function withdrawRewards() public {\r\n        require(stakesBySender[msg.sender].valid, \u0022You are not staking tokens\u0022);\r\n        require(stakesBySender[msg.sender].rewards \u003E 0, \u0022You don\u0027t have rewards to claim\u0022);\r\n        \r\n        uint256 amount = stakesBySender[msg.sender].rewards;\r\n        stakesBySender[msg.sender].rewards = 0;\r\n\r\n        require(litionToken.transfer(msg.sender, amount));\r\n\r\n        emit RewardsWithdrawn(msg.sender, amount);\r\n    }\r\n    \r\n    function finishStaking() public {\r\n        require(_isLockupPeriodFinished(stakesBySender[msg.sender].timestamp, stakesBySender[msg.sender].lockupPeriod), \u0022The lockup period is not finished\u0022);\r\n\r\n        uint256 total = _closeStake(msg.sender);\r\n        \r\n        emit StakingFinished(msg.sender, total);\r\n    }\r\n    \r\n    function getTotalInStake() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i \u003C stakers.length; i\u002B\u002B) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            total = total.add(stake.amount);\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalStakers() public view returns (uint256) {\r\n        return stakers.length;\r\n    }\r\n    \r\n    function getLockupFinishTimestamp(address _staker) public view returns (uint256) {\r\n        require(stakesBySender[_staker].valid, \u0022The address is not staking tokens\u0022);\r\n\r\n        Stake memory stake = stakesBySender[_staker];\r\n        return stake.timestamp \u002B stake.lockupPeriod * (30 days);\r\n    }\r\n\r\n    function _removeStaker(address _staker) public onlyOwner {\r\n        uint256 total = _closeStake(_staker);\r\n\r\n        emit StakerRemoved(_staker, total);\r\n    }\r\n\r\n    function _closeStake(address _staker) internal returns (uint256) {\r\n        require(stakesBySender[_staker].valid, \u0022This is not a valid staker\u0022);\r\n\r\n        stakesBySender[_staker].valid = false;\r\n        uint256 rewards = stakesBySender[_staker].rewards;\r\n        uint256 total = stakesBySender[_staker].amount.add(rewards);\r\n        stakesBySender[_staker].amount = 0;\r\n        stakesBySender[_staker].rewards = 0;\r\n        \r\n        _removeByValue(_staker);\r\n        \r\n        require(litionToken.transfer(_staker, total));\r\n\r\n        return total;\r\n    }\r\n    \r\n    function _extractLitSentByMistake(address _to) public onlyOwner {\r\n        require(stakers.length == 0, \u0022There are still stakers in the contract\u0022);\r\n        uint256 litBalance = litionToken.balanceOf(address(this));\r\n        require(litionToken.transfer(_to, litBalance));\r\n    }\r\n        \r\n    function _calculateParts() internal view returns (uint256) {\r\n        uint256 divideInParts = 0;\r\n        \r\n        for (uint256 i = 0; i \u003C stakers.length; i\u002B\u002B) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            \r\n            if (!_isValidAndNotExpired(stakers[i])) {\r\n                continue;\r\n            }\r\n\r\n            if (stake.lockupPeriod == 1) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(12));\r\n            }\r\n            else if (stake.lockupPeriod == 3) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(14));\r\n            }\r\n            else if (stake.lockupPeriod == 6) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(16));\r\n            }\r\n            else if (stake.lockupPeriod == 12) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(18));\r\n            }\r\n        }\r\n        \r\n        return divideInParts;\r\n    }\r\n    \r\n    function _getAmountToTransfer(uint256 _totalParts, uint256 _rewards, uint8 _lockupPeriod, uint256 _amount) internal pure returns (uint256) {\r\n        uint256 factor;\r\n        \r\n        if (_lockupPeriod == 1) {\r\n            factor = 12;\r\n        }\r\n        else if (_lockupPeriod == 3) {\r\n            factor = 14;\r\n        }\r\n        else if (_lockupPeriod == 6) {\r\n            factor = 16;\r\n        }\r\n        else if (_lockupPeriod == 12) {\r\n            factor = 18;\r\n        }\r\n\r\n        return _amount.mul(factor).mul(_rewards).div(_totalParts).div(10);\r\n    }\r\n    \r\n    function _isValidLockupPeriod(uint8 n) internal pure returns (bool) {\r\n        if (n == 1) {\r\n            return true;\r\n        }\r\n        else if (n == 3) {\r\n            return true;\r\n        }\r\n        else if (n == 6) {\r\n            return true;\r\n        }\r\n        else if (n == 12) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function _isValidAndNotExpired(address _staker) internal view returns (bool) {\r\n        if (!stakesBySender[_staker].valid) {\r\n            return false;\r\n        }\r\n        if (_isLockupPeriodFinished(stakesBySender[_staker].timestamp, stakesBySender[_staker].lockupPeriod)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function _isLockupPeriodFinished(uint256 _timestamp, uint8 _lockupPeriod) internal view returns (bool) {\r\n        return now \u003E _timestamp \u002B _lockupPeriod * (30 days);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function _find(address _value) internal view returns(uint) {\r\n        uint i = 0;\r\n        while (stakers[i] != _value) {\r\n            i\u002B\u002B;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    function _removeByValue(address _value) internal {\r\n        uint i = _find(_value);\r\n        _removeByIndex(i);\r\n    }\r\n\r\n    function _removeByIndex(uint i) internal {\r\n        while (i\u003Cstakers.length-1) {\r\n            stakers[i] = stakers[i\u002B1];\r\n            i\u002B\u002B;\r\n        }\r\n        stakers.length--;\r\n    }\r\n    \r\n    function() external payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getTotalStakers\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022stakesBySender\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022valid\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lockupPeriod\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022compound\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rewards\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022lastRewardedBlock\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_lockupPeriod\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022_compound\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022stakeTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_rewardedBlock\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022rewardStakers\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getLockupFinishTimestamp\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022_removeStaker\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022_extractLitSentByMistake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdrawRewards\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022_transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022finishStaking\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022switchCompound\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getTotalInStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_litionToken\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022lockupPeriod\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022compound\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022StakingStarted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022StakingFinished\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022StakerRemoved\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RewardSent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CompoundChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RewardsWithdrawn\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"LitionPool","CompilerVersion":"v0.5.0\u002Bcommit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000763fa6806e1acf68130d2d0f0df754c93cc546b2","Library":"","SwarmSource":"bzzr://287d665064fba0cb2efd6b75b696cf1dc40f932428621bc6628f12dfa574ec1e"}]