[{"SourceCode":"/*\r\n  Copyright 2019 Swap Holdings Ltd.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.10;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n  * @title Types: Library of Swap Protocol Types and Hashes\r\n  */\r\nlibrary Types {\r\n\r\n  bytes constant internal EIP191_HEADER = \u0022\\x19\\x01\u0022;\r\n\r\n  struct Party {\r\n    address wallet;   // Wallet address of the party\r\n    address token;    // Contract address of the token\r\n    uint256 param;    // Value (ERC-20) or ID (ERC-721)\r\n    bytes4 kind;      // Interface ID of the token\r\n  }\r\n\r\n  struct Order {\r\n    uint256 nonce;    // Unique per order and should be sequential\r\n    uint256 expiry;   // Expiry in seconds since 1 January 1970\r\n    Party maker;      // Party to the trade that sets terms\r\n    Party taker;      // Party to the trade that accepts terms\r\n    Party affiliate;  // Party compensated for facilitating (optional)\r\n  }\r\n\r\n  struct Signature {\r\n    address signer;   // Address of the wallet used to sign\r\n    uint8 v;          // \u0060v\u0060 value of an ECDSA signature\r\n    bytes32 r;        // \u0060r\u0060 value of an ECDSA signature\r\n    bytes32 s;        // \u0060s\u0060 value of an ECDSA signature\r\n    bytes1 version;   // EIP-191 signature version\r\n  }\r\n\r\n  bytes32 constant DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n    \u0022EIP712Domain(\u0022,\r\n    \u0022string name,\u0022,\r\n    \u0022string version,\u0022,\r\n    \u0022address verifyingContract\u0022,\r\n    \u0022)\u0022\r\n  ));\r\n\r\n  bytes32 constant ORDER_TYPEHASH = keccak256(abi.encodePacked(\r\n    \u0022Order(\u0022,\r\n    \u0022uint256 nonce,\u0022,\r\n    \u0022uint256 expiry,\u0022,\r\n    \u0022Party maker,\u0022,\r\n    \u0022Party taker,\u0022,\r\n    \u0022Party affiliate\u0022,\r\n    \u0022)\u0022,\r\n    \u0022Party(\u0022,\r\n    \u0022address wallet,\u0022,\r\n    \u0022address token,\u0022,\r\n    \u0022uint256 param,\u0022,\r\n    \u0022bytes4 kind\u0022,\r\n    \u0022)\u0022\r\n  ));\r\n\r\n  bytes32 constant PARTY_TYPEHASH = keccak256(abi.encodePacked(\r\n    \u0022Party(\u0022,\r\n    \u0022address wallet,\u0022,\r\n    \u0022address token,\u0022,\r\n    \u0022uint256 param,\u0022,\r\n    \u0022bytes4 kind\u0022,\r\n    \u0022)\u0022\r\n  ));\r\n\r\n  /**\r\n    * @notice Hash an order into bytes32\r\n    * @dev EIP-191 header and domain separator included\r\n    * @param _order Order\r\n    * @param _domainSeparator bytes32\r\n    * @return bytes32 returns a keccak256 abi.encodePacked value\r\n    */\r\n  function hashOrder(\r\n    Order calldata _order,\r\n    bytes32 _domainSeparator\r\n  ) external pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\r\n      EIP191_HEADER,\r\n      _domainSeparator,\r\n      keccak256(abi.encode(\r\n        ORDER_TYPEHASH,\r\n        _order.nonce,\r\n        _order.expiry,\r\n        keccak256(abi.encode(\r\n          PARTY_TYPEHASH,\r\n          _order.maker.wallet,\r\n          _order.maker.token,\r\n          _order.maker.param,\r\n          _order.maker.kind\r\n        )),\r\n        keccak256(abi.encode(\r\n          PARTY_TYPEHASH,\r\n          _order.taker.wallet,\r\n          _order.taker.token,\r\n          _order.taker.param,\r\n          _order.taker.kind\r\n        )),\r\n        keccak256(abi.encode(\r\n          PARTY_TYPEHASH,\r\n          _order.affiliate.wallet,\r\n          _order.affiliate.token,\r\n          _order.affiliate.param,\r\n          _order.affiliate.kind\r\n        ))\r\n      ))\r\n    ));\r\n  }\r\n\r\n  /**\r\n    * @notice Hash domain parameters into bytes32\r\n    * @dev Used for signature validation (EIP-712)\r\n    * @param _name bytes\r\n    * @param _version bytes\r\n    * @param _verifyingContract address\r\n    * @return bytes32 returns a keccak256 abi.encodePacked value\r\n    */\r\n  function hashDomain(\r\n    bytes calldata _name,\r\n    bytes calldata _version,\r\n    address _verifyingContract\r\n  ) external pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      DOMAIN_TYPEHASH,\r\n      keccak256(_name),\r\n      keccak256(_version),\r\n      _verifyingContract\r\n    ));\r\n  }\r\n\r\n}\r\n\r\n// File: @airswap/swap/contracts/interfaces/ISwap.sol\r\n\r\n\r\ninterface ISwap {\r\n\r\n  event Swap(\r\n    uint256 indexed nonce,\r\n    uint256 timestamp,\r\n    address indexed makerWallet,\r\n    uint256 makerParam,\r\n    address makerToken,\r\n    address indexed takerWallet,\r\n    uint256 takerParam,\r\n    address takerToken,\r\n    address affiliateWallet,\r\n    uint256 affiliateParam,\r\n    address affiliateToken\r\n  );\r\n\r\n  event Cancel(\r\n    uint256 indexed nonce,\r\n    address indexed makerWallet\r\n  );\r\n\r\n  event Invalidate(\r\n    uint256 indexed nonce,\r\n    address indexed makerWallet\r\n  );\r\n\r\n  event Authorize(\r\n    address indexed approverAddress,\r\n    address indexed delegateAddress,\r\n    uint256 expiry\r\n  );\r\n\r\n  event Revoke(\r\n    address indexed approverAddress,\r\n    address indexed delegateAddress\r\n  );\r\n\r\n  function delegateApprovals(address, address) external returns (uint256);\r\n  function makerOrderStatus(address, uint256) external returns (byte);\r\n  function makerMinimumNonce(address) external returns (uint256);\r\n\r\n  /**\r\n    * @notice Atomic Token Swap\r\n    * @param order Types.Order\r\n    * @param signature Types.Signature\r\n    */\r\n  function swap(\r\n    Types.Order calldata order,\r\n    Types.Signature calldata signature\r\n  ) external;\r\n\r\n  /**\r\n    * @notice Cancel one or more open orders by nonce\r\n    * @param _nonces uint256[]\r\n    */\r\n  function cancel(\r\n    uint256[] calldata _nonces\r\n  ) external;\r\n\r\n  /**\r\n    * @notice Invalidate all orders below a nonce value\r\n    * @param _minimumNonce uint256\r\n    */\r\n  function invalidate(\r\n    uint256 _minimumNonce\r\n  ) external;\r\n\r\n  /**\r\n    * @notice Authorize a delegate\r\n    * @param _delegate address\r\n    * @param _expiry uint256\r\n    */\r\n  function authorize(\r\n    address _delegate,\r\n    uint256 _expiry\r\n  ) external;\r\n\r\n  /**\r\n    * @notice Revoke an authorization\r\n    * @param _delegate address\r\n    */\r\n  function revoke(\r\n    address _delegate\r\n  ) external;\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (\u0060ERC165Checker\u0060).\r\n *\r\n * For an implementation, see \u0060ERC165\u0060.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * \u0060interfaceId\u0060. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in \u0060owner\u0060\u0027s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by \u0060tokenId\u0060.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - \u0060from\u0060, \u0060to\u0060 cannot be zero.\r\n     * - \u0060tokenId\u0060 must be owned by \u0060from\u0060.\r\n     * - If the caller is not \u0060from\u0060, it must be have been allowed to move this\r\n     * NFT by either \u0060approve\u0060 or \u0060setApproveForAll\u0060.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not \u0060from\u0060, it must be approved to move this NFT by\r\n     * either \u0060approve\u0060 or \u0060setApproveForAll\u0060.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: contracts/Swap.sol\r\n\r\n\r\n/**\r\n  * @title Swap: The Atomic Swap used by the Swap Protocol\r\n  */\r\ncontract Swap is ISwap {\r\n\r\n  // Domain and version for use in signatures (EIP-712)\r\n  bytes constant internal DOMAIN_NAME = \u0022SWAP\u0022;\r\n  bytes constant internal DOMAIN_VERSION = \u00222\u0022;\r\n\r\n  // Unique domain identifier for use in signatures (EIP-712)\r\n  bytes32 private domainSeparator;\r\n\r\n  // Possible order statuses\r\n  byte constant private OPEN = 0x00;\r\n  byte constant private TAKEN = 0x01;\r\n  byte constant private CANCELED = 0x02;\r\n\r\n  // ERC-20 (fungible token) interface identifier (ERC-165)\r\n  bytes4 constant internal ERC20_INTERFACE_ID = 0x277f8169;\r\n  /*\r\n    bytes4(keccak256(\u0027transfer(address,uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027balanceOf(address)\u0027)) ^\r\n    bytes4(keccak256(\u0027allowance(address,address)\u0027));\r\n  */\r\n\r\n  // ERC-721 (non-fungible token) interface identifier (ERC-165)\r\n  bytes4 constant internal ERC721_INTERFACE_ID = 0x80ac58cd;\r\n  /*\r\n    bytes4(keccak256(\u0027balanceOf(address)\u0027)) ^\r\n    bytes4(keccak256(\u0027ownerOf(uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027approve(address,uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027getApproved(uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) ^\r\n    bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) ^\r\n    bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256)\u0027)) ^\r\n    bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,bytes)\u0027));\r\n  */\r\n\r\n  // Mapping of peer address to delegate address and expiry.\r\n  mapping (address =\u003E mapping (address =\u003E uint256)) public delegateApprovals;\r\n\r\n  // Mapping of makers to orders by nonce as TAKEN (0x01) or CANCELED (0x02)\r\n  mapping (address =\u003E mapping (uint256 =\u003E byte)) public makerOrderStatus;\r\n\r\n  // Mapping of makers to an optionally set minimum valid nonce\r\n  mapping (address =\u003E uint256) public makerMinimumNonce;\r\n\r\n  /**\r\n    * @notice Contract Constructor\r\n    * @dev Sets domain for signature validation (EIP-712)\r\n    */\r\n  constructor() public {\r\n    domainSeparator = Types.hashDomain(\r\n      DOMAIN_NAME,\r\n      DOMAIN_VERSION,\r\n      address(this)\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @notice Atomic Token Swap\r\n    * @param _order Types.Order\r\n    * @param _signature Types.Signature\r\n    */\r\n  function swap(\r\n    Types.Order calldata _order,\r\n    Types.Signature calldata _signature\r\n  ) external {\r\n\r\n    // Ensure the order is not expired.\r\n    require(_order.expiry \u003E block.timestamp,\r\n      \u0022ORDER_EXPIRED\u0022);\r\n\r\n    // Ensure the order is not already taken.\r\n    require(makerOrderStatus[_order.maker.wallet][_order.nonce] != TAKEN,\r\n      \u0022ORDER_ALREADY_TAKEN\u0022);\r\n\r\n    // Ensure the order is not already canceled.\r\n    require(makerOrderStatus[_order.maker.wallet][_order.nonce] != CANCELED,\r\n      \u0022ORDER_ALREADY_CANCELED\u0022);\r\n\r\n    // Ensure the order nonce is above the minimum.\r\n    require(_order.nonce \u003E= makerMinimumNonce[_order.maker.wallet],\r\n      \u0022NONCE_TOO_LOW\u0022);\r\n\r\n    // Mark the order TAKEN (0x01).\r\n    makerOrderStatus[_order.maker.wallet][_order.nonce] = TAKEN;\r\n\r\n    // Validate the taker side of the trade.\r\n    address finalTakerWallet;\r\n\r\n    if (_order.taker.wallet == address(0)) {\r\n      /**\r\n        * Taker is not specified. The sender of the transaction becomes\r\n        * the taker of the _order.\r\n        */\r\n      finalTakerWallet = msg.sender;\r\n\r\n    } else {\r\n      /**\r\n        * Taker is specified. If the sender is not the specified taker,\r\n        * determine whether the sender has been authorized by the taker.\r\n        */\r\n      if (msg.sender != _order.taker.wallet) {\r\n        require(isAuthorized(_order.taker.wallet, msg.sender),\r\n          \u0022SENDER_UNAUTHORIZED\u0022);\r\n      }\r\n      // The specified taker is all clear.\r\n      finalTakerWallet = _order.taker.wallet;\r\n\r\n    }\r\n\r\n    // Validate the maker side of the trade.\r\n    if (_signature.v == 0) {\r\n      /**\r\n        * Signature is not provided. The maker may have authorized the sender\r\n        * to swap on its behalf, which does not require a _signature.\r\n        */\r\n      require(isAuthorized(_order.maker.wallet, msg.sender),\r\n        \u0022SIGNER_UNAUTHORIZED\u0022);\r\n\r\n    } else {\r\n      /**\r\n        * The signature is provided. Determine whether the signer is\r\n        * authorized by the maker and if so validate the signature itself.\r\n        */\r\n      require(isAuthorized(_order.maker.wallet, _signature.signer),\r\n        \u0022SIGNER_UNAUTHORIZED\u0022);\r\n\r\n      // Ensure the signature is valid.\r\n      require(isValid(_order, _signature, domainSeparator),\r\n        \u0022SIGNATURE_INVALID\u0022);\r\n\r\n    }\r\n    // Transfer token from taker to maker.\r\n    transferToken(\r\n      finalTakerWallet,\r\n      _order.maker.wallet,\r\n      _order.taker.param,\r\n      _order.taker.token,\r\n      _order.taker.kind\r\n    );\r\n\r\n    // Transfer token from maker to taker.\r\n    transferToken(\r\n      _order.maker.wallet,\r\n      finalTakerWallet,\r\n      _order.maker.param,\r\n      _order.maker.token,\r\n      _order.maker.kind\r\n    );\r\n\r\n    // Transfer token from maker to affiliate if specified.\r\n    if (_order.affiliate.wallet != address(0)) {\r\n      transferToken(\r\n        _order.maker.wallet,\r\n        _order.affiliate.wallet,\r\n        _order.affiliate.param,\r\n        _order.affiliate.token,\r\n        _order.affiliate.kind\r\n      );\r\n    }\r\n\r\n    emit Swap(_order.nonce, block.timestamp,\r\n      _order.maker.wallet, _order.maker.param, _order.maker.token,\r\n      finalTakerWallet, _order.taker.param, _order.taker.token,\r\n      _order.affiliate.wallet, _order.affiliate.param, _order.affiliate.token\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @notice Cancel one or more open orders by nonce\r\n    * @dev Canceled orders are marked CANCELED (0x02)\r\n    * @dev Emits a Cancel event\r\n    * @param _nonces uint256[]\r\n    */\r\n  function cancel(\r\n    uint256[] calldata _nonces\r\n  ) external {\r\n    for (uint256 i = 0; i \u003C _nonces.length; i\u002B\u002B) {\r\n      if (makerOrderStatus[msg.sender][_nonces[i]] == OPEN) {\r\n        makerOrderStatus[msg.sender][_nonces[i]] = CANCELED;\r\n        emit Cancel(_nonces[i], msg.sender);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @notice Invalidate all orders below a nonce value\r\n    * @dev Emits an Invalidate event\r\n    * @param _minimumNonce uint256\r\n    */\r\n  function invalidate(\r\n    uint256 _minimumNonce\r\n  ) external {\r\n    makerMinimumNonce[msg.sender] = _minimumNonce;\r\n    emit Invalidate(_minimumNonce, msg.sender);\r\n  }\r\n\r\n  /**\r\n    * @notice Authorize a delegate\r\n    * @dev Emits an Authorize event\r\n    * @param _delegate address\r\n    * @param _expiry uint256\r\n    */\r\n  function authorize(\r\n    address _delegate,\r\n    uint256 _expiry\r\n  ) external {\r\n    require(msg.sender != _delegate, \u0022INVALID_AUTH_DELEGATE\u0022);\r\n    require(_expiry \u003E block.timestamp, \u0022INVALID_AUTH_EXPIRY\u0022);\r\n    delegateApprovals[msg.sender][_delegate] = _expiry;\r\n    emit Authorize(msg.sender, _delegate, _expiry);\r\n  }\r\n\r\n  /**\r\n    * @notice Revoke an authorization\r\n    * @dev Emits a Revoke event\r\n    * @param _delegate address\r\n    */\r\n  function revoke(\r\n    address _delegate\r\n  ) external {\r\n    delete delegateApprovals[msg.sender][_delegate];\r\n    emit Revoke(msg.sender, _delegate);\r\n  }\r\n\r\n  /**\r\n    * @notice Determine whether a delegate is authorized\r\n    * @param _approver address\r\n    * @param _delegate address\r\n    * @return bool returns whether a delegate is authorized\r\n    */\r\n  function isAuthorized(\r\n    address _approver,\r\n    address _delegate\r\n  ) internal view returns (bool) {\r\n    if (_approver == _delegate) return true;\r\n    return (delegateApprovals[_approver][_delegate] \u003E block.timestamp);\r\n  }\r\n\r\n  /**\r\n    * @notice Validate signature using an EIP-712 typed data hash\r\n    * @param _order Order\r\n    * @param _signature Signature\r\n    * @return bool returns whether the signature \u002B order is valid\r\n    */\r\n  function isValid(\r\n    Types.Order memory _order,\r\n    Types.Signature memory _signature,\r\n    bytes32 _domainSeparator\r\n  ) internal pure returns (bool) {\r\n    if (_signature.version == byte(0x01)) {\r\n      return _signature.signer == ecrecover(\r\n        Types.hashOrder(\r\n          _order,\r\n          _domainSeparator),\r\n          _signature.v,\r\n          _signature.r,\r\n          _signature.s\r\n      );\r\n    }\r\n    if (_signature.version == byte(0x45)) {\r\n      return _signature.signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \u0022\\x19Ethereum Signed Message:\\n32\u0022,\r\n            Types.hashOrder(_order, _domainSeparator)\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n    * @notice Perform an ERC-20 or ERC-721 token transfer\r\n    * @dev Transfer type specified by the bytes4 _kind param\r\n    * @param _from address wallet address to send from\r\n    * @param _to address wallet address to send to\r\n    * @param _param uint256 amount for ERC-20 or token ID for ERC-721\r\n    * @param _token address contract address of token\r\n    * @param _kind bytes4 EIP-165 interface ID of the token\r\n    */\r\n  function transferToken(\r\n      address _from,\r\n      address _to,\r\n      uint256 _param,\r\n      address _token,\r\n      bytes4 _kind\r\n  ) internal {\r\n    if (_kind == ERC721_INTERFACE_ID) {\r\n      // Attempt to transfer an ERC-721 token.\r\n      IERC721(_token).safeTransferFrom(_from, _to, _param);\r\n    } else {\r\n      // Attempt to transfer an ERC-20 token.\r\n      require(IERC20(_token).transferFrom(_from, _to, _param));\r\n    }\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_minimumNonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022invalidate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerMinimumNonce\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_nonces\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022cancel\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022expiry\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022param\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022kind\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022param\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022kind\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022taker\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022param\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022kind\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022affiliate\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022_order\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022signer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022version\u0022,\u0022type\u0022:\u0022bytes1\u0022}],\u0022name\u0022:\u0022_signature\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022swap\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022makerOrderStatus\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes1\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022delegateApprovals\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_delegate\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022revoke\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_delegate\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_expiry\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022authorize\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022makerWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022makerParam\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022makerToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022takerWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022takerParam\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022takerToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022affiliateWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022affiliateParam\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022affiliateToken\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Swap\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022makerWallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Cancel\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022makerWallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Invalidate\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022approverAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegateAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022expiry\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Authorize\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022approverAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegateAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Revoke\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Swap","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"Types:c65ff60eb8e4038a2415bb569d1fa6dca47d692e","SwarmSource":"bzzr://5e867a66a2bb8c4fcf634dc135232fe3e0d8251f169861dab06344c87f0e180c"}]