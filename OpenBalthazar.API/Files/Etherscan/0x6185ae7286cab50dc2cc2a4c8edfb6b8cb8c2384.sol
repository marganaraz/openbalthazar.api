[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner || msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b \u003C= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    assert(c \u003E= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\ncontract Token{\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract Staking is Owned{\r\n    Token public token;\r\n    bool lock;\r\n    uint256 public stakeTokens;\r\n    uint256 private basePercent = 200;\r\n    using SafeMath for uint256;\r\n    \r\n    event stakingstarted(address staker, uint256 tokens, uint256 time);\r\n    event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);\r\n    \r\n    struct stake{\r\n        uint256 time;\r\n        bool redeem;\r\n        uint256 tokens;\r\n    }\r\n    mapping(address =\u003E stake) staker;\r\n    \r\n    \r\n    constructor(address tokenContractAddress) public{\r\n        token = Token(tokenContractAddress);\r\n        owner = msg.sender;\r\n        stakeTokens = 500 * 10 ** uint(10);\r\n    }\r\n    \r\n    function startStaking() public{\r\n        require(token.balanceOf(msg.sender) \u003E= stakeTokens \u002B findOnePercent(stakeTokens));\r\n        require(token.transferFrom(msg.sender, address(this), stakeTokens  \u002B findOnePercent(stakeTokens)));\r\n        staker[msg.sender].time = now;\r\n        staker[msg.sender].tokens =  staker[msg.sender].tokens \u002B stakeTokens;\r\n        emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);\r\n    }\r\n    \r\n    function redeem() public{\r\n        require(!lock);\r\n        require(!staker[msg.sender].redeem);\r\n        require(staker[msg.sender].time \u002B 3 weeks \u003C= now);\r\n        require(token.transfer(msg.sender,staker[msg.sender].tokens));\r\n        require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * 30 * 100 / 10000));\r\n        emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * 30 * 100 / 10000);\r\n        staker[msg.sender].redeem = true;\r\n        staker[msg.sender].tokens = 0;\r\n    }\r\n    \r\n    function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{\r\n        stakeTokens = _NewTokensThreshold * 10 ** uint(10);\r\n    }\r\n    \r\n    function lockWithdrawals() public onlyOwner{\r\n        lock = true;\r\n    }\r\n    \r\n    function findOnePercent(uint256 value) private view returns (uint256)  {\r\n        uint256 roundValue = value.ceil(basePercent);\r\n        uint256 onePercent = roundValue.mul(basePercent).div(10000);\r\n        return onePercent;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022newOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Owned","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6e881ac05ff70b8c1f5baf8c4df69547ff68504cd641d05ca044c8498af02ce4"}]