[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * \u003E Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IERC1620.sol\r\n\r\n/// @title ERC-1620 Money Streaming Standard\r\n/// @author Paul Berg - \u003Cpaul@sablier.app\u003E\r\n/// @dev See https://github.com/ethereum/eips/issues/1620\r\n\r\ninterface IERC1620 {\r\n    /// @dev This emits when streams are successfully created.\r\n    event Create(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 deposit,\r\n        address tokenAddress,\r\n        uint256 startTime,\r\n        uint256 stopTime\r\n    );\r\n\r\n    /// @dev This emits when the receiver of a stream withdraws a portion or all their available\r\n    ///  funds from an ongoing stream, without stopping it. Note that we don\u0027t emit both the\r\n    //   sender and the recipient\u0027s balance because only the recipient can withdraw.\r\n    event Withdraw(uint256 indexed streamId, address indexed recipient, uint256 amount);\r\n\r\n    /// @dev This emits when a stream is successfully redeemed and\r\n    ///  all involved parties get their share of the available funds.\r\n    event Cancel(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 senderAmount,\r\n        uint256 recipientAmount\r\n    );\r\n\r\n    /// @notice Creates a new stream between \u0060sender\u0060 and \u0060recipient\u0060.\r\n    /// @dev Throws unless the contract is allowed to transfer more than \u0060deposit\u0060 tokens.\r\n    ///  Throws if \u0060startTime\u0060 is lower or equal to \u0060block.timestamp\u0060.\r\n    ///  Throws if \u0060stopTime\u0060 is lower than \u0060startTime\u0060.\r\n    /// @param recipient The stream recipient or the payee.\r\n    /// @param deposit How much money it\u0027s streamed from sender to recipient.\r\n    /// @param tokenAddress The token contract.\r\n    /// @param startTime The start time of the stream.\r\n    /// @param stopTime The stop time of the stream.\r\n    function create(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)\r\n        external\r\n        returns (uint256 streamId);\r\n\r\n    /// @notice Withdraws all or a portion of the available funds.\r\n    /// @dev If the stream ended and the recipient withdraws the deposit in full, the stream object\r\n    ///  is deleted after this operation to save gas for the user and optimise contract storage.\r\n    ///  Throws if \u0060streamId\u0060 doesn\u0027t point to a valid stream.\r\n    ///  Throws if \u0060msg.sender\u0060 is not the recipient of the given \u0060streamId\u0060\r\n    /// @param streamId The stream to withdraw from\r\n    /// @param funds The amount of money to withdraw\r\n    function withdraw(uint256 streamId, uint256 funds) external;\r\n\r\n    /// @notice Distributes the funds to the sender and the recipient.\r\n    /// @dev The stream object gets deleted after this operation to save gas\r\n    ///  for the user and optimise contract storage.\r\n    ///  Throws if \u0060streamId\u0060 points to an invalid stream.\r\n    ///  Throws if \u0060msg.sender\u0060 is not either the sender or the recipient.\r\n    ///  of the given \u0060streamId\u0060.\r\n    /// @param streamId The stream to stop.\r\n    function cancel(uint256 streamId) external;\r\n\r\n    /// @notice Returns available funds for the given stream id and address\r\n    /// @dev Streams assigned to the zero address are considered invalid, and\r\n    ///  this function throws for queries about the zero address.\r\n    /// @param streamId The stream for whom to query the balance\r\n    /// @param who The address for whom to query the balance\r\n    /// @return The total funds available to \u0060who\u0060 to withdraw\r\n    function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\r\n\r\n    /// @notice Returns the full stream data\r\n    /// @dev Throws if \u0060streamId\u0060 points to an invalid stream.\r\n    /// @param streamId The stream to return data for\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            uint256 deposit,\r\n            address token,\r\n            uint256 startTime,\r\n            uint256 stopTime,\r\n            uint256 balance,\r\n            uint256 rate\r\n        );\r\n}\r\n\r\n// File: contracts/Types.sol\r\n\r\nlibrary Types {\r\n    struct Stream {\r\n        uint256 balance;\r\n        uint256 deposit;\r\n        bool isEntity;\r\n        uint256 rate;\r\n        address recipient;\r\n        address sender;\r\n        uint256 startTime;\r\n        uint256 stopTime;\r\n        address tokenAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/Sablier.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Sablier - Money Streaming Implementation\r\n/// @author Paul Berg - \u003Cpaul@sablier.app\u003E\r\n\r\ncontract Sablier is IERC1620, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(uint256 =\u003E Types.Stream) private streams;\r\n    uint256 public nonce;\r\n\r\n    modifier onlyRecipient(uint256 streamId) {\r\n        require(streams[streamId].recipient == msg.sender, \u0022caller is not the recipient of the stream\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlySenderOrRecipient(uint256 streamId) {\r\n        require(\r\n            msg.sender == streams[streamId].sender || msg.sender == streams[streamId].recipient,\r\n            \u0022caller is not the stream or the recipient of the stream\u0022\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier streamExists(uint256 streamId) {\r\n        require(streams[streamId].isEntity, \u0022stream does not exist\u0022);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        nonce = 1;\r\n    }\r\n\r\n    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 delta = deltaOf(streamId);\r\n        uint256 streamed = delta.mul(stream.rate);\r\n        if (stream.balance != stream.deposit) {\r\n            streamed = streamed.sub(stream.deposit.sub(stream.balance));\r\n        }\r\n        if (who == stream.recipient) {\r\n            return streamed;\r\n        } else if (who == stream.sender) {\r\n            return stream.balance.sub(streamed);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function deltaOf(uint256 streamId) public view streamExists(streamId) returns (uint256 delta) {\r\n        Types.Stream memory stream = streams[streamId];\r\n\r\n        // before the start of the stream\r\n        if (block.timestamp \u003C= stream.startTime) return 0;\r\n\r\n        // during the stream\r\n        if (block.timestamp \u003C stream.stopTime) return block.timestamp - stream.startTime;\r\n\r\n        // after the end of the stream\r\n        return stream.stopTime - stream.startTime;\r\n    }\r\n\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        streamExists(streamId)\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            uint256 deposit,\r\n            address tokenAddress,\r\n            uint256 startTime,\r\n            uint256 stopTime,\r\n            uint256 balance,\r\n            uint256 rate\r\n        )\r\n    {\r\n        Types.Stream memory stream = streams[streamId];\r\n        return (\r\n            stream.sender,\r\n            stream.recipient,\r\n            stream.deposit,\r\n            stream.tokenAddress,\r\n            stream.startTime,\r\n            stream.stopTime,\r\n            stream.balance,\r\n            stream.rate\r\n        );\r\n    }\r\n\r\n    function create(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)\r\n        external\r\n        returns (uint256 streamId)\r\n    {\r\n        require(recipient != address(0x00), \u0022stream to the zero address\u0022);\r\n        require(recipient != address(this), \u0022stream to the contract itself\u0022);\r\n        require(recipient != msg.sender, \u0022stream to the caller\u0022);\r\n        require(deposit \u003E 0, \u0022deposit is zero\u0022);\r\n        require(startTime \u003E= block.timestamp, \u0022start time before block.timestamp\u0022);\r\n        require(stopTime \u003E startTime, \u0022stop time before the start time\u0022);\r\n        require(deposit.mod(stopTime.sub(startTime)) == 0, \u0022deposit not multiple of time delta\u0022);\r\n\r\n        streamId = nonce;\r\n        address sender = msg.sender;\r\n        uint256 rate = deposit.div(stopTime.sub(startTime));\r\n        streams[streamId] = Types.Stream({\r\n            balance: deposit,\r\n            deposit: deposit,\r\n            isEntity: true,\r\n            rate: rate,\r\n            recipient: recipient,\r\n            sender: sender,\r\n            startTime: startTime,\r\n            stopTime: stopTime,\r\n            tokenAddress: tokenAddress\r\n        });\r\n\r\n        emit Create(streamId, sender, recipient, deposit, tokenAddress, startTime, stopTime);\r\n\r\n        nonce = nonce.add(1);\r\n        require(IERC20(tokenAddress).transferFrom(sender, address(this), deposit), \u0022token transfer failure\u0022);\r\n    }\r\n\r\n    function withdraw(uint256 streamId, uint256 amount) external streamExists(streamId) onlyRecipient(streamId) {\r\n        require(amount \u003E 0, \u0022amount is zero\u0022);\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 balance = balanceOf(streamId, stream.recipient);\r\n        require(balance \u003E= amount, \u0022withdrawal exceeds the available balance\u0022);\r\n\r\n        streams[streamId].balance = streams[streamId].balance.sub(amount);\r\n        emit Withdraw(streamId, stream.recipient, amount);\r\n\r\n        // saving gas\r\n        if (streams[streamId].balance == 0) delete streams[streamId];\r\n\r\n        // saving gas by checking beforehand\r\n        require(IERC20(stream.tokenAddress).transfer(stream.recipient, amount), \u0022token transfer failure\u0022);\r\n    }\r\n\r\n    function cancel(uint256 streamId) external streamExists(streamId) onlySenderOrRecipient(streamId) {\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 senderAmount = balanceOf(streamId, stream.sender);\r\n        uint256 recipientAmount = balanceOf(streamId, stream.recipient);\r\n\r\n        emit Cancel(streamId, stream.sender, stream.recipient, senderAmount, recipientAmount);\r\n\r\n        // saving gas\r\n        delete streams[streamId];\r\n\r\n        // saving gas by checking beforehand\r\n        if (recipientAmount \u003E 0)\r\n            require(\r\n                IERC20(stream.tokenAddress).transfer(stream.recipient, recipientAmount),\r\n                \u0022recipient token transfer failure\u0022\r\n            );\r\n        if (senderAmount \u003E 0)\r\n            require(IERC20(stream.tokenAddress).transfer(stream.sender, senderAmount), \u0022sender token transfer failure\u0022);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022deposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022startTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022stopTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022create\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022cancel\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getStream\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022deposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022startTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022stopTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rate\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deltaOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022nonce\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022deposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022startTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022stopTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Create\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Withdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022streamId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022senderAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022recipientAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Cancel\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Sablier","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://24b057e7686e8e9c7e839e67fa15982ba4e94cfc9a0a25345eaf083288541bba"}]