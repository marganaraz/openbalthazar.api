[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n    contract UtilFast2Win {\r\n        using SafeMath for uint;\r\n        uint ETH = 1 ether;\r\n\r\n        //Membership Grade\r\n        function getLevel(uint value) internal view returns(uint) {\r\n            if (value \u003E= 1*ETH \u0026\u0026 value \u003C= 5*ETH) {\r\n                return 1; //low\r\n            }\r\n            if (value \u003E= 6*ETH \u0026\u0026 value \u003C= 10*ETH) {\r\n                return 2; //medium\r\n            }\r\n            if (value \u003E= 11*ETH \u0026\u0026 value \u003C= 15*ETH) {\r\n                return 3; //high\r\n            }\r\n            return 0;\r\n        }\r\n        //dynamic level\r\n        function getLineLevel(uint value) internal view returns(uint) {\r\n            if (value \u003E= 1*ETH \u0026\u0026 value \u003C= 5*ETH) {\r\n                return 1;\r\n            }\r\n            if (value \u003E= 6*ETH \u0026\u0026 value \u003C= 10*ETH) {\r\n                return 2;\r\n            }\r\n            if (value \u003E= 11*ETH) {\r\n                return 3;\r\n            }\r\n            return 0;\r\n        }\r\n        //static dividend everyday gain\r\n        function getScByLevel(uint level, uint reInvestCount) internal pure returns(uint) {\r\n            uint reInvestBouns = reInvestCount.mul(5);\r\n            if (level == 1) {\r\n                return reInvestBouns.add(10);\r\n            }\r\n            if (level == 2) {\r\n                return reInvestBouns.add(15);\r\n            }\r\n            if (level == 3) {\r\n                return reInvestBouns.add(20);\r\n            }\r\n            return 0;\r\n        }\r\n        //reward burn if self level \u003C refer level\r\n        function getBurnByLevel(uint level) internal pure returns(uint) {\r\n            if (level == 1) {\r\n                return 3;\r\n            }\r\n            if (level == 2) {\r\n                return 6;\r\n            }\r\n            if (level == 3) {\r\n                return 10;\r\n            }\r\n            return 0;\r\n        }\r\n        //dynamic generation percent\r\n        function getRecommendScaleByLevelAndTim(uint level,uint times) internal pure returns(uint){\r\n            if (level == 1 \u0026\u0026 times == 1) {\r\n                return 50;\r\n            }\r\n            if (level == 2 \u0026\u0026 times == 1) {\r\n                return 70;\r\n            }\r\n            if (level == 2 \u0026\u0026 times == 2) {\r\n                return 50;\r\n            }\r\n            if (level == 3) {\r\n                if(times == 1){\r\n                    return 100;\r\n                }\r\n                if (times == 2) {\r\n                    return 70;\r\n                }\r\n                if (times == 3) {\r\n                    return 50;\r\n                }\r\n                if (times \u003E= 4 \u0026\u0026 times \u003C= 10) {\r\n                    return 10;\r\n                }\r\n                if (times \u003E= 11 \u0026\u0026 times \u003C= 20) {\r\n                    return 5;\r\n                }\r\n                if (times \u003E= 21) {\r\n                    return 1;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function compareStr(string memory _str, string memory str) internal pure returns(bool) {\r\n            if (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Provides information about the current execution context, including the\r\n     * sender of the transaction and its data. While these are generally available\r\n     * via msg.sender and msg.data, they should not be accessed in such a direct\r\n     * manner, since when dealing with GSN meta-transactions the account sending and\r\n     * paying for execution may not be the actual sender (as far as an application\r\n     * is concerned).\r\n     *\r\n     * This contract is only required for intermediate, library-like contracts.\r\n     */\r\n    contract Context {\r\n        // Empty internal constructor, to prevent people from mistakenly deploying\r\n        // an instance of this contract, which should be used via inheritance.\r\n        constructor() internal {}\r\n        // solhint-disable-previous-line no-empty-blocks\r\n\r\n        function _msgSender() internal view returns (address) {\r\n            return msg.sender;\r\n        }\r\n\r\n        function _msgData() internal view returns (bytes memory) {\r\n            this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n            return msg.data;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Contract module which provides a basic access control mechanism, where\r\n     * there is an account (an owner) that can be granted exclusive access to\r\n     * specific functions.\r\n     *\r\n     * This module is used through inheritance. It will make available the modifier\r\n     * \u0060onlyOwner\u0060, which can be applied to your functions to restrict their use to\r\n     * the owner.\r\n     */\r\n    contract Ownable is Context {\r\n        address private _owner;\r\n\r\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n        /**\r\n         * @dev Initializes the contract setting the deployer as the initial owner.\r\n         */\r\n        constructor () internal {\r\n            _owner = _msgSender();\r\n            emit OwnershipTransferred(address(0), _owner);\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the address of the current owner.\r\n         */\r\n        function owner() public view returns (address) {\r\n            return _owner;\r\n        }\r\n\r\n        /**\r\n         * @dev Throws if called by any account other than the owner.\r\n         */\r\n        modifier onlyOwner() {\r\n            require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n            _;\r\n        }\r\n\r\n        /**\r\n         * @dev Returns true if the caller is the current owner.\r\n         */\r\n        function isOwner() public view returns (bool) {\r\n            return _msgSender() == _owner;\r\n        }\r\n\r\n        /**\r\n         * @dev Leaves the contract without owner. It will not be possible to call\r\n         * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n         *\r\n         * NOTE: Renouncing ownership will leave the contract without an owner,\r\n         * thereby removing any functionality that is only available to the owner.\r\n         */\r\n        function renounceOwnership() public onlyOwner {\r\n            emit OwnershipTransferred(_owner, address(0));\r\n            _owner = address(0);\r\n        }\r\n\r\n        /**\r\n         * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n         * Can only be called by the current owner.\r\n         */\r\n        function transferOwnership(address newOwner) public onlyOwner {\r\n            _transferOwnership(newOwner);\r\n        }\r\n\r\n        /**\r\n         * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n         */\r\n        function _transferOwnership(address newOwner) internal {\r\n            require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n            emit OwnershipTransferred(_owner, newOwner);\r\n            _owner = newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @title Roles\r\n     * @dev Library for managing addresses assigned to a Role.\r\n     */\r\n    library Roles {\r\n        struct Role {\r\n            mapping (address =\u003E bool) bearer;\r\n        }\r\n\r\n        /**\r\n         * @dev Give an account access to this role.\r\n         */\r\n        function add(Role storage role, address account) internal {\r\n            require(!has(role, account), \u0022Roles: account already has role\u0022);\r\n            role.bearer[account] = true;\r\n        }\r\n\r\n        /**\r\n         * @dev Remove an account\u0027s access to this role.\r\n         */\r\n        function remove(Role storage role, address account) internal {\r\n            require(has(role, account), \u0022Roles: account does not have role\u0022);\r\n            role.bearer[account] = false;\r\n        }\r\n\r\n        /**\r\n         * @dev Check if an account has this role.\r\n         * @return bool\r\n         */\r\n        function has(Role storage role, address account) internal view returns (bool) {\r\n            require(account != address(0), \u0022Roles: account is the zero address\u0022);\r\n            return role.bearer[account];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @title WhitelistAdminRole\r\n     * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n     */\r\n    contract WhitelistAdminRole is Context, Ownable {\r\n        using Roles for Roles.Role;\r\n\r\n        event WhitelistAdminAdded(address indexed account);\r\n        event WhitelistAdminRemoved(address indexed account);\r\n\r\n        Roles.Role private _whitelistAdmins;\r\n\r\n        constructor () internal {\r\n            _addWhitelistAdmin(_msgSender());\r\n        }\r\n\r\n        modifier onlyWhitelistAdmin() {\r\n            require(isWhitelistAdmin(_msgSender()) || isOwner(), \u0022WhitelistAdminRole: caller does not have the WhitelistAdmin role\u0022);\r\n            _;\r\n        }\r\n\r\n        function isWhitelistAdmin(address account) public view returns (bool) {\r\n            return _whitelistAdmins.has(account);\r\n        }\r\n\r\n        function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n            _addWhitelistAdmin(account);\r\n        }\r\n\r\n        function removeWhitelistAdmin(address account) public onlyOwner {\r\n            _whitelistAdmins.remove(account);\r\n            emit WhitelistAdminRemoved(account);\r\n        }\r\n\r\n        function renounceWhitelistAdmin() public {\r\n            _removeWhitelistAdmin(_msgSender());\r\n        }\r\n\r\n        function _addWhitelistAdmin(address account) internal {\r\n            _whitelistAdmins.add(account);\r\n            emit WhitelistAdminAdded(account);\r\n        }\r\n\r\n        function _removeWhitelistAdmin(address account) internal {\r\n            _whitelistAdmins.remove(account);\r\n            emit WhitelistAdminRemoved(account);\r\n        }\r\n    }\r\n\r\n    contract Fast2Win is UtilFast2Win, WhitelistAdminRole {\r\n\r\n        using SafeMath for uint;\r\n\r\n        string constant private name = \u0022fast2win foundation\u0022;\r\n\r\n        uint ETH = 1 ether;\r\n\r\n        address payable private devAddr;//admin fee pool\r\n        address payable private savingAddr;//savior pool\r\n        address payable private follow;//follower pool\r\n\r\n        struct User{\r\n            uint id;\r\n            address userAddress;\r\n            uint refId;\r\n            uint staticLevel;\r\n            uint dynamicLevel;\r\n            uint allInvest;\r\n            uint freezeAmount;\r\n            uint unlockAmount;\r\n            uint allStaticAmount;\r\n            uint allDynamicAmount;\r\n            uint hisStaticAmount;\r\n            uint hisDynamicAmount;\r\n            uint inviteAmount;\r\n            uint reInvestCount;\r\n            uint lastReInvestTime;\r\n            Invest[] invests;\r\n            uint staticFlag;\r\n        }\r\n\r\n        struct GameInfo {\r\n            uint luckPort;\r\n            address[] specialUsers;\r\n        }\r\n\r\n        struct UserGlobal {\r\n            uint id;\r\n            address userAddress;\r\n            uint refId;\r\n        }\r\n\r\n        struct Invest{\r\n            address userAddress;\r\n            uint investAmount;\r\n            uint investTime;\r\n            uint times;\r\n        }\r\n\r\n        uint coefficient = 10;\r\n        uint startTime;\r\n        uint investCount = 0;\r\n        mapping(uint =\u003E uint) rInvestCount;\r\n        uint investMoney = 0;\r\n        mapping(uint =\u003E uint) rInvestMoney;\r\n        mapping(uint =\u003E GameInfo) rInfo;\r\n        uint uid = 0;\r\n        uint rid = 1;\r\n        uint constant private PERIOD = 1 days;//1 days\r\n        uint constant private restTime = 2*PERIOD;\r\n        uint constant private HOURS = 1 hours;//1 hours\r\n        uint checkInCount = 0;\r\n        mapping (uint =\u003E mapping(address =\u003E User)) userRoundMapping;\r\n        mapping(address =\u003E UserGlobal) public userMapping;\r\n        mapping (uint =\u003E address) public indexMapping;\r\n\r\n        /**\r\n         * @dev Just a simply check to prevent contract\r\n         * @dev this by calling method in constructor.\r\n         */\r\n        modifier isHuman() {\r\n            address addr = msg.sender;\r\n            uint codeLength;\r\n\r\n            assembly {codeLength := extcodesize(addr)}\r\n            require(codeLength == 0, \u0022sorry humans only\u0022);\r\n            require(tx.origin == msg.sender, \u0022sorry, human only\u0022);\r\n            _;\r\n        }\r\n\r\n        event LogInvestIn(address indexed who, uint indexed uid, uint amount, uint time, uint refId, uint typeFlag);\r\n        event LogWithdrawProfit(address indexed who, uint indexed uid, uint amount, uint time);\r\n        event LogRedeem(address indexed who, uint indexed uid, uint amount, uint now);\r\n        event RegisterUser(address indexed who, uint indexed uid, uint refId, uint now);\r\n\r\n        //==============================================================================\r\n        // Constructor\r\n        //==============================================================================\r\n        constructor (address _devAddr, address _savingAddr, address _follow) public {\r\n            devAddr = address(uint160(_devAddr));\r\n            savingAddr = address(uint160(_savingAddr));\r\n            follow = address(uint160(_follow));\r\n\r\n            //register owner\r\n            address _msgSender = msg.sender;\r\n            UserGlobal storage userGlobal = userMapping[_msgSender];\r\n            userGlobal.id = uid;\r\n            userGlobal.userAddress = _msgSender;\r\n            userGlobal.refId = uid;\r\n            indexMapping[uid] = _msgSender;\r\n        }\r\n\r\n        function () external payable {\r\n        }\r\n\r\n        function activeGame(uint time) external onlyWhitelistAdmin\r\n        {\r\n            require(time \u003E now, \u0022invalid game start time\u0022);\r\n            startTime = time;\r\n        }\r\n\r\n        function setCoefficient(uint coeff) external onlyWhitelistAdmin\r\n        {\r\n            require(coeff \u003E 0, \u0022invalid coeff\u0022);\r\n            coefficient = coeff;\r\n        }\r\n\r\n        function gameStart() private view returns(bool) {\r\n            return startTime != 0 \u0026\u0026 now \u003E startTime;\r\n        }\r\n\r\n        function viewNow() public view onlyWhitelistAdmin returns(uint) {\r\n            return now;\r\n        }\r\n\r\n        function investIn(uint refId)\r\n            public\r\n            isHuman()\r\n            payable\r\n        {\r\n            require(gameStart(), \u0022game not start\u0022);\r\n            require(msg.value \u003E= 1*ETH \u0026\u0026 msg.value \u003C= 15*ETH, \u0022between 1 and 15\u0022);\r\n            require(msg.value == msg.value.div(ETH).mul(ETH), \u0022invalid msg value\u0022);\r\n\r\n            registerUser(msg.sender, refId);\r\n            UserGlobal storage userGlobal = userMapping[msg.sender];\r\n            User storage user = userRoundMapping[rid][msg.sender];\r\n            if (uint(user.userAddress) != 0) {\r\n                require(user.freezeAmount.add(msg.value) \u003C= 15*ETH, \u0022can not beyond 15 eth\u0022);\r\n                user.allInvest = user.allInvest.add(msg.value);\r\n                user.freezeAmount = user.freezeAmount.add(msg.value);\r\n                user.staticLevel = getLevel(user.freezeAmount);\r\n                user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\r\n            } else {\r\n                //no invest this round\r\n                user.id = userGlobal.id;\r\n                user.userAddress = msg.sender;\r\n                user.freezeAmount = msg.value;\r\n                user.staticLevel = getLevel(msg.value);\r\n                user.allInvest = msg.value;\r\n                user.dynamicLevel = getLineLevel(msg.value);\r\n                user.refId = userGlobal.refId;\r\n\r\n                if (refId != 0 \u0026\u0026 userGlobal.refId == refId) {\r\n                    address refIdAddr = getUserAddressByCode(userGlobal.refId);\r\n                    userRoundMapping[rid][refIdAddr].inviteAmount\u002B\u002B;\r\n                }\r\n            }\r\n\r\n            Invest memory invest = Invest(msg.sender, msg.value, now, 0);\r\n            user.invests.push(invest);\r\n\r\n            if (rInvestMoney[rid] != 0 \u0026\u0026 (rInvestMoney[rid].div(10000).div(ETH) != rInvestMoney[rid].add(msg.value).div(10000).div(ETH))) {\r\n                bool isEnough;\r\n                uint sendMoney;\r\n                (isEnough, sendMoney) = isEnoughBalance(rInfo[rid].luckPort);\r\n                if (sendMoney \u003E 0) {\r\n                    sendMoneyToUser(msg.sender, sendMoney);\r\n                }\r\n                rInfo[rid].luckPort = 0;\r\n                if (!isEnough) {\r\n                    endRound();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            investCount = investCount.add(1);\r\n            investMoney = investMoney.add(msg.value);\r\n            rInvestCount[rid] = rInvestCount[rid].add(1);\r\n            rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n            rInfo[rid].luckPort = rInfo[rid].luckPort.add(msg.value.mul(2).div(1000));//lucky\r\n\r\n            sendFeetoAdmin(msg.value);\r\n            emit LogInvestIn(msg.sender, userGlobal.id, msg.value, now, userGlobal.refId, 0);\r\n        }\r\n\r\n\r\n        function reInvestIn() public {\r\n            require(gameStart(), \u0022game not start\u0022);\r\n            User storage user = userRoundMapping[rid][msg.sender];\r\n            require(user.id \u003E 0, \u0022user haven\u0027t invest in round before\u0022);\r\n            calStaticProfitInner(msg.sender);\r\n\r\n            uint reInvestAmount = user.unlockAmount;\r\n            if (user.freezeAmount \u003E 15*ETH) {\r\n                user.freezeAmount = 15*ETH;\r\n            }\r\n            if (user.freezeAmount.add(reInvestAmount) \u003E 15*ETH) {\r\n                reInvestAmount = (15*ETH).sub(user.freezeAmount);\r\n            }\r\n\r\n            if (reInvestAmount == 0) {\r\n                return;\r\n            }\r\n\r\n            uint leastAmount = reInvestAmount.mul(47).div(1000);\r\n            bool isEnough;\r\n            uint sendMoney;\r\n            (isEnough, sendMoney) = isEnoughBalance(leastAmount);\r\n            if (!isEnough) {\r\n                if (sendMoney \u003E 0) {\r\n                    sendMoneyToUser(msg.sender, sendMoney);\r\n                }\r\n                endRound();\r\n                return;\r\n            }\r\n\r\n            user.unlockAmount = user.unlockAmount.sub(reInvestAmount);\r\n            user.allInvest = user.allInvest.add(reInvestAmount);\r\n            user.freezeAmount = user.freezeAmount.add(reInvestAmount);\r\n            user.staticLevel = getLevel(user.freezeAmount);\r\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\r\n            if ((now - user.lastReInvestTime) \u003E 5*PERIOD) {\r\n                user.reInvestCount = user.reInvestCount.add(1);\r\n                user.lastReInvestTime = now;\r\n            }\r\n\r\n            if (user.reInvestCount == 5) {\r\n                rInfo[rid].specialUsers.push(msg.sender);\r\n            }\r\n\r\n            Invest memory invest = Invest(msg.sender, reInvestAmount, now, 0);\r\n            user.invests.push(invest);\r\n\r\n            if (rInvestMoney[rid] != 0 \u0026\u0026 (rInvestMoney[rid].div(10000).div(ETH) != rInvestMoney[rid].add(reInvestAmount).div(10000).div(ETH))) {\r\n                (isEnough, sendMoney) = isEnoughBalance(rInfo[rid].luckPort);\r\n                if (sendMoney \u003E 0) {\r\n                    sendMoneyToUser(msg.sender, sendMoney);\r\n                }\r\n                rInfo[rid].luckPort = 0;\r\n                if (!isEnough) {\r\n                    endRound();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            investCount = investCount.add(1);\r\n            investMoney = investMoney.add(reInvestAmount);\r\n            rInvestCount[rid] = rInvestCount[rid].add(1);\r\n            rInvestMoney[rid] = rInvestMoney[rid].add(reInvestAmount);\r\n            rInfo[rid].luckPort = rInfo[rid].luckPort.add(reInvestAmount.mul(2).div(1000)); //lucky\r\n\r\n            sendFeetoAdmin(reInvestAmount);\r\n            emit LogInvestIn(msg.sender, user.id, reInvestAmount, now, user.refId, 1);\r\n        }\r\n\r\n        function withdrawProfit()\r\n            public\r\n            isHuman()\r\n        {\r\n            require(gameStart(), \u0022game not start\u0022);\r\n            User storage user = userRoundMapping[rid][msg.sender];\r\n            uint sendMoney = user.allStaticAmount.add(user.allDynamicAmount);\r\n\r\n            bool isEnough = false;\r\n            uint resultMoney = 0;\r\n            (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n            if (resultMoney \u003E 0) {\r\n                sendMoneyToUser(msg.sender, resultMoney.mul(98).div(100));\r\n                savingAddr.transfer(resultMoney.mul(5).div(100));  //savior\r\n                user.allStaticAmount = 0;\r\n                user.allDynamicAmount = 0;\r\n                emit LogWithdrawProfit(msg.sender, user.id, resultMoney, now);\r\n            }\r\n\r\n            if (!isEnough) {\r\n                endRound();\r\n            }\r\n        }\r\n\r\n        function isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n            if (sendMoney \u003E= address(this).balance) {\r\n                return (false, address(this).balance);\r\n            } else {\r\n                return (true, sendMoney);\r\n            }\r\n        }\r\n\r\n        function sendMoneyToUser(address payable userAddress, uint money) private {\r\n            userAddress.transfer(money);\r\n        }\r\n\r\n        function calStaticProfit(address userAddr) external onlyWhitelistAdmin returns(uint)\r\n        {\r\n            return calStaticProfitInner(userAddr);\r\n        }\r\n\r\n        function calStaticProfitInner(address userAddr) private returns(uint)\r\n        {\r\n            User storage user = userRoundMapping[rid][userAddr];\r\n            if (user.id == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint scale = getScByLevel(user.staticLevel, user.reInvestCount);\r\n            uint allStatic = 0;\r\n            for (uint i = user.staticFlag; i \u003C user.invests.length; i\u002B\u002B) {\r\n                Invest storage invest = user.invests[i];\r\n                uint startDay = invest.investTime.sub(4*HOURS).div(1*PERIOD).mul(1*PERIOD);\r\n                uint staticGaps = now.sub(4*HOURS).sub(startDay).div(1*PERIOD);\r\n\r\n                uint unlockDay = now.sub(invest.investTime).div(1*PERIOD);\r\n\r\n                if(staticGaps \u003E 5){\r\n                    staticGaps = 5;\r\n                }\r\n\r\n                //withdraw*PERIOD\r\n                if (staticGaps \u003E invest.times) {\r\n                    allStatic \u002B= staticGaps.sub(invest.times).mul(scale).mul(invest.investAmount).div(1000);\r\n                    invest.times = staticGaps;\r\n                }\r\n\r\n                if (unlockDay \u003E= 5) {\r\n                    user.staticFlag = user.staticFlag.add(1);\r\n                    user.freezeAmount = user.freezeAmount.sub(invest.investAmount);\r\n                    user.unlockAmount = user.unlockAmount.add(invest.investAmount);\r\n                    user.staticLevel = getLevel(user.freezeAmount);\r\n                }\r\n\r\n            }\r\n            allStatic = allStatic.mul(coefficient).div(10);\r\n            user.allStaticAmount = user.allStaticAmount.add(allStatic);\r\n            user.hisStaticAmount = user.hisStaticAmount.add(allStatic);\r\n            return user.allStaticAmount;\r\n        }\r\n\r\n        function viewScLevel(address userAddr) public view returns(uint) {\r\n            User memory user = userRoundMapping[rid][userAddr];\r\n            uint scale = getScByLevel(user.staticLevel, user.reInvestCount);\r\n            return scale;\r\n        }\r\n\r\n        function viewStaticProfit(address userAddr) public view returns(uint)\r\n        {\r\n            User memory user = userRoundMapping[rid][userAddr];\r\n            if (user.id == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint scale = getScByLevel(user.staticLevel, user.reInvestCount);\r\n            uint allStatic = 0;\r\n            for (uint i = user.staticFlag; i \u003C user.invests.length; i\u002B\u002B) {\r\n                Invest memory invest = user.invests[i];\r\n                uint staticGaps = now.sub(invest.investTime);\r\n                if(staticGaps \u003E 5*PERIOD){\r\n                    staticGaps = 5*PERIOD;\r\n                }\r\n                //withdraw days\r\n\r\n                if (staticGaps \u003E invest.times.mul(1*PERIOD)) {\r\n                  allStatic \u002B= staticGaps.sub(invest.times.mul(1*PERIOD)).mul(scale).mul(invest.investAmount).div(1000).div(1*PERIOD);\r\n                }\r\n\r\n            }\r\n            allStatic = allStatic.mul(coefficient).div(10);\r\n            return user.allStaticAmount.add(allStatic);\r\n        }\r\n\r\n        function calDynamicProfit(uint start, uint end) external onlyWhitelistAdmin {\r\n            for (uint i = start; i \u003C= end; i\u002B\u002B) {\r\n                address userAddr = indexMapping[i];\r\n                User memory user = userRoundMapping[rid][userAddr];\r\n                if (user.freezeAmount \u003E= 1*ETH) {\r\n                    uint scale = getScByLevel(user.staticLevel, user.reInvestCount);\r\n                    calUserDynamicProfit(user.refId, user.freezeAmount, scale);\r\n                }\r\n                calStaticProfitInner(userAddr);\r\n            }\r\n        }\r\n\r\n        function registerSelfInfo(uint refId) public isHuman(){\r\n            registerUser(msg.sender, refId);\r\n        }\r\n\r\n        function registerUserInfo(address usr, uint refId) public onlyWhitelistAdmin {\r\n            registerUser(usr, refId);\r\n        }\r\n\r\n        function calUserDynamicProfit(uint refId, uint money, uint shareSc) private {\r\n           uint tmprefId = refId;\r\n\r\n            for (uint i = 1; i \u003C= 30; i\u002B\u002B) {\r\n                if (tmprefId == 0) {\r\n                    break;\r\n                }\r\n                address tmpUserAddr = indexMapping[tmprefId];\r\n                User storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n                uint burnSc = getBurnByLevel(calUser.dynamicLevel);\r\n                uint recommendSc = getRecommendScaleByLevelAndTim(calUser.dynamicLevel, i);\r\n                uint moneyResult = 0;\r\n                if (money \u003C= calUser.freezeAmount.add(calUser.unlockAmount)) {\r\n                    moneyResult = money;\r\n                } else {\r\n                    moneyResult = calUser.freezeAmount.add(calUser.unlockAmount);\r\n                }\r\n\r\n                if (recommendSc != 0) {\r\n                    uint tmpDynamicAmount = moneyResult.mul(shareSc).mul(burnSc).mul(recommendSc);\r\n                    tmpDynamicAmount = tmpDynamicAmount.div(1000).div(10).div(100);\r\n\r\n                    tmpDynamicAmount = tmpDynamicAmount.mul(coefficient).div(10);\r\n                    calUser.allDynamicAmount = calUser.allDynamicAmount.add(tmpDynamicAmount);\r\n                    calUser.hisDynamicAmount = calUser.hisDynamicAmount.add(tmpDynamicAmount);\r\n                }\r\n\r\n                tmprefId = calUser.refId;\r\n            }\r\n        }\r\n\r\n        function redeem() // withdraw\r\n            public\r\n            isHuman()\r\n        {\r\n            require(gameStart(), \u0022game not start\u0022);\r\n            User storage user = userRoundMapping[rid][msg.sender];\r\n            require(user.id \u003E 0, \u0022user not exist\u0022);\r\n\r\n            calStaticProfitInner(msg.sender);\r\n\r\n            uint sendMoney = user.unlockAmount;\r\n\r\n            bool isEnough = false;\r\n            uint resultMoney = 0;\r\n\r\n            (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n            if (resultMoney \u003E 0) {\r\n                sendMoneyToUser(msg.sender, resultMoney);\r\n                user.unlockAmount = 0;\r\n                user.staticLevel = getLevel(user.freezeAmount);\r\n                user.dynamicLevel = getLineLevel(user.freezeAmount);\r\n\r\n                emit LogRedeem(msg.sender, user.id, resultMoney, now);\r\n            }\r\n\r\n            // if (user.reInvestCount \u003C 5) {\r\n            //     user.reInvestCount = 0;\r\n            // }\r\n            user.reInvestCount = 0;\r\n\r\n            if (!isEnough) {\r\n                endRound();\r\n            }\r\n        }\r\n\r\n        function endRound() private {\r\n            rid\u002B\u002B;\r\n            startTime = now.add(restTime).div(1*PERIOD).mul(1*PERIOD);\r\n            coefficient = 10;\r\n        }\r\n\r\n        function getUserAddressByCode(uint code) public view returns(address) {\r\n            return indexMapping[code];\r\n        }\r\n\r\n        function sendFeetoAdmin(uint amount) private {\r\n            devAddr.transfer(amount.mul(5).div(100)); //admin fee\r\n            follow.transfer(amount.mul(5).div(1000)); //follower\r\n        }\r\n\r\n        function getGameInfo() public isHuman() view returns(uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n            return (\r\n                rid,\r\n                uid,\r\n                startTime,\r\n                investCount,\r\n                investMoney,\r\n                rInvestCount[rid],\r\n                rInvestMoney[rid],\r\n                coefficient,\r\n                rInfo[rid].luckPort,\r\n                rInfo[rid].specialUsers.length\r\n            );\r\n        }\r\n\r\n        function getUserInfo(address user, uint roundId, uint i) public isHuman() view returns(\r\n            uint[17] memory ct, uint refId\r\n        ) {\r\n\r\n            if(roundId == 0){\r\n                roundId = rid;\r\n            }\r\n\r\n            User memory userInfo = userRoundMapping[roundId][user];\r\n\r\n            ct[0] = userInfo.id;\r\n            ct[1] = userInfo.staticLevel;\r\n            ct[2] = userInfo.dynamicLevel;\r\n            ct[3] = userInfo.allInvest;\r\n            ct[4] = userInfo.freezeAmount;\r\n            ct[5] = userInfo.unlockAmount;\r\n            ct[6] = userInfo.allStaticAmount;\r\n            ct[7] = userInfo.allDynamicAmount;\r\n            ct[8] = userInfo.hisStaticAmount;\r\n            ct[9] = userInfo.hisDynamicAmount;\r\n            ct[10] = userInfo.inviteAmount;\r\n            ct[11] = userInfo.reInvestCount;\r\n            ct[12] = userInfo.staticFlag;\r\n            ct[13] = userInfo.invests.length;\r\n            if (ct[13] != 0) {\r\n                ct[14] = userInfo.invests[i].investAmount;\r\n                ct[15] = userInfo.invests[i].investTime;\r\n                ct[16] = userInfo.invests[i].times;\r\n            } else {\r\n                ct[14] = 0;\r\n                ct[15] = 0;\r\n                ct[16] = 0;\r\n            }\r\n\r\n            refId = userMapping[user].refId;\r\n\r\n            return (\r\n                ct,\r\n                refId\r\n            );\r\n        }\r\n        //follower\r\n        function getSpecialUser(uint _rid, uint i) public view returns(address) {\r\n            return rInfo[_rid].specialUsers[i];\r\n        }\r\n\r\n        function getLatestUnlockAmount(address userAddr) public view returns(uint)\r\n        {\r\n            User memory user = userRoundMapping[rid][userAddr];\r\n            uint allUnlock = user.unlockAmount;\r\n            for (uint i = user.staticFlag; i \u003C user.invests.length; i\u002B\u002B) {\r\n                Invest memory invest = user.invests[i];\r\n                uint unlockDay = now.sub(invest.investTime).div(1*PERIOD);\r\n\r\n                if (unlockDay \u003E= 5) {\r\n                    allUnlock = allUnlock.add(invest.investAmount);\r\n                }\r\n            }\r\n            return allUnlock;\r\n        }\r\n\r\n        function registerUser(address user, uint refId) internal {\r\n            UserGlobal storage userGlobal = userMapping[user];\r\n            if (userGlobal.id == 0) {\r\n                address refIdAddr = getUserAddressByCode(refId);\r\n                require(uint(refIdAddr) != 0, \u0022referer not exist\u0022);\r\n                require(refIdAddr != user, \u0022refId can\u0027t be self\u0022);\r\n                uid\u002B\u002B;\r\n                userGlobal.id = uid;\r\n                userGlobal.userAddress = user;\r\n                userGlobal.refId = refId;\r\n                indexMapping[uid] = user;\r\n\r\n                emit RegisterUser(user, uid, refId, now);\r\n            }\r\n        }\r\n\r\n        function verifyRefId(address user, uint refId) public view returns (bool){\r\n            UserGlobal storage userGlobal = userMapping[user];\r\n            if (userGlobal.id == 0) {\r\n                address refIdAddr = getUserAddressByCode(refId);\r\n                if(uint(refIdAddr) != 0 \u0026\u0026 refIdAddr != user) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function dailyCheckIn() public isHuman() returns (uint){\r\n            checkInCount\u002B\u002B;\r\n            return checkInCount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @title SafeMath\r\n     * @dev Math operations with safety checks that revert on error\r\n     */\r\n    library SafeMath {\r\n\r\n        /**\r\n        * @dev Multiplies two numbers, reverts on overflow.\r\n        */\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n            if (a == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint256 c = a * b;\r\n            require(c / a == b, \u0022mul overflow\u0022);\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n        */\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b \u003E 0, \u0022div zero\u0022); // Solidity only automatically asserts when dividing by 0\r\n            uint256 c = a / b;\r\n            // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n        */\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b \u003C= a, \u0022lower sub bigger\u0022);\r\n            uint256 c = a - b;\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Adds two numbers, reverts on overflow.\r\n        */\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a \u002B b;\r\n            require(c \u003E= a, \u0022overflow\u0022);\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n        * reverts when dividing by zero.\r\n        */\r\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b != 0, \u0022mod zero\u0022);\r\n            return a % b;\r\n        }\r\n    }","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022coeff\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setCoefficient\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022userMapping\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022reInvestIn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022start\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022end\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022calDynamicProfit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022userAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022viewStaticProfit\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getGameInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022verifyRefId\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022viewNow\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceWhitelistAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022userAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022viewScLevel\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeWhitelistAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addWhitelistAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_rid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022i\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getSpecialUser\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022registerUserInfo\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022userAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022calStaticProfit\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdrawProfit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022indexMapping\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isWhitelistAdmin\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022redeem\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022registerSelfInfo\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022activeGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022investIn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022userAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getLatestUnlockAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022roundId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022i\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getUserInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022ct\u0022,\u0022type\u0022:\u0022uint256[17]\u0022},{\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dailyCheckIn\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022code\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getUserAddressByCode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_devAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_savingAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_follow\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022uid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022typeFlag\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogInvestIn\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022uid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogWithdrawProfit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022uid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022now\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogRedeem\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022uid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022refId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022now\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RegisterUser\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022WhitelistAdminAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022WhitelistAdminRemoved\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Fast2Win","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ee4207be83685c94640d2ffb0961f71c2fc4fc4f000000000000000000000000ee4207be83685c94640d2ffb0961f71c2fc4fc4f000000000000000000000000ee4207be83685c94640d2ffb0961f71c2fc4fc4f","Library":"","SwarmSource":"bzzr://29855ac956f0a5d7db28068463f0282b1929fd90c9a51b1f9c1c7ee9b49a0137"}]