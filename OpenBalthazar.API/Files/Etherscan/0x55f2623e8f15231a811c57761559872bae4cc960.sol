[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/E20Incentive.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title E20 Incentive contract\r\n * @dev This contract manages the logic for a compensation scheme as an incentive for token transfers and sharing.\r\n */\r\ncontract E20Incentive {\r\n    //This contract uses a library for Safe Maths from OpenZeppelin\r\n    using SafeMath for uint;\r\n    //SetUp Variables\r\n    uint public ethFee; //Fee amount in ETH for subscription\r\n    uint public minToken; //Minimum amount of tokens required to get a subscription\r\n    uint public maxToken; //Maximum amount of tokens allowed to get a subscription\r\n    uint public intRate; //Fixed interest rate expressed from 0 to 1000 (0-100%) (ex: 1% = 10)\r\n    uint public intRounds; //Number of rounds to be allowed on a session\r\n    uint public bonusRate; //Fixed bonus rate expressed from 0 to 1000 (0-100%) (ex: 1% = 10)\r\n    IERC20 public tokenAddress; //Address of token to be used\r\n    address payable public platformWallet; //Address of platform manager\r\n    address payable public nextPlatformWallet; //Address of platform manager\r\n    uint public claimTime; //Time for each round\r\n\r\n    //Definition of a user account\r\n    struct UserAccount {\r\n        uint userBalance; //How much the user have deposited\r\n        uint intPaid; //How much interest the contract have paid to the user\r\n        uint intRound; //Which round is currently running\r\n        uint lastClaim; //Last claim time stamp\r\n        bool bonusClaimed; //Bonus claim flag\r\n        bool extension; //Session extension flag\r\n    }\r\n    //Mapping to register users\u0027 accounts\r\n    mapping (address=\u003EUserAccount) public userAccounts;\r\n\r\n    //Total contract balance handler\r\n    uint private contractUsersBalance;\r\n\r\n    //EVENTS\r\n    event SessionClaim(address indexed _user, uint _amount, uint round);\r\n    event SessionBegin(address indexed _user, uint _balance);\r\n    event SessionExtended(address indexed _user, uint _balance);\r\n    event SessionEnd(address indexed _user, uint _intPaid);\r\n\r\n    /**\r\n     * @dev Constructor for the main contract\r\n     * @param _tokenAddress Adress of token to be incentivized\r\n     * @param _ethFee eth fee to be used for contract transactions\r\n     * @param _minToken minimum amount of tokens to be deposited\r\n     * @param _maxToken maximum amount of tokens to be deposited\r\n     * @param _intRate interest rate multiplied by 1000\r\n     * @param _intRounds interest rounds per session\r\n     * @param _bonusRate bonus interest rate multiplied by 1000\r\n     * @param _claimTime time per round in epoch format\r\n     * @param _platformWallet initial address of platform manager\r\n     */\r\n    constructor(\r\n        IERC20 _tokenAddress,\r\n        uint _ethFee,\r\n        uint _minToken,\r\n        uint _maxToken,\r\n        uint _intRate,\r\n        uint _intRounds,\r\n        uint _bonusRate,\r\n        uint _claimTime,\r\n        address payable _platformWallet\r\n        ) public {\r\n        tokenAddress = _tokenAddress;\r\n        ethFee = _ethFee;\r\n        minToken = _minToken;\r\n        maxToken = _maxToken;\r\n        intRate = _intRate;\r\n        intRounds = _intRounds;\r\n        bonusRate = _bonusRate;\r\n        claimTime = _claimTime;\r\n        platformWallet = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev This function allows a token holder to open an account on this contract and benefit from it\r\n     * @param _amount is the number of tokens to be deposited on the contract\r\n     */\r\n    function deposit(uint _amount) public payable {\r\n        //Require the eth fee\r\n        require(msg.value == ethFee, \u0022Please send the required fee amount for transactions\u0022);\r\n        //Require the amount of tokens to be deposited to be between limits\r\n        require(_amount \u003E= minToken \u0026\u0026 _amount \u003C= maxToken, \u0022The amount of tokens must be between the set limits\u0022);\r\n        //Require user to provide allowance on the amount of tokens to be deposited\r\n        require(tokenAddress.allowance(msg.sender,address(this)) \u003E= _amount, \u0022Please assign the required allowance to the contract address\u0022);\r\n        //Require the transfer from user\u0027s wallet to be successful\r\n        require(tokenAddress.transferFrom(msg.sender,address(this),_amount), \u0022Error on token transfer using function transferFrom\u0022);\r\n        //Send ETH to Platform Wallet\r\n        platformWallet.transfer(address(this).balance);\r\n        //Update contract user\u0027s balance\r\n        contractUsersBalance = contractUsersBalance.add(_amount);\r\n        //Check if the user is getting registered for the first time\r\n        if (userAccounts[msg.sender].intRound == 0) {\r\n            //If it is, create a new user account\r\n            userAccounts[msg.sender] = UserAccount({\r\n                userBalance: _amount,\r\n                intPaid: 0,\r\n                intRound: 0,\r\n                lastClaim: now,\r\n                bonusClaimed: false,\r\n                extension: false});\r\n\r\n            emit SessionBegin(msg.sender,_amount);\r\n\r\n        } else if (userAccounts[msg.sender].intRound == intRounds \u0026\u0026 userAccounts[msg.sender].extension == false) {\r\n            //If it\u0027s not but the user is allowed to claim an extension, update it\u0027s account\r\n            userAccounts[msg.sender].userBalance = _amount;\r\n            userAccounts[msg.sender].lastClaim = now;\r\n            userAccounts[msg.sender].extension = true;\r\n\r\n            emit SessionExtended(msg.sender, _amount);\r\n\r\n        } else {\r\n            //If doesn\u0027t fall in any case, revert the transaction\r\n            revert(\u0022You cannot renew your suscription\u0022);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A function to allow users to claim their benefits from the contract\r\n     */\r\n    function claim() public {\r\n        //Require the user to hold some balance ont he contract\r\n        require(userAccounts[msg.sender].userBalance != 0, \u0022You don\u0027t have anything to claim\u0022);\r\n        //Require te user to have passed the minimum round time\r\n        require(now.sub(userAccounts[msg.sender].lastClaim) \u003E= claimTime, \u0022The claimTime have not passed yet, try again later\u0022);\r\n\r\n        uint intToPay; //Aux variable to handle interest calculation\r\n        uint toTransfer; //Aux variable to handle total transfer amount\r\n        userAccounts[msg.sender].lastClaim = now; //Update last claim time\r\n        userAccounts[msg.sender].intRound = userAccounts[msg.sender].intRound.add(1); //Update round\r\n\r\n        //Check if the user have claimed the bonus\r\n        if(userAccounts[msg.sender].bonusClaimed == false) {\r\n            //If it\u0027s not, update the account flag\r\n            userAccounts[msg.sender].bonusClaimed = true;\r\n            //Calculate the bonus\r\n            intToPay = userAccounts[msg.sender].userBalance.mul(bonusRate);\r\n            intToPay = intToPay.div(1000);\r\n        } else {\r\n            //If it already claimed the bonus, calculate normal interest\r\n            intToPay = userAccounts[msg.sender].userBalance.mul(intRate);\r\n            intToPay = intToPay.div(1000);\r\n        }\r\n\r\n        //Update interest paid\r\n        userAccounts[msg.sender].intPaid = userAccounts[msg.sender].intPaid.add(intToPay);\r\n\r\n        //Check if user is on final round\r\n        if((userAccounts[msg.sender].extension == false \u0026\u0026 userAccounts[msg.sender].intRound == intRounds) ||\r\n           (userAccounts[msg.sender].extension == true \u0026\u0026 userAccounts[msg.sender].intRound == intRounds.mul(2))\r\n        ){\r\n            //If it is, get user balance on contract\r\n            toTransfer = userAccounts[msg.sender].userBalance;\r\n            //Update contract user\u0027s balance\r\n            contractUsersBalance = contractUsersBalance.sub(userAccounts[msg.sender].userBalance);\r\n            //And reset user balance on contract to 0\r\n            userAccounts[msg.sender].userBalance = 0;\r\n\r\n            emit SessionEnd(msg.sender, userAccounts[msg.sender].intPaid);\r\n        }\r\n\r\n        //SumUp amount to transfer\r\n        toTransfer = toTransfer.add(intToPay);\r\n\r\n        //Require transfer to be done\r\n        require(tokenAddress.transfer(msg.sender,toTransfer), \u0022Error on token transfer using function transfer\u0022);\r\n\r\n        emit SessionClaim(msg.sender, userAccounts[msg.sender].intPaid, userAccounts[msg.sender].intRound);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Function to retrieve any stuck token on the contract, it can only be used by the platform wallet owner\r\n     * @param _tokenAddress Token contract address\r\n     * @param _value amount of tokens to move\r\n     * @param _to address to move tokens to\r\n     */\r\n    function ERC20Recovery(IERC20 _tokenAddress, uint _value, address _to) public{\r\n        //Only the contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == platformWallet, \u0022You are not allowed to use this function\u0022);\r\n\r\n        if(tokenAddress == _tokenAddress){\r\n            //Check that the platform manager is not retrieven user\u0027s tokens\r\n            uint currentContractsBalance = tokenAddress.balanceOf(address(this));\r\n            require(currentContractsBalance.sub(_value) \u003E= contractUsersBalance, \u0022You are not allowed to retrieve user\u0027s tokens\u0022);\r\n            tokenAddress.transfer(_to,_value);\r\n        } else {\r\n            _tokenAddress.transfer(_to,_value);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Function to allow the manager to propose a new manager wallet\r\n    * @param _newPlatformWallet the new wallet to be used as manager one\r\n    */\r\n    function proposePlatformWallet(address payable _newPlatformWallet) public {\r\n        //Only the contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == platformWallet, \u0022You are not allowed to use this function\u0022);\r\n        require(_newPlatformWallet != address(0), \u0022New wallet must be different from zero\u0022);\r\n        nextPlatformWallet = _newPlatformWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to accept or reject the contract management ownership\r\n     * @param _accept boolean answer: Accep = true, Reject = false\r\n     */\r\n    function acceptPlatformWallet(bool _accept) public {\r\n        //Only the new contract platform wallet owner is allowed to use this function\r\n        require(msg.sender == nextPlatformWallet, \u0022You are not allowed to use this function\u0022);\r\n        if(_accept) {\r\n            platformWallet = nextPlatformWallet;\r\n            nextPlatformWallet = address(0);\r\n        } else {\r\n            nextPlatformWallet = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev FallBack function will forward to claim function\r\n     */\r\n    function() external {\r\n        claim();\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022claimTime\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022_tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ERC20Recovery\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ethFee\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022claim\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022userAccounts\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022userBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022intPaid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022intRound\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lastClaim\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022bonusClaimed\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022extension\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022bonusRate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022nextPlatformWallet\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022intRate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_newPlatformWallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022proposePlatformWallet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minToken\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022maxToken\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_accept\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022acceptPlatformWallet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022intRounds\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022platformWallet\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022_tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_ethFee\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_minToken\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_maxToken\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_intRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_intRounds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_bonusRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_claimTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_platformWallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022round\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SessionClaim\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SessionBegin\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SessionExtended\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_intPaid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SessionEnd\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"E20Incentive","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cfd6ae8bf13f42de14867351eaff7a8a3b9fbbe7000000000000000000000000000000000000000000000000008e1bc9bf04000000000000000000000000000000000000000000000000000000000004a817c800000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000001518000000000000000000000000060fe9b4f8239b5d804af3855fd101c4b759d245b","Library":"","SwarmSource":"bzzr://191e75815b5143b9ddae81bb85b0f24e72cb568b7caea663d3e6fc409c006ec1"}]