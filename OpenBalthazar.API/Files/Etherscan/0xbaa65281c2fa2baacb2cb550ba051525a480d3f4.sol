[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\ncontract VatFab {\r\n    function newVat() public returns (Vat vat) {\r\n        vat = new Vat();\r\n        vat.rely(msg.sender);\r\n        vat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract JugFab {\r\n    function newJug(address vat) public returns (Jug jug) {\r\n        jug = new Jug(vat);\r\n        jug.rely(msg.sender);\r\n        jug.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract VowFab {\r\n    function newVow(address vat, address flap, address flop) public returns (Vow vow) {\r\n        vow = new Vow(vat, flap, flop);\r\n        vow.rely(msg.sender);\r\n        vow.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract CatFab {\r\n    function newCat(address vat) public returns (Cat cat) {\r\n        cat = new Cat(vat);\r\n        cat.rely(msg.sender);\r\n        cat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiFab {\r\n    function newDai(uint chainId) public returns (Dai dai) {\r\n        dai = new Dai(chainId);\r\n        dai.rely(msg.sender);\r\n        dai.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiJoinFab {\r\n    function newDaiJoin(address vat, address dai) public returns (DaiJoin daiJoin) {\r\n        daiJoin = new DaiJoin(vat, dai);\r\n    }\r\n}\r\n\r\ncontract FlapFab {\r\n    function newFlap(address vat, address gov) public returns (Flapper flap) {\r\n        flap = new Flapper(vat, gov);\r\n        flap.rely(msg.sender);\r\n        flap.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlopFab {\r\n    function newFlop(address vat, address gov) public returns (Flopper flop) {\r\n        flop = new Flopper(vat, gov);\r\n        flop.rely(msg.sender);\r\n        flop.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlipFab {\r\n    function newFlip(address vat, bytes32 ilk) public returns (Flipper flip) {\r\n        flip = new Flipper(vat, ilk);\r\n        flip.rely(msg.sender);\r\n        flip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract SpotFab {\r\n    function newSpotter(address vat) public returns (Spotter spotter) {\r\n        spotter = new Spotter(vat);\r\n        spotter.rely(msg.sender);\r\n        spotter.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract PotFab {\r\n    function newPot(address vat) public returns (Pot pot) {\r\n        pot = new Pot(vat);\r\n        pot.rely(msg.sender);\r\n        pot.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract EndFab {\r\n    function newEnd() public returns (End end) {\r\n        end = new End();\r\n        end.rely(msg.sender);\r\n        end.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract ESMFab {\r\n    function newESM(address gov, address end, address pit, uint min) public returns (ESM esm) {\r\n        esm = new ESM(gov, end, pit, min);\r\n    }\r\n}\r\n\r\ncontract PauseFab {\r\n    function newPause(uint delay, address owner, DSAuthority authority) public returns(DSPause pause) {\r\n        pause = new DSPause(delay, owner, authority);\r\n    }\r\n}\r\n\r\ncontract GemLikeESM {\r\n    function balanceOf(address) public view returns (uint256);\r\n    function transfer(address, uint256) public returns (bool);\r\n    function transferFrom(address, address, uint256) public returns (bool);\r\n}\r\n\r\ncontract EndLike {\r\n    function cage() public;\r\n}\r\n\r\ncontract ESM {\r\n    GemLikeESM public gem; // collateral\r\n    EndLike public end; // cage module\r\n    address public pit; // burner\r\n    uint256 public min; // threshold\r\n    uint256 public fired;\r\n\r\n    mapping(address =\u003E uint256) public sum; // per-address balance\r\n    uint256 public Sum; // total balance\r\n\r\n    // --- Logs ---\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an \u0027anonymous\u0027 event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n\r\n    constructor(address gem_, address end_, address pit_, uint256 min_) public {\r\n        gem = GemLikeESM(gem_);\r\n        end = EndLike(end_);\r\n        pit = pit_;\r\n        min = min_;\r\n    }\r\n\r\n    // -- math --\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x \u002B y;\r\n        require(z \u003E= x);\r\n    }\r\n\r\n    function fire() external note {\r\n        require(fired == 0,  \u0022esm/already-fired\u0022);\r\n        require(Sum \u003E= min,  \u0022esm/min-not-reached\u0022);\r\n\r\n        end.cage();\r\n\r\n        fired = 1;\r\n    }\r\n\r\n    function join(uint256 wad) external note {\r\n        require(fired == 0, \u0022esm/already-fired\u0022);\r\n\r\n        sum[msg.sender] = add(sum[msg.sender], wad);\r\n        Sum = add(Sum, wad);\r\n\r\n        require(gem.transferFrom(msg.sender, pit, wad), \u0022esm/transfer-failed\u0022);\r\n    }\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \u0022ds-auth-unauthorized\u0022);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DssDeploy is DSAuth {\r\n    VatFab     public vatFab;\r\n    JugFab     public jugFab;\r\n    VowFab     public vowFab;\r\n    CatFab     public catFab;\r\n    DaiFab     public daiFab;\r\n    DaiJoinFab public daiJoinFab;\r\n    FlapFab    public flapFab;\r\n    FlopFab    public flopFab;\r\n    FlipFab    public flipFab;\r\n    SpotFab    public spotFab;\r\n    PotFab     public potFab;\r\n    EndFab     public endFab;\r\n    ESMFab     public esmFab;\r\n    PauseFab   public pauseFab;\r\n\r\n    Vat     public vat;\r\n    Jug     public jug;\r\n    Vow     public vow;\r\n    Cat     public cat;\r\n    Dai     public dai;\r\n    DaiJoin public daiJoin;\r\n    Flapper public flap;\r\n    Flopper public flop;\r\n    Spotter public spotter;\r\n    Pot     public pot;\r\n    End     public end;\r\n    ESM     public esm;\r\n    DSPause public pause;\r\n\r\n    mapping(bytes32 =\u003E Ilk) public ilks;\r\n\r\n    uint8 public step = 0;\r\n\r\n    uint256 constant ONE = 10 ** 27;\r\n\r\n    struct Ilk {\r\n        Flipper flip;\r\n        address join;\r\n    }\r\n\r\n    constructor(\r\n        VatFab vatFab_,\r\n        JugFab jugFab_,\r\n        VowFab vowFab_,\r\n        CatFab catFab_,\r\n        DaiFab daiFab_,\r\n        DaiJoinFab daiJoinFab_,\r\n        FlapFab flapFab_,\r\n        FlopFab flopFab_,\r\n        FlipFab flipFab_,\r\n        SpotFab spotFab_,\r\n        PotFab potFab_,\r\n        EndFab endFab_,\r\n        ESMFab esmFab_,\r\n        PauseFab pauseFab_\r\n    ) public {\r\n        vatFab = vatFab_;\r\n        jugFab = jugFab_;\r\n        vowFab = vowFab_;\r\n        catFab = catFab_;\r\n        daiFab = daiFab_;\r\n        daiJoinFab = daiJoinFab_;\r\n        flapFab = flapFab_;\r\n        flopFab = flopFab_;\r\n        flipFab = flipFab_;\r\n        spotFab = spotFab_;\r\n        potFab = potFab_;\r\n        endFab = endFab_;\r\n        esmFab = esmFab_;\r\n        pauseFab = pauseFab_;\r\n    }\r\n\r\n    function rad(uint wad) internal pure returns (uint) {\r\n        return wad * 10 ** 27;\r\n    }\r\n\r\n    function deployVat() public auth {\r\n        require(address(vat) == address(0), \u0022VAT already deployed\u0022);\r\n        vat = vatFab.newVat();\r\n        spotter = spotFab.newSpotter(address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(spotter));\r\n    }\r\n\r\n    function deployDai(uint256 chainId) public auth {\r\n        require(address(vat) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        dai = daiFab.newDai(chainId);\r\n        daiJoin = daiJoinFab.newDaiJoin(address(vat), address(dai));\r\n        dai.rely(address(daiJoin));\r\n    }\r\n\r\n    function deployTaxation() public auth {\r\n        require(address(vat) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        jug = jugFab.newJug(address(vat));\r\n        pot = potFab.newPot(address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(jug));\r\n        vat.rely(address(pot));\r\n    }\r\n\r\n    function deployAuctions(address gov) public auth {\r\n        require(gov != address(0), \u0022Missing GOV address\u0022);\r\n        require(address(jug) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        flap = flapFab.newFlap(address(vat), gov);\r\n        flop = flopFab.newFlop(address(vat), gov);\r\n        vow = vowFab.newVow(address(vat), address(flap), address(flop));\r\n\r\n        // Internal references set up\r\n        jug.file(\u0022vow\u0022, address(vow));\r\n        pot.file(\u0022vow\u0022, address(vow));\r\n\r\n        // Internal auth\r\n        flap.rely(address(vow));\r\n        flop.rely(address(vow));\r\n    }\r\n\r\n    function deployLiquidator() public auth {\r\n        require(address(vow) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        cat = catFab.newCat(address(vat));\r\n\r\n        // Internal references set up\r\n        cat.file(\u0022vow\u0022, address(vow));\r\n\r\n        // Internal auth\r\n        vat.rely(address(cat));\r\n        vow.rely(address(cat));\r\n    }\r\n\r\n    function deployShutdown(address gov, address pit, uint256 min) public auth {\r\n        require(address(cat) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        end = endFab.newEnd();\r\n\r\n        // Internal references set up\r\n        end.file(\u0022vat\u0022, address(vat));\r\n        end.file(\u0022cat\u0022, address(cat));\r\n        end.file(\u0022vow\u0022, address(vow));\r\n        end.file(\u0022pot\u0022, address(pot));\r\n        end.file(\u0022spot\u0022, address(spotter));\r\n\r\n        // Internal auth\r\n        vat.rely(address(end));\r\n        cat.rely(address(end));\r\n        vow.rely(address(end));\r\n        pot.rely(address(end));\r\n        spotter.rely(address(end));\r\n\r\n        // Deploy ESM\r\n        esm = esmFab.newESM(gov, address(end), address(pit), min);\r\n        end.rely(address(esm));\r\n    }\r\n\r\n    function deployPause(uint delay, DSAuthority authority) public auth {\r\n        require(address(dai) != address(0), \u0022Missing previous step\u0022);\r\n        require(address(end) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        pause = pauseFab.newPause(delay, address(0), authority);\r\n\r\n        vat.rely(address(pause.proxy()));\r\n        cat.rely(address(pause.proxy()));\r\n        vow.rely(address(pause.proxy()));\r\n        jug.rely(address(pause.proxy()));\r\n        pot.rely(address(pause.proxy()));\r\n        spotter.rely(address(pause.proxy()));\r\n        flap.rely(address(pause.proxy()));\r\n        flop.rely(address(pause.proxy()));\r\n        end.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function deployCollateral(bytes32 ilk, address join, address pip) public auth {\r\n        require(ilk != bytes32(\u0022\u0022), \u0022Missing ilk name\u0022);\r\n        require(join != address(0), \u0022Missing join address\u0022);\r\n        require(pip != address(0), \u0022Missing pip address\u0022);\r\n        require(address(pause) != address(0), \u0022Missing previous step\u0022);\r\n\r\n        // Deploy\r\n        ilks[ilk].flip = flipFab.newFlip(address(vat), ilk);\r\n        ilks[ilk].join = join;\r\n        Spotter(spotter).file(ilk, \u0022pip\u0022, address(pip)); // Set pip\r\n\r\n        // Internal references set up\r\n        cat.file(ilk, \u0022flip\u0022, address(ilks[ilk].flip));\r\n        vat.init(ilk);\r\n        jug.init(ilk);\r\n\r\n        // Internal auth\r\n        vat.rely(join);\r\n        ilks[ilk].flip.rely(address(cat));\r\n        ilks[ilk].flip.rely(address(end));\r\n        ilks[ilk].flip.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function releaseAuth() public auth {\r\n        vat.deny(address(this));\r\n        cat.deny(address(this));\r\n        vow.deny(address(this));\r\n        jug.deny(address(this));\r\n        pot.deny(address(this));\r\n        dai.deny(address(this));\r\n        spotter.deny(address(this));\r\n        flap.deny(address(this));\r\n        flop.deny(address(this));\r\n        end.deny(address(this));\r\n    }\r\n\r\n    function releaseAuthFlip(bytes32 ilk) public auth {\r\n        ilks[ilk].flip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract Kicker {\r\n    function kick(address urn, address gal, uint tab, uint lot, uint bid)\r\n        public returns (uint);\r\n}\r\n\r\ncontract VatLikeCat {\r\n    function ilks(bytes32) external view returns (\r\n        uint256 Art,   // wad\r\n        uint256 rate,  // ray\r\n        uint256 spot   // ray\r\n    );\r\n    function urns(bytes32,address) external view returns (\r\n        uint256 ink,   // wad\r\n        uint256 art    // wad\r\n    );\r\n    function grab(bytes32,address,address,address,int,int) external;\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ncontract VowLike {\r\n    function fess(uint) external;\r\n}\r\n\r\ncontract VatLikeEnd {\r\n    function dai(address) external view returns (uint256);\r\n    function ilks(bytes32 ilk) external returns (\r\n        uint256 Art,\r\n        uint256 rate,\r\n        uint256 spot,\r\n        uint256 line,\r\n        uint256 dust\r\n    );\r\n    function urns(bytes32 ilk, address urn) external returns (\r\n        uint256 ink,\r\n        uint256 art\r\n    );\r\n    function debt() external returns (uint256);\r\n    function move(address src, address dst, uint256 rad) external;\r\n    function hope(address) external;\r\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\r\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\r\n    function suck(address u, address v, uint256 rad) external;\r\n    function cage() external;\r\n}\r\n\r\ncontract CatLike {\r\n    function ilks(bytes32) external returns (\r\n        address flip,  // Liquidator\r\n        uint256 chop,  // Liquidation Penalty   [ray]\r\n        uint256 lump   // Liquidation Quantity  [rad]\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ncontract PotLike {\r\n    function cage() external;\r\n}\r\n\r\ncontract VowLikeEnd {\r\n    function cage() external;\r\n}\r\n\r\ncontract Flippy {\r\n    function bids(uint id) external view returns (\r\n        uint256 bid,\r\n        uint256 lot,\r\n        address guy,\r\n        uint48  tic,\r\n        uint48  end,\r\n        address usr,\r\n        address gal,\r\n        uint256 tab\r\n    );\r\n    function yank(uint id) external;\r\n}\r\n\r\ncontract PipLike {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ncontract Spotty {\r\n    function par() external view returns (uint256);\r\n    function ilks(bytes32) external view returns (\r\n        PipLike pip,\r\n        uint256 mat\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ncontract VatLikeFlap {\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract GemLikeFlap {\r\n    function move(address,address,uint) external;\r\n    function burn(address,uint) external;\r\n}\r\n\r\ncontract VatLikeFlip {\r\n    function move(address,address,uint) external;\r\n    function flux(bytes32,address,address,uint) external;\r\n}\r\n\r\ncontract VatLikeFlop {\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract GemLikeFlop {\r\n    function mint(address,uint) external;\r\n}\r\n\r\ncontract GemLike {\r\n    function decimals() public view returns (uint);\r\n    function transfer(address,uint) external returns (bool);\r\n    function transferFrom(address,address,uint) external returns (bool);\r\n}\r\n\r\ncontract DSTokenLike {\r\n    function mint(address,uint) external;\r\n    function burn(address,uint) external;\r\n}\r\n\r\ncontract VatLikeJoin {\r\n    function slip(bytes32,address,int) external;\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract VatLikeJug {\r\n    function ilks(bytes32) external returns (\r\n        uint256 Art,   // wad\r\n        uint256 rate   // ray\r\n    );\r\n    function fold(bytes32,address,int) external;\r\n}\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an \u0027anonymous\u0027 event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\ncontract Cat is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Cat/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        address flip;  // Liquidator\r\n        uint256 chop;  // Liquidation Penalty   [ray]\r\n        uint256 lump;  // Liquidation Quantity  [wad]\r\n    }\r\n\r\n    mapping (bytes32 =\u003E Ilk) public ilks;\r\n\r\n    uint256 public live;\r\n    VatLikeCat public vat;\r\n    VowLike public vow;\r\n\r\n    // --- Events ---\r\n    event Bite(\r\n      bytes32 indexed ilk,\r\n      address indexed urn,\r\n      uint256 ink,\r\n      uint256 art,\r\n      uint256 tab,\r\n      address flip,\r\n      uint256 id\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeCat(vat_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint constant ONE = 10 ** 27;\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / ONE;\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        if (x \u003E y) { z = y; } else { z = x; }\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \u0022vow\u0022) vow = VowLike(data);\r\n        else revert(\u0022Cat/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        if (what == \u0022chop\u0022) ilks[ilk].chop = data;\r\n        else if (what == \u0022lump\u0022) ilks[ilk].lump = data;\r\n        else revert(\u0022Cat/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, address flip) external note auth {\r\n        if (what == \u0022flip\u0022) {\r\n            vat.nope(ilks[ilk].flip);\r\n            ilks[ilk].flip = flip;\r\n            vat.hope(flip);\r\n        }\r\n        else revert(\u0022Cat/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- CDP Liquidation ---\r\n    function bite(bytes32 ilk, address urn) external returns (uint id) {\r\n        (, uint rate, uint spot) = vat.ilks(ilk);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n\r\n        require(live == 1, \u0022Cat/not-live\u0022);\r\n        require(spot \u003E 0 \u0026\u0026 mul(ink, spot) \u003C mul(art, rate), \u0022Cat/not-unsafe\u0022);\r\n\r\n        uint lot = min(ink, ilks[ilk].lump);\r\n        art      = min(art, mul(lot, art) / ink);\r\n\r\n        require(lot \u003C= 2**255 \u0026\u0026 art \u003C= 2**255, \u0022Cat/overflow\u0022);\r\n        vat.grab(ilk, urn, address(this), address(vow), -int(lot), -int(art));\r\n\r\n        vow.fess(mul(art, rate));\r\n        id = Kicker(ilks[ilk].flip).kick({ urn: urn\r\n                                         , gal: address(vow)\r\n                                         , tab: rmul(mul(art, rate), ilks[ilk].chop)\r\n                                         , lot: lot\r\n                                         , bid: 0\r\n                                         });\r\n\r\n        emit Bite(ilk, urn, lot, art, mul(art, rate), ilks[ilk].flip, id);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\ncontract Dai is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Dai/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- ERC20 Data ---\r\n    string  public constant name     = \u0022Dai Stablecoin\u0022;\r\n    string  public constant symbol   = \u0022DAI\u0022;\r\n    string  public constant version  = \u00221\u0022;\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address =\u003E uint)                      public balanceOf;\r\n    mapping (address =\u003E mapping (address =\u003E uint)) public allowance;\r\n    mapping (address =\u003E uint)                      public nonces;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\u0022Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\u0022);\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor(uint256 chainId_) public {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\u0022EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\u0022),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId_,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public returns (bool)\r\n    {\r\n        require(balanceOf[src] \u003E= wad, \u0022Dai/insufficient-balance\u0022);\r\n        if (src != msg.sender \u0026\u0026 allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] \u003E= wad, \u0022Dai/insufficient-allowance\u0022);\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function mint(address usr, uint wad) external auth {\r\n        balanceOf[usr] = add(balanceOf[usr], wad);\r\n        totalSupply    = add(totalSupply, wad);\r\n        emit Transfer(address(0), usr, wad);\r\n    }\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] \u003E= wad, \u0022Dai/insufficient-balance\u0022);\r\n        if (usr != msg.sender \u0026\u0026 allowance[usr][msg.sender] != uint(-1)) {\r\n            require(allowance[usr][msg.sender] \u003E= wad, \u0022Dai/insufficient-allowance\u0022);\r\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply    = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n    function approve(address usr, uint wad) external returns (bool) {\r\n        allowance[msg.sender][usr] = wad;\r\n        emit Approval(msg.sender, usr, wad);\r\n        return true;\r\n    }\r\n\r\n    // --- Alias ---\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \u0022\\x19\\x01\u0022,\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \u0022Dai/invalid-address-0\u0022);\r\n        require(holder == ecrecover(digest, v, r, s), \u0022Dai/invalid-permit\u0022);\r\n        require(expiry == 0 || now \u003C= expiry, \u0022Dai/permit-expired\u0022);\r\n        require(nonce == nonces[holder]\u002B\u002B, \u0022Dai/invalid-nonce\u0022);\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowance[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}\r\n\r\ncontract End is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022End/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLikeEnd  public vat;\r\n    CatLike  public cat;\r\n    VowLikeEnd  public vow;\r\n    PotLike  public pot;\r\n    Spotty   public spot;\r\n\r\n    uint256  public live;  // cage flag\r\n    uint256  public when;  // time of cage\r\n    uint256  public wait;  // processing cooldown length\r\n    uint256  public debt;  // total outstanding dai following processing [rad]\r\n\r\n    mapping (bytes32 =\u003E uint256) public tag;  // cage price           [ray]\r\n    mapping (bytes32 =\u003E uint256) public gap;  // collateral shortfall [wad]\r\n    mapping (bytes32 =\u003E uint256) public Art;  // total debt per ilk   [wad]\r\n    mapping (bytes32 =\u003E uint256) public fix;  // final cash price     [ray]\r\n\r\n    mapping (address =\u003E uint256)                      public bag;  // [wad]\r\n    mapping (bytes32 =\u003E mapping (address =\u003E uint256)) public out;  // [wad]\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x \u002B y;\r\n        require(z \u003E= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x \u003C= y ? x : y;\r\n    }\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, WAD) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        require(live == 1, \u0022End/not-live\u0022);\r\n        if (what == \u0022vat\u0022)  vat = VatLikeEnd(data);\r\n        else if (what == \u0022cat\u0022)  cat = CatLike(data);\r\n        else if (what == \u0022vow\u0022)  vow = VowLikeEnd(data);\r\n        else if (what == \u0022pot\u0022)  pot = PotLike(data);\r\n        else if (what == \u0022spot\u0022) spot = Spotty(data);\r\n        else revert(\u0022End/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \u0022End/not-live\u0022);\r\n        if (what == \u0022wait\u0022) wait = data;\r\n        else revert(\u0022End/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function cage() external note auth {\r\n        require(live == 1, \u0022End/not-live\u0022);\r\n        live = 0;\r\n        when = now;\r\n        vat.cage();\r\n        cat.cage();\r\n        vow.cage();\r\n        spot.cage();\r\n        pot.cage();\r\n    }\r\n\r\n    function cage(bytes32 ilk) external note {\r\n        require(live == 0, \u0022End/still-live\u0022);\r\n        require(tag[ilk] == 0, \u0022End/tag-ilk-already-defined\u0022);\r\n        (Art[ilk],,,,) = vat.ilks(ilk);\r\n        (PipLike pip,) = spot.ilks(ilk);\r\n        // par is a ray, pip returns a wad\r\n        tag[ilk] = wdiv(spot.par(), uint(pip.read()));\r\n    }\r\n\r\n    function skip(bytes32 ilk, uint256 id) external note {\r\n        require(tag[ilk] != 0, \u0022End/tag-ilk-not-defined\u0022);\r\n\r\n        (address flipV,,) = cat.ilks(ilk);\r\n        Flippy flip = Flippy(flipV);\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint bid, uint lot,,,, address usr,, uint tab) = flip.bids(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        vat.suck(address(vow), address(this), bid);\r\n        vat.hope(address(flip));\r\n        flip.yank(id);\r\n\r\n        uint art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int(lot) \u003E= 0 \u0026\u0026 int(art) \u003E= 0, \u0022End/overflow\u0022);\r\n        vat.grab(ilk, usr, address(this), address(vow), int(lot), int(art));\r\n    }\r\n\r\n    function skim(bytes32 ilk, address urn) external note {\r\n        require(tag[ilk] != 0, \u0022End/tag-ilk-not-defined\u0022);\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n\r\n        uint owe = rmul(rmul(art, rate), tag[ilk]);\r\n        uint wad = min(ink, owe);\r\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\r\n\r\n        require(wad \u003C= 2**255 \u0026\u0026 art \u003C= 2**255, \u0022End/overflow\u0022);\r\n        vat.grab(ilk, urn, address(this), address(vow), -int(wad), -int(art));\r\n    }\r\n\r\n    function free(bytes32 ilk) external note {\r\n        require(live == 0, \u0022End/still-live\u0022);\r\n        (uint ink, uint art) = vat.urns(ilk, msg.sender);\r\n        require(art == 0, \u0022End/art-not-zero\u0022);\r\n        require(ink \u003C= 2**255, \u0022End/overflow\u0022);\r\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int(ink), 0);\r\n    }\r\n\r\n    function thaw() external note {\r\n        require(live == 0, \u0022End/still-live\u0022);\r\n        require(debt == 0, \u0022End/debt-not-zero\u0022);\r\n        require(vat.dai(address(vow)) == 0, \u0022End/surplus-not-zero\u0022);\r\n        require(now \u003E= add(when, wait), \u0022End/wait-not-finished\u0022);\r\n        debt = vat.debt();\r\n    }\r\n    function flow(bytes32 ilk) external note {\r\n        require(debt != 0, \u0022End/debt-zero\u0022);\r\n        require(fix[ilk] == 0, \u0022End/fix-ilk-already-defined\u0022);\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\r\n        fix[ilk] = rdiv(mul(sub(wad, gap[ilk]), RAY), debt);\r\n    }\r\n\r\n    function pack(uint256 wad) external note {\r\n        require(debt != 0, \u0022End/debt-zero\u0022);\r\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\r\n        bag[msg.sender] = add(bag[msg.sender], wad);\r\n    }\r\n    function cash(bytes32 ilk, uint wad) external note {\r\n        require(fix[ilk] != 0, \u0022End/fix-ilk-not-defined\u0022);\r\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\r\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\r\n        require(out[ilk][msg.sender] \u003C= bag[msg.sender], \u0022End/insufficient-bag-balance\u0022);\r\n    }\r\n}\r\n\r\ncontract Flapper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Flapper/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n    }\r\n\r\n    mapping (uint =\u003E Bid) public bids;\r\n\r\n    VatLikeFlap  public   vat;\r\n    GemLikeFlap  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid duration\r\n    uint48   public   tau = 2 days;   // 2 days total auction length\r\n    uint256  public kicks = 0;\r\n    uint256  public live;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeFlap(vat_);\r\n        gem = GemLikeFlap(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \u0022beg\u0022) beg = data;\r\n        else if (what == \u0022ttl\u0022) ttl = uint48(data);\r\n        else if (what == \u0022tau\u0022) tau = uint48(data);\r\n        else revert(\u0022Flapper/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \u0022Flapper/not-live\u0022);\r\n        require(kicks \u003C uint(-1), \u0022Flapper/overflow\u0022);\r\n        id = \u002B\u002Bkicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender; // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        vat.move(msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end \u003C now, \u0022Flapper/not-finished\u0022);\r\n        require(bids[id].tic == 0, \u0022Flapper/bid-already-placed\u0022);\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \u0022Flapper/not-live\u0022);\r\n        require(bids[id].guy != address(0), \u0022Flapper/guy-not-set\u0022);\r\n        require(bids[id].tic \u003E now || bids[id].tic == 0, \u0022Flapper/already-finished-tic\u0022);\r\n        require(bids[id].end \u003E now, \u0022Flapper/already-finished-end\u0022);\r\n\r\n        require(lot == bids[id].lot, \u0022Flapper/lot-not-matching\u0022);\r\n        require(bid \u003E  bids[id].bid, \u0022Flapper/bid-not-higher\u0022);\r\n        require(mul(bid, ONE) \u003E= mul(beg, bids[id].bid), \u0022Flapper/insufficient-increase\u0022);\r\n\r\n        gem.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        gem.move(msg.sender, address(this), bid - bids[id].bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \u0022Flapper/not-live\u0022);\r\n        require(bids[id].tic != 0 \u0026\u0026 (bids[id].tic \u003C now || bids[id].end \u003C now), \u0022Flapper/not-finished\u0022);\r\n        vat.move(address(this), bids[id].guy, bids[id].lot);\r\n        gem.burn(address(this), bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n\r\n    function cage(uint rad) external note auth {\r\n       live = 0;\r\n       vat.move(address(this), msg.sender, rad);\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \u0022Flapper/still-live\u0022);\r\n        require(bids[id].guy != address(0), \u0022Flapper/guy-not-set\u0022);\r\n        gem.move(address(this), bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract Flipper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Flipper/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n        address usr;\r\n        address gal;\r\n        uint256 tab;\r\n    }\r\n\r\n    mapping (uint =\u003E Bid) public bids;\r\n\r\n    VatLikeFlip public   vat;\r\n    bytes32 public   ilk;\r\n\r\n    uint256 constant ONE = 1.00E18;\r\n    uint256 public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48  public   ttl = 3 hours;  // 3 hours bid duration\r\n    uint48  public   tau = 2 days;   // 2 days total auction length\r\n    uint256 public kicks = 0;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      uint256 tab,\r\n      address indexed usr,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, bytes32 ilk_) public {\r\n        vat = VatLikeFlip(vat_);\r\n        ilk = ilk_;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \u0022beg\u0022) beg = data;\r\n        else if (what == \u0022ttl\u0022) ttl = uint48(data);\r\n        else if (what == \u0022tau\u0022) tau = uint48(data);\r\n        else revert(\u0022Flipper/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address usr, address gal, uint tab, uint lot, uint bid)\r\n        public auth returns (uint id)\r\n    {\r\n        require(kicks \u003C uint(-1), \u0022Flipper/overflow\u0022);\r\n        id = \u002B\u002Bkicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender; // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n        bids[id].usr = usr;\r\n        bids[id].gal = gal;\r\n        bids[id].tab = tab;\r\n\r\n        vat.flux(ilk, msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid, tab, usr, gal);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end \u003C now, \u0022Flipper/not-finished\u0022);\r\n        require(bids[id].tic == 0, \u0022Flipper/bid-already-placed\u0022);\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint id, uint lot, uint bid) external note {\r\n        require(bids[id].guy != address(0), \u0022Flipper/guy-not-set\u0022);\r\n        require(bids[id].tic \u003E now || bids[id].tic == 0, \u0022Flipper/already-finished-tic\u0022);\r\n        require(bids[id].end \u003E now, \u0022Flipper/already-finished-end\u0022);\r\n\r\n        require(lot == bids[id].lot, \u0022Flipper/lot-not-matching\u0022);\r\n        require(bid \u003C= bids[id].tab, \u0022Flipper/higher-than-tab\u0022);\r\n        require(bid \u003E  bids[id].bid, \u0022Flipper/bid-not-higher\u0022);\r\n        require(mul(bid, ONE) \u003E= mul(beg, bids[id].bid) || bid == bids[id].tab, \u0022Flipper/insufficient-increase\u0022);\r\n\r\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        vat.move(msg.sender, bids[id].gal, bid - bids[id].bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function dent(uint id, uint lot, uint bid) external note {\r\n        require(bids[id].guy != address(0), \u0022Flipper/guy-not-set\u0022);\r\n        require(bids[id].tic \u003E now || bids[id].tic == 0, \u0022Flipper/already-finished-tic\u0022);\r\n        require(bids[id].end \u003E now, \u0022Flipper/already-finished-end\u0022);\r\n\r\n        require(bid == bids[id].bid, \u0022Flipper/not-matching-bid\u0022);\r\n        require(bid == bids[id].tab, \u0022Flipper/tend-not-finished\u0022);\r\n        require(lot \u003C bids[id].lot, \u0022Flipper/lot-not-lower\u0022);\r\n        require(mul(beg, lot) \u003C= mul(bids[id].lot, ONE), \u0022Flipper/insufficient-decrease\u0022);\r\n\r\n        vat.move(msg.sender, bids[id].guy, bid);\r\n        vat.flux(ilk, address(this), bids[id].usr, bids[id].lot - lot);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(bids[id].tic != 0 \u0026\u0026 (bids[id].tic \u003C now || bids[id].end \u003C now), \u0022Flipper/not-finished\u0022);\r\n        vat.flux(ilk, address(this), bids[id].guy, bids[id].lot);\r\n        delete bids[id];\r\n    }\r\n\r\n    function yank(uint id) external note auth {\r\n        require(bids[id].guy != address(0), \u0022Flipper/guy-not-set\u0022);\r\n        require(bids[id].bid \u003C bids[id].tab, \u0022Flipper/already-dent-phase\u0022);\r\n        vat.flux(ilk, address(this), msg.sender, bids[id].lot);\r\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract Flopper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Flopper/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n    }\r\n\r\n    mapping (uint =\u003E Bid) public bids;\r\n\r\n    VatLikeFlop  public   vat;\r\n    GemLikeFlop  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime\r\n    uint48   public   tau = 2 days;   // 2 days total auction length\r\n    uint256  public kicks = 0;\r\n    uint256  public live;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeFlop(vat_);\r\n        gem = GemLikeFlop(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \u0022beg\u0022) beg = data;\r\n        else if (what == \u0022pad\u0022) pad = data;\r\n        else if (what == \u0022ttl\u0022) ttl = uint48(data);\r\n        else if (what == \u0022tau\u0022) tau = uint48(data);\r\n        else revert(\u0022Flopper/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \u0022Flopper/not-live\u0022);\r\n        require(kicks \u003C uint(-1), \u0022Flopper/overflow\u0022);\r\n        id = \u002B\u002Bkicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = gal;\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        emit Kick(id, lot, bid, gal);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end \u003C now, \u0022Flopper/not-finished\u0022);\r\n        require(bids[id].tic == 0, \u0022Flopper/bid-already-placed\u0022);\r\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function dent(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \u0022Flopper/not-live\u0022);\r\n        require(bids[id].guy != address(0), \u0022Flopper/guy-not-set\u0022);\r\n        require(bids[id].tic \u003E now || bids[id].tic == 0, \u0022Flopper/already-finished-tic\u0022);\r\n        require(bids[id].end \u003E now, \u0022Flopper/already-finished-end\u0022);\r\n\r\n        require(bid == bids[id].bid, \u0022Flopper/not-matching-bid\u0022);\r\n        require(lot \u003C  bids[id].lot, \u0022Flopper/lot-not-lower\u0022);\r\n        require(mul(beg, lot) \u003C= mul(bids[id].lot, ONE), \u0022Flopper/insufficient-decrease\u0022);\r\n\r\n        vat.move(msg.sender, bids[id].guy, bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \u0022Flopper/not-live\u0022);\r\n        require(bids[id].tic != 0 \u0026\u0026 (bids[id].tic \u003C now || bids[id].end \u003C now), \u0022Flopper/not-finished\u0022);\r\n        gem.mint(bids[id].guy, bids[id].lot);\r\n        delete bids[id];\r\n    }\r\n\r\n    function cage() external note auth {\r\n       live = 0;\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \u0022Flopper/still-live\u0022);\r\n        require(bids[id].guy != address(0), \u0022Flopper/guy-not-set\u0022);\r\n        vat.move(address(this), bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract GemJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022GemJoin/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    bytes32 public ilk;\r\n    GemLike public gem;\r\n    uint    public dec;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        ilk = ilk_;\r\n        gem = GemLike(gem_);\r\n        dec = gem.decimals();\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        require(live == 1, \u0022GemJoin/not-live\u0022);\r\n        require(int(wad) \u003E= 0, \u0022GemJoin/overflow\u0022);\r\n        vat.slip(ilk, usr, int(wad));\r\n        require(gem.transferFrom(msg.sender, address(this), wad), \u0022GemJoin/failed-transfer\u0022);\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(wad \u003C= 2 ** 255, \u0022GemJoin/overflow\u0022);\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        require(gem.transfer(usr, wad), \u0022GemJoin/failed-transfer\u0022);\r\n    }\r\n}\r\n\r\ncontract ETHJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022ETHJoin/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    bytes32 public ilk;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        ilk = ilk_;\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr) external payable note {\r\n        require(live == 1, \u0022ETHJoin/not-live\u0022);\r\n        require(int(msg.value) \u003E= 0, \u0022ETHJoin/overflow\u0022);\r\n        vat.slip(ilk, usr, int(msg.value));\r\n    }\r\n    function exit(address payable usr, uint wad) external note {\r\n        require(int(wad) \u003E= 0, \u0022ETHJoin/overflow\u0022);\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        usr.transfer(wad);\r\n    }\r\n}\r\n\r\ncontract DaiJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022DaiJoin/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    DSTokenLike public dai;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, address dai_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        dai = DSTokenLike(dai_);\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    uint constant ONE = 10 ** 27;\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        vat.move(address(this), usr, mul(ONE, wad));\r\n        dai.burn(msg.sender, wad);\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(live == 1, \u0022DaiJoin/not-live\u0022);\r\n        vat.move(msg.sender, address(this), mul(ONE, wad));\r\n        dai.mint(usr, wad);\r\n    }\r\n}\r\n\r\ncontract Jug is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Jug/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 duty;\r\n        uint256  rho;\r\n    }\r\n\r\n    mapping (bytes32 =\u003E Ilk) public ilks;\r\n    VatLikeJug                  public vat;\r\n    address                  public vow;\r\n    uint256                  public base;\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeJug(vat_);\r\n    }\r\n\r\n    // --- Math ---\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    uint256 constant ONE = 10 ** 27;\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x \u002B y;\r\n        require(z \u003E= x);\r\n    }\r\n    function diff(uint x, uint y) internal pure returns (int z) {\r\n        z = int(x) - int(y);\r\n        require(int(x) \u003E= 0 \u0026\u0026 int(y) \u003E= 0);\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / ONE;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        Ilk storage i = ilks[ilk];\r\n        require(i.duty == 0, \u0022Jug/ilk-already-init\u0022);\r\n        i.duty = ONE;\r\n        i.rho  = now;\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(now == ilks[ilk].rho, \u0022Jug/rho-not-updated\u0022);\r\n        if (what == \u0022duty\u0022) ilks[ilk].duty = data;\r\n        else revert(\u0022Jug/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \u0022base\u0022) base = data;\r\n        else revert(\u0022Jug/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \u0022vow\u0022) vow = data;\r\n        else revert(\u0022Jug/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Stability Fee Collection ---\r\n    function drip(bytes32 ilk) external note returns (uint rate) {\r\n        require(now \u003E= ilks[ilk].rho, \u0022Jug/invalid-now\u0022);\r\n        (, uint prev) = vat.ilks(ilk);\r\n        rate = rmul(rpow(add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\r\n        vat.fold(ilk, vow, diff(rate, prev));\r\n        ilks[ilk].rho = now;\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSPause is DSAuth, DSNote {\r\n\r\n    // --- admin ---\r\n\r\n    modifier wait { require(msg.sender == address(proxy), \u0022ds-pause-undelayed-call\u0022); _; }\r\n\r\n    function setOwner(address owner_) public wait {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n    function setAuthority(DSAuthority authority_) public wait {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n    function setDelay(uint delay_) public note wait {\r\n        delay = delay_;\r\n    }\r\n\r\n    // --- math ---\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x \u002B y;\r\n        require(z \u003E= x, \u0022ds-pause-addition-overflow\u0022);\r\n    }\r\n\r\n    // --- data ---\r\n\r\n    mapping (bytes32 =\u003E bool) public plans;\r\n    DSPauseProxy public proxy;\r\n    uint         public delay;\r\n\r\n    // --- init ---\r\n\r\n    constructor(uint delay_, address owner_, DSAuthority authority_) public {\r\n        delay = delay_;\r\n        owner = owner_;\r\n        authority = authority_;\r\n        proxy = new DSPauseProxy();\r\n    }\r\n\r\n    // --- util ---\r\n\r\n    function hash(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        internal pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(usr, tag, fax, eta));\r\n    }\r\n\r\n    function soul(address usr)\r\n        internal view\r\n        returns (bytes32 tag)\r\n    {\r\n        assembly { tag := extcodehash(usr) }\r\n    }\r\n\r\n    // --- operations ---\r\n\r\n    function plot(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        require(eta \u003E= add(now, delay), \u0022ds-pause-delay-not-respected\u0022);\r\n        plans[hash(usr, tag, fax, eta)] = true;\r\n    }\r\n\r\n    function drop(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n    }\r\n\r\n    function exec(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note\r\n        returns (bytes memory out)\r\n    {\r\n        require(plans[hash(usr, tag, fax, eta)], \u0022ds-pause-unplotted-plan\u0022);\r\n        require(soul(usr) == tag,                \u0022ds-pause-wrong-codehash\u0022);\r\n        require(now \u003E= eta,                      \u0022ds-pause-premature-exec\u0022);\r\n\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n\r\n        out = proxy.exec(usr, fax);\r\n        require(proxy.owner() == address(this), \u0022ds-pause-illegal-storage-change\u0022);\r\n    }\r\n}\r\n\r\ncontract DSPauseProxy {\r\n    address public owner;\r\n    modifier auth { require(msg.sender == owner, \u0022ds-pause-proxy-unauthorized\u0022); _; }\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    function exec(address usr, bytes memory fax)\r\n        public auth\r\n        returns (bytes memory out)\r\n    {\r\n        bool ok;\r\n        (ok, out) = usr.delegatecall(fax);\r\n        require(ok, \u0022ds-pause-delegatecall-error\u0022);\r\n    }\r\n}\r\n\r\ncontract VatLikePot {\r\n    function move(address,address,uint256) external;\r\n    function suck(address,address,uint256) external;\r\n}\r\n\r\ncontract Pot is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Pot/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    mapping (address =\u003E uint256) public pie;  // user Savings Dai\r\n\r\n    uint256 public Pie;  // total Savings Dai\r\n    uint256 public dsr;  // the Dai Savings Rate\r\n    uint256 public chi;  // the Rate Accumulator\r\n\r\n    VatLikePot public vat;  // CDP engine\r\n    address public vow;  // debt engine\r\n    uint256 public rho;  // time of last drip\r\n\r\n    uint256 public live;  // Access Flag\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikePot(vat_);\r\n        dsr = ONE;\r\n        chi = ONE;\r\n        rho = now;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant ONE = 10 ** 27;\r\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / ONE;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \u0022Pot/not-live\u0022);\r\n        require(now == rho, \u0022Pot/rho-not-updated\u0022);\r\n        if (what == \u0022dsr\u0022) dsr = data;\r\n        else revert(\u0022Pot/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    function file(bytes32 what, address addr) external note auth {\r\n        if (what == \u0022vow\u0022) vow = addr;\r\n        else revert(\u0022Pot/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n        dsr = ONE;\r\n    }\r\n\r\n    // --- Savings Rate Accumulation ---\r\n    function drip() external note returns (uint tmp) {\r\n        require(now \u003E= rho, \u0022Pot/invalid-now\u0022);\r\n        tmp = rmul(rpow(dsr, now - rho, ONE), chi);\r\n        uint chi_ = sub(tmp, chi);\r\n        chi = tmp;\r\n        rho = now;\r\n        vat.suck(address(vow), address(this), mul(Pie, chi_));\r\n    }\r\n\r\n    // --- Savings Dai Management ---\r\n    function join(uint wad) external note {\r\n        require(now == rho, \u0022Pot/rho-not-updated\u0022);\r\n        pie[msg.sender] = add(pie[msg.sender], wad);\r\n        Pie             = add(Pie,             wad);\r\n        vat.move(msg.sender, address(this), mul(chi, wad));\r\n    }\r\n\r\n    function exit(uint wad) external note {\r\n        pie[msg.sender] = sub(pie[msg.sender], wad);\r\n        Pie             = sub(Pie,             wad);\r\n        vat.move(address(this), msg.sender, mul(chi, wad));\r\n    }\r\n}\r\n\r\ncontract VatLikeSpot {\r\n    function file(bytes32, bytes32, uint) external;\r\n}\r\n\r\ncontract PipLikeSpot {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ncontract Spotter is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1;  }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Spotter/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        PipLikeSpot pip;\r\n        uint256 mat;\r\n    }\r\n\r\n    mapping (bytes32 =\u003E Ilk) public ilks;\r\n\r\n    VatLikeSpot public vat;\r\n    uint256 public par; // ref per dai\r\n\r\n    uint256 public live;\r\n\r\n    // --- Events ---\r\n    event Poke(\r\n      bytes32 ilk,\r\n      bytes32 val,\r\n      uint256 spot\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeSpot(vat_);\r\n        par = ONE;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint constant ONE = 10 ** 27;\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, ONE) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 ilk, bytes32 what, address pip_) external note auth {\r\n        require(live == 1, \u0022Spotter/not-live\u0022);\r\n        if (what == \u0022pip\u0022) ilks[ilk].pip = PipLikeSpot(pip_);\r\n        else revert(\u0022Spotter/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \u0022Spotter/not-live\u0022);\r\n        if (what == \u0022par\u0022) par = data;\r\n        else revert(\u0022Spotter/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \u0022Spotter/not-live\u0022);\r\n        if (what == \u0022mat\u0022) ilks[ilk].mat = data;\r\n        else revert(\u0022Spotter/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // --- Update value ---\r\n    function poke(bytes32 ilk) external {\r\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\r\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\r\n        vat.file(ilk, \u0022spot\u0022, spot);\r\n        emit Poke(ilk, val, spot);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\ncontract Vat {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \u0022Vat/not-live\u0022); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { require(live == 1, \u0022Vat/not-live\u0022); wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Vat/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    mapping(address =\u003E mapping (address =\u003E uint)) public can;\r\n    function hope(address usr) external note { can[msg.sender][usr] = 1; }\r\n    function nope(address usr) external note { can[msg.sender][usr] = 0; }\r\n    function wish(address bit, address usr) internal view returns (bool) {\r\n        return either(bit == usr, can[bit][usr] == 1);\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n\r\n    mapping (bytes32 =\u003E Ilk)                       public ilks;\r\n    mapping (bytes32 =\u003E mapping (address =\u003E Urn )) public urns;\r\n    mapping (bytes32 =\u003E mapping (address =\u003E uint)) public gem;  // [wad]\r\n    mapping (address =\u003E uint256)                   public dai;  // [rad]\r\n    mapping (address =\u003E uint256)                   public sin;  // [rad]\r\n\r\n    uint256 public debt;  // Total Dai Issued    [rad]\r\n    uint256 public vice;  // Total Unbacked Dai  [rad]\r\n    uint256 public Line;  // Total Debt Ceiling  [rad]\r\n    uint256 public live;  // Access Flag\r\n\r\n    // --- Logs ---\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes32  indexed  arg3,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an \u0027anonymous\u0027 event with a constant 6 words of calldata\r\n            // and four indexed topics: the selector and the first three args\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36),                    // arg2\r\n                 calldataload(68)                     // arg3\r\n                )\r\n        }\r\n    }\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x \u002B uint(y);\r\n        require(y \u003E= 0 || z \u003C= x);\r\n        require(y \u003C= 0 || z \u003E= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y \u003C= 0 || z \u003C= x);\r\n        require(y \u003E= 0 || z \u003E= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) \u003E= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        require(ilks[ilk].rate == 0, \u0022Vat/ilk-already-init\u0022);\r\n        ilks[ilk].rate = 10 ** 27;\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \u0022Vat/not-live\u0022);\r\n        if (what == \u0022Line\u0022) Line = data;\r\n        else revert(\u0022Vat/file-unrecognized-param\u0022);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \u0022Vat/not-live\u0022);\r\n        if (what == \u0022spot\u0022) ilks[ilk].spot = data;\r\n        else if (what == \u0022line\u0022) ilks[ilk].line = data;\r\n        else if (what == \u0022dust\u0022) ilks[ilk].dust = data;\r\n        else revert(\u0022Vat/file-unrecognized-param\u0022);\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n\r\n    // --- Fungibility ---\r\n    function slip(bytes32 ilk, address usr, int256 wad) external note auth {\r\n        gem[ilk][usr] = add(gem[ilk][usr], wad);\r\n    }\r\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external note {\r\n        require(wish(src, msg.sender), \u0022Vat/not-allowed\u0022);\r\n        gem[ilk][src] = sub(gem[ilk][src], wad);\r\n        gem[ilk][dst] = add(gem[ilk][dst], wad);\r\n    }\r\n    function move(address src, address dst, uint256 rad) external note {\r\n        require(wish(src, msg.sender), \u0022Vat/not-allowed\u0022);\r\n        dai[src] = sub(dai[src], rad);\r\n        dai[dst] = add(dai[dst], rad);\r\n    }\r\n\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- CDP Manipulation ---\r\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external note {\r\n        // system is live\r\n        require(live == 1, \u0022Vat/not-live\u0022);\r\n\r\n        Urn memory urn = urns[i][u];\r\n        Ilk memory ilk = ilks[i];\r\n        // ilk has been initialised\r\n        require(ilk.rate != 0, \u0022Vat/ilk-not-init\u0022);\r\n\r\n        urn.ink = add(urn.ink, dink);\r\n        urn.art = add(urn.art, dart);\r\n        ilk.Art = add(ilk.Art, dart);\r\n\r\n        int dtab = mul(ilk.rate, dart);\r\n        uint tab = mul(ilk.rate, urn.art);\r\n        debt     = add(debt, dtab);\r\n\r\n        // either debt has decreased, or debt ceilings are not exceeded\r\n        require(either(dart \u003C= 0, both(mul(ilk.Art, ilk.rate) \u003C= ilk.line, debt \u003C= Line)), \u0022Vat/ceiling-exceeded\u0022);\r\n        // urn is either less risky than before, or it is safe\r\n        require(either(both(dart \u003C= 0, dink \u003E= 0), tab \u003C= mul(urn.ink, ilk.spot)), \u0022Vat/not-safe\u0022);\r\n\r\n        // urn is either more safe, or the owner consents\r\n        require(either(both(dart \u003C= 0, dink \u003E= 0), wish(u, msg.sender)), \u0022Vat/not-allowed-u\u0022);\r\n        // collateral src consents\r\n        require(either(dink \u003C= 0, wish(v, msg.sender)), \u0022Vat/not-allowed-v\u0022);\r\n        // debt dst consents\r\n        require(either(dart \u003E= 0, wish(w, msg.sender)), \u0022Vat/not-allowed-w\u0022);\r\n\r\n        // urn has no debt, or a non-dusty amount\r\n        require(either(urn.art == 0, tab \u003E= ilk.dust), \u0022Vat/dust\u0022);\r\n\r\n        gem[i][v] = sub(gem[i][v], dink);\r\n        dai[w]    = add(dai[w],    dtab);\r\n\r\n        urns[i][u] = urn;\r\n        ilks[i]    = ilk;\r\n    }\r\n    // --- CDP Fungibility ---\r\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external note {\r\n        Urn storage u = urns[ilk][src];\r\n        Urn storage v = urns[ilk][dst];\r\n        Ilk storage i = ilks[ilk];\r\n\r\n        u.ink = sub(u.ink, dink);\r\n        u.art = sub(u.art, dart);\r\n        v.ink = add(v.ink, dink);\r\n        v.art = add(v.art, dart);\r\n\r\n        uint utab = mul(u.art, i.rate);\r\n        uint vtab = mul(v.art, i.rate);\r\n\r\n        // both sides consent\r\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \u0022Vat/not-allowed\u0022);\r\n\r\n        // both sides safe\r\n        require(utab \u003C= mul(u.ink, i.spot), \u0022Vat/not-safe-src\u0022);\r\n        require(vtab \u003C= mul(v.ink, i.spot), \u0022Vat/not-safe-dst\u0022);\r\n\r\n        // both sides non-dusty\r\n        require(either(utab \u003E= i.dust, u.art == 0), \u0022Vat/dust-src\u0022);\r\n        require(either(vtab \u003E= i.dust, v.art == 0), \u0022Vat/dust-dst\u0022);\r\n    }\r\n    // --- CDP Confiscation ---\r\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external note auth {\r\n        Urn storage urn = urns[i][u];\r\n        Ilk storage ilk = ilks[i];\r\n\r\n        urn.ink = add(urn.ink, dink);\r\n        urn.art = add(urn.art, dart);\r\n        ilk.Art = add(ilk.Art, dart);\r\n\r\n        int dtab = mul(ilk.rate, dart);\r\n\r\n        gem[i][v] = sub(gem[i][v], dink);\r\n        sin[w]    = sub(sin[w],    dtab);\r\n        vice      = sub(vice,      dtab);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function heal(uint rad) external note {\r\n        address u = msg.sender;\r\n        sin[u] = sub(sin[u], rad);\r\n        dai[u] = sub(dai[u], rad);\r\n        vice   = sub(vice,   rad);\r\n        debt   = sub(debt,   rad);\r\n    }\r\n    function suck(address u, address v, uint rad) external note auth {\r\n        sin[u] = add(sin[u], rad);\r\n        dai[v] = add(dai[v], rad);\r\n        vice   = add(vice,   rad);\r\n        debt   = add(debt,   rad);\r\n    }\r\n\r\n    // --- Rates ---\r\n    function fold(bytes32 i, address u, int rate) external note auth {\r\n        require(live == 1, \u0022Vat/not-live\u0022);\r\n        Ilk storage ilk = ilks[i];\r\n        ilk.rate = add(ilk.rate, rate);\r\n        int rad  = mul(ilk.Art, rate);\r\n        dai[u]   = add(dai[u], rad);\r\n        debt     = add(debt,   rad);\r\n    }\r\n}\r\n\r\ncontract FlopLike {\r\n    function kick(address gal, uint lot, uint bid) external returns (uint);\r\n    function cage() external;\r\n    function live() external returns (uint);\r\n}\r\n\r\ncontract FlapLike {\r\n    function kick(uint lot, uint bid) external returns (uint);\r\n    function cage(uint) external;\r\n    function live() external returns (uint);\r\n}\r\n\r\ncontract VatLikeVow {\r\n    function dai (address) external view returns (uint);\r\n    function sin (address) external view returns (uint);\r\n    function heal(uint256) external;\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ncontract Vow is LibNote {\r\n    // --- Auth ---\r\n    mapping (address =\u003E uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \u0022Vow/not-live\u0022); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \u0022Vow/not-authorized\u0022);\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLikeVow public vat;\r\n    FlapLike public flapper;\r\n    FlopLike public flopper;\r\n\r\n    mapping (uint256 =\u003E uint256) public sin; // debt queue\r\n    uint256 public Sin;   // queued debt          [rad]\r\n    uint256 public Ash;   // on-auction debt      [rad]\r\n\r\n    uint256 public wait;  // flop delay\r\n    uint256 public dump;  // flop initial lot size  [wad]\r\n    uint256 public sump;  // flop fixed bid size    [rad]\r\n\r\n    uint256 public bump;  // flap fixed lot size    [rad]\r\n    uint256 public hump;  // surplus buffer       [rad]\r\n\r\n    uint256 public live;\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address flapper_, address flopper_) public {\r\n        wards[msg.sender] = 1;\r\n        vat     = VatLikeVow(vat_);\r\n        flapper = FlapLike(flapper_);\r\n        flopper = FlopLike(flopper_);\r\n        vat.hope(flapper_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x \u003C= y ? x : y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \u0022wait\u0022) wait = data;\r\n        else if (what == \u0022bump\u0022) bump = data;\r\n        else if (what == \u0022sump\u0022) sump = data;\r\n        else if (what == \u0022dump\u0022) dump = data;\r\n        else if (what == \u0022hump\u0022) hump = data;\r\n        else revert(\u0022Vow/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \u0022flapper\u0022) {\r\n            vat.nope(address(flapper));\r\n            flapper = FlapLike(data);\r\n            vat.hope(data);\r\n        }\r\n        else if (what == \u0022flopper\u0022) flopper = FlopLike(data);\r\n        else revert(\u0022Vow/file-unrecognized-param\u0022);\r\n    }\r\n\r\n    // Push to debt-queue\r\n    function fess(uint tab) external note auth {\r\n        sin[now] = add(sin[now], tab);\r\n        Sin = add(Sin, tab);\r\n    }\r\n    // Pop from debt-queue\r\n    function flog(uint era) external note {\r\n        require(add(era, wait) \u003C= now, \u0022Vow/wait-not-finished\u0022);\r\n        Sin = sub(Sin, sin[era]);\r\n        sin[era] = 0;\r\n    }\r\n\r\n    // Debt settlement\r\n    function heal(uint rad) external note {\r\n        require(rad \u003C= vat.dai(address(this)), \u0022Vow/insufficient-surplus\u0022);\r\n        require(rad \u003C= sub(sub(vat.sin(address(this)), Sin), Ash), \u0022Vow/insufficient-debt\u0022);\r\n        vat.heal(rad);\r\n    }\r\n    function kiss(uint rad) external note {\r\n        require(rad \u003C= Ash, \u0022Vow/not-enough-ash\u0022);\r\n        require(rad \u003C= vat.dai(address(this)), \u0022Vow/insufficient-surplus\u0022);\r\n        Ash = sub(Ash, rad);\r\n        vat.heal(rad);\r\n    }\r\n\r\n    // Debt auction\r\n    function flop() external note returns (uint id) {\r\n        require(sump \u003C= sub(sub(vat.sin(address(this)), Sin), Ash), \u0022Vow/insufficient-debt\u0022);\r\n        require(vat.dai(address(this)) == 0, \u0022Vow/surplus-not-zero\u0022);\r\n        Ash = add(Ash, sump);\r\n        id = flopper.kick(address(this), dump, sump);\r\n    }\r\n    // Surplus auction\r\n    function flap() external note returns (uint id) {\r\n        require(vat.dai(address(this)) \u003E= add(add(vat.sin(address(this)), bump), hump), \u0022Vow/insufficient-surplus\u0022);\r\n        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \u0022Vow/debt-not-zero\u0022);\r\n        id = flapper.kick(bump, 0);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        require(live == 1, \u0022Vow/not-live\u0022);\r\n        live = 0;\r\n        Sin = 0;\r\n        Ash = 0;\r\n        flapper.cage(vat.dai(address(flapper)));\r\n        flopper.cage();\r\n        vat.heal(min(vat.dai(address(this)), vat.sin(address(this))));\r\n    }\r\n}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract VatFab\u0022,\u0022name\u0022:\u0022vatFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract JugFab\u0022,\u0022name\u0022:\u0022jugFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract VowFab\u0022,\u0022name\u0022:\u0022vowFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract CatFab\u0022,\u0022name\u0022:\u0022catFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract DaiFab\u0022,\u0022name\u0022:\u0022daiFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract DaiJoinFab\u0022,\u0022name\u0022:\u0022daiJoinFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract FlapFab\u0022,\u0022name\u0022:\u0022flapFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract FlopFab\u0022,\u0022name\u0022:\u0022flopFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract FlipFab\u0022,\u0022name\u0022:\u0022flipFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract SpotFab\u0022,\u0022name\u0022:\u0022spotFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract PotFab\u0022,\u0022name\u0022:\u0022potFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract EndFab\u0022,\u0022name\u0022:\u0022endFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract ESMFab\u0022,\u0022name\u0022:\u0022esmFab_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract PauseFab\u0022,\u0022name\u0022:\u0022pauseFab_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022authority\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetAuthority\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetOwner\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022authority\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Cat\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022catFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract CatFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dai\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Dai\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022daiFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DaiFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022daiJoin\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DaiJoin\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022daiJoinFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DaiJoinFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022gov\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022deployAuctions\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022ilk\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022join\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022pip\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022deployCollateral\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022chainId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deployDai\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deployLiquidator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delay\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022authority\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022deployPause\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022gov\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022pit\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022min\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deployShutdown\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deployTaxation\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deployVat\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022end\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract End\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022endFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract EndFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022esm\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ESM\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022esmFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ESMFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022flap\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Flapper\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022flapFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract FlapFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022flipFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract FlipFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022flop\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Flopper\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022flopFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract FlopFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022ilks\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Flipper\u0022,\u0022name\u0022:\u0022flip\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022join\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022jug\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Jug\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022jugFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract JugFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pause\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DSPause\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pauseFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract PauseFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pot\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Pot\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022potFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract PotFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022releaseAuth\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022ilk\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022releaseAuthFlip\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022authority_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAuthority\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spotFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract SpotFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022spotter\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Spotter\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022step\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022vat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Vat\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022vatFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract VatFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022vow\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract Vow\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022vowFab\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract VowFab\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"DssDeploy","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000403689148fa98a5a6fdcc0b984914ae968d788e500000000000000000000000045f0a929889ec8cc2d5b8cd79ab55e3279945cde00000000000000000000000068322ca1a9aeb8c1d610b5fc8a8920aa0fba423b000000000000000000000000a9ee75d81d78c36c4163004e6cc7a988eec9433e000000000000000000000000b5b06a16621616875a6c2637948bf98ea57c58fa00000000000000000000000064a84e558192dd025f3a96775fee8fb530f27177000000000000000000000000d27a5f3416d8791fc238c148c93630d9e3c882e5000000000000000000000000c41c4759f67ff54c7a7314d155f40fc6504f5d28000000000000000000000000bab4fbea257abbfe84f4588d4eedc43656e46fc5000000000000000000000000dedd12bcb045c02b2fe11031c2b269bcde4574100000000000000000000000001a5ee7c64cf874c735968e3a42fa13f1c03427f9000000000000000000000000fd34e2c588a519f173d54be539a56fed4830ba530000000000000000000000002e278c5fb9231581f4284a253cc5728b6acd372d00000000000000000000000084f2b4648990d93c0f478d5d82d3c38d98a4ee91","Library":"","SwarmSource":"bzzr://cfe73dd1e4d37386716e919548d8dae4a01254c98e363a63f2b57d562975ce38"}]