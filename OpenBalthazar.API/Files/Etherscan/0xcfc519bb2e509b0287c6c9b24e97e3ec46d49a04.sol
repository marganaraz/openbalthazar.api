[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract OtcInterface {\r\n    function getOffer(uint id) external view returns (uint, ERC20, uint, ERC20);\r\n    function getBestOffer(ERC20 sellGem, ERC20 buyGem) external view returns(uint);\r\n    function getWorseOffer(uint id) external view returns(uint);\r\n    function take(bytes32 id, uint128 maxTakeAmount) external;\r\n}\r\n\r\n\r\ncontract WethInterface is ERC20 {\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\n\r\ncontract TradeEth2DAI {\r\n    \r\n    address public admin;\r\n    uint constant INVALID_ID = uint(-1);\r\n    uint constant internal COMMON_DECIMALS = 18;\r\n    OtcInterface public otc = OtcInterface(0x39755357759cE0d7f32dC8dC45414CCa409AE24e);\r\n    WethInterface public wethToken = WethInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    ERC20 public DAIToken = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint constant BASE_TAKE_ORDERS = 2;\r\n    uint constant MAX_TAKE_ORDERS = 5;\r\n    uint constant BASE_TRAVERSE_ORDERS = 7;\r\n    uint constant MAX_TRAVERSE_ORDERS = 20;\r\n    uint constant NUM_TAKE_ORDERS_FACTOR = 3 * 10 ** 18; // 3 Eth\r\n    uint constant NUM_TRAVERSE_ORDERS_FACTOR = 10 ** 18; // 1 Eth\r\n    uint constant TAKE_ORDER_GAS_COST = 100000; //according to off chain checks.\r\n    \r\n    constructor() public {\r\n        require(wethToken.decimals() == COMMON_DECIMALS);\r\n    \r\n        admin = msg.sender;\r\n\r\n        require(DAIToken.approve(address(otc), 2**255));\r\n        require(wethToken.approve(address(otc), 2**255));\r\n    }\r\n\r\n    function() external payable {\r\n        \r\n    }\r\n    \r\n    event TradeExecute(\r\n        address indexed sender,\r\n        bool isEthToDai,\r\n        uint srcAmount,\r\n        uint destAmount,\r\n        address destAddress\r\n    );\r\n\r\n    function tradeEthVsDAI(\r\n        uint numTakeOrders,\r\n        uint numTraverseOrders,\r\n        bool isEthToDai,\r\n        uint srcAmount\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        address payable dstAddress = msg.sender;\r\n        uint userTotalDestAmount;\r\n        \r\n        if (isEthToDai) {\r\n            require(msg.value == srcAmount);\r\n            wethToken.deposit.value(msg.value)();\r\n            userTotalDestAmount = takeOrders(wethToken, DAIToken, srcAmount, numTakeOrders, numTraverseOrders);\r\n            require(DAIToken.transfer(dstAddress, userTotalDestAmount));\r\n        } else {\r\n            //Dai To Eth\r\n            require(DAIToken.transferFrom(msg.sender, address(this), srcAmount));\r\n            userTotalDestAmount = takeOrders(DAIToken, wethToken, srcAmount, numTakeOrders, numTraverseOrders);\r\n            wethToken.withdraw(userTotalDestAmount);    \r\n            dstAddress.transfer(userTotalDestAmount);\r\n        }\r\n\r\n        emit TradeExecute(msg.sender, isEthToDai, srcAmount, userTotalDestAmount, dstAddress);\r\n    }\r\n\r\n    function getNextOffer(uint prevOfferId, bool isEthToDai) public view\r\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount) \r\n    {\r\n        uint prevId = prevOfferId == 0 ? INVALID_ID : prevOfferId;       \r\n        \r\n        if(isEthToDai) {\r\n            // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n            return(getNextBestOffer(DAIToken, wethToken, 1, prevId));\r\n        }\r\n        \r\n        // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n        return(getNextBestOffer(wethToken, DAIToken, 1, prevId));\r\n    }\r\n    \r\n    \r\n    struct OfferDescriptor {\r\n        uint payAmount;\r\n        uint buyAmount;\r\n        uint id;\r\n    }\r\n    \r\n    function showBestOffers(bool isEthToDai, uint srcAmount) public \r\n        returns(uint totalDestAmount, uint numOffers, uint [] memory offerIds) \r\n    {\r\n        OfferDescriptor [] memory offers;\r\n        (totalDestAmount, numOffers, , offers) = findBestOffers(isEthToDai, srcAmount);\r\n        \r\n        offerIds = new uint[](offers.length);\r\n        \r\n        for (uint i; i \u003C offers.length; i\u002B\u002B) {\r\n            offerIds[i] = offers[i].id;\r\n        }\r\n    }\r\n    \r\n    function findBestOffers(bool isEthToDai, uint srcAmount) internal \r\n        returns(uint totalDestAmount, uint numTaken, uint numTraversed, OfferDescriptor [] memory offers) \r\n    {\r\n        uint remainingSrcAmount = srcAmount;\r\n        offers = new OfferDescriptor[](MAX_TRAVERSE_ORDERS);\r\n        uint minTakeAmount = 5 ** 18; // 0.5 eth\r\n        uint remainingTakeOrders;\r\n        uint maxTraversedOrders;\r\n        \r\n        ERC20 srcToken = isEthToDai ? wethToken : DAIToken;\r\n        ERC20 dstToken = isEthToDai ? DAIToken : wethToken;\r\n        uint thisOffer;\r\n        \r\n        numTraversed = 1;\r\n        \r\n        // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n        offers[0].id = otc.getBestOffer(dstToken, srcToken);\r\n        (offers[0].payAmount, , offers[0].buyAmount, ) = otc.getOffer(offers[0].id);\r\n        \r\n        (remainingTakeOrders, maxTraversedOrders) = \r\n            calcOfferParams(true, offers[0].payAmount, offers[0].buyAmount, srcAmount);\r\n        \r\n        for (uint i = 0; i \u003C maxTraversedOrders; \u002B\u002Bi) {\r\n            thisOffer = numTaken;\r\n            \r\n            if (offers[numTaken].payAmount \u003E remainingSrcAmount) {\r\n                offers[numTaken].buyAmount = offers[numTaken].payAmount * remainingSrcAmount / offers[numTaken].buyAmount;\r\n                offers[numTaken].payAmount = remainingSrcAmount;\r\n                totalDestAmount \u002B= offers[numTaken].buyAmount;\r\n                \u002B\u002BnumTaken;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else {\r\n                if (remainingTakeOrders \u003E 1 \u0026\u0026 \r\n                    minTakeAmount \u003C (isEthToDai ? offers[numTaken].payAmount : offers[numTaken].buyAmount)) \r\n                {\r\n                    totalDestAmount \u002B= offers[numTaken].buyAmount;\r\n                    remainingSrcAmount -= offers[numTaken].payAmount;\r\n                    --remainingTakeOrders;\r\n                    \u002B\u002BnumTaken;\r\n                }\r\n            }\r\n\r\n            offers[numTaken].id = otc.getWorseOffer(offers[thisOffer].id);\r\n            (offers[numTaken].payAmount, , offers[numTaken].buyAmount, ) = otc.getOffer(offers[numTaken].id);\r\n        \r\n            \u002B\u002BnumTraversed;\r\n        }\r\n        \r\n        if (remainingSrcAmount \u003E 0) totalDestAmount = 0;\r\n    }\r\n    \r\n    // function takeBestOffers(bool isEthToDai, uint srcAmount) public returns(uint totalDestAmount) {\r\n        \r\n    //     uint remainingSrcAmount = srcAmount;\r\n    //     uint destAmount;\r\n    //     OfferDescriptor [] memory offers;\r\n    //     offers = new OfferDescriptor[](MAX_TRAVERSE_ORDERS);\r\n        \r\n    //     uint remainingTakeOrders;\r\n    //     uint maxTraversedOrders;\r\n    //     uint takeCost = tx.gasprice * TAKE_ORDER_GAS_COST;\r\n        \r\n    //     // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n    //     uint offerId = otc.getBestOffer(dstToken, srcToken);\r\n    //     (offers[0].payAmount, , offers[0].buyAmount, ) = otc.getOffer(offerId);\r\n        \r\n    //     (remainingTakeOrders, maxTraversedOrders) = \r\n    //         calcOfferParams(true, offers[0].payAmount, offers[0].buyAmount, srcAmount);\r\n        \r\n    //     for (uint i = 0; i \u003C MAX_TRAVERSE_ORDERS \u0026\u0026 remainingSrcAmount \u003E 0; \u002B\u002Bi) {\r\n\r\n    //         if (offers[i].payAmount \u003E remainingSrcAmount) {\r\n    //             if (!calcOnly) totalDestAmount \u002B= takeMatchingOffer(remainingSrcAmount, offerId);\r\n    //             else totalDestAmount \u002B= remainingSrcAmount * offers[i].payAmount / offers[i].buyAmount;\r\n    //             break;\r\n    //         } else {\r\n    //             offerId = otc.getWorseOffer(offerId);\r\n    //             require(offerId \u003E 0);\r\n    //             (offers[i \u002B 1].payAmount, , offers[i \u002B 1].buyAmount, ) = otc.getOffer(offerId);\r\n                \r\n    //             if (remainingTakeOrders \u003E 1) {\r\n    //                 //is it very small?\r\n    //                 if( (offers[i].payAmount \u003E srcAmount / 2) || \r\n    //                     (remainingTakeOrders \u003E 2 \u0026\u0026 offers[i].payAmount \u003E remainingSrcAmount / 2)) {\r\n    //                         destAmount = offers[i].buyAmount;\r\n    //                 } else {\r\n    //                     if (takeCost \u003C calcSkipCost(srcToken, dstToken, offers[i].payAmount, offers[i].buyAmount, \r\n    //                         offers[i \u002B 1].payAmount, offers[i \u002B 1].buyAmount)) {\r\n    //                             destAmount = offers[i].buyAmount;\r\n    //                     }\r\n    //                 }                \r\n    //             }\r\n    //         }\r\n            \r\n    //         if (destAmount \u003E 0) {\r\n    //             if (!calcOnly) destAmount = takeMatchingOffer(offers[i].payAmount, offerId);\r\n    //             remainingSrcAmount -= offers[i].payAmount;\r\n    //             totalDestAmount \u002B= destAmount;\r\n    //             destAmount = 0;\r\n    //         }\r\n    //     }\r\n    // }\r\n    \r\n    function calcOfferParams(bool isSrcEth, uint payAmount, uint buyAmount, uint srcAmount) internal \r\n        returns(uint maxTraversedOrders, uint maxTakeOrders) \r\n    {\r\n        uint calcAmount = isSrcEth ? srcAmount : srcAmount * buyAmount / payAmount; \r\n        \r\n        maxTakeOrders = BASE_TAKE_ORDERS \u002B calcAmount / NUM_TAKE_ORDERS_FACTOR;\r\n        maxTakeOrders = maxTakeOrders \u003E MAX_TAKE_ORDERS ? MAX_TAKE_ORDERS : maxTakeOrders;\r\n        \r\n        maxTraversedOrders = BASE_TRAVERSE_ORDERS \u002B calcAmount / NUM_TRAVERSE_ORDERS_FACTOR;            \r\n        maxTraversedOrders = maxTraversedOrders \u003E MAX_TRAVERSE_ORDERS ? MAX_TRAVERSE_ORDERS : maxTraversedOrders;\r\n    }\r\n    \r\n    // function calcSkipCost(ERC20 payToken, ERC20 buyToken, uint pay1, uint buy1, uint pay2, uint buy2) internal \r\n    //     returns (uint skipOrderCost) \r\n    // {\r\n    //     // calcucate skip cost in buyToken\r\n    //     skipOrderCost = buy1 - (pay1 * buy2 / pay2);\r\n        \r\n    //     if (true) { //(buyToken != ETH) {\r\n    //         // calcucate rate with both rate values we have\r\n    //         skipOrderCost = skipOrderCost * (pay1 \u002B pay2) / (buy1 \u002B buy2); \r\n    //     }\r\n    // }\r\n    \r\n    function takeOrders(ERC20 srcToken, ERC20 dstToken, uint srcAmount, uint numTakeOrders, uint numTraverseOrders) \r\n        internal \r\n        returns(uint userTotalDestAmount)\r\n    {\r\n        uint remainingAmount = srcAmount;\r\n        uint destAmount;\r\n        uint offerId = INVALID_ID;\r\n        uint i;\r\n        \r\n        for (i = numTraverseOrders; i \u003E 0; i--) {\r\n            //this loop to see cost of \u0027peeking\u0027 into order\r\n            (offerId, , ) = getNextBestOffer(dstToken, srcToken, remainingAmount / i, offerId);\r\n            \r\n            require(offerId \u003E 0);\r\n        }\r\n        \r\n        for (i = numTakeOrders; i \u003E 0; i--) {\r\n            \r\n            // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n            (offerId, , ) = getNextBestOffer(dstToken, srcToken, remainingAmount / i, offerId);\r\n            \r\n            require(offerId \u003E 0);\r\n            \r\n            destAmount = takeMatchingOffer(remainingAmount / i, offerId);\r\n            userTotalDestAmount \u002B= destAmount;\r\n            remainingAmount -= (remainingAmount / i);\r\n        }\r\n    }\r\n    \r\n    function getNextBestOffer(\r\n        ERC20 offerSellGem,\r\n        ERC20 offerBuyGem,\r\n        uint payAmount,\r\n        uint prevOfferId\r\n    )\r\n        internal\r\n        view\r\n        returns(\r\n            uint offerId,\r\n            uint offerPayAmount,\r\n            uint offerBuyAmount\r\n        )\r\n    {\r\n        if (prevOfferId == INVALID_ID) {\r\n            offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\r\n        } else {\r\n            offerId = otc.getWorseOffer(prevOfferId);\r\n        }\r\n\r\n        (offerPayAmount, , offerBuyAmount, ) = otc.getOffer(offerId);\r\n\r\n        while (payAmount \u003E offerBuyAmount) {\r\n            offerId = otc.getWorseOffer(offerId); // next best offer\r\n            if (offerId == 0) {\r\n                offerId = 0;\r\n                offerPayAmount = 0;\r\n                offerBuyAmount = 0;\r\n                break;\r\n            }\r\n            (offerPayAmount, , offerBuyAmount, ) = otc.getOffer(offerId);\r\n        }\r\n    }\r\n    \r\n    function takeOffer(uint payAmount, uint buyAmount, uint offerId) internal {\r\n        require(payAmount \u003C= MAX_QTY);\r\n        otc.take(bytes32(offerId), uint128(buyAmount));  // Take the portion of the offer that we need\r\n        return;\r\n    }\r\n\r\n    function takeMatchingOffer(\r\n        uint srcAmount, \r\n        uint offerId\r\n    )\r\n        internal\r\n        returns(uint actualDestAmount)\r\n    {\r\n        uint offerPayAmt;\r\n        uint offerBuyAmt;\r\n\r\n        // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\r\n        (offerPayAmt, , offerBuyAmt, ) = otc.getOffer(offerId);\r\n        \r\n        actualDestAmount = srcAmount * offerPayAmt / offerBuyAmt;\r\n\r\n        require(uint128(actualDestAmount) == actualDestAmount);\r\n        otc.take(bytes32(offerId), uint128(actualDestAmount));  // Take the portion of the offer that we need\r\n        return(actualDestAmount);\r\n    }\r\n    \r\n    function getEthToDaiOrders(uint numOrders) public view\r\n        returns(uint [] memory ethPayAmtTokens, uint [] memory daiBuyAmtTokens, uint [] memory rate100KFactor) \r\n    {\r\n        uint offerId = INVALID_ID;\r\n        ethPayAmtTokens = new uint[](numOrders);\r\n        daiBuyAmtTokens = new uint[](numOrders);    \r\n        rate100KFactor = new uint[](numOrders);\r\n        \r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n        \r\n        for (uint i = 0; i \u003C numOrders; i\u002B\u002B) {\r\n            \r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(DAIToken, wethToken, 1, offerId);\r\n            \r\n            ethPayAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            daiBuyAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            rate100KFactor[i] = offerBuyAmt * 100000 / offerPayAmt;\r\n            \r\n            if(offerId == 0) break;\r\n        }\r\n        \r\n        return(daiBuyAmtTokens, ethPayAmtTokens, rate100KFactor);\r\n    }\r\n    \r\n    function getDaiToEthOrders(uint numOrders) public view\r\n        returns(uint [] memory daiPayAmtTokens, uint [] memory ethBuyAmtTokens, uint [] memory rateNoFactor)\r\n    {\r\n        uint offerId = INVALID_ID;\r\n        daiPayAmtTokens = new uint[](numOrders);\r\n        ethBuyAmtTokens = new uint[](numOrders);\r\n        rateNoFactor = new uint[](numOrders);\r\n\r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n\r\n        for (uint i = 0; i \u003C numOrders; i\u002B\u002B) {\r\n\r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(wethToken, DAIToken, 1, offerId);\r\n\r\n            daiPayAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            ethBuyAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            rateNoFactor[i] = offerBuyAmt / offerPayAmt;\r\n\r\n            if(offerId == 0) break;\r\n        }\r\n\r\n        return(ethBuyAmtTokens, daiPayAmtTokens, rateNoFactor);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numOrders\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getEthToDaiOrders\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ethPayAmtTokens\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022daiBuyAmtTokens\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022rate100KFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numTakeOrders\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numTraverseOrders\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isEthToDai\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tradeEthVsDAI\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022DAIToken\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022otc\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract OtcInterface\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022wethToken\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract WethInterface\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022prevOfferId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isEthToDai\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022getNextOffer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022offerId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022offerPayAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022offerBuyAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isEthToDai\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022showBestOffers\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalDestAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numOffers\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022offerIds\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022numOrders\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getDaiToEthOrders\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022daiPayAmtTokens\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ethBuyAmtTokens\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022rateNoFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022admin\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isEthToDai\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022destAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022destAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TradeExecute\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"TradeEth2DAI","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://62d2323b70f8dfc2fd9dfe207ec9c3cba7a0d1b4a70448716f463c4c8247ba76"}]