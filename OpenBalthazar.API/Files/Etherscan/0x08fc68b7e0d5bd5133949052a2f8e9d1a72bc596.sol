[{"SourceCode":"// Sources flattened with buidler v1.2.0 https://buidler.dev\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * \u0060interfaceId\u0060. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\nabstract contract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in \u0060owner\u0060\u0027s account.\r\n     */\r\n    function balanceOf(address owner) public view virtual returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by \u0060tokenId\u0060.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - \u0060from\u0060, \u0060to\u0060 cannot be zero.\r\n     * - \u0060tokenId\u0060 must be owned by \u0060from\u0060.\r\n     * - If the caller is not \u0060from\u0060, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual;\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not \u0060from\u0060, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual;\r\n    function approve(address to, uint256 tokenId) public virtual;\r\n    function getApproved(uint256 tokenId) public view virtual returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public virtual;\r\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual;\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view virtual returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view virtual returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\nabstract contract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as \u0060this.onERC721Received.selector\u0060. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called \u0060safeTransferFrom\u0060 function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public virtual returns (bytes4);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, \u0060isContract\u0060 will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. \u0060keccak256(\u0027\u0027)\u0060\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an \u0060address\u0060 into \u0060address payable\u0060. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s \u0060transfer\u0060: sends \u0060amount\u0060 wei to\r\n     * \u0060recipient\u0060, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by \u0060transfer\u0060, making them unable to receive funds via\r\n     * \u0060transfer\u0060. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to \u0060recipient\u0060, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003E= amount, \u0022Address: insufficient balance\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\u0022\u0022);\r\n        require(success, \u0022Address: unable to send value, recipient may have reverted\u0022);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with \u0060using Counters for Counters.Counter;\u0060\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, \u0060increment\u0060 can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying \u0060_value\u0060 is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value \u002B= 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\r\n     */\r\n    mapping(bytes4 =\u003E bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * \u0060interfaceId\u0060. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060interfaceId\u0060 cannot be the ERC165 invalid interface (\u00600xffffffff\u0060).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \u0022ERC165: invalid interface id\u0022);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060\r\n    // which can be also obtained as \u0060IERC721Receiver(0).onERC721Received.selector\u0060\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 =\u003E address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 =\u003E address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address =\u003E Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address =\u003E mapping (address =\u003E bool)) private _operatorApprovals;\r\n\r\n    /*\r\n     *     bytes4(keccak256(\u0027balanceOf(address)\u0027)) == 0x70a08231\r\n     *     bytes4(keccak256(\u0027ownerOf(uint256)\u0027)) == 0x6352211e\r\n     *     bytes4(keccak256(\u0027approve(address,uint256)\u0027)) == 0x095ea7b3\r\n     *     bytes4(keccak256(\u0027getApproved(uint256)\u0027)) == 0x081812fc\r\n     *     bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) == 0xa22cb465\r\n     *     bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) == 0xe985e9c5\r\n     *     bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) == 0x23b872dd\r\n     *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256)\u0027)) == 0x42842e0e\r\n     *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,bytes)\u0027)) == 0xb88d4fde\r\n     *\r\n     *     =\u003E 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        require(owner != address(0), \u0022ERC721: balance query for the zero address\u0022);\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \u0022ERC721: owner query for nonexistent token\u0022);\r\n\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \u0022ERC721: approval to current owner\u0022);\r\n\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \u0022ERC721: approve caller is not owner nor approved for all\u0022\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        require(_exists(tokenId), \u0022ERC721: approved query for nonexistent token\u0022);\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     * @param operator operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \u0022ERC721: approve to caller\u0022);\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner.\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \u0022ERC721: transfer caller is not owner nor approved\u0022);\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \u0022\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the _msgSender() to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \u0022ERC721: transfer caller is not owner nor approved\u0022);\r\n        _safeTransferFrom(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \u0022ERC721: transfer to non ERC721Receiver implementer\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists.\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \u0022ERC721: operator query for nonexistent token\u0022);\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \u0022\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \u0022ERC721: transfer to non ERC721Receiver implementer\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \u0022ERC721: mint to the zero address\u0022);\r\n        require(!_exists(tokenId), \u0022ERC721: token already minted\u0022);\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use {_burn} instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal virtual {\r\n        require(ownerOf(tokenId) == owner, \u0022ERC721: burn of token that is not own\u0022);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ownerOf(tokenId) == from, \u0022ERC721: transfer of token that is not own\u0022);\r\n        require(to != address(0), \u0022ERC721: transfer to the zero address\u0022);\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * This is an internal detail of the \u0060ERC721\u0060 contract and its use is deprecated.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal virtual returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            _msgSender(),\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ));\r\n        if (!success) {\r\n            if (returndata.length \u003E 0) {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0022ERC721: transfer to non ERC721Receiver implementer\u0022);\r\n            }\r\n        } else {\r\n            bytes4 retval = abi.decode(returndata, (bytes4));\r\n            return (retval == _ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when \u0060from\u0060 and \u0060to\u0060 are both non-zero, \u0060from\u0060\u0027s \u0060tokenId\u0060 will be\r\n     * transferred to \u0060to\u0060.\r\n     * - when \u0060from\u0060 is zero, \u0060tokenId\u0060 will be minted for \u0060to\u0060.\r\n     * - when \u0060to\u0060 is zero, \u0060from\u0060\u0027s \u0060tokenId\u0060 will be burned.\r\n     * - \u0060from\u0060 and \u0060to\u0060 are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address =\u003E uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 =\u003E uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 =\u003E uint256) private _allTokensIndex;\r\n\r\n    /*\r\n     *     bytes4(keccak256(\u0027totalSupply()\u0027)) == 0x18160ddd\r\n     *     bytes4(keccak256(\u0027tokenOfOwnerByIndex(address,uint256)\u0027)) == 0x2f745c59\r\n     *     bytes4(keccak256(\u0027tokenByIndex(uint256)\u0027)) == 0x4f6ccce7\r\n     *\r\n     *     =\u003E 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /**\r\n     * @dev Constructor function.\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\r\n        require(index \u003C balanceOf(owner), \u0022ERC721Enumerable: owner index out of bounds\u0022);\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract.\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens.\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\r\n        require(index \u003C totalSupply(), \u0022ERC721Enumerable: global index out of bounds\u0022);\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            // When minting\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (to == address(0)) {\r\n            // When burning\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n            // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n            _ownedTokensIndex[tokenId] = 0;\r\n\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner.\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension\u0027s ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension\u0027s token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension\u0027s ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the \u0060_ownedTokensIndex\u0060 mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from\u0027s tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\r\n        }\r\n\r\n        // Deletes the contents at the last position of the array\r\n        _ownedTokens[from].pop();\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn\u0027t been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension\u0027s token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\r\n\r\n        // Delete the contents at the last position of the array\r\n        _allTokens.pop();\r\n\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721Metadata is IERC721 {\r\n    function name() external view virtual returns (string memory);\r\n    function symbol() external view virtual returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view virtual returns (string memory);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Base URI\r\n    string private _baseURI;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 =\u003E string) private _tokenURIs;\r\n\r\n    /*\r\n     *     bytes4(keccak256(\u0027name()\u0027)) == 0x06fdde03\r\n     *     bytes4(keccak256(\u0027symbol()\u0027)) == 0x95d89b41\r\n     *     bytes4(keccak256(\u0027tokenURI(uint256)\u0027)) == 0xc87b56dd\r\n     *\r\n     *     =\u003E 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name.\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol.\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI for a given token ID. May return an empty string.\r\n     *\r\n     * If the token\u0027s URI is non-empty and a base URI was set (via\r\n     * {_setBaseURI}), it will be added to the token ID\u0027s URI as a prefix.\r\n     *\r\n     * Reverts if the token ID does not exist.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view override returns (string memory) {\r\n        require(_exists(tokenId), \u0022ERC721Metadata: URI query for nonexistent token\u0022);\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n\r\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\r\n        if (bytes(_tokenURI).length == 0) {\r\n            return \u0022\u0022;\r\n        } else {\r\n            // abi.encodePacked is being used to concatenate strings\r\n            return string(abi.encodePacked(_baseURI, _tokenURI));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token.\r\n     *\r\n     * Reverts if the token ID does not exist.\r\n     *\r\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\r\n     * \u0060http://api.myproject.com/token/\u003Cid\u003E\u0060), use {_setBaseURI} to store\r\n     * it and save gas.\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(tokenId), \u0022ERC721Metadata: URI set of nonexistent token\u0022);\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the base URI for all token IDs. It is\r\n     * automatically added as a prefix to the value returned in {tokenURI}.\r\n     *\r\n     * _Available since v2.5.0._\r\n     */\r\n    function _setBaseURI(string memory baseURI) internal virtual {\r\n        _baseURI = baseURI;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\r\n    * automatically added as a preffix in {tokenURI} to each token\u0027s URI, when\r\n    * they are non-empty.\r\n    *\r\n    * _Available since v2.5.0._\r\n    */\r\n    function baseURI() external view returns (string memory) {\r\n        return _baseURI;\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (to == address(0)) { // When burning tokens\r\n            // Clear metadata (if any)\r\n            if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n                delete _tokenURIs[tokenId];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Full.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Full is ERC721Enumerable, ERC721Metadata {\r\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) { }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\r\n        virtual\r\n        override(ERC721Enumerable, ERC721Metadata)\r\n        internal\r\n    {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address =\u003E bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \u0022Roles: account already has role\u0022);\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account\u0027s access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \u0022Roles: account does not have role\u0022);\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \u0022Roles: account is the zero address\u0022);\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/math/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003E= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a \u002B b) / 2 can overflow, so we distribute\r\n        return (a / 2) \u002B (b / 2) \u002B ((a % 2 \u002B b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Greeter.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n    /// @title X5Badges\r\n    /// @author Original from Jason Haas \u003Cjasonrhaas@gmail.com\u003E modified by Youssef Khouidi, Scott Stevenson for the X5Engine.com and Web3vm.com projects\r\n    /// @notice X5Badges ERC721 interface for minting, cloning, and transferring X5Badges tokens.\r\n    /// Solidity Code was forked and modified from Gitcoin Kudos Token https://github.com/gitcoinco/Kudos721Contract\r\n    /// Licensed under GNU GENERAL PUBLIC LICENSE (GPL3)\r\n\r\ncontract X5Badges is ERC721Full(\u0022X5Badges Token\u0022, \u0022X5B\u0022), Ownable {\r\n    using SafeMath for uint256;\r\n    using Roles for Roles.Role; // Using the Roles library\r\n    Roles.Role moderators; // Stores the moderator Roles\r\n    address payable xowner = 0xD277a99c0d08DED3bDB253024bfF81E41496465c;\r\n    address payable owner2 = 0x00a2Ddfa736214563CEa9AEf5100f2e90c402918;\r\n    address payable reserveAccount = 0x7beAd6F7dB10Ae70090aee1742F5f9Af83D76784;\r\n\r\n    struct X5Badge {\r\n        uint256 priceFinney;\r\n        uint256 numClonesAllowed;\r\n        uint256 numClonesInWild;\r\n        uint256 clonedFromId;\r\n    }\r\n\r\n    X5Badge[] public x5badges;\r\n    uint256 public cloneFeePercentage = 10;\r\n    bool public isMintable = true;\r\n    // address payable xowner = payable(Ownable.owner());\r\n\r\n    modifier mintable {\r\n        require(\r\n            isMintable == true,\r\n            \u0022New x5badges are no longer mintable on this contract.\u0022\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        // If the array is new, skip over the first index.\r\n        if (x5badges.length == 0) {\r\n            X5Badge memory _dummyX5Badge = X5Badge({priceFinney: 0,numClonesAllowed: 0, numClonesInWild: 0,\r\n                                           clonedFromId: 0\r\n                                           });\r\n            x5badges.push(_dummyX5Badge);\r\n        }\r\n    }\r\n\r\n    function addModRoles(address [] memory _moderators) public onlyOwner {\r\n        for(uint i=0; i\u003C _moderators.length; i\u002B\u002B)\r\n        {\r\n            moderators.add(_moderators[i]);\r\n        }\r\n    }\r\n\r\n    function addOneModRole(address _moderator) public onlyOwner {\r\n        moderators.add(_moderator);\r\n    }\r\n\r\n    function removeOneModRole(address _moderator) public onlyOwner {\r\n        moderators.remove(_moderator);\r\n    }\r\n\r\n   function isMod() public view returns (bool){\r\n       return moderators.has(msg.sender);\r\n    }\r\n\r\n    /// @dev mint(): Mint a new Gen0 X5Badges.  These are the tokens that other X5Badges will be \u0022cloned from\u0022.\r\n    /// @param _to Address to mint to.\r\n    /// @param _priceFinney Price of the X5Badges in Finney.\r\n    /// @param _numClonesAllowed Maximum number of times this X5Badges is allowed to be cloned.\r\n    /// @param _tokenURI A URL to the JSON file containing the metadata for the X5Badges.  See metadata.json for an example.\r\n    /// @return tokenId the tokenId of the X5Badges that has been minted.  Note that in a transaction only the tx_hash is returned.\r\n    function mint(address _to, uint256 _priceFinney, uint256 _numClonesAllowed, string memory _tokenURI) public mintable returns (uint256 tokenId) {\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n\r\n        X5Badge memory _x5badge = X5Badge({priceFinney: _priceFinney, numClonesAllowed: _numClonesAllowed,\r\n                                  numClonesInWild: 0, clonedFromId: 0\r\n                                  });\r\n        // The new x5badge is pushed onto the array and minted\r\n        // Note that Solidity uses 0 as a default value when an item is not found in a mapping.\r\n\r\n        x5badges.push(_x5badge);\r\n        tokenId = x5badges.length - 1;\r\n        x5badges[tokenId].clonedFromId = tokenId;\r\n\r\n        _mint(_to, tokenId);\r\n        _setTokenURI(tokenId, _tokenURI);\r\n\r\n    }\r\n\r\n    /// @dev clone(): Clone a new X5Badges from a Gen0 X5Badges.\r\n    /// @param _to The address to clone to.\r\n    /// @param _tokenId The token id of the X5Badges to clone and transfer.\r\n    /// @param _numClonesRequested Number of clones to generate.\r\n    function clone(address _to, uint256  _tokenId, uint256 _numClonesRequested) public payable mintable {\r\n\r\n        // https://medium.com/swlh/understanding-ownership-and-role-based-access-with-solidity-and-open-zeppelin-dbd096e4bd99\r\n        // Grab existing X5Badge blueprint\r\n        X5Badge memory _x5badge = x5badges[_tokenId];\r\n        uint256 cloningCost  = _x5badge.priceFinney * 10**15 * _numClonesRequested;\r\n        require(\r\n            _x5badge.numClonesInWild \u002B _numClonesRequested \u003C= _x5badge.numClonesAllowed,\r\n            \u0022The number of X5Badges clones requested exceeds the number of clones allowed.\u0022);\r\n        require(\r\n            msg.value \u003E= cloningCost,\r\n            \u0022Not enough Wei to pay for the X5Badges clones.\u0022);\r\n\r\n        // Pay the contract owner\r\n\r\n        // reserve account to cover overhead and operating expenses\r\n        uint256 reserveCut = (cloningCost.mul(20)).div(100);\r\n        reserveAccount.transfer(reserveCut);\r\n\r\n        // xowner portion of proceeds\r\n        uint256 ownerCut = (cloningCost.mul(48)).div(100);\r\n        xowner.transfer(ownerCut);\r\n\r\n        // owner2 portion of proceeds\r\n        uint256 owner2Cut = (cloningCost.mul(32)).div(100);\r\n        owner2.transfer(owner2Cut);\r\n\r\n        // Update original x5badge struct in the array\r\n        _x5badge.numClonesInWild \u002B= _numClonesRequested;\r\n        x5badges[_tokenId] = _x5badge;\r\n\r\n        // Create new x5badge, don\u0027t let it be cloned\r\n        for (uint i = 0; i \u003C _numClonesRequested; i\u002B\u002B) {\r\n            X5Badge memory _newX5Badge;\r\n            _newX5Badge.priceFinney = _x5badge.priceFinney;\r\n            _newX5Badge.numClonesAllowed = 0;\r\n            _newX5Badge.numClonesInWild = 0;\r\n            _newX5Badge.clonedFromId = _tokenId;\r\n\r\n            // Note that Solidity uses 0 as a default value when an item is not found in a mapping.\r\n            x5badges.push(_newX5Badge);\r\n            uint256 newTokenId = x5badges.length-1;\r\n\r\n            // Mint the new x5badges to the _to account\r\n            _mint(_to, newTokenId);\r\n\r\n            // Use the same tokenURI metadata from the Gen0 X5Badges\r\n            string memory _tokenURI = this.tokenURI(_tokenId);\r\n            _setTokenURI(newTokenId, _tokenURI);\r\n        }\r\n        // Return the any leftover ETH to the cloningCost\r\n        msg.sender.transfer( msg.value - cloningCost );\r\n    }\r\n\r\n\r\n    /// @dev burn(): Burn X5Badges token.\r\n    /// @param _owner The owner address of the token to burn.\r\n    /// @param _tokenId The X5Badges ID to be burned.\r\n    function burn(address _owner, uint256 _tokenId) public {\r\n\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n\r\n        X5Badge memory _x5badge = x5badges[_tokenId];\r\n        uint256 gen0Id = _x5badge.clonedFromId;\r\n        if (_tokenId != gen0Id) {\r\n            X5Badge memory _gen0X5Badge = x5badges[gen0Id];\r\n            _gen0X5Badge.numClonesInWild -= 1;\r\n            x5badges[gen0Id] = _gen0X5Badge;\r\n        }\r\n        delete x5badges[_tokenId];\r\n        _burn(_owner, _tokenId);\r\n    }\r\n\r\n    /// @dev setCloneFeePercentage(): Update the X5Badges clone fee percentage.  Upon cloning a new x5badges,\r\n    ///                               cloneFeePercentage will go to the contract owner, and\r\n    ///                               (100 - cloneFeePercentage) will go to the Gen0 X5Badges owner.\r\n    /// @param _cloneFeePercentage The percentage fee between 0 and 100.\r\n    function setCloneFeePercentage(uint256 _cloneFeePercentage) public {\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n        require(\r\n            _cloneFeePercentage \u003E= 0 \u0026\u0026 _cloneFeePercentage \u003C= 100,\r\n            \u0022Invalid range for cloneFeePercentage.  Must be between 0 and 100.\u0022);\r\n        cloneFeePercentage = _cloneFeePercentage;\r\n    }\r\n\r\n    /// @dev setMintable(): set the isMintable public variable.  When set to \u0060false\u0060, no new \r\n    ///                     x5badges are allowed to be minted or cloned.  However, all of already\r\n    ///                     existing x5badges will remain unchanged.\r\n    /// @param _isMintable flag for the mintable function modifier.\r\n    function setMintable(bool _isMintable) public {\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n        isMintable = _isMintable;\r\n    }\r\n\r\n    /// @dev setPrice(): Update the X5Badges listing price.\r\n    /// @param _tokenId The X5Badges Id.\r\n    /// @param _newPriceFinney The new price of the X5Badges.\r\n    function setPrice(uint256 _tokenId, uint256 _newPriceFinney) public {\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n        X5Badge memory _x5badge = x5badges[_tokenId];\r\n\r\n        _x5badge.priceFinney = _newPriceFinney;\r\n        x5badges[_tokenId] = _x5badge;\r\n    }\r\n\r\n    /// @dev setTokenURI(): Set an existing token URI.\r\n    /// @param _tokenId The token id.\r\n    /// @param _tokenURI The tokenURI string.  Typically this will be a link to a json file on IPFS.\r\n    function setTokenURI(uint256 _tokenId, string memory _tokenURI) public {\r\n        require(moderators.has(msg.sender) || Ownable.isOwner(), \u0022USer does not have Moderator role or is not Owner\u0022);\r\n        _setTokenURI(_tokenId, _tokenURI);\r\n    }\r\n\r\n    function getX5BadgesById(uint256 _tokenId) view public returns (uint256 priceFinney,\r\n                                                                uint256 numClonesAllowed,\r\n                                                                uint256 numClonesInWild,\r\n                                                                uint256 clonedFromId\r\n                                                                )\r\n    {\r\n        X5Badge memory _x5badge = x5badges[_tokenId];\r\n\r\n        priceFinney = _x5badge.priceFinney;\r\n        numClonesAllowed = _x5badge.numClonesAllowed;\r\n        numClonesInWild = _x5badge.numClonesInWild;\r\n        clonedFromId = _x5badge.clonedFromId;\r\n    }\r\n\r\n    /// @dev getNumClonesInWild(): Return a X5Badges struct/array given a X5Badges Id. \r\n    /// @param _tokenId The X5Badges Id.\r\n    /// @return numClonesInWild the number of cloes in the wild\r\n    function getNumClonesInWild(uint256 _tokenId) view public returns (uint256 numClonesInWild)\r\n    {   \r\n        X5Badge memory _x5badge = x5badges[_tokenId];\r\n\r\n        numClonesInWild = _x5badge.numClonesInWild;\r\n    }\r\n\r\n    /// @dev getLatestId(): Returns the newest X5Badges Id in the x5badges array.\r\n    /// @return tokenId the latest x5badges id.\r\n    function getLatestId() view public returns (uint256 tokenId)\r\n    {\r\n        if (x5badges.length == 0) {\r\n            tokenId = 0;\r\n        } else {\r\n            tokenId = x5badges.length - 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/ERC1046/ERC20Metadata.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC-1047 Token Metadata\r\n * @dev See https://eips.ethereum.org/EIPS/eip-1046\r\n * @dev {tokenURI} must respond with a URI that implements https://eips.ethereum.org/EIPS/eip-1047\r\n */\r\ncontract ERC20Metadata {\r\n    string private _tokenURI;\r\n\r\n    constructor (string memory tokenURI_) public {\r\n        _setTokenURI(tokenURI_);\r\n    }\r\n\r\n    function tokenURI() external view returns (string memory) {\r\n        return _tokenURI;\r\n    }\r\n\r\n    function _setTokenURI(string memory tokenURI_) internal virtual {\r\n        _tokenURI = tokenURI_;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/Arrays.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to array types.\r\n */\r\nlibrary Arrays {\r\n   /**\r\n     * @dev Searches a sorted \u0060array\u0060 and returns the first index that contains\r\n     * a value greater or equal to \u0060element\u0060. If no such index exists (i.e. all\r\n     * values in the array are strictly less than \u0060element\u0060), the array length is\r\n     * returned. Time complexity O(log n).\r\n     *\r\n     * \u0060array\u0060 is expected to be sorted in ascending order, and to contain no\r\n     * repeated elements.\r\n     */\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        if (array.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        while (low \u003C high) {\r\n            uint256 mid = Math.average(low, high);\r\n\r\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n            // because Math.average rounds down (it does integer division with truncation).\r\n            if (array[mid] \u003E element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid \u002B 1;\r\n            }\r\n        }\r\n\r\n        // At this point \u0060low\u0060 is the exclusive upper bound. We will return the inclusive upper bound.\r\n        if (low \u003E 0 \u0026\u0026 array[low - 1] == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003E uint256) private _balances;\r\n\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - the caller must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     * - the caller must have allowance for \u0060sender\u0060\u0027s tokens of at least\r\n     * \u0060amount\u0060.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \u0022ERC20: transfer amount exceeds allowance\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 must have allowance for the caller of at least\r\n     * \u0060subtractedValue\u0060.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \u0022ERC20: decreased allowance below zero\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060sender\u0060 cannot be the zero address.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \u0022ERC20: transfer from the zero address\u0022);\r\n        require(recipient != address(0), \u0022ERC20: transfer to the zero address\u0022);\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \u0022ERC20: transfer amount exceeds balance\u0022);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060to\u0060 cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \u0022ERC20: mint to the zero address\u0022);\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \u0022ERC20: burn from the zero address\u0022);\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \u0022ERC20: burn amount exceeds balance\u0022);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\r\n     *\r\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060owner\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \u0022ERC20: approve from the zero address\u0022);\r\n        require(spender != address(0), \u0022ERC20: approve to the zero address\u0022);\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal virtual {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \u0022ERC20: burn amount exceeds allowance\u0022));\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when \u0060from\u0060 and \u0060to\u0060 are both non-zero, \u0060amount\u0060 of \u0060from\u0060\u0027s tokens\r\n     * will be to transferred to \u0060to\u0060.\r\n     * - when \u0060from\u0060 is zero, \u0060amount\u0060 tokens will be minted for \u0060to\u0060.\r\n     * - when \u0060to\u0060 is zero, \u0060amount\u0060 of \u0060from\u0060\u0027s tokens will be burned.\r\n     * - \u0060from\u0060 and \u0060to\u0060 are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/ERC20Snapshot.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 token with snapshots.\r\n * @dev Inspired by Jordi Baylina\u0027s\r\n * https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol[MiniMeToken]\r\n * to record historical balances.\r\n *\r\n * When a snapshot is made, the balances and total supply at the time of the snapshot are recorded for later\r\n * access.\r\n *\r\n * To make a snapshot, call the {snapshot} function, which will emit the {Snapshot} event and return a snapshot id.\r\n * To get the total supply from a snapshot, call the function {totalSupplyAt} with the snapshot id.\r\n * To get the balance of an account from a snapshot, call the {balanceOfAt} function with the snapshot id and the\r\n * account address.\r\n * @author Validity Labs AG \u003Cinfo@validitylabs.org\u003E\r\n */\r\ncontract ERC20Snapshot is ERC20 {\r\n    using SafeMath for uint256;\r\n    using Arrays for uint256[];\r\n    using Counters for Counters.Counter;\r\n\r\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n    // Snapshot struct, but that would impede usage of functions that work on an array.\r\n    struct Snapshots {\r\n        uint256[] ids;\r\n        uint256[] values;\r\n    }\r\n\r\n    mapping (address =\u003E Snapshots) private _accountBalanceSnapshots;\r\n    Snapshots private _totalSupplySnapshots;\r\n\r\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\n    Counters.Counter private _currentSnapshotId;\r\n\r\n    event Snapshot(uint256 id);\r\n\r\n    // Creates a new snapshot id. Balances are only stored in snapshots on demand: unless a snapshot was taken, a\r\n    // balance change will not be recorded. This means the extra added cost of storing snapshotted balances is only paid\r\n    // when required, but is also flexible enough that it allows for e.g. daily snapshots.\r\n    function snapshot() public virtual returns (uint256) {\r\n        _currentSnapshotId.increment();\r\n\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        emit Snapshot(currentId);\r\n        return currentId;\r\n    }\r\n\r\n    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\r\n\r\n        return snapshotted ? value : balanceOf(account);\r\n    }\r\n\r\n    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\r\n\r\n        return snapshotted ? value : totalSupply();\r\n    }\r\n\r\n    // _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\r\n    // snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\r\n    // The same is true for the total supply and _mint and _burn.\r\n    function _transfer(address from, address to, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(from);\r\n        _updateAccountSnapshot(to);\r\n\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._burn(account, value);\r\n    }\r\n\r\n    // When a valid snapshot is queried, there are three possibilities:\r\n    //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\r\n    //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\r\n    //  to this id is the current one.\r\n    //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\r\n    //  requested id, and its value is the one to return.\r\n    //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\r\n    //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\r\n    //  larger than the requested one.\r\n    //\r\n    // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\r\n    // it is not found, unless said value doesn\u0027t exist (e.g. when all values are smaller). Arrays.findUpperBound does\r\n    // exactly this.\r\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\r\n        private view returns (bool, uint256)\r\n    {\r\n        require(snapshotId \u003E 0, \u0022ERC20Snapshot: id is 0\u0022);\r\n        // solhint-disable-next-line max-line-length\r\n        require(snapshotId \u003C= _currentSnapshotId.current(), \u0022ERC20Snapshot: nonexistent id\u0022);\r\n\r\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\n        if (index == snapshots.ids.length) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, snapshots.values[index]);\r\n        }\r\n    }\r\n\r\n    function _updateAccountSnapshot(address account) private {\r\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\r\n    }\r\n\r\n    function _updateTotalSupplySnapshot() private {\r\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\r\n    }\r\n\r\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        if (_lastSnapshotId(snapshots.ids) \u003C currentId) {\r\n            snapshots.ids.push(currentId);\r\n            snapshots.values.push(currentValue);\r\n        }\r\n    }\r\n\r\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\n        if (ids.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return ids[ids.length - 1];\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a \u0060using SafeERC20 for ERC20;\u0060 statement to your contract,\r\n * which allows you to call the safe operations as \u0060token.safeTransfer(...)\u0060, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \u0022SafeERC20: approve from non-zero to non-zero allowance\u0022\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \u0022SafeERC20: decreased allowance below zero\u0022);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \u0022SafeERC20: call to non-contract\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \u0022SafeERC20: low-level call failed\u0022);\r\n\r\n        if (returndata.length \u003E 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \u0022SafeERC20: ERC20 operation did not succeed\u0022);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/TokenVesting.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\r\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\r\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\r\n    // cliff period of a year and a duration of four years, are safe to use.\r\n    // solhint-disable not-rely-on-time\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event TokensReleased(address token, uint256 amount);\r\n    event TokenVestingRevoked(address token);\r\n\r\n    // beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\r\n    uint256 private _cliff;\r\n    uint256 private _start;\r\n    uint256 private _duration;\r\n\r\n    bool private _revocable;\r\n\r\n    mapping (address =\u003E uint256) private _released;\r\n    mapping (address =\u003E bool) private _revoked;\r\n\r\n    /**\r\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n     * beneficiary, gradually in a linear fashion until start \u002B duration. By then all\r\n     * of the balance will have vested.\r\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\r\n     * @param start the time (as Unix time) at which point vesting starts\r\n     * @param duration duration in seconds of the period in which the tokens will vest\r\n     * @param revocable whether the vesting is revocable or not\r\n     */\r\n    constructor (address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration, bool revocable) public {\r\n        require(beneficiary != address(0), \u0022TokenVesting: beneficiary is the zero address\u0022);\r\n        // solhint-disable-next-line max-line-length\r\n        require(cliffDuration \u003C= duration, \u0022TokenVesting: cliff is longer than duration\u0022);\r\n        require(duration \u003E 0, \u0022TokenVesting: duration is 0\u0022);\r\n        // solhint-disable-next-line max-line-length\r\n        require(start.add(duration) \u003E block.timestamp, \u0022TokenVesting: final time is before current time\u0022);\r\n\r\n        _beneficiary = beneficiary;\r\n        _revocable = revocable;\r\n        _duration = duration;\r\n        _cliff = start.add(cliffDuration);\r\n        _start = start;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the cliff time of the token vesting.\r\n     */\r\n    function cliff() public view returns (uint256) {\r\n        return _cliff;\r\n    }\r\n\r\n    /**\r\n     * @return the start time of the token vesting.\r\n     */\r\n    function start() public view returns (uint256) {\r\n        return _start;\r\n    }\r\n\r\n    /**\r\n     * @return the duration of the token vesting.\r\n     */\r\n    function duration() public view returns (uint256) {\r\n        return _duration;\r\n    }\r\n\r\n    /**\r\n     * @return true if the vesting is revocable.\r\n     */\r\n    function revocable() public view returns (bool) {\r\n        return _revocable;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of the token released.\r\n     */\r\n    function released(address token) public view returns (uint256) {\r\n        return _released[token];\r\n    }\r\n\r\n    /**\r\n     * @return true if the token is revoked.\r\n     */\r\n    function revoked(address token) public view returns (bool) {\r\n        return _revoked[token];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function release(IERC20 token) public {\r\n        uint256 unreleased = _releasableAmount(token);\r\n\r\n        require(unreleased \u003E 0, \u0022TokenVesting: no tokens are due\u0022);\r\n\r\n        _released[address(token)] = _released[address(token)].add(unreleased);\r\n\r\n        token.safeTransfer(_beneficiary, unreleased);\r\n\r\n        emit TokensReleased(address(token), unreleased);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n     * remain in the contract, the rest are returned to the owner.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function revoke(IERC20 token) public onlyOwner {\r\n        require(_revocable, \u0022TokenVesting: cannot revoke\u0022);\r\n        require(!_revoked[address(token)], \u0022TokenVesting: token already revoked\u0022);\r\n\r\n        uint256 balance = token.balanceOf(address(this));\r\n\r\n        uint256 unreleased = _releasableAmount(token);\r\n        uint256 refund = balance.sub(unreleased);\r\n\r\n        _revoked[address(token)] = true;\r\n\r\n        token.safeTransfer(owner(), refund);\r\n\r\n        emit TokenVestingRevoked(address(token));\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn\u0027t been released yet.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\r\n        return _vestedAmount(token).sub(_released[address(token)]);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\r\n        uint256 currentBalance = token.balanceOf(address(this));\r\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\r\n\r\n        if (block.timestamp \u003C _cliff) {\r\n            return 0;\r\n        } else if (block.timestamp \u003E= _start.add(_duration) || _revoked[address(token)]) {\r\n            return totalBalance;\r\n        } else {\r\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/IRelayRecipient.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.\r\n *\r\n * TIP: You don\u0027t need to write an implementation yourself! Inherit from {GSNRecipient} instead.\r\n */\r\ninterface IRelayRecipient {\r\n    /**\r\n     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.\r\n     */\r\n    function getHubAddr() external view returns (address);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the\r\n     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).\r\n     *\r\n     * The relay request was originated by \u0060from\u0060 and will be served by \u0060relay\u0060. \u0060encodedFunction\u0060 is the relayed call\r\n     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded \u0060gasLimit\u0060 gas,\r\n     * and the transaction executed with a gas price of at least \u0060gasPrice\u0060. \u0060relay\u0060\u0027s fee is \u0060transactionFee\u0060, and the\r\n     * recipient will be charged at most \u0060maxPossibleCharge\u0060 (in wei). \u0060nonce\u0060 is the sender\u0027s (\u0060from\u0060) nonce for\r\n     * replay attack protection in {IRelayHub}, and \u0060approvalData\u0060 is a optional parameter that can be used to hold a signature\r\n     * over all or some of the previous values.\r\n     *\r\n     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,\r\n     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.\r\n     *\r\n     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered\r\n     * rejected. A regular revert will also trigger a rejection.\r\n     */\r\n    function acceptRelayedCall(\r\n        address relay,\r\n        address from,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata approvalData,\r\n        uint256 maxPossibleCharge\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, bytes memory);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.\r\n     * pre-charge the sender of the transaction.\r\n     *\r\n     * \u0060context\u0060 is the second value returned in the tuple by {acceptRelayedCall}.\r\n     *\r\n     * Returns a value to be passed to {postRelayedCall}.\r\n     *\r\n     * {preRelayedCall} is called with 100k gas: if it runs out during exection or otherwise reverts, the relayed call\r\n     * will not be executed, but the recipient will still be charged for the transaction\u0027s cost.\r\n     */\r\n    function preRelayedCall(bytes calldata context) external returns (bytes32);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.\r\n     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform\r\n     * contract-specific bookkeeping.\r\n     *\r\n     * \u0060context\u0060 is the second value returned in the tuple by {acceptRelayedCall}. \u0060success\u0060 is the execution status of\r\n     * the relayed call. \u0060actualCharge\u0060 is an estimate of how much the recipient will be charged for the transaction,\r\n     * not including any gas used by {postRelayedCall} itself. \u0060preRetVal\u0060 is {preRelayedCall}\u0027s return value.\r\n     *\r\n     *\r\n     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\r\n     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the\r\n     * transaction\u0027s cost.\r\n     */\r\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/IRelayHub.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface for \u0060RelayHub\u0060, the core contract of the GSN. Users should not need to interact with this contract\r\n * directly.\r\n *\r\n * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\r\n * how to deploy an instance of \u0060RelayHub\u0060 on your local test network.\r\n */\r\ninterface IRelayHub {\r\n    // Relay management\r\n\r\n    /**\r\n     * @dev Adds stake to a relay and sets its \u0060unstakeDelay\u0060. If the relay does not exist, it is created, and the caller\r\n     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\r\n     * cannot be its own owner.\r\n     *\r\n     * All Ether in this function call will be added to the relay\u0027s stake.\r\n     * Its unstake delay will be assigned to \u0060unstakeDelay\u0060, but the new value must be greater or equal to the current one.\r\n     *\r\n     * Emits a {Staked} event.\r\n     */\r\n    function stake(address relayaddr, uint256 unstakeDelay) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when a relay\u0027s stake or unstakeDelay are increased\r\n     */\r\n    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\r\n\r\n    /**\r\n     * @dev Registers the caller as a relay.\r\n     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\r\n     *\r\n     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\r\n     * \u0060transactionFee\u0060 is not enforced by {relayCall}.\r\n     *\r\n     * Emits a {RelayAdded} event.\r\n     */\r\n    function registerRelay(uint256 transactionFee, string calldata url) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is registered or re-registerd. Looking at these events (and filtering out\r\n     * {RelayRemoved} events) lets a client discover the list of available relays.\r\n     */\r\n    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\r\n\r\n    /**\r\n     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\r\n     *\r\n     * Can only be called by the owner of the relay. After the relay\u0027s \u0060unstakeDelay\u0060 has elapsed, {unstake} will be\r\n     * callable.\r\n     *\r\n     * Emits a {RelayRemoved} event.\r\n     */\r\n    function removeRelayByOwner(address relay) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is removed (deregistered). \u0060unstakeTime\u0060 is the time when unstake will be callable.\r\n     */\r\n    event RelayRemoved(address indexed relay, uint256 unstakeTime);\r\n\r\n    /** Deletes the relay from the system, and gives back its stake to the owner.\r\n     *\r\n     * Can only be called by the relay owner, after \u0060unstakeDelay\u0060 has elapsed since {removeRelayByOwner} was called.\r\n     *\r\n     * Emits an {Unstaked} event.\r\n     */\r\n    function unstake(address relay) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is unstaked for, including the returned stake.\r\n     */\r\n    event Unstaked(address indexed relay, uint256 stake);\r\n\r\n    // States a relay can be in\r\n    enum RelayState {\r\n        Unknown, // The relay is unknown to the system: it has never been staked for\r\n        Staked, // The relay has been staked for, but it is not yet active\r\n        Registered, // The relay has registered itself, and is active (can relay calls)\r\n        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a relay\u0027s status. Note that relays can be deleted when unstaked or penalized, causing this function\r\n     * to return an empty entry.\r\n     */\r\n    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\r\n\r\n    // Balance management\r\n\r\n    /**\r\n     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\r\n     *\r\n     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\r\n     *\r\n     * Emits a {Deposited} event.\r\n     */\r\n    function depositFor(address target) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\r\n     */\r\n    event Deposited(address indexed recipient, address indexed from, uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns an account\u0027s deposits. These can be either a contracts\u0027s funds, or a relay owner\u0027s revenue.\r\n     */\r\n    function balanceOf(address target) external view returns (uint256);\r\n\r\n    /**\r\n     * Withdraws from an account\u0027s balance, sending it back to it. Relay owners call this to retrieve their revenue, and\r\n     * contracts can use it to reduce their funding.\r\n     *\r\n     * Emits a {Withdrawn} event.\r\n     */\r\n    function withdraw(uint256 amount, address payable dest) external;\r\n\r\n    /**\r\n     * @dev Emitted when an account withdraws funds from \u0060RelayHub\u0060.\r\n     */\r\n    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\r\n\r\n    // Relaying\r\n\r\n    /**\r\n     * @dev Checks if the \u0060RelayHub\u0060 will accept a relayed operation.\r\n     * Multiple things must be true for this to happen:\r\n     *  - all arguments must be signed for by the sender (\u0060from\u0060)\r\n     *  - the sender\u0027s nonce must be the current one\r\n     *  - the recipient must accept this transaction (via {acceptRelayedCall})\r\n     *\r\n     * Returns a \u0060PreconditionCheck\u0060 value (\u0060OK\u0060 when the transaction can be relayed), or a recipient-specific error\r\n     * code if it returns one in {acceptRelayedCall}.\r\n     */\r\n    function canRelay(\r\n        address relay,\r\n        address from,\r\n        address to,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata signature,\r\n        bytes calldata approvalData\r\n    ) external view returns (uint256 status, bytes memory recipientContext);\r\n\r\n    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\r\n    enum PreconditionCheck {\r\n        OK,                         // All checks passed, the call can be relayed\r\n        WrongSignature,             // The transaction to relay is not signed by requested sender\r\n        WrongNonce,                 // The provided nonce has already been used by the sender\r\n        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\r\n        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\r\n    }\r\n\r\n    /**\r\n     * @dev Relays a transaction.\r\n     *\r\n     * For this to succeed, multiple conditions must be met:\r\n     *  - {canRelay} must \u0060return PreconditionCheck.OK\u0060\r\n     *  - the sender must be a registered relay\r\n     *  - the transaction\u0027s gas price must be larger or equal to the one that was requested by the sender\r\n     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\r\n     * recipient) use all gas available to them\r\n     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\r\n     * spent)\r\n     *\r\n     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\r\n     * function and {postRelayedCall} will be called in that order.\r\n     *\r\n     * Parameters:\r\n     *  - \u0060from\u0060: the client originating the request\r\n     *  - \u0060to\u0060: the target {IRelayRecipient} contract\r\n     *  - \u0060encodedFunction\u0060: the function call to relay, including data\r\n     *  - \u0060transactionFee\u0060: fee (%) the relay takes over actual gas cost\r\n     *  - \u0060gasPrice\u0060: gas price the client is willing to pay\r\n     *  - \u0060gasLimit\u0060: gas to forward when calling the encoded function\r\n     *  - \u0060nonce\u0060: client\u0027s nonce\r\n     *  - \u0060signature\u0060: client\u0027s signature over all previous params, plus the relay and RelayHub addresses\r\n     *  - \u0060approvalData\u0060: dapp-specific data forwared to {acceptRelayedCall}. This value is *not* verified by the\r\n     * \u0060RelayHub\u0060, but it still can be used for e.g. a signature.\r\n     *\r\n     * Emits a {TransactionRelayed} event.\r\n     */\r\n    function relayCall(\r\n        address from,\r\n        address to,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata signature,\r\n        bytes calldata approvalData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted when an attempt to relay a call failed.\r\n     *\r\n     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\r\n     * actual relayed call was not executed, and the recipient not charged.\r\n     *\r\n     * The \u0060reason\u0060 parameter contains an error code: values 1-10 correspond to \u0060PreconditionCheck\u0060 entries, and values\r\n     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\r\n     */\r\n    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\r\n\r\n    /**\r\n     * @dev Emitted when a transaction is relayed.\r\n     * Useful when monitoring a relay\u0027s operation and relayed calls to a contract\r\n     *\r\n     * Note that the actual encoded function might be reverted: this is indicated in the \u0060status\u0060 parameter.\r\n     *\r\n     * \u0060charge\u0060 is the Ether value deducted from the recipient\u0027s balance, paid to the relay\u0027s owner.\r\n     */\r\n    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\r\n\r\n    // Reason error codes for the TransactionRelayed event\r\n    enum RelayCallStatus {\r\n        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\r\n        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\r\n        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\r\n        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\r\n        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient\u0027s balance changing\r\n    }\r\n\r\n    /**\r\n     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\r\n     * spend up to \u0060relayedCallStipend\u0060 gas.\r\n     */\r\n    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\r\n     */\r\n    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\r\n\r\n     // Relay penalization.\r\n     // Any account can penalize relays, removing them from the system immediately, and rewarding the\r\n    // reporter with half of the relay\u0027s stake. The other half is burned so that, even if the relay penalizes itself, it\r\n    // still loses half of its stake.\r\n\r\n    /**\r\n     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\r\n     * different data (gas price, gas limit, etc. may be different).\r\n     *\r\n     * The (unsigned) transaction data and signature for both transactions must be provided.\r\n     */\r\n    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\r\n\r\n    /**\r\n     * @dev Penalize a relay that sent a transaction that didn\u0027t target \u0060RelayHub\u0060\u0027s {registerRelay} or {relayCall}.\r\n     */\r\n    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is penalized.\r\n     */\r\n    event Penalized(address indexed relay, address sender, uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns an account\u0027s nonce in \u0060RelayHub\u0060.\r\n     */\r\n    function getNonce(address from) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/GSNRecipient.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface\r\n * and enables GSN support on all contracts in the inheritance tree.\r\n *\r\n * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},\r\n *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be\r\n * provided by derived contracts. See the\r\n * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more\r\n * information on how to use the pre-built {GSNRecipientSignature} and\r\n * {GSNRecipientERC20Fee}, or how to write your own.\r\n */\r\nabstract contract GSNRecipient is IRelayRecipient, Context {\r\n    // Default RelayHub address, deployed on mainnet and all testnets at the same address\r\n    address private _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;\r\n\r\n    uint256 constant private RELAYED_CALL_ACCEPTED = 0;\r\n    uint256 constant private RELAYED_CALL_REJECTED = 11;\r\n\r\n    // How much gas is forwarded to postRelayedCall\r\n    uint256 constant internal POST_RELAYED_CALL_MAX_GAS = 100000;\r\n\r\n    /**\r\n     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.\r\n     */\r\n    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);\r\n\r\n    /**\r\n     * @dev Returns the address of the {IRelayHub} contract for this recipient.\r\n     */\r\n    function getHubAddr() public view override returns (address) {\r\n        return _relayHub;\r\n    }\r\n\r\n    /**\r\n     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there\u0027s no reason to not\r\n     * use the default instance.\r\n     *\r\n     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old\r\n     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.\r\n     */\r\n    function _upgradeRelayHub(address newRelayHub) internal virtual {\r\n        address currentRelayHub = _relayHub;\r\n        require(newRelayHub != address(0), \u0022GSNRecipient: new RelayHub is the zero address\u0022);\r\n        require(newRelayHub != currentRelayHub, \u0022GSNRecipient: new RelayHub is the current one\u0022);\r\n\r\n        emit RelayHubChanged(currentRelayHub, newRelayHub);\r\n\r\n        _relayHub = newRelayHub;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If\r\n     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.\r\n     */\r\n    // This function is view for future-proofing, it may require reading from\r\n    // storage in the future.\r\n    function relayHubVersion() public view returns (string memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return \u00221.0.0\u0022;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the recipient\u0027s deposits in \u0060RelayHub\u0060.\r\n     *\r\n     * Derived contracts should expose this in an external interface with proper access control.\r\n     */\r\n    function _withdrawDeposits(uint256 amount, address payable payee) internal virtual {\r\n        IRelayHub(_relayHub).withdraw(amount, payee);\r\n    }\r\n\r\n    // Overrides for Context\u0027s functions: when called from RelayHub, sender and\r\n    // data require some pre-processing: the actual sender is stored at the end\r\n    // of the call data, which in turns means it needs to be removed from it\r\n    // when handling said data.\r\n\r\n    /**\r\n     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\r\n     * and the end-user for GSN relayed calls (where msg.sender is actually \u0060RelayHub\u0060).\r\n     *\r\n     * IMPORTANT: Contracts derived from {GSNRecipient} should never use \u0060msg.sender\u0060, and use {_msgSender} instead.\r\n     */\r\n    function _msgSender() internal view virtual override returns (address payable) {\r\n        if (msg.sender != _relayHub) {\r\n            return msg.sender;\r\n        } else {\r\n            return _getRelayedCallSender();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,\r\n     * and a reduced version for GSN relayed calls (where msg.data contains additional information).\r\n     *\r\n     * IMPORTANT: Contracts derived from {GSNRecipient} should never use \u0060msg.data\u0060, and use {_msgData} instead.\r\n     */\r\n    function _msgData() internal view virtual override returns (bytes memory) {\r\n        if (msg.sender != _relayHub) {\r\n            return msg.data;\r\n        } else {\r\n            return _getRelayedCallData();\r\n        }\r\n    }\r\n\r\n    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\r\n    // internal hook.\r\n\r\n    /**\r\n     * @dev See \u0060IRelayRecipient.preRelayedCall\u0060.\r\n     *\r\n     * This function should not be overriden directly, use \u0060_preRelayedCall\u0060 instead.\r\n     *\r\n     * * Requirements:\r\n     *\r\n     * - the caller must be the \u0060RelayHub\u0060 contract.\r\n     */\r\n    function preRelayedCall(bytes calldata context) external virtual override returns (bytes32) {\r\n        require(msg.sender == getHubAddr(), \u0022GSNRecipient: caller is not RelayHub\u0022);\r\n        return _preRelayedCall(context);\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IRelayRecipient.preRelayedCall\u0060.\r\n     *\r\n     * Called by \u0060GSNRecipient.preRelayedCall\u0060, which asserts the caller is the \u0060RelayHub\u0060 contract. Derived contracts\r\n     * must implement this function with any relayed-call preprocessing they may wish to do.\r\n     *\r\n     */\r\n    function _preRelayedCall(bytes memory context) internal virtual returns (bytes32);\r\n\r\n    /**\r\n     * @dev See \u0060IRelayRecipient.postRelayedCall\u0060.\r\n     *\r\n     * This function should not be overriden directly, use \u0060_postRelayedCall\u0060 instead.\r\n     *\r\n     * * Requirements:\r\n     *\r\n     * - the caller must be the \u0060RelayHub\u0060 contract.\r\n     */\r\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external virtual override {\r\n        require(msg.sender == getHubAddr(), \u0022GSNRecipient: caller is not RelayHub\u0022);\r\n        _postRelayedCall(context, success, actualCharge, preRetVal);\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IRelayRecipient.postRelayedCall\u0060.\r\n     *\r\n     * Called by \u0060GSNRecipient.postRelayedCall\u0060, which asserts the caller is the \u0060RelayHub\u0060 contract. Derived contracts\r\n     * must implement this function with any relayed-call postprocessing they may wish to do.\r\n     *\r\n     */\r\n    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal virtual;\r\n\r\n    /**\r\n     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract\r\n     * will be charged a fee by RelayHub\r\n     */\r\n    function _approveRelayedCall() internal pure returns (uint256, bytes memory) {\r\n        return _approveRelayedCall(\u0022\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060GSNRecipient._approveRelayedCall\u0060.\r\n     *\r\n     * This overload forwards \u0060context\u0060 to _preRelayedCall and _postRelayedCall.\r\n     */\r\n    function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {\r\n        return (RELAYED_CALL_ACCEPTED, context);\r\n    }\r\n\r\n    /**\r\n     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.\r\n     */\r\n    function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {\r\n        return (RELAYED_CALL_REJECTED \u002B errorCode, \u0022\u0022);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates how much RelayHub will charge a recipient for using \u0060gas\u0060 at a \u0060gasPrice\u0060, given a relayer\u0027s\r\n     * \u0060serviceFee\u0060.\r\n     */\r\n    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure returns (uint256) {\r\n        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be\r\n        // charged for 1.4 times the spent amount.\r\n        return (gas * gasPrice * (100 \u002B serviceFee)) / 100;\r\n    }\r\n\r\n    function _getRelayedCallSender() private pure returns (address payable result) {\r\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\r\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\r\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\r\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\r\n        // bytes. This can always be done due to the 32-byte prefix.\r\n\r\n        // The final memory read index is msg.data.length - 20 \u002B 32 - 12 = msg.data.length. Using inline assembly is the\r\n        // easiest/most-efficient way to perform this operation.\r\n\r\n        // These fields are not accessible from assembly\r\n        bytes memory array = msg.data;\r\n        uint256 index = msg.data.length;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _getRelayedCallData() private pure returns (bytes memory) {\r\n        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,\r\n        // we must strip the last 20 bytes (length of an address type) from it.\r\n\r\n        uint256 actualDataLength = msg.data.length - 20;\r\n        bytes memory actualData = new bytes(actualDataLength);\r\n\r\n        for (uint256 i = 0; i \u003C actualDataLength; \u002B\u002Bi) {\r\n            actualData[i] = msg.data[i];\r\n        }\r\n\r\n        return actualData;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/ownership/Secondary.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\r\n */\r\ncontract Secondary is Context {\r\n    address private _primary;\r\n\r\n    /**\r\n     * @dev Emitted when the primary contract changes.\r\n     */\r\n    event PrimaryTransferred(\r\n        address recipient\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _primary = msgSender;\r\n        emit PrimaryTransferred(msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if called from any account other than the primary.\r\n     */\r\n    modifier onlyPrimary() {\r\n        require(_msgSender() == _primary, \u0022Secondary: caller is not the primary account\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the primary.\r\n     */\r\n    function primary() public view returns (address) {\r\n        return _primary;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers contract to a new primary.\r\n     * @param recipient The address of new primary.\r\n     */\r\n    function transferPrimary(address recipient) public virtual onlyPrimary {\r\n        require(recipient != address(0), \u0022Secondary: new primary is the zero address\u0022);\r\n        _primary = recipient;\r\n        emit PrimaryTransferred(recipient);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for \u0060name\u0060, \u0060symbol\u0060, and \u0060decimals\u0060. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if \u0060decimals\u0060 equals \u00602\u0060, a balance of \u0060505\u0060 tokens should\r\n     * be displayed to a user as \u00605,05\u0060 (\u0060505 / 10 ** 2\u0060).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/GSNRecipientERC20Fee.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that charges transaction fees in a special purpose ERC20\r\n * token, which we refer to as the gas payment token. The amount charged is exactly the amount of Ether charged to the\r\n * recipient. This means that the token is essentially pegged to the value of Ether.\r\n *\r\n * The distribution strategy of the gas payment token to users is not defined by this contract. It\u0027s a mintable token\r\n * whose only minter is the recipient, so the strategy must be implemented in a derived contract, making use of the\r\n * internal {_mint} function.\r\n */\r\ncontract GSNRecipientERC20Fee is GSNRecipient {\r\n    using SafeERC20 for __unstable__ERC20PrimaryAdmin;\r\n    using SafeMath for uint256;\r\n\r\n    enum GSNRecipientERC20FeeErrorCodes {\r\n        INSUFFICIENT_BALANCE\r\n    }\r\n\r\n    __unstable__ERC20PrimaryAdmin private _token;\r\n\r\n    /**\r\n     * @dev The arguments to the constructor are the details that the gas payment token will have: \u0060name\u0060 and \u0060symbol\u0060. \u0060decimals\u0060 is hard-coded to 18.\r\n     */\r\n    constructor(string memory name, string memory symbol) public {\r\n        _token = new __unstable__ERC20PrimaryAdmin(name, symbol, 18);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the gas payment token.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return IERC20(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints the gas payment token. Derived contracts should expose this function in their public API, with proper access control mechanisms.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        _token.mint(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.\r\n     */\r\n    function acceptRelayedCall(\r\n        address,\r\n        address from,\r\n        bytes calldata,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata,\r\n        uint256 maxPossibleCharge\r\n    )\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256, bytes memory)\r\n    {\r\n        if (_token.balanceOf(from) \u003C maxPossibleCharge) {\r\n            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));\r\n        }\r\n\r\n        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the precharge to the user. The maximum possible charge (depending on gas limit, gas price, and\r\n     * fee) will be deducted from the user balance of gas payment token. Note that this is an overestimation of the\r\n     * actual charge, necessary because we cannot predict how much gas the execution will actually need. The remainder\r\n     * is returned to the user in {_postRelayedCall}.\r\n     */\r\n    function _preRelayedCall(bytes memory context) internal virtual override returns (bytes32) {\r\n        (address from, uint256 maxPossibleCharge) = abi.decode(context, (address, uint256));\r\n\r\n        // The maximum token charge is pre-charged from the user\r\n        _token.safeTransferFrom(from, address(this), maxPossibleCharge);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to the user the extra amount that was previously charged, once the actual execution cost is known.\r\n     */\r\n    function _postRelayedCall(bytes memory context, bool, uint256 actualCharge, bytes32) internal virtual override {\r\n        (address from, uint256 maxPossibleCharge, uint256 transactionFee, uint256 gasPrice) =\r\n            abi.decode(context, (address, uint256, uint256, uint256));\r\n\r\n        // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.\r\n        // This implementation\u0027s gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an\r\n        // ERC20 transfer.\r\n        uint256 overestimation = _computeCharge(POST_RELAYED_CALL_MAX_GAS.sub(10000), gasPrice, transactionFee);\r\n        actualCharge = actualCharge.sub(overestimation);\r\n\r\n        // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned\r\n        _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));\r\n    }\r\n}\r\n\r\n/**\r\n * @title __unstable__ERC20PrimaryAdmin\r\n * @dev An ERC20 token owned by another contract, which has minting permissions and can use transferFrom to receive\r\n * anyone\u0027s tokens. This contract is an internal helper for GSNRecipientERC20Fee, and should not be used\r\n * outside of this context.\r\n */\r\n// solhint-disable-next-line contract-name-camelcase\r\ncontract __unstable__ERC20PrimaryAdmin is ERC20, ERC20Detailed, Secondary {\r\n    uint256 private constant UINT256_MAX = 2**256 - 1;\r\n\r\n    constructor(string memory name, string memory symbol, uint8 decimals) public ERC20Detailed(name, symbol, decimals) { }\r\n\r\n    // The primary account (GSNRecipientERC20Fee) can mint tokens\r\n    function mint(address account, uint256 amount) public onlyPrimary {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    // The primary account has \u0027infinite\u0027 allowance for all token holders\r\n    function allowance(address owner, address spender) public view override(ERC20, IERC20) returns (uint256) {\r\n        if (spender == primary()) {\r\n            return UINT256_MAX;\r\n        } else {\r\n            return super.allowance(owner, spender);\r\n        }\r\n    }\r\n\r\n    // Allowance for the primary account cannot be changed (it is always \u0027infinite\u0027)\r\n    function _approve(address owner, address spender, uint256 value) internal override {\r\n        if (spender == primary()) {\r\n            return;\r\n        } else {\r\n            super._approve(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {\r\n        if (recipient == primary()) {\r\n            _transfer(sender, recipient, amount);\r\n            return true;\r\n        } else {\r\n            return super.transferFrom(sender, recipient, amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (\u0060hash\u0060) with\r\n     * \u0060signature\u0060. This address can then be used for verification purposes.\r\n     *\r\n     * The \u0060ecrecover\u0060 EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the \u0060s\u0060 value to be in the lower\r\n     * half order, and the \u0060v\u0060 value to be either 27 or 28.\r\n     *\r\n     * NOTE: This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * IMPORTANT: \u0060hash\u0060 _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 \u003C s \u003C secp256k1n \u00F7 2 \u002B 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) \u003E 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a \u0060hash\u0060. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[\u0060eth_sign\u0060]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\u0022\\x19Ethereum Signed Message:\\n32\u0022, hash));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/GSN/GSNRecipientSignature.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that allows relayed transactions through when they are\r\n * accompanied by the signature of a trusted signer. The intent is for this signature to be generated by a server that\r\n * performs validations off-chain. Note that nothing is charged to the user in this scheme. Thus, the server should make\r\n * sure to account for this in their economic and threat model.\r\n */\r\ncontract GSNRecipientSignature is GSNRecipient {\r\n    using ECDSA for bytes32;\r\n\r\n    address private _trustedSigner;\r\n\r\n    enum GSNRecipientSignatureErrorCodes {\r\n        INVALID_SIGNER\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the trusted signer that is going to be producing signatures to approve relayed calls.\r\n     */\r\n    constructor(address trustedSigner) public {\r\n        require(trustedSigner != address(0), \u0022GSNRecipientSignature: trusted signer is the zero address\u0022);\r\n        _trustedSigner = trustedSigner;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.\r\n     */\r\n    function acceptRelayedCall(\r\n        address relay,\r\n        address from,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata approvalData,\r\n        uint256\r\n    )\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256, bytes memory)\r\n    {\r\n        bytes memory blob = abi.encodePacked(\r\n            relay,\r\n            from,\r\n            encodedFunction,\r\n            transactionFee,\r\n            gasPrice,\r\n            gasLimit,\r\n            nonce, // Prevents replays on RelayHub\r\n            getHubAddr(), // Prevents replays in multiple RelayHubs\r\n            address(this) // Prevents replays in multiple recipients\r\n        );\r\n        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {\r\n            return _approveRelayedCall();\r\n        } else {\r\n            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));\r\n        }\r\n    }\r\n\r\n    function _preRelayedCall(bytes memory) internal virtual override returns (bytes32) { }\r\n\r\n    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal virtual override { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/IERC1820Implementer.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface for an ERC1820 implementer, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\r\n * Used by contracts that will be registered as implementers in the\r\n * {IERC1820Registry}.\r\n */\r\ninterface IERC1820Implementer {\r\n    /**\r\n     * @dev Returns a special value (\u0060ERC1820_ACCEPT_MAGIC\u0060) if this contract\r\n     * implements \u0060interfaceHash\u0060 for \u0060account\u0060.\r\n     *\r\n     * See {IERC1820Registry-setInterfaceImplementer}.\r\n     */\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/ERC1820Implementer.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC1820Implementer} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\r\n * declare their willingness to be implementers.\r\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\r\n * registration to be complete.\r\n */\r\ncontract ERC1820Implementer is IERC1820Implementer {\r\n    bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\u0022ERC1820_ACCEPT_MAGIC\u0022));\r\n\r\n    mapping(bytes32 =\u003E mapping(address =\u003E bool)) private _supportedInterfaces;\r\n\r\n    /**\r\n     * See {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view override returns (bytes32) {\r\n        return _supportedInterfaces[interfaceHash][account] ? ERC1820_ACCEPT_MAGIC : bytes32(0x00);\r\n    }\r\n\r\n    /**\r\n     * @dev Declares the contract as willing to be an implementer of\r\n     * \u0060interfaceHash\u0060 for \u0060account\u0060.\r\n     *\r\n     * See {IERC1820Registry-setInterfaceImplementer} and\r\n     * {IERC1820Registry-interfaceHash}.\r\n     */\r\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {\r\n        _supportedInterfaces[interfaceHash][account] = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers \u0060whenNotPaused\u0060 and \u0060whenPaused\u0060, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (\u0060account\u0060).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (\u0060account\u0060).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \u0022Pausable: paused\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \u0022Pausable: not paused\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/AddressImpl.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract AddressImpl {\r\n    function isContract(address account) external view returns (bool) {\r\n        return Address.isContract(account);\r\n    }\r\n\r\n    function toPayable(address account) external pure returns (address payable) {\r\n        return Address.toPayable(account);\r\n    }\r\n\r\n    function sendValue(address payable receiver, uint256 amount) external {\r\n        Address.sendValue(receiver, amount);\r\n    }\r\n\r\n    // sendValue\u0027s tests require the contract to hold Ether\r\n    receive () external payable { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ArraysImpl.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ArraysImpl {\r\n    using Arrays for uint256[];\r\n\r\n    uint256[] private array;\r\n\r\n    constructor (uint256[] memory _array) public {\r\n        array = _array;\r\n    }\r\n\r\n    function findUpperBound(uint256 _element) external view returns (uint256) {\r\n        return array.findUpperBound(_element);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/payment/escrow/Escrow.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n /**\r\n  * @title Escrow\r\n  * @dev Base escrow contract, holds funds designated for a payee until they\r\n  * withdraw them.\r\n  *\r\n  * Intended usage: This contract (and derived escrow contracts) should be a\r\n  * standalone contract, that only interacts with the contract that instantiated\r\n  * it. That way, it is guaranteed that all Ether will be handled according to\r\n  * the \u0060Escrow\u0060 rules, and there is no need to check for payable functions or\r\n  * transfers in the inheritance tree. The contract that uses the escrow as its\r\n  * payment method should be its primary, and provide public methods redirecting\r\n  * to the escrow\u0027s deposit and withdraw.\r\n  */\r\ncontract Escrow is Secondary {\r\n    using SafeMath for uint256;\r\n    using Address for address payable;\r\n\r\n    event Deposited(address indexed payee, uint256 weiAmount);\r\n    event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n    mapping(address =\u003E uint256) private _deposits;\r\n\r\n    function depositsOf(address payee) public view returns (uint256) {\r\n        return _deposits[payee];\r\n    }\r\n\r\n    /**\r\n     * @dev Stores the sent amount as credit to be withdrawn.\r\n     * @param payee The destination address of the funds.\r\n     */\r\n    function deposit(address payee) public virtual payable onlyPrimary {\r\n        uint256 amount = msg.value;\r\n        _deposits[payee] = _deposits[payee].add(amount);\r\n\r\n        emit Deposited(payee, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance for a payee, forwarding 2300 gas (a\r\n     * Solidity \u0060transfer\u0060).\r\n     *\r\n     * NOTE: This function has been deprecated, use {withdrawWithGas} instead.\r\n     * Calling contracts with fixed-gas limits is an anti-pattern and may break\r\n     * contract interactions in network upgrades (hardforks).\r\n     * https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more.]\r\n     *\r\n     * @param payee The address whose funds will be withdrawn and transferred to.\r\n     */\r\n    function withdraw(address payable payee) public virtual onlyPrimary {\r\n        uint256 payment = _deposits[payee];\r\n\r\n        _deposits[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n\r\n        emit Withdrawn(payee, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {withdraw}, but forwarding all gas to the recipient.\r\n     *\r\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\r\n     * Make sure you trust the recipient, or are either following the\r\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function withdrawWithGas(address payable payee) public virtual onlyPrimary {\r\n        uint256 payment = _deposits[payee];\r\n\r\n        _deposits[payee] = 0;\r\n\r\n        payee.sendValue(payment);\r\n\r\n        emit Withdrawn(payee, payment);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/payment/escrow/ConditionalEscrow.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\r\n */\r\nabstract contract ConditionalEscrow is Escrow {\r\n    /**\r\n     * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n     * implemented by derived contracts.\r\n     * @param payee The destination address of the funds.\r\n     */\r\n    function withdrawalAllowed(address payee) public view virtual returns (bool);\r\n\r\n    function withdraw(address payable payee) public virtual override {\r\n        require(withdrawalAllowed(payee), \u0022ConditionalEscrow: payee is not allowed to withdraw\u0022);\r\n        super.withdraw(payee);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ConditionalEscrowMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n// mock class using ConditionalEscrow\r\ncontract ConditionalEscrowMock is ConditionalEscrow {\r\n    mapping(address =\u003E bool) private _allowed;\r\n\r\n    function setAllowed(address payee, bool allowed) public {\r\n        _allowed[payee] = allowed;\r\n    }\r\n\r\n    function withdrawalAllowed(address payee) public view override returns (bool) {\r\n        return _allowed[payee];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ContextMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ContextMock is Context {\r\n    event Sender(address sender);\r\n\r\n    function msgSender() public {\r\n        emit Sender(_msgSender());\r\n    }\r\n\r\n    event Data(bytes data, uint256 integerValue, string stringValue);\r\n\r\n    function msgData(uint256 integerValue, string memory stringValue) public {\r\n        emit Data(_msgData(), integerValue, stringValue);\r\n    }\r\n}\r\n\r\ncontract ContextMockCaller {\r\n    function callSender(ContextMock context) public {\r\n        context.msgSender();\r\n    }\r\n\r\n    function callData(ContextMock context, uint256 integerValue, string memory stringValue) public {\r\n        context.msgData(integerValue, stringValue);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/CountersImpl.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract CountersImpl {\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter private _counter;\r\n\r\n    function current() public view returns (uint256) {\r\n        return _counter.current();\r\n    }\r\n\r\n    function increment() public {\r\n        _counter.increment();\r\n    }\r\n\r\n    function decrement() public {\r\n        _counter.decrement();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/Create2.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Helper to make usage of the \u0060CREATE2\u0060 EVM opcode easier and safer.\r\n * \u0060CREATE2\u0060 can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as \u0027counterfactual interactions\u0027.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n *\r\n * _Available since v2.5.0._\r\n */\r\nlibrary Create2 {\r\n    /**\r\n     * @dev Deploys a contract using \u0060CREATE2\u0060. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}. Note that\r\n     * a contract cannot be deployed twice using the same salt.\r\n     */\r\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address) {\r\n        address addr;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \u0022Create2: Failed on deploy\u0022);\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the \u0060bytecode\u0060\r\n     * or \u0060salt\u0060 will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\r\n        return computeAddress(salt, bytecode, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * \u0060deployer\u0060. If \u0060deployer\u0060 is this contract\u0027s address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecode, address deployer) internal pure returns (address) {\r\n        return computeAddress(salt, keccak256(bytecode), deployer);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * \u0060deployer\u0060. If \u0060deployer\u0060 is this contract\u0027s address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\r\n        );\r\n        return address(bytes20(_data \u003C\u003C 96));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/Create2Impl.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract Create2Impl {\r\n    function deploy(bytes32 salt, bytes memory code) public {\r\n        Create2.deploy(salt, code);\r\n    }\r\n\r\n    function deployERC20(bytes32 salt) public {\r\n        // solhint-disable-next-line indent\r\n        Create2.deploy(salt, type(ERC20).creationCode);\r\n    }\r\n\r\n    function computeAddress(bytes32 salt, bytes memory code) public view returns (address) {\r\n        return Create2.computeAddress(salt, code);\r\n    }\r\n\r\n    function computeAddress(bytes32 salt, bytes memory code, address deployer) public pure returns (address) {\r\n        return Create2.computeAddress(salt, code, deployer);\r\n    }\r\n\r\n    function computeAddress(bytes32 salt, bytes32 codeHash, address deployer) public pure returns (address) {\r\n        return Create2.computeAddress(salt, codeHash, deployer);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ECDSAMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ECDSAMock {\r\n    using ECDSA for bytes32;\r\n\r\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\r\n        return hash.recover(signature);\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\r\n        return hash.toEthSignedMessageHash();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/EnumerableSet.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * As of v2.5.0, only \u0060address\u0060 sets are supported.\r\n *\r\n * Include with \u0060using EnumerableSet for EnumerableSet.AddressSet;\u0060.\r\n *\r\n * _Available since v2.5.0._\r\n *\r\n * @author Alberto Cuesta Ca\u00F1ada\r\n */\r\nlibrary EnumerableSet {\r\n\r\n    struct AddressSet {\r\n        // Position of the value in the \u0060values\u0060 array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (address =\u003E uint256) index;\r\n        address[] values;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     * Returns false if the value was already in the set.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!contains(set, value)) {\r\n            set.values.push(value);\r\n            // The element is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set.index[value] = set.values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     * Returns false if the value was not present in the set.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (contains(set, value)){\r\n            uint256 toDeleteIndex = set.index[value] - 1;\r\n            uint256 lastIndex = set.values.length - 1;\r\n\r\n            // If the element we\u0027re deleting is the last one, we can just remove it without doing a swap\r\n            if (lastIndex != toDeleteIndex) {\r\n                address lastValue = set.values[lastIndex];\r\n\r\n                // Move the last value to the index where the deleted value is\r\n                set.values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set.index[lastValue] = toDeleteIndex \u002B 1; // All indexes are 1-based\r\n            }\r\n\r\n            // Delete the index entry for the deleted value\r\n            delete set.index[value];\r\n\r\n            // Delete the old entry for the moved value\r\n            set.values.pop();\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set.index[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array with all values in the set. O(N).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n\r\n     * WARNING: This function may run out of gas on large sets: use {length} and\r\n     * {get} instead in these cases.\r\n     */\r\n    function enumerate(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory output = new address[](set.values.length);\r\n        for (uint256 i; i \u003C set.values.length; i\u002B\u002B){\r\n            output[i] = set.values[i];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements on the set. O(1).\r\n     */\r\n    function length(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return set.values.length;\r\n    }\r\n\r\n   /** @dev Returns the element stored at position \u0060index\u0060 in the set. O(1).\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - \u0060index\u0060 must be strictly less than {length}.\r\n    */\r\n    function get(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return set.values[index];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/EnumerableSetMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract EnumerableSetMock{\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    event TransactionResult(bool result);\r\n\r\n    EnumerableSet.AddressSet private set;\r\n\r\n    function contains(address value) public view returns (bool) {\r\n        return set.contains(value);\r\n    }\r\n\r\n    function add(address value) public {\r\n        bool result = set.add(value);\r\n        emit TransactionResult(result);\r\n    }\r\n\r\n    function remove(address value) public {\r\n        bool result = set.remove(value);\r\n        emit TransactionResult(result);\r\n    }\r\n\r\n    function enumerate() public view returns (address[] memory) {\r\n        return set.enumerate();\r\n    }\r\n\r\n    function length() public view returns (uint256) {\r\n        return set.length();\r\n    }\r\n\r\n    function get(uint256 index) public view returns (address) {\r\n        return set.get(index);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC165/ERC165InterfacesSupported.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * https://eips.ethereum.org/EIPS/eip-214#specification\r\n * From the specification:\r\n * \u003E Any attempts to make state-changing operations inside an execution instance with STATIC set to true will instead\r\n * throw an exception.\r\n * \u003E These operations include [...], LOG0, LOG1, LOG2, [...]\r\n *\r\n * therefore, because this contract is staticcall\u0027d we need to not emit events (which is how solidity-coverage works)\r\n * solidity-coverage ignores the /mocks folder, so we duplicate its implementation here to avoid instrumenting it\r\n */\r\ncontract SupportsInterfaceWithLookupMock is IERC165 {\r\n    /*\r\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\r\n     */\r\n    bytes4 public constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev A mapping of interface id to whether or not it\u0027s supported.\r\n     */\r\n    mapping(bytes4 =\u003E bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself.\r\n     */\r\n    constructor () public {\r\n        _registerInterface(INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev Implement supportsInterface(bytes4) using a lookup table.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Private method for registering an interface.\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \u0022ERC165InterfacesSupported: invalid interface id\u0022);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\ncontract ERC165InterfacesSupported is SupportsInterfaceWithLookupMock {\r\n    constructor (bytes4[] memory interfaceIds) public {\r\n        for (uint256 i = 0; i \u003C interfaceIds.length; i\u002B\u002B) {\r\n            _registerInterface(interfaceIds[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/ERC165Checker.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * \u0060revert\u0060 if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /*\r\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports the {IERC165} interface,\r\n     */\r\n    function _supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) \u0026\u0026\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports the interface defined by\r\n     * \u0060interfaceId\u0060. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return _supportsERC165(account) \u0026\u0026\r\n            _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports all the interfaces defined in\r\n     * \u0060interfaceIds\u0060. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!_supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i \u003C interfaceIds.length; i\u002B\u002B) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with the \u0060supportsERC165\u0060 method in this library.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r\n        // success determines whether the staticcall succeeded and result determines\r\n        // whether the contract at account indicates support of _interfaceId\r\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\r\n\r\n        return (success \u0026\u0026 result);\r\n    }\r\n\r\n    /**\r\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return success true if the STATICCALL succeeded, false otherwise\r\n     * @return result true if the STATICCALL succeeded and the contract at account\r\n     * indicates support of the interface with identifier interfaceId, false otherwise\r\n     */\r\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\r\n        private\r\n        view\r\n        returns (bool, bool)\r\n    {\r\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\r\n        (bool success, bytes memory result) = account.staticcall.gas(30000)(encodedParams);\r\n        if (result.length \u003C 32) return (false, false);\r\n        return (success, abi.decode(result, (bool)));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC165CheckerMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC165CheckerMock {\r\n    using ERC165Checker for address;\r\n\r\n    function supportsERC165(address account) public view returns (bool) {\r\n        return account._supportsERC165();\r\n    }\r\n\r\n    function supportsInterface(address account, bytes4 interfaceId) public view returns (bool) {\r\n        return account._supportsInterface(interfaceId);\r\n    }\r\n\r\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) public view returns (bool) {\r\n        return account._supportsAllInterfaces(interfaceIds);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC165Mock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC165Mock is ERC165 {\r\n    function registerInterface(bytes4 interfaceId) public {\r\n        _registerInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC1820ImplementerMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC1820ImplementerMock is ERC1820Implementer {\r\n    function registerInterfaceForAddress(bytes32 interfaceHash, address account) public {\r\n        _registerInterfaceForAddress(interfaceHash, account);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/ERC20Burnable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\ncontract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_burnFrom}.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _burnFrom(account, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20BurnableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC20BurnableMock is ERC20Burnable {\r\n    constructor (address initialAccount, uint256 initialBalance) public {\r\n        _mint(initialAccount, initialBalance);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/ERC20Capped.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\r\n */\r\ncontract ERC20Capped is ERC20 {\r\n    uint256 private _cap;\r\n\r\n    /**\r\n     * @dev Sets the value of the \u0060cap\u0060. This value is immutable, it can only be\r\n     * set once during construction.\r\n     */\r\n    constructor (uint256 cap) public {\r\n        require(cap \u003E 0, \u0022ERC20Capped: cap is 0\u0022);\r\n        _cap = cap;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the cap on the token\u0027s total supply.\r\n     */\r\n    function cap() public view returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - minted tokens must not cause the total supply to go over the cap.\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n\r\n        if (from == address(0)) { // When minting tokens\r\n            require(totalSupply().add(amount) \u003C= _cap, \u0022ERC20Capped: cap exceeded\u0022);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20CappedMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC20CappedMock is ERC20Capped {\r\n    constructor (uint256 cap) public ERC20Capped(cap) { }\r\n\r\n    function mint(address to, uint256 tokenId) public {\r\n        _mint(to, tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20DetailedMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract ERC20DetailedMock is ERC20, ERC20Detailed {\r\n    constructor (string memory name, string memory symbol, uint8 decimals)\r\n        public\r\n        ERC20Detailed(name, symbol, decimals)\r\n    {\r\n\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20MetadataMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract ERC20MetadataMock is ERC20, ERC20Metadata {\r\n    constructor (string memory tokenURI) public ERC20Metadata(tokenURI) { }\r\n\r\n    function setTokenURI(string memory tokenURI) public {\r\n        _setTokenURI(tokenURI);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20Mock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n// mock class using ERC20\r\ncontract ERC20Mock is ERC20 {\r\n    constructor (address initialAccount, uint256 initialBalance) public {\r\n        _mint(initialAccount, initialBalance);\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public {\r\n        _burnFrom(account, amount);\r\n    }\r\n\r\n    function transferInternal(address from, address to, uint256 value) public {\r\n        _transfer(from, to, value);\r\n    }\r\n\r\n    function approveInternal(address owner, address spender, uint256 value) public {\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/ERC20Pausable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev ERC20 with pausable transfers and allowances.\r\n *\r\n * Useful if you want to stop trades until the end of a crowdsale, or have\r\n * an emergency switch for freezing all token transfers in the event of a large\r\n * bug.\r\n */\r\ncontract ERC20Pausable is ERC20, Pausable {\r\n    /**\r\n     * @dev See {ERC20-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n\r\n        require(!paused(), \u0022ERC20Pausable: token transfer while paused\u0022);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20PausableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n// mock class using ERC20Pausable\r\ncontract ERC20PausableMock is ERC20Pausable {\r\n    constructor (address initialAccount, uint256 initialBalance) public {\r\n        _mint(initialAccount, initialBalance);\r\n    }\r\n\r\n    function pause() external {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC20SnapshotMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract ERC20SnapshotMock is ERC20Snapshot {\r\n    constructor(address initialAccount, uint256 initialBalance) public {\r\n        _mint(initialAccount, initialBalance);\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public {\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Burnable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Burnable Token\r\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract ERC721Burnable is Context, ERC721 {\r\n    /**\r\n     * @dev Burns a specific ERC721 token.\r\n     * @param tokenId uint256 id of the ERC721 token to be burned.\r\n     */\r\n    function burn(uint256 tokenId) public virtual {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \u0022ERC721Burnable: caller is not owner nor approved\u0022);\r\n        _burn(tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721BurnableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC721BurnableMock is ERC721Burnable {\r\n    function mint(address to, uint256 tokenId) public {\r\n        _mint(to, tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721FullMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721FullMock\r\n * This mock just provides public functions for setting metadata URI, getting all tokens of an owner,\r\n * checking token existence, removal of a token from an address\r\n */\r\ncontract ERC721FullMock is ERC721Full, ERC721Burnable {\r\n    constructor (string memory name, string memory symbol) public ERC721Full(name, symbol) { }\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function tokensOfOwner(address owner) public view returns (uint256[] memory) {\r\n        return _tokensOfOwner(owner);\r\n    }\r\n\r\n    function setTokenURI(uint256 tokenId, string memory uri) public {\r\n        _setTokenURI(tokenId, uri);\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public {\r\n        _setBaseURI(baseURI);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Full) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public {\r\n        _mint(to, tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721GSNRecipientMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721GSNRecipientMock\r\n * A simple ERC721 mock that has GSN support enabled\r\n */\r\ncontract ERC721GSNRecipientMock is ERC721, GSNRecipient, GSNRecipientSignature {\r\n    constructor(address trustedSigner) public GSNRecipientSignature(trustedSigner) { }\r\n\r\n    function mint(uint256 tokenId) public {\r\n        _mint(_msgSender(), tokenId);\r\n    }\r\n\r\n    function _msgSender() internal view override(Context, GSNRecipient) returns (address payable) {\r\n        return GSNRecipient._msgSender();\r\n    }\r\n\r\n    function _msgData() internal view override(Context, GSNRecipient) returns (bytes memory) {\r\n        return GSNRecipient._msgData();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721Mock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC721Mock\r\n * This mock just provides a public safeMint, mint, and burn functions for testing purposes\r\n */\r\ncontract ERC721Mock is ERC721 {\r\n    function safeMint(address to, uint256 tokenId) public {\r\n        _safeMint(to, tokenId);\r\n    }\r\n\r\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public {\r\n        _safeMint(to, tokenId, _data);\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public {\r\n        _mint(to, tokenId);\r\n    }\r\n\r\n    function burn(address owner, uint256 tokenId) public {\r\n        _burn(owner, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public {\r\n        _burn(tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Pausable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Pausable token\r\n * @dev ERC721 modified with pausable transfers.\r\n */\r\ncontract ERC721Pausable is ERC721, Pausable {\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        require(!paused(), \u0022ERC721Pausable: token transfer while paused\u0022);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721PausableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC721PausableMock\r\n * This mock just provides a public mint, burn and exists functions for testing purposes\r\n */\r\ncontract ERC721PausableMock is ERC721Pausable {\r\n    function mint(address to, uint256 tokenId) public {\r\n        super._mint(to, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public {\r\n        super._burn(tokenId);\r\n    }\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return super._exists(tokenId);\r\n    }\r\n\r\n    function pause() external {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC721ReceiverMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC721ReceiverMock is IERC721Receiver {\r\n    bytes4 private _retval;\r\n    bool private _reverts;\r\n\r\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\r\n\r\n    constructor (bytes4 retval, bool reverts) public {\r\n        _retval = retval;\r\n        _reverts = reverts;\r\n    }\r\n\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n        public override returns (bytes4)\r\n    {\r\n        require(!_reverts, \u0022ERC721ReceiverMock: reverting\u0022);\r\n        emit Received(operator, from, tokenId, data, gasleft());\r\n        return _retval;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC777/IERC777.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See {IERC1820Registry} and\r\n * {ERC1820Implementer}.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (\u0060owner\u0060).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * If send or receive hooks are registered for the caller and \u0060recipient\u0060,\r\n     * the corresponding functions will be called with \u0060data\u0060 and empty\r\n     * \u0060operatorData\u0060. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least \u0060amount\u0060 tokens.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - if \u0060recipient\u0060 is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from the caller\u0027s account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with \u0060data\u0060 and empty \u0060operatorData\u0060. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least \u0060amount\u0060 tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of \u0060tokenHolder\u0060.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See {operatorSend} and {operatorBurn}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor}.\r\n     *\r\n     * Emits an {AuthorizedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060operator\u0060 cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor} and {defaultOperators}.\r\n     *\r\n     * Emits a {RevokedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060operator\u0060 cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if {authorizeOperator} was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060. The caller must\r\n     * be an operator of \u0060sender\u0060.\r\n     *\r\n     * If send or receive hooks are registered for \u0060sender\u0060 and \u0060recipient\u0060,\r\n     * the corresponding functions will be called with \u0060data\u0060 and\r\n     * \u0060operatorData\u0060. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060sender\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have at least \u0060amount\u0060 tokens.\r\n     * - the caller must be an operator for \u0060sender\u0060.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - if \u0060recipient\u0060 is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destoys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the total supply.\r\n     * The caller must be an operator of \u0060account\u0060.\r\n     *\r\n     * If a send hook is registered for \u0060account\u0060, the corresponding function\r\n     * will be called with \u0060data\u0060 and \u0060operatorData\u0060. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n     * - the caller must be an operator for \u0060account\u0060.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC777/IERC777Recipient.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (\u0060to\u0060). The type of operation\r\n     * is conveyed by \u0060from\u0060 being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract\u0027s state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC777/IERC777Sender.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * {IERC777} Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n *  their own implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever a registered holder\u0027s\r\n     * (\u0060from\u0060) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by \u0060to\u0060 being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract\u0027s state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/introspection/IERC1820Registry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets \u0060newManager\u0060 as the manager for \u0060account\u0060. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of \u00600x0\u0060 in\r\n     * \u0060newManager\u0060 will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for \u0060account\u0060.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for \u0060account\u0060.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the \u0060implementer\u0060 contract as \u0060account\u0060\u0027s implementer for\r\n     * \u0060interfaceHash\u0060.\r\n     *\r\n     * \u0060account\u0060 being the zero address is an alias for the caller\u0027s address.\r\n     * The zero address can also be used in \u0060implementer\u0060 to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for \u0060account\u0060.\r\n     * - \u0060interfaceHash\u0060 must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - \u0060implementer\u0060 must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless \u0060implementer\u0060 is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of \u0060interfaceHash\u0060 for \u0060account\u0060. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If \u0060interfaceHash\u0060 is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), \u0060account\u0060 will be queried for support of it.\r\n     *\r\n     * \u0060account\u0060 being the zero address is an alias for the caller\u0027s address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an \u0060interfaceName\u0060, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if \u0060account\u0060 implements \u0060interfaceId\u0060, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if \u0060account\u0060 implements \u0060interfaceId\u0060, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC777/ERC777.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC777} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n *\r\n * Support for ERC20 is included in this contract, as specified by the EIP: both\r\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\r\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\r\n * movements.\r\n *\r\n * Additionally, the {IERC777-granularity} value is hard-coded to \u00601\u0060, meaning that there\r\n * are no special restrictions in the amount of tokens that created, moved, or\r\n * destroyed. This makes integration with ERC20 applications seamless.\r\n */\r\ncontract ERC777 is Context, IERC777, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    mapping(address =\u003E uint256) private _balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    // We inline the result of the following hashes because Solidity doesn\u0027t resolve them at compile time.\r\n    // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n    // keccak256(\u0022ERC777TokensSender\u0022)\r\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\r\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n\r\n    // keccak256(\u0022ERC777TokensRecipient\u0022)\r\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\r\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n    // This isn\u0027t ever read from - it\u0027s only used to respond to the defaultOperators query.\r\n    address[] private _defaultOperatorsArray;\r\n\r\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\r\n    mapping(address =\u003E bool) private _defaultOperators;\r\n\r\n    // For each account, a mapping of its operators and revoked default operators.\r\n    mapping(address =\u003E mapping(address =\u003E bool)) private _operators;\r\n    mapping(address =\u003E mapping(address =\u003E bool)) private _revokedDefaultOperators;\r\n\r\n    // ERC20-allowances\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n    /**\r\n     * @dev \u0060defaultOperators\u0060 may be an empty array.\r\n     */\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        address[] memory defaultOperators\r\n    ) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        _defaultOperatorsArray = defaultOperators;\r\n        for (uint256 i = 0; i \u003C _defaultOperatorsArray.length; i\u002B\u002B) {\r\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\r\n        }\r\n\r\n        // register interfaces\r\n        ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\u0022ERC777Token\u0022), address(this));\r\n        ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\u0022ERC20Token\u0022), address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-name}.\r\n     */\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-symbol}.\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20Detailed-decimals}.\r\n     *\r\n     * Always returns 18, as per the\r\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-granularity}.\r\n     *\r\n     * This implementation always returns \u00601\u0060.\r\n     */\r\n    function granularity() public view override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-totalSupply}.\r\n     */\r\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (\u0060tokenHolder\u0060).\r\n     */\r\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\r\n        return _balances[tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-send}.\r\n     *\r\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes memory data) public override  {\r\n        _send(_msgSender(), _msgSender(), recipient, amount, data, \u0022\u0022, true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Unlike \u0060send\u0060, \u0060recipient\u0060 is _not_ required to implement the {IERC777Recipient}\r\n     * interface if it is a contract.\r\n     *\r\n     * Also emits a {Sent} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        require(recipient != address(0), \u0022ERC777: transfer to the zero address\u0022);\r\n\r\n        address from = _msgSender();\r\n\r\n        _callTokensToSend(from, from, recipient, amount, \u0022\u0022, \u0022\u0022);\r\n\r\n        _move(from, from, recipient, amount, \u0022\u0022, \u0022\u0022);\r\n\r\n        _callTokensReceived(from, from, recipient, amount, \u0022\u0022, \u0022\u0022, false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-burn}.\r\n     *\r\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\r\n     */\r\n    function burn(uint256 amount, bytes memory data) public override  {\r\n        _burn(_msgSender(), _msgSender(), amount, data, \u0022\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-isOperatorFor}.\r\n     */\r\n    function isOperatorFor(\r\n        address operator,\r\n        address tokenHolder\r\n    ) public view override returns (bool) {\r\n        return operator == tokenHolder ||\r\n            (_defaultOperators[operator] \u0026\u0026 !_revokedDefaultOperators[tokenHolder][operator]) ||\r\n            _operators[tokenHolder][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-authorizeOperator}.\r\n     */\r\n    function authorizeOperator(address operator) public override  {\r\n        require(_msgSender() != operator, \u0022ERC777: authorizing self as operator\u0022);\r\n\r\n        if (_defaultOperators[operator]) {\r\n            delete _revokedDefaultOperators[_msgSender()][operator];\r\n        } else {\r\n            _operators[_msgSender()][operator] = true;\r\n        }\r\n\r\n        emit AuthorizedOperator(operator, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-revokeOperator}.\r\n     */\r\n    function revokeOperator(address operator) public override  {\r\n        require(operator != _msgSender(), \u0022ERC777: revoking self as operator\u0022);\r\n\r\n        if (_defaultOperators[operator]) {\r\n            _revokedDefaultOperators[_msgSender()][operator] = true;\r\n        } else {\r\n            delete _operators[_msgSender()][operator];\r\n        }\r\n\r\n        emit RevokedOperator(operator, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-defaultOperators}.\r\n     */\r\n    function defaultOperators() public view override returns (address[] memory) {\r\n        return _defaultOperatorsArray;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorSend}.\r\n     *\r\n     * Emits {Sent} and {IERC20-Transfer} events.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    public override\r\n    {\r\n        require(isOperatorFor(_msgSender(), sender), \u0022ERC777: caller is not an operator for holder\u0022);\r\n        _send(_msgSender(), sender, recipient, amount, data, operatorData, true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorBurn}.\r\n     *\r\n     * Emits {Burned} and {IERC20-Transfer} events.\r\n     */\r\n    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\r\n        require(isOperatorFor(_msgSender(), account), \u0022ERC777: caller is not an operator for holder\u0022);\r\n        _burn(_msgSender(), account, amount, data, operatorData);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators may\r\n     * not have allowance, and accounts with allowance may not be operators\r\n     * themselves.\r\n     */\r\n    function allowance(address holder, address spender) public view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Note that accounts cannot have allowance issued by their operators.\r\n     */\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        address holder = _msgSender();\r\n        _approve(holder, spender, value);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    * @dev See {IERC20-transferFrom}.\r\n    *\r\n    * Note that operator and allowance concepts are orthogonal: operators cannot\r\n    * call \u0060transferFrom\u0060 (unless they have allowance), and accounts with\r\n    * allowance cannot call \u0060operatorSend\u0060 (unless they are operators).\r\n    *\r\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\r\n    */\r\n    function transferFrom(address holder, address recipient, uint256 amount) public override returns (bool) {\r\n        require(recipient != address(0), \u0022ERC777: transfer to the zero address\u0022);\r\n        require(holder != address(0), \u0022ERC777: transfer from the zero address\u0022);\r\n\r\n        address spender = _msgSender();\r\n\r\n        _callTokensToSend(spender, holder, recipient, amount, \u0022\u0022, \u0022\u0022);\r\n\r\n        _move(spender, holder, recipient, amount, \u0022\u0022, \u0022\u0022);\r\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \u0022ERC777: transfer amount exceeds allowance\u0022));\r\n\r\n        _callTokensReceived(spender, holder, recipient, amount, \u0022\u0022, \u0022\u0022, false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n     * the total supply.\r\n     *\r\n     * If a send hook is registered for \u0060account\u0060, the corresponding function\r\n     * will be called with \u0060operator\u0060, \u0060data\u0060 and \u0060operatorData\u0060.\r\n     *\r\n     * See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits {Minted} and {IERC20-Transfer} events.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - if \u0060account\u0060 is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function _mint(\r\n        address operator,\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n    internal virtual\r\n    {\r\n        require(account != address(0), \u0022ERC777: mint to the zero address\u0022);\r\n\r\n        // Update state variables\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\r\n\r\n        emit Minted(operator, account, amount, userData, operatorData);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _send(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        internal\r\n    {\r\n        require(from != address(0), \u0022ERC777: send from the zero address\u0022);\r\n        require(to != address(0), \u0022ERC777: send to the zero address\u0022);\r\n\r\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n        _move(operator, from, to, amount, userData, operatorData);\r\n\r\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens\r\n     * @param operator address operator requesting the operation\r\n     * @param from address token holder address\r\n     * @param amount uint256 amount of tokens to burn\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _burn(\r\n        address operator,\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n        internal virtual\r\n    {\r\n        require(from != address(0), \u0022ERC777: burn from the zero address\u0022);\r\n\r\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n        // Update state variables\r\n        _balances[from] = _balances[from].sub(amount, \u0022ERC777: burn amount exceeds balance\u0022);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n\r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _move(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        private\r\n    {\r\n        _beforeTokenTransfer(operator, from, to, amount);\r\n\r\n        _balances[from] = _balances[from].sub(amount, \u0022ERC777: transfer amount exceeds balance\u0022);\r\n        _balances[to] = _balances[to].add(amount);\r\n\r\n        emit Sent(operator, from, to, amount, userData, operatorData);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve(address holder, address spender, uint256 value) internal {\r\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\r\n        // currently unnecessary.\r\n        //require(holder != address(0), \u0022ERC777: approve from the zero address\u0022);\r\n        require(spender != address(0), \u0022ERC777: approve to the zero address\u0022);\r\n\r\n        _allowances[holder][spender] = value;\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Call from.tokensToSend() if the interface is registered\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _callTokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        address implementer = ERC1820_REGISTRY.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n     * tokensReceived() was not registered for the recipient\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _callTokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        internal\r\n    {\r\n        address implementer = ERC1820_REGISTRY.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n        } else if (requireReceptionAck) {\r\n            require(!to.isContract(), \u0022ERC777: token recipient contract has no implementer for ERC777TokensRecipient\u0022);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes\r\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when \u0060from\u0060 and \u0060to\u0060 are both non-zero, \u0060from\u0060\u0027s \u0060tokenId\u0060 will be\r\n     * transferred to \u0060to\u0060.\r\n     * - when \u0060from\u0060 is zero, \u0060tokenId\u0060 will be minted for \u0060to\u0060.\r\n     * - when \u0060to\u0060 is zero, \u0060from\u0060\u0027s \u0060tokenId\u0060 will be burned.\r\n     * - \u0060from\u0060 and \u0060to\u0060 are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 tokenId) internal virtual { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC777Mock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract ERC777Mock is Context, ERC777 {\r\n    constructor(\r\n        address initialHolder,\r\n        uint256 initialBalance,\r\n        string memory name,\r\n        string memory symbol,\r\n        address[] memory defaultOperators\r\n    ) public ERC777(name, symbol, defaultOperators) {\r\n        _mint(_msgSender(), initialHolder, initialBalance, \u0022\u0022, \u0022\u0022);\r\n    }\r\n\r\n    function mintInternal (\r\n        address operator,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    ) public {\r\n        _mint(operator, to, amount, userData, operatorData);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC777SenderRecipientMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC777SenderRecipientMock is Context, IERC777Sender, IERC777Recipient, ERC1820Implementer {\r\n    event TokensToSendCalled(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData,\r\n        address token,\r\n        uint256 fromBalance,\r\n        uint256 toBalance\r\n    );\r\n\r\n    event TokensReceivedCalled(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData,\r\n        address token,\r\n        uint256 fromBalance,\r\n        uint256 toBalance\r\n    );\r\n\r\n    bool private _shouldRevertSend;\r\n    bool private _shouldRevertReceive;\r\n\r\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH = keccak256(\u0022ERC777TokensSender\u0022);\r\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\u0022ERC777TokensRecipient\u0022);\r\n\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external override {\r\n        if (_shouldRevertSend) {\r\n            revert();\r\n        }\r\n\r\n        IERC777 token = IERC777(_msgSender());\r\n\r\n        uint256 fromBalance = token.balanceOf(from);\r\n        // when called due to burn, to will be the zero address, which will have a balance of 0\r\n        uint256 toBalance = token.balanceOf(to);\r\n\r\n        emit TokensToSendCalled(\r\n            operator,\r\n            from,\r\n            to,\r\n            amount,\r\n            userData,\r\n            operatorData,\r\n            address(token),\r\n            fromBalance,\r\n            toBalance\r\n        );\r\n    }\r\n\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external override {\r\n        if (_shouldRevertReceive) {\r\n            revert();\r\n        }\r\n\r\n        IERC777 token = IERC777(_msgSender());\r\n\r\n        uint256 fromBalance = token.balanceOf(from);\r\n        // when called due to burn, to will be the zero address, which will have a balance of 0\r\n        uint256 toBalance = token.balanceOf(to);\r\n\r\n        emit TokensReceivedCalled(\r\n            operator,\r\n            from,\r\n            to,\r\n            amount,\r\n            userData,\r\n            operatorData,\r\n            address(token),\r\n            fromBalance,\r\n            toBalance\r\n        );\r\n    }\r\n\r\n    function senderFor(address account) public {\r\n        _registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH, account);\r\n\r\n        address self = address(this);\r\n        if (account == self) {\r\n            registerSender(self);\r\n        }\r\n    }\r\n\r\n    function registerSender(address sender) public {\r\n        _erc1820.setInterfaceImplementer(address(this), TOKENS_SENDER_INTERFACE_HASH, sender);\r\n    }\r\n\r\n    function recipientFor(address account) public {\r\n        _registerInterfaceForAddress(TOKENS_RECIPIENT_INTERFACE_HASH, account);\r\n\r\n        address self = address(this);\r\n        if (account == self) {\r\n            registerRecipient(self);\r\n        }\r\n    }\r\n\r\n    function registerRecipient(address recipient) public {\r\n        _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, recipient);\r\n    }\r\n\r\n    function setShouldRevertSend(bool shouldRevert) public {\r\n        _shouldRevertSend = shouldRevert;\r\n    }\r\n\r\n    function setShouldRevertReceive(bool shouldRevert) public {\r\n        _shouldRevertReceive = shouldRevert;\r\n    }\r\n\r\n    function send(IERC777 token, address to, uint256 amount, bytes memory data) public {\r\n        // This is 777\u0027s send function, not the Solidity send function\r\n        token.send(to, amount, data); // solhint-disable-line check-send-result\r\n    }\r\n\r\n    function burn(IERC777 token, uint256 amount, bytes memory data) public {\r\n        token.burn(amount, data);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/GSNRecipientERC20FeeMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract GSNRecipientERC20FeeMock is GSNRecipient, GSNRecipientERC20Fee {\r\n    constructor(string memory name, string memory symbol) public GSNRecipientERC20Fee(name, symbol) { }\r\n\r\n    function mint(address account, uint256 amount) public {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    event MockFunctionCalled(uint256 senderBalance);\r\n\r\n    function mockFunction() public {\r\n        emit MockFunctionCalled(token().balanceOf(_msgSender()));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/GSNRecipientMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n// By inheriting from GSNRecipient, Context\u0027s internal functions are overridden automatically\r\ncontract GSNRecipientMock is ContextMock, GSNRecipient {\r\n    function withdrawDeposits(uint256 amount, address payable payee) public {\r\n        _withdrawDeposits(amount, payee);\r\n    }\r\n\r\n    function acceptRelayedCall(address, address, bytes calldata, uint256, uint256, uint256, uint256, bytes calldata, uint256)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256, bytes memory)\r\n    {\r\n        return (0, \u0022\u0022);\r\n    }\r\n\r\n    function _preRelayedCall(bytes memory) internal override returns (bytes32) { }\r\n\r\n    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal override { }\r\n\r\n    function upgradeRelayHub(address newRelayHub) public {\r\n        return _upgradeRelayHub(newRelayHub);\r\n    }\r\n\r\n    function _msgSender() internal override(Context, GSNRecipient) view virtual returns (address payable) {\r\n        return GSNRecipient._msgSender();\r\n    }\r\n\r\n    function _msgData() internal override(Context, GSNRecipient) view virtual returns (bytes memory) {\r\n        return GSNRecipient._msgData();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/GSNRecipientSignatureMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract GSNRecipientSignatureMock is GSNRecipient, GSNRecipientSignature {\r\n    constructor(address trustedSigner) public GSNRecipientSignature(trustedSigner) { }\r\n\r\n    event MockFunctionCalled();\r\n\r\n    function mockFunction() public {\r\n        emit MockFunctionCalled();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/MathMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract MathMock {\r\n    function max(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return Math.max(a, b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return Math.min(a, b);\r\n    }\r\n\r\n    function average(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return Math.average(a, b);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/cryptography/MerkleProof.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a \u0060leaf\u0060 can be proved to be a part of a Merkle tree\r\n     * defined by \u0060root\u0060. For this, a \u0060proof\u0060 must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i \u003C proof.length; i\u002B\u002B) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash \u003C= proofElement) {\r\n                // Hash(current computed hash \u002B current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof \u002B current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/MerkleProofWrapper.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract MerkleProofWrapper {\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) public pure returns (bool) {\r\n        return MerkleProof.verify(proof, root, leaf);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/OwnableInterfaceId.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Ownable interface id calculator.\r\n * @dev See the EIP165 specification for more information:\r\n * https://eips.ethereum.org/EIPS/eip-165#specification\r\n */\r\ncontract OwnableInterfaceId {\r\n    function getInterfaceId() public pure returns (bytes4) {\r\n        Ownable i;\r\n        return i.owner.selector ^ i.isOwner.selector ^ i.renounceOwnership.selector ^ i.transferOwnership.selector;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/OwnableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract OwnableMock is Ownable { }\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/PausableMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract PausableMock is Pausable {\r\n    bool public drasticMeasureTaken;\r\n    uint256 public count;\r\n\r\n    constructor () public {\r\n        drasticMeasureTaken = false;\r\n        count = 0;\r\n    }\r\n\r\n    function normalProcess() external whenNotPaused {\r\n        count\u002B\u002B;\r\n    }\r\n\r\n    function drasticMeasure() external whenPaused {\r\n        drasticMeasureTaken = true;\r\n    }\r\n\r\n    function pause() external {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/payment/PullPayment.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Simple implementation of a\r\n * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]\r\n * strategy, where the paying contract doesn\u0027t interact directly with the\r\n * receiver account, which must withdraw its payments itself.\r\n *\r\n * Pull-payments are often considered the best practice when it comes to sending\r\n * Ether, security-wise. It prevents recipients from blocking execution, and\r\n * eliminates reentrancy concerns.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * To use, derive from the \u0060PullPayment\u0060 contract, and use {_asyncTransfer}\r\n * instead of Solidity\u0027s \u0060transfer\u0060 function. Payees can query their due\r\n * payments with {payments}, and retrieve them with {withdrawPayments}.\r\n */\r\ncontract PullPayment {\r\n    Escrow private _escrow;\r\n\r\n    constructor () internal {\r\n        _escrow = new Escrow();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated payments.\r\n     *\r\n     * Note that _any_ account can call this function, not just the \u0060payee\u0060.\r\n     * This means that contracts unaware of the \u0060PullPayment\u0060 protocol can still\r\n     * receive funds this way, by having a separate account call\r\n     * {withdrawPayments}.\r\n     *\r\n     * NOTE: This function has been deprecated, use {withdrawPaymentsWithGas}\r\n     * instead. Calling contracts with fixed gas limits is an anti-pattern and\r\n     * may break contract interactions in network upgrades (hardforks).\r\n     * https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more.]\r\n     *\r\n     * @param payee Whose payments will be withdrawn.\r\n     */\r\n    function withdrawPayments(address payable payee) public virtual {\r\n        _escrow.withdraw(payee);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {withdrawPayments}, but forwarding all gas to the recipient.\r\n     *\r\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\r\n     * Make sure you trust the recipient, or are either following the\r\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function withdrawPaymentsWithGas(address payable payee) external virtual {\r\n        _escrow.withdrawWithGas(payee);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the payments owed to an address.\r\n     * @param dest The creditor\u0027s address.\r\n     */\r\n    function payments(address dest) public view returns (uint256) {\r\n        return _escrow.depositsOf(dest);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\r\n     * there is no danger of them being spent before withdrawal.\r\n     *\r\n     * @param dest The destination address of the funds.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\r\n        _escrow.deposit.value(amount)(dest);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/PullPaymentMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n// mock class using PullPayment\r\ncontract PullPaymentMock is PullPayment {\r\n    constructor () public payable { }\r\n\r\n    // test helper function to call asyncTransfer\r\n    function callTransfer(address dest, uint256 amount) public {\r\n        _asyncTransfer(dest, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ReentrancyAttack.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract ReentrancyAttack is Context {\r\n    function callSender(bytes4 data) public {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = _msgSender().call(abi.encodeWithSelector(data));\r\n        require(success, \u0022ReentrancyAttack: failed call\u0022);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from \u0060ReentrancyGuard\u0060 will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single \u0060nonReentrant\u0060 guard, functions marked as\r\n * \u0060nonReentrant\u0060 may not call one another. This can be worked around by making\r\n * those functions \u0060private\u0060, and then adding \u0060external\u0060 \u0060nonReentrant\u0060 entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction\u0027s gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \u0022ReentrancyGuard: reentrant call\u0022);\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ReentrancyMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract ReentrancyMock is ReentrancyGuard {\r\n    uint256 public counter;\r\n\r\n    constructor () public {\r\n        counter = 0;\r\n    }\r\n\r\n    function callback() external nonReentrant {\r\n        count();\r\n    }\r\n\r\n    function countLocalRecursive(uint256 n) public nonReentrant {\r\n        if (n \u003E 0) {\r\n            count();\r\n            countLocalRecursive(n - 1);\r\n        }\r\n    }\r\n\r\n    function countThisRecursive(uint256 n) public nonReentrant {\r\n        if (n \u003E 0) {\r\n            count();\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success,) = address(this).call(abi.encodeWithSignature(\u0022countThisRecursive(uint256)\u0022, n - 1));\r\n            require(success, \u0022ReentrancyMock: failed call\u0022);\r\n        }\r\n    }\r\n\r\n    function countAndCall(ReentrancyAttack attacker) public nonReentrant {\r\n        count();\r\n        bytes4 func = bytes4(keccak256(\u0022callback()\u0022));\r\n        attacker.callSender(func);\r\n    }\r\n\r\n    function count() private {\r\n        counter \u002B= 1;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/RolesMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract RolesMock {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private dummyRole;\r\n\r\n    function add(address account) public {\r\n        dummyRole.add(account);\r\n    }\r\n\r\n    function remove(address account) public {\r\n        dummyRole.remove(account);\r\n    }\r\n\r\n    function has(address account) public view returns (bool) {\r\n        return dummyRole.has(account);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. \u0060SafeCast\u0060 restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on \u0060uint256\u0060 and then downcasting.\r\n *\r\n * _Available since v2.5.0._\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060uint128\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value \u003C 2**128, \u0022SafeCast: value doesn\\\u0027t fit in 128 bits\u0022);\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060uint64\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value \u003C 2**64, \u0022SafeCast: value doesn\\\u0027t fit in 64 bits\u0022);\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060uint32\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value \u003C 2**32, \u0022SafeCast: value doesn\\\u0027t fit in 32 bits\u0022);\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060uint16\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value \u003C 2**16, \u0022SafeCast: value doesn\\\u0027t fit in 16 bits\u0022);\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060uint8\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value \u003C 2**8, \u0022SafeCast: value doesn\\\u0027t fit in 8 bits\u0022);\r\n        return uint8(value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/SafeCastMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract SafeCastMock {\r\n    using SafeCast for uint;\r\n\r\n    function toUint128(uint a) public pure returns (uint128) {\r\n        return a.toUint128();\r\n    }\r\n\r\n    function toUint64(uint a) public pure returns (uint64) {\r\n        return a.toUint64();\r\n    }\r\n\r\n    function toUint32(uint a) public pure returns (uint32) {\r\n        return a.toUint32();\r\n    }\r\n\r\n    function toUint16(uint a) public pure returns (uint16) {\r\n        return a.toUint16();\r\n    }\r\n\r\n    function toUint8(uint a) public pure returns (uint8) {\r\n        return a.toUint8();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/SafeERC20Helper.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\ncontract ERC20ReturnFalseMock is Context {\r\n    uint256 private _allowance;\r\n\r\n    // IERC20\u0027s functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\r\n    // we write to a dummy state variable.\r\n    uint256 private _dummy;\r\n\r\n    function transfer(address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address, address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return false;\r\n    }\r\n\r\n    function approve(address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return false;\r\n    }\r\n\r\n    function allowance(address, address) public view returns (uint256) {\r\n        require(_dummy == 0); // Duummy read from a state variable so that the function is view\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract ERC20ReturnTrueMock is Context {\r\n    mapping (address =\u003E uint256) private _allowances;\r\n\r\n    // IERC20\u0027s functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\r\n    // we write to a dummy state variable.\r\n    uint256 private _dummy;\r\n\r\n    function transfer(address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address, address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return true;\r\n    }\r\n\r\n    function approve(address, uint256) public returns (bool) {\r\n        _dummy = 0;\r\n        return true;\r\n    }\r\n\r\n    function setAllowance(uint256 allowance_) public {\r\n        _allowances[_msgSender()] = allowance_;\r\n    }\r\n\r\n    function allowance(address owner, address) public view returns (uint256) {\r\n        return _allowances[owner];\r\n    }\r\n}\r\n\r\ncontract ERC20NoReturnMock is Context {\r\n    mapping (address =\u003E uint256) private _allowances;\r\n\r\n    // IERC20\u0027s functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\r\n    // we write to a dummy state variable.\r\n    uint256 private _dummy;\r\n\r\n    function transfer(address, uint256) public {\r\n        _dummy = 0;\r\n    }\r\n\r\n    function transferFrom(address, address, uint256) public {\r\n        _dummy = 0;\r\n    }\r\n\r\n    function approve(address, uint256) public {\r\n        _dummy = 0;\r\n    }\r\n\r\n    function setAllowance(uint256 allowance_) public {\r\n        _allowances[_msgSender()] = allowance_;\r\n    }\r\n\r\n    function allowance(address owner, address) public view returns (uint256) {\r\n        return _allowances[owner];\r\n    }\r\n}\r\n\r\ncontract SafeERC20Wrapper is Context {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 private _token;\r\n\r\n    constructor (IERC20 token) public {\r\n        _token = token;\r\n    }\r\n\r\n    function transfer() public {\r\n        _token.safeTransfer(address(0), 0);\r\n    }\r\n\r\n    function transferFrom() public {\r\n        _token.safeTransferFrom(address(0), address(0), 0);\r\n    }\r\n\r\n    function approve(uint256 amount) public {\r\n        _token.safeApprove(address(0), amount);\r\n    }\r\n\r\n    function increaseAllowance(uint256 amount) public {\r\n        _token.safeIncreaseAllowance(address(0), amount);\r\n    }\r\n\r\n    function decreaseAllowance(uint256 amount) public {\r\n        _token.safeDecreaseAllowance(address(0), amount);\r\n    }\r\n\r\n    function setAllowance(uint256 allowance_) public {\r\n        ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);\r\n    }\r\n\r\n    function allowance() public view returns (uint256) {\r\n        return _token.allowance(address(0), address(0));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/SafeMathMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract SafeMathMock {\r\n    function mul(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return SafeMath.mul(a, b);\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return SafeMath.div(a, b);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return SafeMath.sub(a, b);\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return SafeMath.add(a, b);\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return SafeMath.mod(a, b);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/SecondaryMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract SecondaryMock is Secondary {\r\n    function onlyPrimaryMock() public view onlyPrimary { }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/SignedSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 \u0026\u0026 b == INT256_MIN), \u0022SignedSafeMath: multiplication overflow\u0022);\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \u0022SignedSafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \u0022SignedSafeMath: division by zero\u0022);\r\n        require(!(b == -1 \u0026\u0026 a == INT256_MIN), \u0022SignedSafeMath: division overflow\u0022);\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b \u003E= 0 \u0026\u0026 c \u003C= a) || (b \u003C 0 \u0026\u0026 c \u003E a), \u0022SignedSafeMath: subtraction overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a \u002B b;\r\n        require((b \u003E= 0 \u0026\u0026 c \u003E= a) || (b \u003C 0 \u0026\u0026 c \u003C a), \u0022SignedSafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/SignedSafeMathMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract SignedSafeMathMock {\r\n    function mul(int256 a, int256 b) public pure returns (int256) {\r\n        return SignedSafeMath.mul(a, b);\r\n    }\r\n\r\n    function div(int256 a, int256 b) public pure returns (int256) {\r\n        return SignedSafeMath.div(a, b);\r\n    }\r\n\r\n    function sub(int256 a, int256 b) public pure returns (int256) {\r\n        return SignedSafeMath.sub(a, b);\r\n    }\r\n\r\n    function add(int256 a, int256 b) public pure returns (int256) {\r\n        return SignedSafeMath.add(a, b);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/drafts/Strings.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title Strings\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a \u0060uint256\u0060 to a \u0060string\u0060.\r\n     * via OraclizeAPI - MIT licence\r\n     * https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n     */\r\n    function fromUint256(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \u00220\u0022;\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits\u002B\u002B;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 \u002B temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/StringsMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract StringsMock {\r\n    function fromUint256(uint256 value) public pure returns (string memory) {\r\n        return Strings.fromUint256(value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/payment/escrow/RefundEscrow.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title RefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\r\n * parties.\r\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\r\n * @dev The primary account (that is, the contract that instantiates this\r\n * contract) may deposit, close the deposit period, and allow for either\r\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\r\n * with \u0060RefundEscrow\u0060 will be made through the primary contract. See the\r\n * \u0060RefundableCrowdsale\u0060 contract for an example of \u0060RefundEscrow\u0060\u2019s use.\r\n */\r\ncontract RefundEscrow is ConditionalEscrow {\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    event RefundsClosed();\r\n    event RefundsEnabled();\r\n\r\n    State private _state;\r\n    address payable private _beneficiary;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param beneficiary The beneficiary of the deposits.\r\n     */\r\n    constructor (address payable beneficiary) public {\r\n        require(beneficiary != address(0), \u0022RefundEscrow: beneficiary is the zero address\u0022);\r\n        _beneficiary = beneficiary;\r\n        _state = State.Active;\r\n    }\r\n\r\n    /**\r\n     * @return The current state of the escrow.\r\n     */\r\n    function state() public view returns (State) {\r\n        return _state;\r\n    }\r\n\r\n    /**\r\n     * @return The beneficiary of the escrow.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores funds that may later be refunded.\r\n     * @param refundee The address funds will be sent to if a refund occurs.\r\n     */\r\n    function deposit(address refundee) public payable virtual override {\r\n        require(_state == State.Active, \u0022RefundEscrow: can only deposit while active\u0022);\r\n        super.deposit(refundee);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n     * further deposits.\r\n     */\r\n    function close() public onlyPrimary virtual {\r\n        require(_state == State.Active, \u0022RefundEscrow: can only close while active\u0022);\r\n        _state = State.Closed;\r\n        emit RefundsClosed();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for refunds to take place, rejecting further deposits.\r\n     */\r\n    function enableRefunds() public onlyPrimary virtual {\r\n        require(_state == State.Active, \u0022RefundEscrow: can only enable refunds while active\u0022);\r\n        _state = State.Refunding;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the beneficiary\u0027s funds.\r\n     */\r\n    function beneficiaryWithdraw() public virtual {\r\n        require(_state == State.Closed, \u0022RefundEscrow: beneficiary can only withdraw while closed\u0022);\r\n        _beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\r\n     * \u0027payee\u0027 argument, but we ignore it here since the condition is global, not per-payee.\r\n     */\r\n    function withdrawalAllowed(address) public view override returns (bool) {\r\n        return _state == State.Refunding;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/payment/PaymentSplitter.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title PaymentSplitter\r\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\r\n * that the Ether will be split in this way, since it is handled transparently by the contract.\r\n *\r\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\r\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\r\n * an amount proportional to the percentage of total shares they were assigned.\r\n *\r\n * \u0060PaymentSplitter\u0060 follows a _pull payment_ model. This means that payments are not automatically forwarded to the\r\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\r\n * function.\r\n */\r\ncontract PaymentSplitter is Context {\r\n    using SafeMath for uint256;\r\n\r\n    event PayeeAdded(address account, uint256 shares);\r\n    event PaymentReleased(address to, uint256 amount);\r\n    event PaymentReceived(address from, uint256 amount);\r\n\r\n    uint256 private _totalShares;\r\n    uint256 private _totalReleased;\r\n\r\n    mapping(address =\u003E uint256) private _shares;\r\n    mapping(address =\u003E uint256) private _released;\r\n    address[] private _payees;\r\n\r\n    /**\r\n     * @dev Creates an instance of \u0060PaymentSplitter\u0060 where each account in \u0060payees\u0060 is assigned the number of shares at\r\n     * the matching position in the \u0060shares\u0060 array.\r\n     *\r\n     * All addresses in \u0060payees\u0060 must be non-zero. Both arrays must have the same non-zero length, and there must be no\r\n     * duplicates in \u0060payees\u0060.\r\n     */\r\n    constructor (address[] memory payees, uint256[] memory shares) public payable {\r\n        // solhint-disable-next-line max-line-length\r\n        require(payees.length == shares.length, \u0022PaymentSplitter: payees and shares length mismatch\u0022);\r\n        require(payees.length \u003E 0, \u0022PaymentSplitter: no payees\u0022);\r\n\r\n        for (uint256 i = 0; i \u003C payees.length; i\u002B\u002B) {\r\n            _addPayee(payees[i], shares[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\r\n     * reliable: it\u0027s possible for a contract to receive Ether without triggering this function. This only affects the\r\n     * reliability of the events, and not the actual splitting of Ether.\r\n     *\r\n     * To learn more about this see the Solidity documentation for\r\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\r\n     * functions].\r\n     */\r\n    receive () external payable virtual {\r\n        emit PaymentReceived(_msgSender(), msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total shares held by payees.\r\n     */\r\n    function totalShares() public view returns (uint256) {\r\n        return _totalShares;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total amount of Ether already released.\r\n     */\r\n    function totalReleased() public view returns (uint256) {\r\n        return _totalReleased;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of shares held by an account.\r\n     */\r\n    function shares(address account) public view returns (uint256) {\r\n        return _shares[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of Ether already released to a payee.\r\n     */\r\n    function released(address account) public view returns (uint256) {\r\n        return _released[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the address of the payee number \u0060index\u0060.\r\n     */\r\n    function payee(uint256 index) public view returns (address) {\r\n        return _payees[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers a transfer to \u0060account\u0060 of the amount of Ether they are owed, according to their percentage of the\r\n     * total shares and their previous withdrawals.\r\n     */\r\n    function release(address payable account) public virtual {\r\n        require(_shares[account] \u003E 0, \u0022PaymentSplitter: account has no shares\u0022);\r\n\r\n        uint256 totalReceived = address(this).balance.add(_totalReleased);\r\n        uint256 payment = totalReceived.mul(_shares[account]).div(_totalShares).sub(_released[account]);\r\n\r\n        require(payment != 0, \u0022PaymentSplitter: account is not due payment\u0022);\r\n\r\n        _released[account] = _released[account].add(payment);\r\n        _totalReleased = _totalReleased.add(payment);\r\n\r\n        account.transfer(payment);\r\n        emit PaymentReleased(account, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new payee to the contract.\r\n     * @param account The address of the payee to add.\r\n     * @param shares_ The number of shares owned by the payee.\r\n     */\r\n    function _addPayee(address account, uint256 shares_) private {\r\n        require(account != address(0), \u0022PaymentSplitter: account is the zero address\u0022);\r\n        require(shares_ \u003E 0, \u0022PaymentSplitter: shares are 0\u0022);\r\n        require(_shares[account] == 0, \u0022PaymentSplitter: account already has shares\u0022);\r\n\r\n        _payees.push(account);\r\n        _shares[account] = shares_;\r\n        _totalShares = _totalShares.add(shares_);\r\n        emit PayeeAdded(account, shares_);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC20/TokenTimelock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev A token holder contract that will allow a beneficiary to extract the\r\n * tokens after a given release time.\r\n *\r\n * Useful for simple vesting schedules like \u0022advisors get all of their tokens\r\n * after 1 year\u0022.\r\n *\r\n * For a more complete vesting schedule, see {TokenVesting}.\r\n */\r\ncontract TokenTimelock {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ERC20 basic token contract being held\r\n    IERC20 private _token;\r\n\r\n    // beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // timestamp when token release is enabled\r\n    uint256 private _releaseTime;\r\n\r\n    constructor (IERC20 token, address beneficiary, uint256 releaseTime) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(releaseTime \u003E block.timestamp, \u0022TokenTimelock: release time is before current time\u0022);\r\n        _token = token;\r\n        _beneficiary = beneficiary;\r\n        _releaseTime = releaseTime;\r\n    }\r\n\r\n    /**\r\n     * @return the token being held.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the time when the tokens are released.\r\n     */\r\n    function releaseTime() public view returns (uint256) {\r\n        return _releaseTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by timelock to beneficiary.\r\n     */\r\n    function release() public virtual {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp \u003E= _releaseTime, \u0022TokenTimelock: current time is before release time\u0022);\r\n\r\n        uint256 amount = _token.balanceOf(address(this));\r\n        require(amount \u003E 0, \u0022TokenTimelock: no tokens to release\u0022);\r\n\r\n        _token.safeTransfer(_beneficiary, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/ERC721Holder.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/token/ERC721/IERC721Full.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata { }\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/ERC165/ERC165NotSupported.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract ERC165NotSupported { }\r\n\r\n\r\n// File contracts/openzeppelin-contracts/contracts/mocks/EtherReceiverMock.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract EtherReceiverMock {\r\n    bool private _acceptEther;\r\n\r\n    function setAcceptEther(bool acceptEther) public {\r\n        _acceptEther = acceptEther;\r\n    }\r\n\r\n    receive () external payable {\r\n        if (!_acceptEther) {\r\n            revert();\r\n        }\r\n    }\r\n}","ABI":"[]","ContractName":"Address","CompilerVersion":"v0.6.0\u002Bcommit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"ipfs://5df7f7b4ae12776c810ddb316b52548d362b421791830ee59ca28a08e2654d1f"}]