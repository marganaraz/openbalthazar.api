[{"SourceCode":"/*\r\n|| THE LEXDAO REGISTRY (TLDR) ||\r\n\r\nDEAR MSG.SENDER(S):\r\n\r\n/ TLDR is a project in beta.\r\n// Please audit and use at your own risk.\r\n/// Entry into TLDR shall not create an attorney/client relationship.\r\n//// Likewise, TLDR should not be construed as legal advice or replacement for professional counsel.\r\n\r\n///// STEAL THIS C0D3SL4W \r\n\r\n|| lexDAO || \r\n~presented by Open, ESQ LLC_DAO~\r\n*/\r\n\r\npragma solidity 0.5.9;\r\n\r\n/***************\r\nOPENZEPPELIN REFERENCE CONTRACTS - SafeMath, ScribeRole, ERC-20 scripts\r\n***************/\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address =\u003E bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \u0022Roles: account already has role\u0022);\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account\u0027s access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \u0022Roles: account does not have role\u0022);\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \u0022Roles: account is the zero address\u0022);\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ScribeRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event ScribeAdded(address indexed account);\r\n    event ScribeRemoved(address indexed account);\r\n\r\n    Roles.Role private _Scribes;\r\n\r\n    constructor () internal {\r\n        _addScribe(_msgSender());\r\n    }\r\n\r\n    modifier onlyScribe() {\r\n        require(isScribe(_msgSender()), \u0022ScribeRole: caller does not have the Scribe role\u0022);\r\n        _;\r\n    }\r\n\r\n    function isScribe(address account) public view returns (bool) {\r\n        return _Scribes.has(account);\r\n    }\r\n\r\n    function addScribe(address account) public onlyScribe {\r\n        _addScribe(account);\r\n    }\r\n\r\n    function renounceScribe() public {\r\n        _removeScribe(_msgSender());\r\n    }\r\n\r\n    function _addScribe(address account) internal {\r\n        _Scribes.add(account);\r\n        emit ScribeAdded(account);\r\n    }\r\n\r\n    function _removeScribe(address account) internal {\r\n        _Scribes.remove(account);\r\n        emit ScribeRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/***************\r\nTLDR CONTRACT\r\n***************/\r\n\r\ncontract lexDAORegistry is ScribeRole { // **TLDR: lexDAO-maintained legal engineering registry to wrap and enforce digital transactions with legal and ethereal security**\r\n    using SafeMath for uint256;\r\n    \r\n    // **lexAgon DAO treasury references (aragon.org digital organization)**\r\n\taddress payable public lexAgonDAO = 0xBBE222Ef97076b786f661246232E41BE0DFf6cc4;\r\n\t\r\n\t// **counters for lexScribe lexScriptWrapper and registered DDR**\r\n\tuint256 public LSW = 1; // **number of lexScriptWrappers enscribed herein**\r\n\tuint256 public RDDR; // **number of DDRs registered hereby**\r\n\t\r\n\t// **internal lexScript references** //\r\n\tuint256 private lexRate; // **rate paid from payDDR transaction to associated lexAddress (lexFee)**\r\n\taddress private lexAddress; // **lexScribe nominated lexAddress to receive lexFee**\r\n    \r\n    mapping(address =\u003E uint256) public reputation; // **mapping lexScribe reputation**\r\n    mapping(address =\u003E uint256) public lastActionTimestamp; // **mapping lexScribe governance actions*\r\n    \r\n    mapping (uint256 =\u003E lexScriptWrapper) public lexScript; // **mapping registered lexScript \u0027wet code\u0027 templates**\r\n\tmapping (uint256 =\u003E DDR) public rddr; // **mapping registered rddr call numbers**\r\n\t\r\n    struct lexScriptWrapper { // **LSW: Digital Dollar Retainer (DDR) lexScript templates maintained by lexDAO scribes (lexScribe)**\r\n            address lexScribe; // **lexScribe that enscribed lexScript template into TLDR**\r\n            address lexAddress; // **ethereum address to forward lexScript template lexScribe fees**\r\n            string templateTerms; // **lexScript template terms to wrap DDR for legal security**\r\n            uint256 lexID; // **ID number to reference in DDR to inherit lexScript wrapper**\r\n            uint256 lexRate; // **lexScribe fee in ddrToken type per rddr payment made thereunder / e.g., 100 = 1% fee on rddr payDDR payment transaction** \r\n        } \r\n\r\n\tstruct DDR { // **Digital Dollar Retainer**\r\n        \taddress client; // **client ethereum address**\r\n        \taddress provider; // **ethereum address that receives payments in exchange for goods or services**\r\n        \tIERC20 ddrToken; // **ERC-20 digital token address used to transfer value on ethereum under rddr / e.g., DAI \u0027digital dollar\u0027 - 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359**\r\n        \tstring deliverable; // **goods or services (deliverable) retained for benefit of ethereum payments**\r\n        \tstring governingLawForum; // **choice of law and forum for retainer relationship (or similar legal description)**\r\n        \tuint256 ddrNumber; // **rddr number generated on registration / identifies rddr for payDDR calls**\r\n        \tuint256 timeStamp; // **block.timestamp of registration used to calculate retainerTermination UnixTime**\r\n        \tuint256 retainerDuration; // **duration of rddr in seconds**\r\n        \tuint256 retainerTermination; // **termination date of rddr in UnixTime**\r\n        \tuint256 deliverableRate; // **rate for rddr deliverables in digital dollar wei amount / 1 = 1000000000000000000**\r\n        \tuint256 paid; // **tracking amount of designated ERC-20 paid under rddr in wei amount**\r\n        \tuint256 payCap; // **cap in wei amount to limit payments under rddr**;\r\n        \tuint256 lexID; // **lexID number reference to include lexScriptWrapper for legal security / default \u00270\u0027 for general DDR lexScript template**\r\n    \t}\r\n\r\n\tconstructor() public { // **deploys TLDR contract and stores base template \u00220\u0022 (lexID) for rddr lexScript terms**\r\n\t        address LEXScribe = msg.sender; // **TLDR creator is initial lexScribe**\r\n\t        // **default lexScript legal wrapper stating general human-readable DDR terms for rddr to inherit / lexID = \u00270\u0027**\r\n\t        string memory ddrTerms = \u0022|| Establishing a digital retainer hereby as [[ddrNumber]] and acknowledging mutual consideration and agreement, Client, identified by ethereum address 0x[[client]], commits to perform under this digital payment transactional script capped at $[[payCap]] digital dollar value denominated in 0x[[ddrToken]] for benefit of Provider, identified by ethereum address 0x[[provider]], in exchange for prompt satisfaction of the following, [[deliverable]], to Client by Provider upon scripted payments set at the rate of $[[deliverableRate]] per deliverable, with such retainer relationship not to exceed [[retainerDuration]] seconds and to be governed by choice of [[governingLawForum]] law and \u0027either/or\u0027 arbitration rules in [[governingLawForum]]. ||\u0022;\r\n\t        uint256 lexID = 0; // **default lexID for constructor / general rddr reference**\r\n\t        uint256 LEXRate = 100; // **1% lexRate**\r\n\t        address LEXAddress = 0xBBE222Ef97076b786f661246232E41BE0DFf6cc4; // **Open, ESQ LLC_DAO ethereum address**\r\n\t        lexScript[lexID] = lexScriptWrapper( // **populate default \u00270\u0027 lexScript data for reference in LSW**\r\n                \tLEXScribe,\r\n                \tLEXAddress,\r\n                \tddrTerms,\r\n                \tlexID,\r\n                \tLEXRate);\r\n        }\r\n\r\n    // **TLDR Events**\r\n    event Enscribed(uint256 indexed lexID, address indexed lexScribe); // **triggered on successful edits to LSW**\r\n\tevent Registered(uint256 indexed ddrNumber, uint256 indexed lexID, address client, address provider); // **triggered on successful registration**\r\n\tevent Paid(uint256 indexed ddrNumber, uint256 indexed lexID, uint256 ratePaid, uint256 totalPaid, address client); // **triggered on successful rddr payments**\r\n\r\n    /***************\r\n    GOVERNANCE FUNCTIONS\r\n    ***************/\r\n    // **lexScribes can stake ether (\u039E) value for TLDR reputation and function access**\r\n    function stakeReputation() payable public onlyScribe {\r\n            require(msg.value == 0.1 ether);\r\n            reputation[msg.sender] = 10;\r\n            address(lexAgonDAO).transfer(msg.value);\r\n        }\r\n    // **check on lexScribe reputation**\r\n    function isReputable(address x) public view returns (bool) {\r\n            return reputation[x] \u003E 0;\r\n        }\r\n    // **restricts governance function calls to once per day**\r\n    modifier cooldown() {\r\n            require(now.sub(lastActionTimestamp[msg.sender]) \u003E 1 days);\r\n            _;\r\n            lastActionTimestamp[msg.sender] = now;\r\n        }\r\n    // **reputable LexScribes can reduce each other\u0027s reputation**\r\n    function reduceScribeRep(address reducedLexScribe) cooldown public {\r\n            require(isReputable(msg.sender));\r\n            reputation[reducedLexScribe] = reputation[reducedLexScribe].sub(1); \r\n        }\r\n    // **reputable LexScribes can repair each other\u0027s reputation**\r\n    function repairScribeRep(address repairedLexScribe) cooldown public {\r\n            require(isReputable(msg.sender));\r\n            require(reputation[repairedLexScribe] \u003C 10);\r\n            reputation[repairedLexScribe] = reputation[repairedLexScribe].add(1); \r\n            lastActionTimestamp[msg.sender] = now;\r\n        }\r\n\r\n    /***************\r\n    LEXSCRIBE FUNCTIONS\r\n    ***************/\r\n    // **reputable lexScribes can register lexScript legal wrappers on TLDR and program fees for usage**\r\n\tfunction writeLEXScriptWrapper(string memory templateTerms, uint256 LEXRate, address LEXAddress) public onlyScribe {\r\n\t        require(isReputable(msg.sender));\r\n\t        address lexScribe = msg.sender;\r\n\t        uint256 lexID = LSW.add(1); // **reflects new lexScript value for tracking legal wrappers**\r\n\t        LSW = LSW.add(1); // counts new entry to LSW \r\n\t    \r\n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for reference in rddr\r\n                \tlexScribe,\r\n                \tLEXAddress,\r\n                \ttemplateTerms,\r\n                \tlexID,\r\n                \tLEXRate);\r\n                \t\r\n            emit Enscribed(lexID, lexScribe); \r\n\t    }\r\n\t// **lexScribes can update registered lexScript legal wrappers with newTemplateTerms and newLexAddress**\r\n\tfunction editLEXScriptWrapper(uint256 lexID, string memory newTemplateTerms, address newLEXAddress) public {\r\n\t        lexScriptWrapper storage lS = lexScript[lexID];\r\n\t        require(address(msg.sender) == lS.lexScribe); // program safety check / authorization\r\n\t    \r\n\t        lexScript[lexID] = lexScriptWrapper( // populate updated lexScript data for reference in rddr\r\n                \tmsg.sender,\r\n                \tnewLEXAddress,\r\n                \tnewTemplateTerms,\r\n                \tlexID,\r\n                \tlS.lexRate);\r\n            emit Enscribed(lexID, msg.sender);\r\n    \t}\r\n    \t\r\n    /***************\r\n    MARKET FUNCTIONS\r\n    ***************/\r\n\t// **register DDR with TLDR lexScripts**\r\n\tfunction registerDDR(\r\n    \t    address client,\r\n    \t    address provider,\r\n    \t    IERC20 ddrToken,\r\n    \t    string memory deliverable,\r\n    \t    string memory governingLawForum,\r\n    \t    uint256 retainerDuration,\r\n    \t    uint256 deliverableRate,\r\n    \t    uint256 payCap,\r\n    \t    uint256 lexID) public {\r\n            require(deliverableRate \u003C= payCap, \u0022registerDDR: deliverableRate cannot exceed payCap\u0022); // **program safety check / economics**\r\n            uint256 ddrNumber = RDDR.add(1); // **reflects new rddr value for tracking payments**\r\n            uint256 paid = 0; // **initial zero value for rddr** \r\n            uint256 timeStamp = now; // **block.timestamp of rddr**\r\n            uint256 retainerTermination = timeStamp \u002B retainerDuration; // **rddr termination date in UnixTime**\r\n    \r\n        \tRDDR = RDDR.add(1); // counts new entry to RDDR\r\n    \r\n        \trddr[ddrNumber] = DDR( // populate rddr data \r\n                \tclient,\r\n                \tprovider,\r\n                \tddrToken,\r\n                \tdeliverable,\r\n                \tgoverningLawForum,\r\n                \tddrNumber,\r\n                \ttimeStamp,\r\n                \tretainerDuration,\r\n                \tretainerTermination,\r\n                \tdeliverableRate,\r\n                \tpaid,\r\n                \tpayCap,\r\n                \tlexID);\r\n        \t \r\n            emit Registered(ddrNumber, lexID, client, provider); \r\n        }\r\n\r\n    // **pay registered DDR on TLDR**\r\n\tfunction payDDR(uint256 ddrNumber) public { // **forwards approved ddrToken deliverableRate amount to provider ethereum address**\r\n    \t    DDR storage ddr = rddr[ddrNumber]; // **retrieve rddr data**\r\n    \t    lexScriptWrapper storage lS = lexScript[ddr.lexID];\r\n    \t    require (now \u003C= ddr.retainerTermination); // **program safety check / time**\r\n    \t    require(address(msg.sender) == ddr.client); // program safety check / authorization\r\n    \t    require(ddr.paid.add(ddr.deliverableRate) \u003C= ddr.payCap, \u0022payDAI: payCap exceeded\u0022); // **program safety check / economics**\r\n    \t    uint256 lexFee = ddr.deliverableRate.div(lS.lexRate);\r\n    \t    ddr.ddrToken.transferFrom(msg.sender, ddr.provider, ddr.deliverableRate); // **executes ERC-20 transfer**\r\n    \t    ddr.ddrToken.transferFrom(msg.sender, lS.lexAddress, lexFee);\r\n    \t    ddr.paid = ddr.paid.add(ddr.deliverableRate); // **tracks amount paid under rddr**\r\n        \temit Paid(ddr.ddrNumber, ddr.lexID, ddr.deliverableRate, ddr.paid, msg.sender); \r\n    \t}\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022newTemplateTerms\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022newLEXAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022editLEXScriptWrapper\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022templateTerms\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022LEXRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022LEXAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022writeLEXScriptWrapper\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022lastActionTimestamp\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022client\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022provider\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022ddrToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022deliverable\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022governingLawForum\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022retainerDuration\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022deliverableRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022payCap\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022registerDDR\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022stakeReputation\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceScribe\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022lexAgonDAO\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isReputable\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022repairedLexScribe\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022repairScribeRep\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022lexScript\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022lexScribe\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022lexAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022templateTerms\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lexRate\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022reputation\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022rddr\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022client\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022provider\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022ddrToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022deliverable\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022governingLawForum\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022ddrNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022timeStamp\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022retainerDuration\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022retainerTermination\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022deliverableRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022paid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022payCap\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addScribe\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isScribe\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022reducedLexScribe\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022reduceScribeRep\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022ddrNumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022payDDR\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022RDDR\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022LSW\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022lexScribe\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Enscribed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022ddrNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022client\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022provider\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Registered\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022ddrNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022lexID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022ratePaid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022totalPaid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022client\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Paid\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ScribeAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ScribeRemoved\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"lexDAORegistry","CompilerVersion":"v0.5.9\u002Bcommit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9aac58feb1d4e0e3f227b28ad43d6cb66a39e4bd781c0e00e3014fca2b66b150"}]