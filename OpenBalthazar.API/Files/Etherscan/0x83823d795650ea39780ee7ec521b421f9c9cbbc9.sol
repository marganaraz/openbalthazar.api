[{"SourceCode":"// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\utils\\Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract\u0027s constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. \u0060keccak256(\u0027\u0027)\u0060\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an \u0060address\u0060 into \u0060address payable\u0060. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s \u0060transfer\u0060: sends \u0060amount\u0060 wei to\r\n     * \u0060recipient\u0060, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by \u0060transfer\u0060, making them unable to receive funds via\r\n     * \u0060transfer\u0060. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to \u0060recipient\u0060, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003E= amount, \u0022Address: insufficient balance\u0022);\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\u0022\u0022);\r\n        require(success, \u0022Address: unable to send value, recipient may have reverted\u0022);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a \u0060using SafeERC20 for ERC20;\u0060 statement to your contract,\r\n * which allows you to call the safe operations as \u0060token.safeTransfer(...)\u0060, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \u0022SafeERC20: approve from non-zero to non-zero allowance\u0022\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \u0022SafeERC20: decreased allowance below zero\u0022);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \u0022SafeERC20: call to non-contract\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \u0022SafeERC20: low-level call failed\u0022);\r\n\r\n        if (returndata.length \u003E 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \u0022SafeERC20: ERC20 operation did not succeed\u0022);\r\n        }\r\n    }\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\GSN\\Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003E uint256) private _balances;\r\n\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - the caller must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     * - the caller must have allowance for \u0060sender\u0060\u0027s tokens of at least\r\n     * \u0060amount\u0060.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \u0022ERC20: transfer amount exceeds allowance\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 must have allowance for the caller of at least\r\n     * \u0060subtractedValue\u0060.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \u0022ERC20: decreased allowance below zero\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060sender\u0060 cannot be the zero address.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \u0022ERC20: transfer from the zero address\u0022);\r\n        require(recipient != address(0), \u0022ERC20: transfer to the zero address\u0022);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \u0022ERC20: transfer amount exceeds balance\u0022);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060to\u0060 cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \u0022ERC20: mint to the zero address\u0022);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \u0022ERC20: burn from the zero address\u0022);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \u0022ERC20: burn amount exceeds balance\u0022);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\r\n     *\r\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060owner\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \u0022ERC20: approve from the zero address\u0022);\r\n        require(spender != address(0), \u0022ERC20: approve to the zero address\u0022);\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \u0022ERC20: burn amount exceeds allowance\u0022));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: zos-lib\\contracts\\Initializable.sol\r\n\r\npragma solidity \u003E=0.4.24 \u003C0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the \u0060initializer\u0060 modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \u0022Contract instance has already been initialized\u0022);\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth\\contracts\\ownership\\Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \u0022user permissions\u0022.\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if \u0060msg.sender\u0060 is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the \u0060onlyOwner\u0060\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\library\\Enums.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\nlibrary Enums {\r\n    enum VotingCategory { APPROVE_ATTESTER, SUSPEND_ATTESTER, SUSPEND_DELEGATE, UNSUSPEND_DELEGATE, ARBITRARY }\r\n    enum DelegateRole { NONE, MASTERNODE, VALIDATOR }\r\n}\r\n\r\n// File: contracts\\governance\\IGovernance.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n* @title Governance reference to be used in other contracts\r\n*/\r\ninterface IGovernance {\r\n    /**\r\n    * @notice Make generic proposal\r\n    * @param _id Voting id\r\n    * @param _category Voting category\r\n    * @param _address Delegate / Attester affected by voting\r\n    * @param _data Extra data or data for arbitrary voting\r\n    * @param _votingPeriod Period when delegates can vote from proposal submission\r\n    */\r\n    function submitProposal(bytes32 _id, Enums.VotingCategory _category, address _address, bytes32 _data, uint256 _votingPeriod) external;\r\n\r\n   /**\r\n   * @notice Vote in favor or against proposal with the specified identifier\r\n   * @param _id Voting id\r\n   * @param _inFavor Support proposal or not\r\n   */\r\n    function vote(bytes32 _id, bool _inFavor) external;\r\n\r\n    /**\r\n    * @notice Finalize voting and apply proposed changes if success.\r\n    * This method will fail if voting period is not over.\r\n    * @param _id Voting id\r\n    */\r\n    function finalizeVoting(bytes32 _id) external;\r\n\r\n    /**\r\n     * @notice Whether specified delegate is known by governance, created by governance\r\n     * @param _delegate Delegate address to check\r\n     */\r\n    function isDelegateKnown(address _delegate) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Create new delegate contract, get bond and transfer ownership to a caller\r\n    * @param _name Delegate name\r\n    * @param _signer Delegate Signer address\r\n    * @param _bond Delegate bond amount\r\n    */\r\n    function createDelegate(bytes32 _name, address _signer, uint256 _bond) external returns (address);\r\n\r\n    /**\r\n    * @notice Launches delegate, activates and sets a proper role\r\n    * @param _isAttested Delegate is attested or not\r\n    */\r\n    function launchDelegate(bool _isAttested) external;\r\n\r\n    /**\r\n    * @notice Unregister specified delegate. Can only be called by delegate itself\r\n    */\r\n    function unregisterDelegate() external;\r\n\r\n    /**\r\n    * @notice Slashes suspended delegate bond to governing council\r\n    * @param _delegate Delegate address\r\n    * @param _amount Tokens amount\r\n    */\r\n    function slashBond(address _delegate, uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Approves specified attester. Can only be called by owner.\r\n    * @param _attester Attester address\r\n    */\r\n    function approveAttester(address _attester) external;\r\n\r\n    /**\r\n    * @notice Suspends specified attester. Can only be called by owner.\r\n    * @param _attester Attester address\r\n    */\r\n    function suspendAttester(address _attester) external;\r\n\r\n    /**\r\n    * @notice Whether specified attester is valid.\r\n    * @param _attester Attesters address to check\r\n    */\r\n    function isAttesterValid(address _attester) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Get governing council address\r\n    */\r\n    function getGoverningCouncil() external view returns(address);\r\n\r\n    /**\r\n    * @notice Checks if delegate is validator\r\n    * @param _delegate Delegate to be checked\r\n    */\r\n    function isValidator(address _delegate) external view returns (bool);\r\n}\r\n\r\n// File: contracts\\governance\\IDelegate.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n* @title Delegate reference to be used in other contracts\r\n*/\r\ninterface IDelegate {\r\n    /**\r\n    * @notice Init delegate when created. May be called only once.\r\n    */\r\n    function init(address _owner, ERC20 _token, address _governance, bytes32 _name, address _signer) external;\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens\r\n    * @param _amount Amount to stake\r\n    */\r\n    function stake(uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens for other staker\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to stake\r\n    */\r\n    function delegateStake(address _staker, uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function unstake(uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens for other user\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function delegateUnstake(address _staker, uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Return number of tokens staked by the specified staker\r\n    * @param _staker Staker address\r\n    */\r\n    function stakeOfStaker(address _staker) external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Stake at the given timestamp\r\n    * @param _timestamp Time for which we would like to check stake\r\n    */\r\n    function stakeOfDelegate(uint256 _timestamp) external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Delegated stake for some staker and msg.sender as a caller\r\n    * @param _staker Staker of tokens\r\n    * @param _caller Caller who delegated stake\r\n    */\r\n    function delegatedStakeOfStaker(address _staker, address _caller) external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Whether this delegate is activated now\r\n    */\r\n    function isActiveNow() external view returns (bool);\r\n\r\n    /**\r\n    * @notice Whether this delegate was activated at the given timestamp\r\n    * @param _timestamp Time for which we would like to check activation status\r\n    */\r\n    function isActive(uint256 _timestamp) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Activate delegate.\r\n    */\r\n    function activate() external;\r\n\r\n    /**\r\n    * @notice Deactivate delegate\r\n    */\r\n    function deactivate() external;\r\n\r\n    /**\r\n    * @notice Delegate owner\r\n    */\r\n    function owner() external view returns(address);\r\n\r\n    /**\r\n    * @notice Returns delegate\u0027s signer address\r\n    */\r\n    function getSignerAddress() external view returns (address);\r\n\r\n    /**\r\n    * @notice Returns delegate\u0027s name as bytes32\r\n    */\r\n    function getNameAsBytes() external view returns (bytes32);\r\n\r\n    /**\r\n    * @notice Submits delegate attestation data and depending on result approves attestation\r\n    * @param _hash Signed hashed data\r\n    * @param _v V part of signing\r\n    * @param _r R part of signing\r\n    * @param _s S part of signing\r\n    */\r\n    function submitAttestation(bytes32[] calldata _hash, uint8[] calldata _v, bytes32[] calldata _r, bytes32[] calldata _s) external;\r\n\r\n    /**\r\n    * @notice Whether this delegate is suspended now\r\n    */\r\n    function isSuspendedNow() external view returns (bool);\r\n\r\n    /**\r\n    * @notice Whether this delegate was suspended at the given timestamp\r\n    * @param _timestamp Time for which we would like to check slash\r\n    */\r\n    function isSuspended(uint256 _timestamp) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Suspend delegate\r\n    */\r\n    function suspend() external;\r\n\r\n    /**\r\n    * @notice Unsuspend delegate\r\n    */\r\n    function unsuspend() external;\r\n\r\n    /**\r\n    * @notice Unlocks stakes\r\n    * @param _timeout Timeout at which stake will become available\r\n    */\r\n    function unlockStakes(uint256 _timeout) external;\r\n}\r\n\r\n// File: contracts\\library\\OperationStore.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\nlibrary OperationStore {\r\n\r\n    /**\r\n     * @notice Stores historical integer data\r\n     * @param _history History of stored int data in format time1, value1, time2, value2, time3...\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeInt(uint256[] storage _history, uint256 _value) internal {\r\n        _history.push(now);\r\n        _history.push(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns integer value for specified time\r\n     * @param _history History of stored int data in format time1, value1, time2, value2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getInt(uint256[] storage _history, uint256 _timestamp) internal view returns (uint256) {\r\n        uint256 index = findIndex(_history, _timestamp, 2);\r\n        if (index \u003E 0) {\r\n            return _history[index - 1];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores historical boolean data\r\n     * @param _history History of stored boolean data in format: new record each times value changed (time1, time2...)\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeBool(uint256[] storage _history, bool _value) internal {\r\n        bool current = (_history.length % 2 == 1);\r\n        if (current != _value) {\r\n            _history.push(now);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean value for specified time\r\n     * @param _history History of stored boolean data in format: new record each times value changed (time1, time2...)\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getBool(uint256[] storage _history, uint256 _timestamp) internal view returns (bool) {\r\n        return findIndex(_history, _timestamp, 1) % 2 == 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores historical timestamp data\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeTimestamp(uint256[] storage _history, uint256 _value) internal {\r\n        _history.push(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns last timestamp value for specified time\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getTimestamp(uint256[] storage _history, uint256 _timestamp) internal view returns (uint256) {\r\n        uint256 index = findIndex(_history, _timestamp, 1);\r\n        if (index \u003E 0) {\r\n            return _history[index - 1];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Searches for index of timestamp with specified step\r\n     * @dev History elements is sorted so binary search is used.\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     * @param _step Step used for binary search. For bool \u0026 timestamp steps is 1, for uint step is 2\r\n     */\r\n    function findIndex(uint256[] storage _history, uint256 _timestamp, uint256 _step) internal view returns (uint256) {\r\n        if (_history.length == 0) {\r\n            return 0;\r\n        }\r\n        uint256 low = 0;\r\n        uint256 high = _history.length - _step;\r\n\r\n        while (low \u003C= high) {\r\n            uint256 mid = ((low \u002B high) \u003E\u003E _step) \u003C\u003C (_step - 1);\r\n            uint256 midVal = _history[mid];\r\n            if (midVal \u003C _timestamp) {\r\n                low = mid \u002B _step;\r\n            } else if (midVal \u003E _timestamp) {\r\n                if (mid == 0) {\r\n                    return 0;\r\n                    // min key\r\n                }\r\n                high = mid - _step;\r\n            } else {\r\n                // take the last one if there are many same items\r\n                uint256 result = mid \u002B _step;\r\n                while (result \u003C _history.length \u0026\u0026 _history[result] == _timestamp) {\r\n                    result = result \u002B _step;\r\n                }\r\n                // key found\r\n                return result;\r\n            }\r\n        }\r\n        // key not found\r\n        return low;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\library\\Conversions.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\nlibrary Conversions {\r\n    /**\r\n     * @notice Converts bytes32 to string\r\n     */\r\n    function bytes32ToString(bytes32 _input) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint256 charCount = 0;\r\n        uint256 index = 0;\r\n        for (index = 0; index \u003C 32; index\u002B\u002B) {\r\n            byte char = byte(bytes32(uint256(_input) * 2 ** (8 * index)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount\u002B\u002B;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (index = 0; index \u003C charCount; index\u002B\u002B) {\r\n            bytesStringTrimmed[index] = bytesString[index];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    function addressToString(address _addr) internal pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \u00220123456789abcdef\u0022;\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = \u00270\u0027;\r\n        str[1] = \u0027x\u0027;\r\n        for (uint256 i = 0; i \u003C 20; i\u002B\u002B) {\r\n            str[2\u002Bi*2] = alphabet[uint8(value[i \u002B 12] \u003E\u003E 4)];\r\n            str[3\u002Bi*2] = alphabet[uint8(value[i \u002B 12] \u0026 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n}\r\n\r\n// File: contracts\\library\\AddressSet.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/// @title An implementation of the set data structure for addresses.\r\n/// @author Noah Zinsmeister\r\n/// @dev O(1) insertion, removal, contains, and length functions.\r\nlibrary AddressSet {\r\n    struct Set {\r\n        address[] members;\r\n        mapping(address =\u003E uint) memberIndices;\r\n    }\r\n\r\n    /// @dev Inserts an element into a set. If the element already exists in the set, the function is a no-op.\r\n    /// @param self The set to insert into.\r\n    /// @param other The element to insert.\r\n    function insert(Set storage self, address other) public {\r\n        if (!contains(self, other)) {\r\n            self.memberIndices[other] = self.members.push(other);\r\n        }\r\n    }\r\n\r\n    /// @dev Removes an element from a set. If the element does not exist in the set, the function is a no-op.\r\n    /// @param self The set to remove from.\r\n    /// @param other The element to remove.\r\n    function remove(Set storage self, address other) public {\r\n        if (contains(self, other)) {\r\n            // replace other with the last element\r\n            self.members[self.memberIndices[other] - 1] = self.members[length(self) - 1];\r\n            // reflect this change in the indices\r\n            self.memberIndices[self.members[self.memberIndices[other] - 1]] = self.memberIndices[other];\r\n            delete self.memberIndices[other];\r\n            // remove the last element\r\n            self.members.pop();\r\n        }\r\n    }\r\n\r\n    /// @dev Checks set membership.\r\n    /// @param self The set to check membership in.\r\n    /// @param other The element to check membership of.\r\n    /// @return true if the element is in the set, false otherwise.\r\n    function contains(Set storage self, address other) public view returns (bool) {\r\n        return ( // solium-disable-line operator-whitespace\r\n        self.memberIndices[other] \u003E 0 \u0026\u0026\r\n        self.members.length \u003E= self.memberIndices[other] \u0026\u0026\r\n        self.members[self.memberIndices[other] - 1] == other\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the number of elements in a set.\r\n    /// @param self The set to check the length of.\r\n    /// @return The number of elements in the set.\r\n    function length(Set storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n}\r\n\r\n// File: contracts\\token\\TokenRecipient.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n* @dev Interface to use the receiveApproval method\r\n**/\r\ninterface TokenRecipient {\r\n\r\n    /**\r\n    * @notice Receives a notification of approval of the transfer\r\n    * @param _from Sender of approval\r\n    * @param _value  The amount of tokens to be spent\r\n    * @param _tokenContract Address of the token contract\r\n    * @param _extraData Extra data\r\n    **/\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts\\upgradeability\\ParameterizedInitializable.sol\r\n\r\npragma solidity \u003E=0.4.24 \u003C0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the \u0060initializer\u0060 modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract ParameterizedInitializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    mapping(string =\u003E bool) private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    mapping(string =\u003E bool) private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initiator(string memory _label) {\r\n        require(initializing[_label] || isConstructor() || !initialized[_label], \u0022Contract instance has already been initialized\u0022);\r\n\r\n        bool isTopLevelCall = !initializing[_label];\r\n        if (isTopLevelCall) {\r\n            initializing[_label] = true;\r\n            initialized[_label] = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing[_label] = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        assembly {cs := extcodesize\r\n        (address) }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\governance\\Delegate.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ethereum-based contract for delegate\r\n */\r\ncontract Delegate is IDelegate, TokenRecipient, ParameterizedInitializable, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    using OperationStore for uint256[];\r\n    using Conversions for bytes32;\r\n    using Conversions for address;\r\n    using AddressSet for AddressSet.Set;\r\n\r\n    struct Attestation {\r\n        bool done;\r\n        address attester;\r\n        bytes32[] hashes;\r\n        uint256 time;\r\n    }\r\n\r\n    /** Token **/\r\n    ERC20 public token;\r\n\r\n    /** Governance address **/\r\n    IGovernance public governance;\r\n\r\n    /** Description name of the delegate */\r\n    bytes32 public name;\r\n\r\n    /** Signer address used for coin distribution */\r\n    address public signerAddress;\r\n\r\n    /** Attestations **/\r\n    Attestation public attestation;\r\n\r\n    /** Delegate stakers */\r\n    AddressSet.Set private stakers;\r\n\r\n    /** Stake in the delegate */\r\n    uint256[] delegateStakeHistory;\r\n\r\n    /** Are stakes locked in the delegate */\r\n    bool stakesLocked;\r\n\r\n    /** Time at which stakes have been unlocked */\r\n    uint256 public stakesUnlockedOn;\r\n\r\n    /** Stake per user address in the delegate */\r\n    mapping(address =\u003E uint256) public stakes;\r\n\r\n    /** Delegated stake per user address in the delegate */\r\n    mapping(address =\u003E mapping(address =\u003E uint256)) public delegatedStakes;\r\n\r\n    /** History on when delegate was activated or not */\r\n    uint256[] public activationHistory;\r\n\r\n    /** History on when delegate was suspended or not */\r\n    uint256[] public suspendHistory;\r\n\r\n    event ActivationStatusUpdated(bool activated);\r\n    event SuspendStatusUpdated(bool suspended);\r\n    event StakeLocked(bool locked);\r\n\r\n    event Staked(address indexed staker, address indexed caller, uint256 amount);\r\n    event Unstaked(address indexed staker, address indexed caller, uint256 amount);\r\n\r\n    /** Check if the sender is a governance */\r\n    modifier onlyGovernance {\r\n        require(msg.sender == address(governance), \u0027msg.sender should be governance\u0027);\r\n        _;\r\n    }\r\n\r\n    /** Check if the sender is governance or owner */\r\n    modifier onlyOwnerOrGovernance {\r\n        require((msg.sender == address(governance)) || (msg.sender == owner()), \u0027msg.sender should be or delegate owner\u0027);\r\n        _;\r\n    }\r\n\r\n    /** Check if the sender is a valid governing council */\r\n    modifier onlyGoverningCouncil {\r\n        require(msg.sender == governance.getGoverningCouncil(), \u0027msg.sender should be governing council\u0027);\r\n        _;\r\n    }\r\n\r\n    /** Check if the sender is governance or governing council */\r\n    modifier onlyGoverningCouncilOrGovernance {\r\n        require((msg.sender == address(governance)) || (msg.sender == governance.getGoverningCouncil()), \u0027msg.sender should be governance or governing council\u0027);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Delegate initializer\r\n    * @dev This init is called by governance when created\r\n    * @param _owner Delegate owner address\r\n    * @param _token Token address\r\n    * @param _governance Governance address\r\n    * @param _name Delegate name\r\n    * @param _signer Delegate signer address\r\n    */\r\n    function init(address _owner, ERC20 _token, address _governance, bytes32 _name, address _signer)\r\n        initiator(\u0022v1\u0022) public {\r\n        Ownable.initialize(_owner);\r\n        name = _name;\r\n        token = _token;\r\n        signerAddress = _signer;\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns delegate name as string\r\n    */\r\n    function getName() public view returns (string memory) {\r\n        return name.bytes32ToString();\r\n    }\r\n\r\n    /**\r\n    * @notice Returns delegate\u0027s name as bytes32\r\n    */\r\n    function getNameAsBytes() external view returns (bytes32) {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns delegate\u0027s signer address.\r\n    * We cannot have setter for it as in this case we need store history of addresses\r\n    */\r\n    function getSignerAddress() external view returns (address) {\r\n        return signerAddress;\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate is activated now\r\n    */\r\n    function isActiveNow() public view returns (bool) {\r\n        return isActive(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate was activated at the given timestamp\r\n    * @param _timestamp Time for which we would like to check activation status\r\n    */\r\n    function isActive(uint256 _timestamp) public view returns (bool) {\r\n        return activationHistory.getBool(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Launches delegate. Sets active.\r\n    */\r\n    function launch() external onlyOwner {\r\n        governance.launchDelegate(attestation.done);\r\n    }\r\n\r\n    /**\r\n    * @notice Activate delegate.\r\n    */\r\n    function activate() external onlyGovernance {\r\n        _activate(true);\r\n    }\r\n\r\n    /**\r\n    * @notice Deactivate delegate. Note we don\u0027t need activate for now. It\u0027s done via attestations\r\n    */\r\n    function deactivate() external onlyGovernance {\r\n        _activate(false);\r\n    }\r\n\r\n    /**\r\n    * @notice Change delegate activations status\r\n    * @param _active Is delegate active or not\r\n    */\r\n    function _activate(bool _active) internal {\r\n        activationHistory.storeBool(_active);\r\n        emit ActivationStatusUpdated(_active);\r\n    }\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens\r\n    * @param _amount Amount to stake\r\n    */\r\n    function stake(uint256 _amount) external {\r\n        _stake(msg.sender, msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens for other staker\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to stake\r\n    */\r\n    function delegateStake(address _staker, uint256 _amount) external {\r\n        _stake(msg.sender, _staker, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens\r\n    * @param _caller Address of a person who delegates a stake\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to stake\r\n    */\r\n    function _stake(address _caller, address _staker, uint256 _amount) internal {\r\n        require(_amount \u003E 0, \u0027Amount should be more than 0\u0027);\r\n        require(isActiveNow(), \u0027Delegate is not active\u0027);\r\n        require(!isSuspendedNow(), \u0027Delegate is suspended\u0027);\r\n        require(governance.isValidator(address(this)), \u0027Delegate is not validator\u0027);\r\n\r\n        token.safeTransferFrom(_caller, address(this), _amount);\r\n\r\n        stakers.insert(_staker);\r\n\r\n        stakes[_staker] = stakes[_staker].add(_amount);\r\n        delegatedStakes[_staker][_caller] = delegatedStakes[_staker][_caller].add(_amount);\r\n        delegateStakeHistory.storeInt(delegateStakeHistory.getInt(now).add(_amount));\r\n\r\n        emit Staked(_staker, _caller, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function unstake(uint256 _amount) external {\r\n        _unstake(msg.sender, msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens for other user\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function delegateUnstake(address _staker, uint256 _amount) external {\r\n        _unstake(msg.sender, _staker, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens\r\n    * @param _caller Address of a person who delegates a stake\r\n    * @param _staker Address of a staker\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function _unstake(address _caller, address _staker, uint256 _amount) internal {\r\n        require(!stakesLocked, \u0027Delegate stakes are locked\u0027);\r\n        require(stakesUnlockedOn \u003C= now, \u0027Delegate stakes are not unlocked yet\u0027);\r\n        require(delegatedStakes[_staker][_caller] \u003E= _amount, \u0027Too large amount of tokens to unstake specified\u0027);\r\n        require(token.balanceOf(address(this)) \u003E= _amount, \u0027Not enough tokens balance\u0027);\r\n\r\n        stakes[_staker] = stakes[_staker].sub(_amount);\r\n        delegatedStakes[_staker][_caller] = delegatedStakes[_staker][_caller].sub(_amount);\r\n        delegateStakeHistory.storeInt(delegateStakeHistory.getInt(now).sub(_amount));\r\n\r\n        if (stakes[_staker] == 0) {\r\n            stakers.remove(_staker);\r\n        }\r\n\r\n        token.safeTransfer(_caller, _amount);\r\n\r\n        emit Unstaked(_staker, _caller, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Return number of tokens staked by the specified staker\r\n    * @param _staker Staker address\r\n    */\r\n    function stakeOfStaker(address _staker) external view returns (uint256) {\r\n        return stakes[_staker];\r\n    }\r\n\r\n    /**\r\n    * @notice Stake at the given timestamp\r\n    * @param _timestamp Time for which we would like to check stake\r\n    */\r\n    function stakeOfDelegate(uint256 _timestamp) public view returns (uint256) {\r\n        return delegateStakeHistory.getInt(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Delegated stake for some staker and msg.sender as a caller\r\n    * @param _staker Staker of tokens\r\n    * @param _caller Caller who delegated stake\r\n    */\r\n    function delegatedStakeOfStaker(address _staker, address _caller) public view returns (uint256) {\r\n        return delegatedStakes[_staker][_caller];\r\n    }\r\n\r\n    /**\r\n    * @notice Get delegate stakers\r\n    */\r\n    function getStakerAddresses() public view returns (address[] memory) {\r\n        return stakers.members;\r\n    }\r\n\r\n    /**\r\n    * @notice Get delegate stakers and stakes\r\n    */\r\n    function getStakers() public view returns (address[] memory, uint256[] memory) {\r\n        uint256[] memory stakerStakes = new uint256[](stakers.length());\r\n        for (uint256 index = 0; index \u003C stakers.length(); index\u002B\u002B) {\r\n            stakerStakes[index] = stakes[stakers.members[index]];\r\n        }\r\n        return (stakers.members, stakerStakes);\r\n    }\r\n\r\n    /**\r\n    * @notice Make generic proposal\r\n    * @param _id Voting id\r\n    * @param _category Voting category\r\n    * @param _address Delegate / Attester affected by voting\r\n    * @param _data Extra data or data for arbitrary voting\r\n    * @param _votingPeriod Period when delegates can vote from proposal submission\r\n    */\r\n    function submitProposal(bytes32 _id, Enums.VotingCategory _category, address _address, bytes32 _data, uint256 _votingPeriod) external onlyOwner {\r\n        governance.submitProposal(_id, _category, _address, _data, _votingPeriod);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote in favor or against blacklist proposal with the specified identifier\r\n    * @param _id Proposal / voting id\r\n    * @param _inFavor Support or do not support proposal\r\n    */\r\n    function vote(bytes32 _id, bool _inFavor) external onlyOwner {\r\n        governance.vote(_id, _inFavor);\r\n    }\r\n\r\n    /**\r\n    * @notice Finalize voting and apply proposed changes if success.\r\n    * This method will fail if voting period is not over.\r\n    * @param _id Proposal / voting id\r\n    */\r\n    function finalizeVoting(bytes32 _id) external {\r\n        governance.finalizeVoting(_id);\r\n    }\r\n\r\n    /**\r\n    * @notice Submits delegate attestation data and depending on result approves attestation\r\n    * @param _hashes Signed hashed data [hashOfHashes, nameHash, emailHash, countryHash, dateHash]\r\n    * @param _v V part of signing\r\n    * @param _r R part of signing\r\n    * @param _s S part of signing\r\n    */\r\n    function submitAttestation(bytes32[] calldata _hashes, uint8[] calldata _v, bytes32[] calldata _r, bytes32[] calldata _s) external {\r\n        require(_hashes.length == 5, \u0027Hash should be provided\u0027);\r\n\r\n        address attester = ecrecover(_hashes[0], _v[0], _r[0], _s[0]);\r\n\r\n        for (uint index = 0; index \u003C _hashes.length; index\u002B\u002B) {\r\n            address hashAttester = ecrecover(_hashes[index], _v[index], _r[index], _s[index]);\r\n            require(hashAttester == attester, \u0027Hashes should be from the same attester\u0027);\r\n            require(governance.isAttesterValid(hashAttester), \u0027Hash should be signed with valid attester\u0027);\r\n        }\r\n\r\n        // NOTE: Next loop we start from 1 and hash[0] is hash of text\r\n        bytes32 hash = keccak256(abi.encodePacked(\u0027I hereby certify that I have reviewed the documents confirming the identity of the applicant, their country of registration or citizenship, date of registration or birth and the ethereum delegate contract address to be associated with the applicant.\u0027));\r\n        for (uint index = 1; index \u003C _hashes.length; index\u002B\u002B) {\r\n            hash = keccak256(abi.encodePacked(hash, _hashes[index]));\r\n        }\r\n        hash = keccak256(abi.encodePacked(hash, keccak256(abi.encodePacked(address(this)))));\r\n        require(_hashes[0] == hash, \u0027Zero hash should be valid for current delegate\u0027);\r\n\r\n        attestation = Attestation({\r\n            done : true,\r\n            attester : attester,\r\n            hashes : _hashes,\r\n            time: now\r\n        });\r\n    }\r\n\r\n    /**\r\n    * @notice Returns attestation information\r\n    */\r\n    function getAttestation() external view returns (bool, address, bytes32[] memory, uint256) {\r\n        return (attestation.done, attestation.attester, attestation.hashes, attestation.time);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate is suspended\r\n    */\r\n    function isSuspendedNow() public view returns (bool) {\r\n        return isSuspended(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate was suspended at the given timestamp\r\n    * @param _timestamp Time for which we would like to check suspend\r\n    */\r\n    function isSuspended(uint256 _timestamp) public view returns (bool) {\r\n        return suspendHistory.getBool(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Suspend delegate\r\n    */\r\n    function suspend() external onlyGovernance {\r\n        _suspend(true);\r\n    }\r\n\r\n    /**\r\n    * @notice Unsuspend delegate\r\n    */\r\n    function unsuspend() external onlyGoverningCouncilOrGovernance {\r\n        _suspend(false);\r\n    }\r\n\r\n    /**\r\n    * @notice Change delegate suspend status\r\n    * @param _suspended Suspend delegate or not\r\n    */\r\n    function _suspend(bool _suspended) internal {\r\n        stakesUnlockedOn = 0;\r\n        suspendHistory.storeBool(_suspended);\r\n        emit SuspendStatusUpdated(_suspended);\r\n\r\n        stakesLocked = _suspended;\r\n        emit StakeLocked(_suspended);\r\n    }\r\n\r\n    /**\r\n    * @notice Unlocks stakes\r\n    * @param _timeout Timeout at which stake will become available\r\n    */\r\n    function unlockStakes(uint256 _timeout) external onlyGoverningCouncil {\r\n        stakesUnlockedOn = now.add(_timeout);\r\n        stakesLocked = false;\r\n        emit StakeLocked(false);\r\n    }\r\n\r\n    /**\r\n    * @notice Unregister delegate and return bond back\r\n    */\r\n    function unregister() external onlyOwner {\r\n        governance.unregisterDelegate();\r\n    }\r\n\r\n    /**\r\n    * @notice Implementation of receiveApproval interface for ERC20 token with approveAndCall support\r\n    */\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata /**_extraData */) external returns (bool) {\r\n        require(_tokenContract == address(token), \u0027Token in approval call is invalid\u0027);\r\n        _stake(_from, _from, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022activated\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022ActivationStatusUpdated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022locked\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022StakeLocked\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022caller\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Staked\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022suspended\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022SuspendStatusUpdated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022caller\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Unstaked\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022activate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022activationHistory\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022attestation\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022done\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022attester\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deactivate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022delegateStake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022delegateUnstake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_caller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022delegatedStakeOfStaker\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022delegatedStakes\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022finalizeVoting\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAttestation\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getName\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getNameAsBytes\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getSignerAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getStakerAddresses\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getStakers\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022governance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IGovernance\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_governance\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_signer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022init\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022initialize\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isActive\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isActiveNow\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isSuspended\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isSuspendedNow\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022launch\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_tokenContract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022receiveApproval\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022signerAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022stake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022stakeOfDelegate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022stakeOfStaker\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022stakes\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022stakesUnlockedOn\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022_hashes\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022internalType\u0022:\u0022uint8[]\u0022,\u0022name\u0022:\u0022_v\u0022,\u0022type\u0022:\u0022uint8[]\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022_r\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022_s\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022name\u0022:\u0022submitAttestation\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022enum Enums.VotingCategory\u0022,\u0022name\u0022:\u0022_category\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_votingPeriod\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022submitProposal\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022suspend\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022suspendHistory\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022token\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_timeout\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022unlockStakes\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022unregister\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022unstake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022unsuspend\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_inFavor\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022vote\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"Delegate","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"AddressSet:4ac998b2338682e6b830f434e0e4b3e2a804c11a","SwarmSource":"bzzr://a24aca12033c16135aa10fedf54c1bd2cdcd43f2d5b7a6987ac85a72917d3c2d"}]