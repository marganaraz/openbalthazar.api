[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b \u003E 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b \u003C= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    assert(c \u003E= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface ERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/DividendInterface.sol\r\n\r\ninterface DividendInterface{\r\n  function issueDividends(uint _amount) external payable returns (bool);\r\n\r\n  // @dev Total number of tokens in existence\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function getERC20() external view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/KyberInterface.sol\r\n\r\n// @notice Trade via the Kyber Proxy Contract\r\ninterface KyberInterface {\r\n  function getExpectedRate(address src, address dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n  function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId) external payable returns(uint);\r\n}\r\n\r\n// File: contracts/interfaces/MinterInterface.sol\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/CrowdsaleReserveInterface.sol\r\n\r\ninterface CrowdsaleReserveInterface {\r\n  function issueETH(address _receiver, uint256 _amount) external returns (bool);\r\n  function receiveETH(address _payer) external payable returns (bool);\r\n  function refundETHAsset(address _asset, uint256 _amount) external returns (bool);\r\n  function issueERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function requestERC20(address _payer, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function approveERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function refundERC20Asset(address _asset, uint256 _amount, address _tokenAddress) external returns (bool);\r\n}\r\n\r\n// File: contracts/crowdsale/CrowdsaleERC20.sol\r\n\r\ninterface Events {  function transaction(string _message, address _from, address _to, uint _amount, address _token)  external; }\r\ninterface DB {\r\n  function addressStorage(bytes32 _key) external view returns (address);\r\n  function uintStorage(bytes32 _key) external view returns (uint);\r\n  function setUint(bytes32 _key, uint _value) external;\r\n  function deleteUint(bytes32 _key) external;\r\n  function setBool(bytes32 _key, bool _value) external;\r\n  function boolStorage(bytes32 _key) external view returns (bool);\r\n}\r\n\r\n// @title An asset crowdsale contract which accepts funding from ERC20 tokens.\r\n// @notice Begins a crowdfunding period for a digital asset, minting asset dividend tokens to investors when particular ERC20 token is received\r\n// @author Kyle Dewhurst, MyBit Foundation\r\n// @notice creates a dividend token to represent the newly created asset.\r\ncontract CrowdsaleERC20{\r\n  using SafeMath for uint256;\r\n\r\n  DB private database;\r\n  Events private events;\r\n  MinterInterface private minter;\r\n  CrowdsaleReserveInterface private reserve;\r\n  KyberInterface private kyber;\r\n\r\n  // @notice Constructor: initializes database instance\r\n  // @param: The address for the platform database\r\n  constructor(address _database, address _events, address _kyber)\r\n  public{\r\n      database = DB(_database);\r\n      events = Events(_events);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\u0022contract\u0022, \u0022Minter\u0022))));\r\n      reserve = CrowdsaleReserveInterface(database.addressStorage(keccak256(abi.encodePacked(\u0022contract\u0022, \u0022CrowdsaleReserve\u0022))));\r\n      kyber = KyberInterface(_kyber);\r\n  }\r\n\r\n  // @notice Investors can send ERC20 tokens here to fund an asset, receiving an equivalent number of asset-tokens.\r\n  // @dev investor must approve this contract to transfer tokens\r\n  // @param (address) _assetAddress = The address of the asset tokens, investor wishes to purchase\r\n  // @param (uint) _amount = The amount to spend purchasing this asset\r\n  function buyAssetOrderERC20(address _assetAddress, uint _amount, address _paymentToken)\r\n  external\r\n  payable\r\n  returns (bool) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\u0022asset.manager\u0022, _assetAddress))) != address(0), \u0022Invalid asset\u0022);\r\n    require(now \u003C= database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress))), \u0022Past deadline\u0022);\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.finalized\u0022, _assetAddress))), \u0022Crowdsale finalized\u0022);\r\n\r\n    if(_paymentToken == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      require(msg.value == _amount, \u0027Msg.value does not match amount\u0027);\r\n    } else {\r\n      require(msg.value == 0, \u0027Msg.value should equal zero\u0027);\r\n    }\r\n    ERC20 fundingToken = ERC20(DividendInterface(_assetAddress).getERC20());\r\n    uint fundingRemaining = database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.remaining\u0022, _assetAddress)));\r\n    uint collected; //This will be the value received by the contract after any conversions\r\n    uint amount; //The number of tokens that will be minted\r\n    //Check if the payment token is the same as the funding token. If not, convert, else just collect the funds\r\n    if(_paymentToken == address(fundingToken)){\r\n      collected = collectPayment(msg.sender, _amount, fundingRemaining, fundingToken);\r\n    } else {\r\n      collected = convertTokens(msg.sender, _amount, fundingToken, ERC20(_paymentToken), fundingRemaining);\r\n    }\r\n    require(collected \u003E 0);\r\n    if(collected \u003C fundingRemaining){\r\n      amount = collected.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\u0022platform.fee\u0022)))));\r\n      database.setUint(keccak256(abi.encodePacked(\u0022crowdsale.remaining\u0022, _assetAddress)), fundingRemaining.sub(collected));\r\n      require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \u0022Investor minting failed\u0022);\r\n      require(fundingToken.transfer(address(reserve), collected));\r\n    } else {\r\n      amount = fundingRemaining.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\u0022platform.fee\u0022)))));\r\n      database.setBool(keccak256(abi.encodePacked(\u0022crowdsale.finalized\u0022, _assetAddress)), true);\r\n      database.deleteUint(keccak256(abi.encodePacked(\u0022crowdsale.remaining\u0022, _assetAddress)));\r\n      require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \u0022Investor minting failed\u0022);   // Send remaining asset tokens to investor\r\n      require(fundingToken.transfer(address(reserve), fundingRemaining));\r\n      if(collected \u003E fundingRemaining){\r\n        require(fundingToken.transfer(msg.sender, collected.sub(fundingRemaining)));    // return extra funds\r\n      }\r\n    }\r\n    events.transaction(\u0027Asset purchased\u0027, address(this), msg.sender, amount, _assetAddress);\r\n    return true;\r\n  }\r\n\r\n  // @notice This is called once funding has succeeded. Sends Ether to a distribution contract where operator/assetManager can withdraw\r\n  // @dev The contract manager needs to know  the address PlatformDistribution contract\r\n  function payoutERC20(address _assetAddress)\r\n  external\r\n  whenNotPaused\r\n  returns (bool) {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.finalized\u0022, _assetAddress))), \u0022Crowdsale not finalized\u0022);\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.paid\u0022, _assetAddress))), \u0022Crowdsale has paid out\u0022);\r\n    //Set paid to true\r\n    database.setBool(keccak256(abi.encodePacked(\u0022crowdsale.paid\u0022, _assetAddress)), true);\r\n    //Setup token\r\n    address fundingToken = DividendInterface(_assetAddress).getERC20();\r\n    //Mint tokens for the asset manager and platform\r\n    address platformAssetsWallet = database.addressStorage(keccak256(abi.encodePacked(\u0022platform.wallet.assets\u0022)));\r\n    require(platformAssetsWallet != address(0), \u0022Platform assets wallet not set\u0022);\r\n    require(minter.mintAssetTokens(_assetAddress, database.addressStorage(keccak256(abi.encodePacked(\u0022contract\u0022, \u0022AssetManagerFunds\u0022))), database.uintStorage(keccak256(abi.encodePacked(\u0022asset.managerTokens\u0022, _assetAddress)))), \u0022Manager minting failed\u0022);\r\n    require(minter.mintAssetTokens(_assetAddress, platformAssetsWallet, database.uintStorage(keccak256(abi.encodePacked(\u0022asset.platformTokens\u0022, _assetAddress)))), \u0022Platform minting failed\u0022);\r\n    //Get the addresses for the receiver and platform\r\n    address receiver = database.addressStorage(keccak256(abi.encodePacked(\u0022asset.manager\u0022, _assetAddress)));\r\n    address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked(\u0022platform.wallet.funds\u0022)));\r\n    require(receiver != address(0) \u0026\u0026 platformFundsWallet != address(0), \u0022Platform funds walllet or receiver address not set\u0022);\r\n    //Calculate amounts for platform and receiver\r\n    uint amount = database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.goal\u0022, _assetAddress)));\r\n    uint platformFee = amount.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked(\u0022platform.fee\u0022))));\r\n    //Transfer funds to receiver and platform\r\n    require(reserve.issueERC20(platformFundsWallet, platformFee, fundingToken), \u0027Platform funds not paid\u0027);\r\n    require(reserve.issueERC20(receiver, amount, fundingToken), \u0027Receiver funds not paid\u0027);\r\n    //Delete crowdsale start time\r\n    database.deleteUint(keccak256(abi.encodePacked(\u0022crowdsale.start\u0022, _assetAddress)));\r\n    //Increase asset count for manager\r\n    address manager = database.addressStorage(keccak256(abi.encodePacked(\u0022asset.manager\u0022, _assetAddress)));\r\n    database.setUint(keccak256(abi.encodePacked(\u0022manager.assets\u0022, manager)), database.uintStorage(keccak256(abi.encodePacked(\u0022manager.assets\u0022, manager))).add(1));\r\n    //Emit event\r\n    events.transaction(\u0027Asset payout\u0027, _assetAddress, receiver, amount, fundingToken);\r\n    return true;\r\n  }\r\n\r\n  function cancel(address _assetAddress)\r\n  external\r\n  whenNotPaused\r\n  validAsset(_assetAddress)\r\n  beforeDeadline(_assetAddress)\r\n  notFinalized(_assetAddress)\r\n  returns (bool){\r\n    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(\u0022asset.manager\u0022, _assetAddress))));\r\n    database.setUint(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress)), 1);\r\n    refund(_assetAddress);\r\n  }\r\n\r\n  // @notice Contributors can retrieve their funds here if crowdsale has paased deadline\r\n  // @param (address) _assetAddress =  The address of the asset which didn\u0027t reach it\u0027s crowdfunding goals\r\n  function refund(address _assetAddress)\r\n  public\r\n  whenNotPaused\r\n  validAsset(_assetAddress)\r\n  afterDeadline(_assetAddress)\r\n  notFinalized(_assetAddress)\r\n  returns (bool) {\r\n    require(database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress))) != 0);\r\n    database.deleteUint(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress)));\r\n    DividendInterface assetToken = DividendInterface(_assetAddress);\r\n    address tokenAddress = assetToken.getERC20();\r\n    uint refundValue = assetToken.totalSupply().mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\u0022platform.fee\u0022))))).div(100); //total supply plus platform fees\r\n    reserve.refundERC20Asset(_assetAddress, refundValue, tokenAddress);\r\n    return true;\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------\r\n  //                                            Internal Functions\r\n  //------------------------------------------------------------------------------------------------------------------\r\n\r\n  function collectPayment(address user, uint amount, uint max, ERC20 token)\r\n  private\r\n  returns (uint){\r\n    if(amount \u003E max){\r\n      token.transferFrom(user, address(this), max);\r\n      return max;\r\n    } else {\r\n      token.transferFrom(user, address(this), amount);\r\n      return amount;\r\n    }\r\n  }\r\n\r\n  /*\r\n  function fundBurn(address _investor, uint _amount, bytes4 _sig, ERC20 _burnToken)\r\n  private\r\n  returns (uint) {\r\n    require(_burnToken.transferFrom(_investor, address(this), _amount), \u0022Transfer failed\u0022); // transfer investors tokens into contract\r\n    uint balanceBefore = _burnToken.balanceOf(this);\r\n    require(burner.burn(address(this), database.uintStorage(keccak256(abi.encodePacked(_sig, address(this)))), address(_burnToken)));\r\n    uint change = _burnToken.balanceOf(this) - balanceBefore;\r\n    return change;\r\n  }\r\n  */\r\n\r\n  function convertTokens(address _investor, uint _amount, /*bytes4 _sig,*/ ERC20 _fundingToken, ERC20 _paymentToken, uint _maxTokens)\r\n  private\r\n  returns (uint) {\r\n    //( , uint minRate) = kyber.getExpectedRate(address(_paymentToken), address(_fundingToken), 0);\r\n    uint paymentBalanceBefore;\r\n    uint fundingBalanceBefore;\r\n    uint change;\r\n    uint investment;\r\n    if(address(_paymentToken) == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      paymentBalanceBefore = address(this).balance;\r\n      fundingBalanceBefore = _fundingToken.balanceOf(this);\r\n      //Convert remaining funds into the funding token\r\n      kyber.trade.value(_amount)(address(_paymentToken), _amount, address(_fundingToken), address(this), _maxTokens, 0, 0);\r\n      change = _amount.sub(paymentBalanceBefore.sub(address(this).balance));\r\n      investment = _fundingToken.balanceOf(this).sub(fundingBalanceBefore);\r\n      if(change \u003E 0){\r\n        _investor.transfer(change);\r\n      }\r\n    } else {\r\n      //Collect funds\r\n      collectPayment(_investor, _amount, _amount, _paymentToken);\r\n      // Mitigate ERC20 Approve front-running attack, by initially setting\r\n      // allowance to 0\r\n      require(_paymentToken.approve(address(kyber), 0));\r\n      // Approve tokens so network can take them during the swap\r\n      _paymentToken.approve(address(kyber), _amount);\r\n      paymentBalanceBefore = _paymentToken.balanceOf(this);\r\n      fundingBalanceBefore = _fundingToken.balanceOf(this);\r\n      //Convert remaining funds into the funding token\r\n      kyber.trade(address(_paymentToken), _amount, address(_fundingToken), address(this), _maxTokens, 0, 0);\r\n      // Return any remaining source tokens to user\r\n      change = _amount.sub(paymentBalanceBefore.sub(_paymentToken.balanceOf(this)));\r\n      investment = _fundingToken.balanceOf(this).sub(fundingBalanceBefore);\r\n      if(change \u003E 0){\r\n        _paymentToken.transfer(_investor, change);\r\n      }\r\n    }\r\n\r\n    emit Convert(address(_paymentToken), change, investment);\r\n    return investment;\r\n  }\r\n\r\n  // @notice platform owners can recover tokens here\r\n  function recoverTokens(address _erc20Token)\r\n  onlyOwner\r\n  external {\r\n    ERC20 thisToken = ERC20(_erc20Token);\r\n    uint contractBalance = thisToken.balanceOf(address(this));\r\n    thisToken.transfer(msg.sender, contractBalance);\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction(\u0027CrowdsaleERC20 destroyed\u0027, address(this), msg.sender, address(this).balance, address(0));\r\n    //emit LogDestruction(address(this).balance, msg.sender);\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  // @notice fallback function. We need to receive Ether from Kyber Network\r\n  function ()\r\n  external\r\n  payable {\r\n    emit EtherReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------\r\n  //                                            Modifiers\r\n  //------------------------------------------------------------------------------------------------------------------\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))), \u0022Not owner\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice function won\u0027t run if owners have paused this contract\r\n  modifier whenNotPaused {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\u0022paused\u0022, address(this)))));\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the asset does not have a token address set in the database\r\n  modifier validAsset(address _assetAddress) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\u0022asset.manager\u0022, _assetAddress))) != address(0), \u0022Invalid asset\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has not passed\r\n  modifier beforeDeadline(address _assetAddress) {\r\n    require(now \u003C database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress))), \u0022Before deadline\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has already past or crowsale has not started\r\n  modifier betweenDeadlines(address _assetAddress) {\r\n    require(now \u003C= database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress))), \u0022Past deadline\u0022);\r\n    require(now \u003E= database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.start\u0022, _assetAddress))), \u0022Before start time\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has already past\r\n  modifier afterDeadline(address _assetAddress) {\r\n    require(now \u003E database.uintStorage(keccak256(abi.encodePacked(\u0022crowdsale.deadline\u0022, _assetAddress))), \u0022Before deadline\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale is finshed\r\n  modifier finalized(address _assetAddress) {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.finalized\u0022, _assetAddress))), \u0022Crowdsale not finalized\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale is not finshed\r\n  modifier notFinalized(address _assetAddress) {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.finalized\u0022, _assetAddress))), \u0022Crowdsale finalized\u0022);\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale has not paid out\r\n  modifier notPaid(address _assetAddress) {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\u0022crowdsale.paid\u0022, _assetAddress))), \u0022Crowdsale has paid out\u0022);\r\n    _;\r\n  }\r\n\r\n  event Convert(address token, uint change, uint investment);\r\n  event EtherReceived(address sender, uint amount);\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022payoutERC20\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_erc20Token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022recoverTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022cancel\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022destroy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_paymentToken\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022buyAssetOrderERC20\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022refund\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_database\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_events\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_kyber\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022change\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022investment\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Convert\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022EtherReceived\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"CrowdsaleERC20","CompilerVersion":"v0.4.24\u002Bcommit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755","Library":"","SwarmSource":"bzzr://c98dcead9f67f9f0c280b2f40a5ad7ee6304b4db72c7eee9338247b0eeb993c4"}]