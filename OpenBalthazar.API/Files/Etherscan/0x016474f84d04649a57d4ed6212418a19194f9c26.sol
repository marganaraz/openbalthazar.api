[{"SourceCode":"{\u0022SafeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a \u002B b;\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\u0022SafeMath: subtraction overflow\\\u0022);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\u0022SafeMath: division by zero\\\u0022);\\n        uint256 c = a / b;\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\u0022SafeMath: modulo by zero\\\u0022);\\n        return a % b;\\n    }\\n}\\n\u0022},\u0022SnakesAndLadders.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./SafeMath.sol\\\u0022;\\n\\ncontract SnakesAndLadders {\\n    using SafeMath for uint;\\n    using SafeMath for uint8;  // 0-255\\n\\n    // All balances\\n    mapping(address =\\u003e uint) public balances;\\n    uint public totalBalance;\\n\\n    // Payout addresses\\n    address private payout1;\\n    address private payout2;\\n\\n    // Board composition\\n    uint8 constant private tiles = 100;\\n    mapping(uint8 =\\u003e uint8) private boardElements;\\n\\n    // Player: is true if it\\u0027s the user, otherwise is the AI\\n    // Turn: starting from 1\\n    // Move: the dice move from 1 to 6\\n    event LogGame(address sender, bool result, int balancediff, uint seed);\\n    event LogAddPlayerFunds(address sender, uint amount);\\n    event LogWithdrawPlayerFunds(address sender, uint amount);\\n    event LogAddFunds(address sender, uint amount);\\n    event LogPayout(address sender, uint amount);\\n\\n    constructor(address _payout1, address _payout2) public {\\n        // ladders\\n        boardElements[4] = 14;\\n        boardElements[8] = 32;\\n        boardElements[20] = 38;\\n        boardElements[28] = 84;\\n        boardElements[40] = 59;\\n        boardElements[58] = 83;\\n        boardElements[72] = 93;\\n        // snakes\\n        boardElements[15] = 3;\\n        boardElements[31] = 9;\\n        boardElements[44] = 26;\\n        boardElements[62] = 19;\\n        boardElements[74] = 70;\\n        boardElements[85] = 33;\\n        boardElements[91] = 71;\\n        boardElements[98] = 80;\\n        // payouts\\n        payout1 = _payout1;\\n        payout2 = _payout2;\\n    }\\n\\n    /**\\n     * Avoid sending money directly to the contract\\n     */\\n    function () external payable {\\n        revert(\\\u0022Use addPlayerFunds to send money.\\\u0022);\\n    }\\n\\n    /**\\n     * Plays the game\\n     */\\n    function play(uint amount) public {\\n        require(amount \\u003e 0, \\\u0022You must send something to bet\\\u0022);\\n        require(amount \\u003c= balances[msg.sender], \\\u0022You don\\u0027t have enough balance to play\\\u0022);\\n        require(amount*5 \\u003c address(this).balance - totalBalance, \\\u0022You cannot bet more than 1/5 of this contract free balance\\\u0022);\\n        require(amount \\u003c= 1 ether, \\\u0022Maximum bet amount is 1 ether\\\u0022);\\n        require(tx.origin == msg.sender, \\\u0022Contracts cannot play the game\\\u0022);\\n        uint seed = random();\\n        uint turn = 0;\\n        // let\\u0027s decide who starts\\n        bool player = false;  // true if next move is for player, false if for computer\\n        uint8 move = randomDice(seed, turn);  // move 0 decides who starts\\n        if (move == 1 || move == 2) {\\n            player = true;\\n        }\\n        // make all the moves and emit the results\\n        uint8 playerUser = 0;\\n        uint8 playerAI = 0;\\n        uint8 boardElement;\\n        while (playerUser != tiles \\u0026\\u0026 playerAI != tiles) {\\n            turn\u002B\u002B;\\n            move = randomDice(seed, turn);\\n            if (player) {\\n                playerUser = playerUser \u002B move;\\n                if (playerUser \\u003e tiles) {\\n                    playerUser = tiles - (playerUser - tiles);\\n                }\\n                boardElement = boardElements[playerUser];\\n                if (boardElement != 0) {\\n                    playerUser = boardElement;\\n                }\\n            } else {\\n                playerAI = playerAI \u002B move;\\n                if (playerAI \\u003e tiles) {\\n                    playerAI = tiles - (playerAI - tiles);\\n                }\\n                boardElement = boardElements[playerAI];\\n                if (boardElement != 0) {\\n                    playerAI = boardElement;\\n                }\\n            }\\n            // if the player rolls a 6 has an extra turn\\n            if (move != 6) {\\n                player = !player;\\n            }\\n        }\\n        if (playerUser == tiles) {\\n            balances[msg.sender] \u002B= amount;\\n            totalBalance \u002B= amount;\\n            emit LogGame(msg.sender, true, int(amount), seed);\\n        } else {\\n            balances[msg.sender] -= amount;\\n            totalBalance -= amount;\\n            emit LogGame(msg.sender, false, -int(amount), seed);\\n        }\\n\\n        // in case that there are more than 2 ether in the pool generate payout\\n        if (address(this).balance - totalBalance \\u003e= 2 ether) {\\n            emit LogPayout(msg.sender, 0.4 ether);\\n            balances[payout1] \u002B= 0.2 ether;\\n            balances[payout2] \u002B= 0.2 ether;\\n            totalBalance \u002B= 0.4 ether;\\n        }\\n    }\\n\\n    /**\\n     * Returns a non-miner-secure random uint.\\n     */\\n    function random() public view returns(uint) {\\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender)));\\n    }\\n\\n    /**\\n     * Returns a random number from 1 to 6 based from a uint and turn.\\n     */\\n    function randomDice(uint randomString, uint turn) public pure returns(uint8) {\\n        return uint8(randomString/2**(turn%256))%6 \u002B 1;\\n    }\\n\\n    /**\\n     * User adds player funds.\\n     */\\n    function addPlayerFunds() public payable {\\n        require(msg.value \\u003e 0, \\\u0022You must send something to add into balance\\\u0022);\\n        emit LogAddPlayerFunds(msg.sender, msg.value);\\n        balances[msg.sender] \u002B= msg.value;\\n        totalBalance \u002B= msg.value;\\n    }\\n\\n    /**\\n     * Withdraw player funds.\\n     */\\n    function withdrawPlayerFunds() public {\\n        uint toWithdraw = balances[msg.sender];\\n        require(toWithdraw \\u003e 0, \\\u0022There is no balance to withdraw\\\u0022);\\n        require(toWithdraw \\u003c= totalBalance, \\\u0022There are not enough funds in the contract to withdraw\\\u0022);\\n        require(tx.origin == msg.sender, \\\u0022Contracts cannot withdraw funds\\\u0022);\\n        emit LogWithdrawPlayerFunds(msg.sender, toWithdraw);\\n        balances[msg.sender] = 0;\\n        totalBalance -= toWithdraw;\\n        msg.sender.transfer(toWithdraw);\\n    }\\n\\n    /**\\n     * Anyone can send funds but it has to be from this function. This does not count in totalBalance.\\n     */\\n    function addFunds() public payable {\\n        require(msg.value \\u003e 0, \\\u0022You must send something when calling this function\\\u0022);\\n        emit LogAddFunds(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * Only payout addresses can emit payouts.\\n     */\\n    function payout(uint amount) public {\\n        require(msg.sender == payout1 || msg.sender == payout2, \\\u0022You must be one a payout address\\\u0022);\\n        require(amount \\u003e 0, \\\u0022The balance that you want to withdraw must be more than 0\\\u0022);\\n        require(amount%2 == 0, \\\u0022Amount to withdraw must be pair\\\u0022);\\n        // this is made in a way to protect the customer\\n        require(address(this).balance - totalBalance \\u003e= amount, \\\u0022There is not enough free balance to withdraw\\\u0022);\\n        emit LogPayout(msg.sender, amount);\\n        uint half = amount/2;\\n        balances[payout1] \u002B= half;\\n        balances[payout2] \u002B= half;\\n        totalBalance \u002B= amount;\\n    }\\n}\\n\u0022}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balances\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022random\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022play\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022addPlayerFunds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022randomString\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022turn\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022randomDice\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022addFunds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdrawPlayerFunds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022payout\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_payout1\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_payout2\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022result\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022balancediff\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022seed\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogGame\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogAddPlayerFunds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogWithdrawPlayerFunds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogAddFunds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogPayout\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"SnakesAndLadders","CompilerVersion":"v0.5.0\u002Bcommit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000042d69871dde6671bd3ff31e574ddb633aa5ac59a0000000000000000000000002e01efc4ceb6252368aba343b97a91b850a2503a","Library":"","SwarmSource":"bzzr://decde68c1ad8307e1cc237f0581a5ed1688794f649e3a4f28234efe225523b08"}]