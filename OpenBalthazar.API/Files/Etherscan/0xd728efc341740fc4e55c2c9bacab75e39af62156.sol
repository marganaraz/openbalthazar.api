[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\ninterface CTokenInterface {\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CERC20Interface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function repayBorrow(uint repayAmount) external returns (uint); // For ERC20\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable; // For ETH\r\n    function repayBorrow() external payable; // For ETH\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ninterface CompOracleInterface {\r\n    function getUnderlyingPrice(address) external view returns (uint);\r\n}\r\n\r\ninterface SplitSwapInterface {\r\n    function getBest(address src, address dest, uint srcAmt) external view returns (uint bestExchange, uint destAmt);\r\n    function ethToDaiSwap(uint splitAmt, uint slippageAmt) external payable returns (uint destAmt);\r\n    function daiToEthSwap(uint srcAmt, uint splitAmt, uint slippageAmt) external returns (uint destAmt);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x, \u0022math-not-safe\u0022);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        z = x - y \u003C= x ? x - y : 0;\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \u0022math-not-safe\u0022);\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get Dai v2 address\r\n     */\r\n    function getAddressDAI() public pure returns (address dai) {\r\n        dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() public pure returns (address troller) {\r\n        troller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Orcale Address\r\n     */\r\n    function getCompOracleAddress() public pure returns (address troller) {\r\n        troller = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Ceth Address\r\n     */\r\n    function getCETHAddress() public pure returns (address cEth) {\r\n        cEth = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Dai Address\r\n     */\r\n    function getCDAIAddress() public pure returns (address cDai) {\r\n        cDai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    }\r\n\r\n    /**\r\n     * @dev get SplitSwap address\r\n     */\r\n    function getAddressSplitSwap() public pure returns (address payable splitSwap) {\r\n        splitSwap = 0x0a6bb2770450F8BB7Cc0b42ee859ac7f9177010D;\r\n    }\r\n\r\n    function enterMarket(address cErc20) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i \u003C markets.length; i\u002B\u002B) {\r\n            if (markets[i] == cErc20) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cErc20;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev setting allowance to compound for the \u0022user proxy\u0022 if required.\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        ERC20Interface erc20Contract = ERC20Interface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt \u003E tokenAllowance) {\r\n            erc20Contract.approve(to, 2**255);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract CompoundHelper is Helpers {\r\n\r\n    /**\r\n     * @dev get users overall details for Compound\r\n     */\r\n    function getCompStats(\r\n        address user,\r\n        address[] memory cTokenAddr,\r\n        uint[] memory cTokenFactor\r\n    ) public returns (uint totalSupply, uint totalBorrow, uint maxBorrow, uint borrowRemain, uint maxWithdraw, uint ratio)\r\n    {\r\n        for (uint i = 0; i \u003C cTokenAddr.length; i\u002B\u002B) {\r\n            address cTokenAdd = cTokenAddr[i];\r\n            uint factor = cTokenFactor[i];\r\n            (uint supplyInEth, uint borrowInEth) = compSupplyBorrow(cTokenAdd, user);\r\n            totalSupply \u002B= supplyInEth;\r\n            totalBorrow \u002B= borrowInEth;\r\n            maxBorrow \u002B= wmul(supplyInEth, factor);\r\n        }\r\n        borrowRemain = sub(maxBorrow, totalBorrow);\r\n        maxWithdraw = sub(wdiv(borrowRemain, 750000000000000000), 10); // divide it by 0.75 (ETH Factor)\r\n        uint userEthSupply = getEthSupply(user);\r\n        maxWithdraw = userEthSupply \u003E maxWithdraw ? maxWithdraw : userEthSupply;\r\n        ratio = wdiv(totalBorrow, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev get user\u0027s token supply and borrow in ETH\r\n     */\r\n    function compSupplyBorrow(address cTokenAdd, address user) internal returns(uint supplyInEth, uint borrowInEth) {\r\n        CTokenInterface cTokenContract = CTokenInterface(cTokenAdd);\r\n        uint tokenPriceInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(cTokenAdd);\r\n        uint cTokenBal = sub(cTokenContract.balanceOf(user), 1);\r\n        uint cTokenExchangeRate = cTokenContract.exchangeRateCurrent();\r\n        uint tokenSupply = sub(wmul(cTokenBal, cTokenExchangeRate), 1);\r\n        supplyInEth = sub(wmul(tokenSupply, tokenPriceInEth), 10);\r\n        uint tokenBorrowed = cTokenContract.borrowBalanceCurrent(user);\r\n        borrowInEth = add(wmul(tokenBorrowed, tokenPriceInEth), 10);\r\n    }\r\n\r\n    function getEthSupply(address user) internal returns (uint ethSupply) {\r\n        CTokenInterface cTokenContract = CTokenInterface(getCETHAddress());\r\n        uint cTokenBal = sub(cTokenContract.balanceOf(user), 1);\r\n        uint cTokenExchangeRate = cTokenContract.exchangeRateCurrent();\r\n        ethSupply = wmul(cTokenBal, cTokenExchangeRate);\r\n    }\r\n\r\n    function daiBorrowed(address user) internal returns (uint daiAmt) {\r\n        CTokenInterface cTokenContract = CTokenInterface(getCDAIAddress());\r\n        daiAmt = cTokenContract.borrowBalanceCurrent(user);\r\n    }\r\n\r\n    function getDaiRemainBorrow(uint daiInEth) internal view returns (uint daiAmt) {\r\n        uint tokenPriceInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\r\n        daiAmt = sub(wdiv(daiInEth, tokenPriceInEth), 10);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundResolver is CompoundHelper {\r\n\r\n    event LogMint(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRedeem(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogBorrow(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRepay(address erc20, address cErc20, uint tokenAmt, address owner);\r\n\r\n    function getSave(\r\n        address user,\r\n        uint ethToFree,\r\n        address[] memory cTokenAddr,\r\n        uint[] memory ctokenFactor\r\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint daiDebt, bool isOk)\r\n    {\r\n        (uint totalSupply, uint totalBorrow,,,uint maxWithdraw,) = getCompStats(user, cTokenAddr, ctokenFactor);\r\n        uint ethToSwap = ethToFree \u003C maxWithdraw ? ethToFree : maxWithdraw;\r\n        (, uint expectedDAI) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressETH(), getAddressDAI(), ethToSwap);\r\n        uint daiBorrowed = daiBorrowed(user);\r\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\r\n        if (daiBorrowed \u003C expectedDAI) {\r\n            finalColInEth = sub(totalSupply, ethToSwap);\r\n            finalDebtInEth = sub(totalBorrow, wmul(daiBorrowed, daiInEth));\r\n            daiDebt = 0;\r\n            isOk = false;\r\n        } else {\r\n            finalColInEth = sub(totalSupply, ethToSwap);\r\n            finalDebtInEth = sub(totalBorrow, wmul(expectedDAI, daiInEth));\r\n            daiDebt = sub(daiBorrowed, expectedDAI);\r\n            isOk = true;\r\n        }\r\n    }\r\n\r\n    function getLeverage(\r\n        address user,\r\n        uint daiToBorrow,\r\n        address[] memory cTokenAddr,\r\n        uint[] memory ctokenFactor\r\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint ethCol)\r\n    {\r\n        (uint totalSupply, uint totalBorrow,, uint borrowRemain,,) = getCompStats(user, cTokenAddr, ctokenFactor);\r\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\r\n        daiToSwap = daiToSwap \u003C daiToBorrow ? daiToSwap : daiToBorrow;\r\n        (, uint expectedETH) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressDAI(), getAddressETH(), daiToSwap);\r\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\r\n        finalColInEth = add(totalSupply, expectedETH);\r\n        finalDebtInEth = add(totalBorrow, wmul(daiToSwap, daiInEth));\r\n        ethCol = add(getEthSupply(user), expectedETH);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20 and mint Compound Tokens\r\n     */\r\n    function mintCEth(uint tokenAmt) internal {\r\n        CETHInterface cToken = CETHInterface(getCETHAddress());\r\n        cToken.mint.value(tokenAmt)();\r\n        emit LogMint(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem ETH/ERC20 and mint Compound Tokens\r\n     * @param tokenAmt Amount of token To Redeem\r\n     */\r\n    function redeemEth(uint tokenAmt) internal {\r\n        CTokenInterface cToken = CTokenInterface(getCETHAddress());\r\n        setApproval(getCETHAddress(), 10**30, getCETHAddress());\r\n        require(cToken.redeemUnderlying(tokenAmt) == 0, \u0022something went wrong\u0022);\r\n        emit LogRedeem(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev borrow ETH/ERC20\r\n     */\r\n    function borrow(uint tokenAmt) internal {\r\n        require(CTokenInterface(getCDAIAddress()).borrow(tokenAmt) == 0, \u0022got collateral?\u0022);\r\n        emit LogBorrow(\r\n            getAddressDAI(),\r\n            getCDAIAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Pay Debt ETH/ERC20\r\n     */\r\n    function repayDai(uint tokenAmt) internal {\r\n        CERC20Interface cToken = CERC20Interface(getCDAIAddress());\r\n        setApproval(getAddressDAI(), tokenAmt, getCDAIAddress());\r\n        require(cToken.repayBorrow(tokenAmt) == 0, \u0022transfer approved?\u0022);\r\n        emit LogRepay(\r\n            getAddressDAI(),\r\n            getCDAIAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundSave is CompoundResolver {\r\n\r\n    event LogSaveDaiCompound(uint srcETH, uint destDAI);\r\n    event LogLeverageDaiCompound(uint srcDAI,uint destETH);\r\n\r\n    function save(\r\n        uint ethToFree,\r\n        address[] memory ctokenAddr,\r\n        uint[] memory ctokenFactor,\r\n        uint splitAmt,\r\n        uint slippageAmt\r\n    ) public\r\n    {\r\n        enterMarket(getCETHAddress());\r\n        enterMarket(getCDAIAddress());\r\n        (,,,,uint maxWithdraw,) = getCompStats(address(this), ctokenAddr, ctokenFactor);\r\n        uint ethToSwap = ethToFree \u003C maxWithdraw ? ethToFree : maxWithdraw;\r\n        redeemEth(ethToSwap);\r\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).ethToDaiSwap.value(ethToSwap)(splitAmt, slippageAmt);\r\n        repayDai(destAmt);\r\n        emit LogSaveDaiCompound(ethToSwap, destAmt);\r\n    }\r\n\r\n    function leverage(\r\n        uint daiToBorrow,\r\n        address[] memory cTokenAddr,\r\n        uint[] memory ctokenFactor,\r\n        uint splitAmt,\r\n        uint slippageAmt\r\n    ) public\r\n    {\r\n        enterMarket(getCETHAddress());\r\n        enterMarket(getCDAIAddress());\r\n        (,,,uint borrowRemain,,) = getCompStats(address(this), cTokenAddr, ctokenFactor);\r\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\r\n        daiToSwap = daiToSwap \u003C daiToBorrow ? daiToSwap : daiToBorrow;\r\n        borrow(daiToSwap);\r\n        ERC20Interface(getAddressDAI()).approve(getAddressSplitSwap(), daiToSwap);\r\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).daiToEthSwap(daiToSwap, splitAmt, slippageAmt);\r\n        mintCEth(destAmt);\r\n        emit LogLeverageDaiCompound(daiToSwap, destAmt);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaCompDaiSave is CompoundSave {\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022daiToBorrow\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022cTokenAddr\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022ctokenFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022splitAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022slippageAmt\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022leverage\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getComptrollerAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022troller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022ethToFree\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022cTokenAddr\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022ctokenFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022getSave\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022finalColInEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022finalDebtInEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022daiDebt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022isOk\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCompOracleAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022troller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022daiToBorrow\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022cTokenAddr\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022ctokenFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022getLeverage\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022finalColInEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022finalDebtInEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022ethCol\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAddressETH\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022eth\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAddressDAI\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022dai\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCETHAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022cEth\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022ethToFree\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022ctokenAddr\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022ctokenFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022splitAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022slippageAmt\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022save\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022cTokenAddr\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022cTokenFactor\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022getCompStats\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022totalSupply\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalBorrow\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxBorrow\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022borrowRemain\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxWithdraw\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022ratio\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAddressSplitSwap\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022splitSwap\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCDAIAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022cDai\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcETH\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022destDAI\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogSaveDaiCompound\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcDAI\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022destETH\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogLeverageDaiCompound\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022erc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022cErc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogMint\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022erc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022cErc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogRedeem\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022erc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022cErc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogBorrow\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022erc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022cErc20\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenAmt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogRepay\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"InstaCompDaiSave","CompilerVersion":"v0.5.8\u002Bcommit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3e016323b16ed416af01fc05c3f6a1969d4b62342794e0ec3459b1f52201cb19"}]