[{"SourceCode":"pragma solidity ^0.5.2;\r\ncontract RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n\r\n    function encodeBytes(bytes memory self) internal  returns (bytes memory) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 \u0026\u0026 uint8(self[0]) \u003C 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal  returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private  returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        bytes memory encoded;\r\n        uint encodedPtr;\r\n\r\n        uint len = self.length;\r\n        uint lenLen;\r\n        uint i = 0x1;\r\n        while(len/i != 0) {\r\n            lenLen\u002B\u002B;\r\n            i *= 0x100;\r\n        }\r\n\r\n        if(len \u003C= 55) {\r\n            encoded = new bytes(len\u002B1);\r\n\r\n            // length encoding byte\r\n            encoded[0] = byte(uint8(prefix1\u002Blen));\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        } else {\r\n            // 1 is the length of the length of the length\r\n            encoded = new bytes(1\u002BlenLen\u002Blen);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(uint8(prefix2\u002BlenLen));\r\n\r\n            // length bytes\r\n            for(i=1; i\u003C=lenLen; i\u002B\u002B) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    function flatten(bytes[] memory self) private  returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i\u003Cself.length; i\u002B\u002B) {\r\n            len \u002B= self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i\u003Cself.length; i\u002B\u002B) {\r\n            bytes memory item = self[i];\r\n\r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr \u002B= self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson\u0027s string utils library\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003E= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest \u002B= 32;\r\n            src \u002B= 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function strToBytes(string memory data)internal pure returns (bytes memory){\r\n        uint _ascii_0 = 48;\r\n        uint _ascii_A = 65;\r\n        uint _ascii_a = 97;\r\n\r\n        bytes memory a = bytes(data);\r\n        uint[] memory b = new uint[](a.length);\r\n\r\n        for (uint i = 0; i \u003C a.length; i\u002B\u002B) {\r\n            uint _a = uint8(a[i]);\r\n\r\n            if (_a \u003E 96) {\r\n                b[i] = _a - 97 \u002B 10;\r\n            }\r\n            else if (_a \u003E 66) {\r\n                b[i] = _a - 65 \u002B 10;\r\n            }\r\n            else {\r\n                b[i] = _a - 48;\r\n            }\r\n        }\r\n\r\n        bytes memory c = new bytes(b.length / 2);\r\n        for (uint _i = 0; _i \u003C b.length; _i \u002B= 2) {\r\n            c[_i / 2] = byte(uint8(b[_i] * 16 \u002B b[_i \u002B 1]));\r\n        }\r\n\r\n        return c;\r\n    }\r\n\r\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i\u003Cb.length;i\u002B\u002B){\r\n            number = number \u002B uint8(b[i])*(2**(8*(b.length-(i\u002B1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function stringToUint(string memory s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i \u003C b.length; i\u002B\u002B) {\r\n           if (uint8(b[i]) \u003E= 48 \u0026\u0026 uint8(b[i]) \u003C= 57){\r\n                result = result * 16 \u002B (uint8(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n            else if(uint8(b[i]) \u003E= 97 \u0026\u0026 uint8(b[i]) \u003C= 122)\r\n            {\r\n                result = result * 16 \u002B (uint8(b[i]) - 87);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function subString(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i \u003C endIndex; i\u002B\u002B) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length \u002B _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i \u003C _ba.length; i\u002B\u002B) bab[k\u002B\u002B] = _ba[i];\r\n            for (uint i = 0; i \u003C _bb.length; i\u002B\u002B) bab[k\u002B\u002B] = _bb[i];\r\n                return string(bab);\r\n        }\r\n\r\n    function stringToAddr(string memory _input) internal pure returns (address){\r\n        string memory _a = strConcat(\u00220x\u0022,_input);\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i\u003C2\u002B2*20; i\u002B=2){\r\n            iaddr *= 256;\r\n            b1 = uint8(tmp[i]);\r\n            b2 = uint8(tmp[i\u002B1]);\r\n            if ((b1 \u003E= 97)\u0026\u0026(b1 \u003C= 102)) b1 -= 87;\r\n            else if ((b1 \u003E= 48)\u0026\u0026(b1 \u003C= 57)) b1 -= 48;\r\n            if ((b2 \u003E= 97)\u0026\u0026(b2 \u003C= 102)) b2 -= 87;\r\n            else if ((b2 \u003E= 48)\u0026\u0026(b2 \u003C= 57)) b2 -= 48;\r\n            iaddr \u002B= (b1*16\u002Bb2);\r\n        }\r\n            return address(iaddr);\r\n    }\r\n\r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \u00220123456789abcdef\u0022;\r\n\r\n        bytes memory str = new bytes(40);\r\n\r\n        for (uint i = 0; i \u003C 20; i\u002B\u002B) {\r\n            str[i*2] = alphabet[uint8(value[i \u002B 12] \u003E\u003E 4)];\r\n            str[1\u002Bi*2] = alphabet[uint8(value[i \u002B 12] \u0026 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function toHexDigit(uint8 d) pure internal returns (byte) {                                                                                      \r\n        if (0 \u003C= d \u0026\u0026 d \u003C= 9) {                                                                                                                      \r\n            return byte(uint8(byte(\u00270\u0027)) \u002B d);                                                                                                       \r\n        } else if (10 \u003C= uint8(d) \u0026\u0026 uint8(d) \u003C= 15) {                                                                                               \r\n            return byte(uint8(byte(\u0027a\u0027)) \u002B d - 10);                                                                                                  \r\n        }                                                                                                                                            \r\n    }   \r\n    \r\n    function fromCode(bytes4 code) public pure returns (string memory) {                                                                                    \r\n        bytes memory result = new bytes(8);                                                                                                         \r\n        //result[0] = byte(\u00270\u0027);\r\n        //result[1] = byte(\u0027x\u0027);\r\n        for (uint i=0; i\u003C4; \u002B\u002Bi) {\r\n            result[2*i\u002B0] = toHexDigit(uint8(code[i])/16);\r\n            result[2*i\u002B1] = toHexDigit(uint8(code[i])%16);\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    \r\n    function getMsgHash(address _destination, string memory _value, string memory _strTransactionData)  internal returns (bytes32){\r\n\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        bytes[] memory bytesArray = new bytes[](9);\r\n\r\n        rawTx[0] = hex\u002209\u0022;\r\n        rawTx[1] = hex\u002209502f9000\u0022;\r\n        rawTx[2] = hex\u00225208\u0022;\r\n        rawTx[3] = addressToBytes(_destination);\r\n        rawTx[4] = strToBytes(_value);\r\n        rawTx[5] = strToBytes(_strTransactionData);\r\n        rawTx[6] = hex\u002201\u0022; //03=testnet,01=mainnet\r\n\r\n        for(uint8 i = 0; i \u003C 9; i\u002B\u002B){\r\n            bytesArray[i] = encodeBytes(rawTx[i]);\r\n        }\r\n\r\n        bytes memory bytesList = encodeList(bytesArray);\r\n\r\n        return keccak256(bytesList);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IVTPermission\r\n * @dev Contract for Permission applications.\r\n */\r\ncontract IVTPermission is RLPEncode {\r\n\r\n    /// @dev  (\u7B7E\u540D\u5730\u5740==\u300B\u6807\u5FD7\u4F4D)\r\n    mapping (address =\u003E bool) public signers;\r\n    /// @dev  \uFF08\u4EA4\u6613\u5386\u53F2==\u300B\u6807\u5FD7\u4F4D\uFF09\r\n    mapping (uint256 =\u003E bool) public transactions;\r\n    /// @dev  \u7B7E\u540D\u6240\u9700\u6700\u5C11\u7B7E\u540D\r\n    uint8 public required;\r\n\r\n/// @dev  Emitted by successful \u0060upgrade\u0060 calls.\r\n    event Completed(\r\n        bytes4 _callbackSelector,\r\n        address _newAddress,\r\n        address _sender\r\n    );\r\n\r\n    constructor(address[] memory _signers, uint8 _required) public {\r\n        require(_required \u003C= _signers.length \u0026\u0026 _required \u003E 0 \u0026\u0026 _signers.length \u003E 0);\r\n\r\n        for (uint8 i = 0; i \u003C _signers.length; i\u002B\u002B){\r\n            require(_signers[i] != address(0));\r\n            signers[_signers[i]] = true;\r\n        }\r\n        required = _required;\r\n    }\r\n\r\n/**\r\n * @dev    \u5916\u90E8\u51FD\u6570\uFF0C\u5347\u7EA7\u786E\u8BA4\r\n * @param  _callbackSelector \u56DE\u8C03\u51FD\u6570\u9009\u62E9\u5668\r\n * @param  _newAddress \u65B0\u7684\u5730\u5740\r\n * @param  _strTransactionData v4\u7248\u672C\u6570\u636E\u7ED3\u6784 [proxy\u5730\u5740]\u002B[\u65F6\u95F4\u6233]\r\n * @param  _v v\u6570\u7EC4\uFF0C\u5982[27,28,28]\r\n * @param  _r r\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @param  _s s\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @return \r\n */\r\n    function confirmChange(bytes4 _callbackSelector, address _newAddress, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s) public {\r\n        processAndCheckParam(_newAddress, _strTransactionData, _v, _r, _s);\r\n        _strTransactionData = RLPEncode.strConcat(_strTransactionData, RLPEncode.fromCode(_callbackSelector));\r\n        //value \u4F7F\u7528\u56FA\u5B9A\u503C03e8\r\n        bytes32 _msgHash = getMsgHash(_newAddress, \u002203e8\u0022, _strTransactionData);\r\n        \r\n        verifySignatures(_msgHash, _v, _r, _s);\r\n\r\n        msg.sender.call(abi.encodeWithSelector(_callbackSelector, _newAddress));\r\n        emit Completed(_callbackSelector, _newAddress, msg.sender);\r\n    }\r\n\r\n\r\n/**\r\n * @dev    \u6821\u9A8C\u53C2\u6570\uFF0C\u5185\u90E8\u51FD\u6570\r\n * @param  _destination \u5347\u7EA7\u65B0\u5730\u5740\r\n * @param  _strTransactionData \u7B7E\u540D\u6570\u636E\uFF0Cv4\u7248\u672C\u6570\u636E\u7ED3\u6784\u4E3A [proxy\u5730\u5740]\u002B[\u65F6\u95F4\u6233]\r\n * @param  _v \u5982\u4E0A\r\n * @param  _r \u5982\u4E0A\r\n * @param  _s \u5982\u4E0A\r\n * @return \r\n */\r\n    function processAndCheckParam(address _destination, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s)  internal {\r\n        require(_destination != address(0)  \u0026\u0026 _v.length == _r.length \u0026\u0026 _v.length == _s.length \u0026\u0026 _v.length \u003E 0);\r\n\r\n        string memory strTransactionTime = RLPEncode.subString(_strTransactionData, 40, 48);\r\n        uint256 transactionTime = RLPEncode.stringToUint(strTransactionTime);\r\n        require(!transactions[transactionTime]);\r\n\r\n        string memory strTransactionAddress = RLPEncode.subString(_strTransactionData, 0, 40);\r\n        address contractAddress = RLPEncode.stringToAddr(strTransactionAddress);\r\n        //\u591A\u7B7E\u5730\u5740 == proxy\u5730\u5740\r\n        require(contractAddress == address(msg.sender));\r\n\r\n        transactions[transactionTime] = true;\r\n    }\r\n\r\n\r\n/**\r\n * @dev   \u5185\u90E8\u51FD\u6570\uFF0C\u6821\u9A8C\u7B7E\u540D\r\n * @param _msgHash \u7B7E\u540D\u6D88\u606FHash\r\n * @param  _v  \u5982\u4E0A\r\n * @param  _r  \u5982\u4E0A\r\n * @param  _s  \u5982\u4E0A\r\n * @return \r\n */\r\n    function verifySignatures(bytes32 _msgHash, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s) view internal {\r\n        uint8 hasConfirmed = 0;\r\n        address[] memory  tempAddresses = new address[](_v.length);\r\n\r\n        for (uint8 i = 0; i \u003C _v.length; i\u002B\u002B){\r\n            tempAddresses[i]  = ecrecover(_msgHash, _v[i], _r[i], _s[i]);\r\n       \r\n            require(signers[tempAddresses[i]]);\r\n            hasConfirmed\u002B\u002B;\r\n        }\r\n\r\n        for (uint8 m = 0; m \u003C _v.length; m\u002B\u002B){\r\n            for (uint8 n = m \u002B 1; n\u003C _v.length; n\u002B\u002B){\r\n                require(tempAddresses[m] != tempAddresses[n]);\r\n            }\r\n        }\r\n\r\n        require(hasConfirmed \u003E= required);\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_callbackSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022name\u0022:\u0022_newAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_strTransactionData\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_v\u0022,\u0022type\u0022:\u0022uint8[]\u0022},{\u0022name\u0022:\u0022_r\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022name\u0022:\u0022_s\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022name\u0022:\u0022confirmChange\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022code\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022fromCode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022signers\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transactions\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022required\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_signers\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022_required\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_callbackSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_newAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Completed\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"IVTPermission","CompilerVersion":"v0.5.2\u002Bcommit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000004f5626836da5e26b08ebb5dcf289b7abab35e237000000000000000000000000120a601ad7f892a52e330a20d20db23c87dd8526000000000000000000000000b2ba8ab4712f15fb75cda3e821a13ee677990dfa","Library":"","SwarmSource":"bzzr://d5cde17c1342f06d56ef4157af86355454464d714deadee30170d3004e57b589"}]