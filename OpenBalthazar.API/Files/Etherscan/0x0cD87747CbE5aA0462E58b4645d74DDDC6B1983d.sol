[{"SourceCode":"// File: contracts/commons/SigUtils.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\nlibrary SigUtils {\r\n    /**\r\n      @dev Recovers address who signed the message \r\n      @param _hash operation ethereum signed message hash\r\n      @param _signature message \u0060hash\u0060 signature  \r\n    */\r\n    function ecrecover2 (\r\n        bytes32 _hash, \r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v \u003C 27) {\r\n            v \u002B= 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            _hash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/Marmo.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/*\r\n    Marmo wallet\r\n\r\n    It has a signer, and it accepts signed messages \u00B4Intents\u00B4 (Meta-Txs)\r\n    all messages are composed by an interpreter and a \u00B4data\u00B4 field.\r\n*/\r\ncontract Marmo {\r\n    event Relayed(bytes32 indexed _id, address _implementation, bytes _data);\r\n    event Canceled(bytes32 indexed _id);\r\n\r\n    // Random Invalid signer address\r\n    // Intents signed with this address are invalid\r\n    address private constant INVALID_ADDRESS = address(0x9431Bab00000000000000000000000039bD955c9);\r\n\r\n    // Random slot to store signer\r\n    bytes32 private constant SIGNER_SLOT = keccak256(\u0022marmo.wallet.signer\u0022);\r\n\r\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\r\n    mapping(bytes32 =\u003E bytes32) private intentReceipt;\r\n\r\n    function() external payable {}\r\n\r\n    // Inits the wallet, any address can Init\r\n    // it must be called using another contract\r\n    function init(address _signer) external payable {\r\n        address signer;\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { signer := sload(signerSlot) }\r\n        require(signer == address(0), \u0022Signer already defined\u0022);\r\n        assembly { sstore(signerSlot, _signer) }\r\n    }\r\n\r\n    // Signer of the Marmo wallet\r\n    // can perform transactions by signing Intents\r\n    function signer() public view returns (address _signer) {\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { _signer := sload(signerSlot) }\r\n    } \r\n\r\n    // Address that relayed the \u0060_id\u0060 intent\r\n    // address(0) if the intent was not relayed\r\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\r\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Block when the intent was relayed\r\n    // 0 if the intent was not relayed\r\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\r\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // True if the intent was canceled\r\n    // An executed intent can\u0027t be canceled and\r\n    // a Canceled intent can\u0027t be executed\r\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\r\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Relay a signed intent\r\n    //\r\n    // The implementation receives data containing the id of the \u0027intent\u0027 and its data,\r\n    // and it will perform all subsequent calls.\r\n    //\r\n    // The same _implementation and _data combination can only be relayed once\r\n    //\r\n    // Returns the result of the \u0027delegatecall\u0027 execution\r\n    function relay(\r\n        address _implementation,\r\n        bytes calldata _data,\r\n        bytes calldata _signature\r\n    ) external payable returns (\r\n        bytes memory result\r\n    ) {\r\n        // Calculate ID from\r\n        // (this, _implementation, data)\r\n        // Any change in _data results in a different ID\r\n        bytes32 id = keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _implementation,\r\n                keccak256(_data)\r\n            )\r\n        );\r\n\r\n        // Read receipt only once\r\n        // if the receipt is 0, the Intent was not canceled or relayed\r\n        if (intentReceipt[id] != bytes32(0)) {\r\n            // Decode the receipt and determine if the Intent was canceled or relayed\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\r\n            require(relayer == address(0), \u0022Intent already relayed\u0022);\r\n            require(!canceled, \u0022Intent was canceled\u0022);\r\n            revert(\u0022Unknown error\u0022);\r\n        }\r\n\r\n        // Read the signer from storage, avoid multiples \u0027sload\u0027 ops\r\n        address _signer = signer();\r\n\r\n        // The signer \u0027INVALID_ADDRESS\u0027 is considered invalid and it will always throw\r\n        // this is meant to disable the wallet safely\r\n        require(_signer != INVALID_ADDRESS, \u0022Signer is not a valid address\u0022);\r\n\r\n        // Validate is the msg.sender is the signer or if the provided signature is valid\r\n        require(_signer == msg.sender || _signer == SigUtils.ecrecover2(id, _signature), \u0022Invalid signature\u0022);\r\n\r\n        // Save the receipt before performing any other action\r\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\r\n\r\n        // Emit the \u0027relayed\u0027 event\r\n        emit Relayed(id, _implementation, _data);\r\n\r\n        // Perform \u0027delegatecall\u0027 to _implementation, appending the id of the intent\r\n        // to the beginning of the _data.\r\n\r\n        bool success;\r\n        (success, result) = _implementation.delegatecall(abi.encode(id, _data));\r\n\r\n        // If the \u0027delegatecall\u0027 failed, reverts the transaction\r\n        // forwarding the revert message\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(result, 32), mload(result))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cancels a not executed Intent \u0027_id\u0027\r\n    // a canceled intent can\u0027t be executed\r\n    function cancel(bytes32 _id) external {\r\n        require(msg.sender == address(this), \u0022Only wallet can cancel txs\u0022);\r\n\r\n        if (intentReceipt[_id] != bytes32(0)) {\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\r\n            require(relayer == address(0), \u0022Intent already relayed\u0022);\r\n            require(!canceled, \u0022Intent was canceled\u0022);\r\n            revert(\u0022Unknown error\u0022);\r\n        }\r\n\r\n        emit Canceled(_id);\r\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\r\n    }\r\n\r\n    // Encodes an Intent receipt\r\n    // into a single bytes32\r\n    // canceled (1 bit) \u002B block (95 bits) \u002B relayer (160 bits)\r\n    // notice: Does not validate the _block length,\r\n    // a _block overflow would not corrupt the wallet state\r\n    function _encodeReceipt(\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) internal pure returns (bytes32 _receipt) {\r\n        assembly {\r\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\r\n        }\r\n    }\r\n    \r\n    // Decodes an Intent receipt\r\n    // reverse of _encodeReceipt(bool,uint256,address)\r\n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) {\r\n        assembly {\r\n            _canceled := shr(255, _receipt)\r\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\r\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    // Used to receive ERC721 tokens\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\r\n        return bytes4(0x150b7a02);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/DepsUtils.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n// Utils Toolset to use as dependencies\r\n// in a Marmo Intent\r\ncontract DepsUtils {\r\n    // Validates if a list of \u0027intents\u0027 was relayed\r\n    // Returns true if all intents where relayed, false otherwise\r\n    function multipleDeps(Marmo[] calldata _wallets, bytes32[] calldata _ids) external view returns (bool) {\r\n        uint256 size = _wallets.length;\r\n\r\n        require(\r\n            size == _ids.length,\r\n            \u0022_wallets and _ids should have equal length\u0022\r\n        );\r\n\r\n        for (uint256 i = 0; i \u003C size; i\u002B\u002B) {\r\n            if (_wallets[i].relayedBy(_ids[i]) == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract Marmo[]\u0022,\u0022name\u0022:\u0022_wallets\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022_ids\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022name\u0022:\u0022multipleDeps\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"DepsUtils","CompilerVersion":"v0.5.16\u002Bcommit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9ab5386f7c79600a4b6e873d6e5541435102ce649218afa918eef71aa7b9c156"}]