[{"SourceCode":"// File: contracts/ERC20Interface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=\u003Euint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty \u003C= MAX_QTY);\r\n        require(rate \u003C= MAX_RATE);\r\n\r\n        if (dstDecimals \u003E= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) \u003C= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) \u003C= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty \u003C= MAX_QTY);\r\n        require(rate \u003C= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals \u003E= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) \u003C= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) \u003C= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator \u002B denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/ConversionRatesInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface ConversionRatesInterface {\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public;\r\n\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=\u003Ebool) internal operators;\r\n    mapping(address=\u003Ebool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length \u003C MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i \u003C alertersGroup.length; \u002B\u002Bi) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length \u003C MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i \u003C operatorsGroup.length; \u002B\u002Bi) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/reserves/VolumeImbalanceRecorder.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\ncontract VolumeImbalanceRecorder is Withdrawable {\r\n\r\n    uint constant internal SLIDING_WINDOW_SIZE = 5;\r\n    uint constant internal POW_2_64 = 2 ** 64;\r\n\r\n    struct TokenControlInfo {\r\n        uint minimalRecordResolution; // can be roughly 1 cent\r\n        uint maxPerBlockImbalance; // in twei resolution\r\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\r\n                            // before halting trade\r\n    }\r\n\r\n    mapping(address =\u003E TokenControlInfo) internal tokenControlInfo;\r\n\r\n    struct TokenImbalanceData {\r\n        int  lastBlockBuyUnitsImbalance;\r\n        uint lastBlock;\r\n\r\n        int  totalBuyUnitsImbalance;\r\n        uint lastRateUpdateBlock;\r\n    }\r\n\r\n    mapping(address =\u003E mapping(uint=\u003Euint)) public tokenImbalanceData;\r\n\r\n    function VolumeImbalanceRecorder(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    function setTokenControlInfo(\r\n        ERC20 token,\r\n        uint minimalRecordResolution,\r\n        uint maxPerBlockImbalance,\r\n        uint maxTotalImbalance\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            );\r\n    }\r\n\r\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\r\n        return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance);\r\n    }\r\n\r\n    function addImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        internal\r\n    {\r\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\r\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\r\n\r\n        int prevImbalance = 0;\r\n\r\n        TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\r\n\r\n        // first scenario - this is not the first tx in the current block\r\n        if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance \u002B= recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance \u002B= recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) \u002B recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance \u002B= recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) \u002B recordedBuyAmount;\r\n        }\r\n\r\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\r\n    }\r\n\r\n    function setGarbageToVolumeRecorder(ERC20 token) internal {\r\n        for (uint i = 0; i \u003C SLIDING_WINDOW_SIZE; i\u002B\u002B) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }\r\n    }\r\n\r\n    function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\r\n        // check the imbalance in the sliding window\r\n        require(startBlock \u003C= endBlock);\r\n\r\n        buyImbalance = 0;\r\n\r\n        for (uint windowInd = 0; windowInd \u003C SLIDING_WINDOW_SIZE; windowInd\u002B\u002B) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock \u003C= endBlock \u0026\u0026 perBlockData.lastBlock \u003E= startBlock) {\r\n                buyImbalance \u002B= int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int buyImbalance, int currentBlockImbalance)\r\n    {\r\n        buyImbalance = 0;\r\n        currentBlockImbalance = 0;\r\n        uint latestBlock = 0;\r\n        int imbalanceInRange = 0;\r\n        uint startBlock = rateUpdateBlock;\r\n        uint endBlock = currentBlock;\r\n\r\n        for (uint windowInd = 0; windowInd \u003C SLIDING_WINDOW_SIZE; windowInd\u002B\u002B) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock \u003C= endBlock \u0026\u0026 perBlockData.lastBlock \u003E= startBlock) {\r\n                imbalanceInRange \u002B= perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock \u003C latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }\r\n\r\n        if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }\r\n    }\r\n\r\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        totalImbalance *= resolution;\r\n        currentBlockImbalance *= resolution;\r\n    }\r\n\r\n    function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxPerBlockImbalance;\r\n    }\r\n\r\n    function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxTotalImbalance;\r\n    }\r\n\r\n    function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance \u003C int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance \u003E int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock \u003C POW_2_64);\r\n        require(data.totalBuyUnitsImbalance \u003C int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance \u003E int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock \u003C POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) \u0026 (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) \u0026 (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }\r\n\r\n    function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\r\n        TokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input \u0026 (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) \u0026 (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) \u0026 (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }\r\n}\r\n\r\n// File: contracts/reserves/fprConversionRate/ConversionRates.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ConversionRates is ConversionRatesInterface, VolumeImbalanceRecorder, Utils {\r\n\r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        bool listed;  // was added to reserve\r\n        bool enabled; // whether trade is enabled\r\n\r\n        // position in the compact data\r\n        uint compactDataArrayIndex;\r\n        uint compactDataFieldIndex;\r\n\r\n        // rate data. base and changes according to quantity and reserve balance.\r\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\r\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\r\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\r\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n\r\n    /*\r\n    this is the data for tokenRatesCompactData\r\n    but solidity compiler optimizer is sub-optimal, and cannot write this structure in a single storage write\r\n    so we represent it as bytes32 and do the byte tricks ourselves.\r\n    struct TokenRatesCompactData {\r\n        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\r\n        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\r\n\r\n        uint32 blockNumber;\r\n    } */\r\n    uint public validRateDurationInBlocks = 10; // rates are valid for this amount of blocks\r\n    ERC20[] internal listedTokens;\r\n    mapping(address=\u003ETokenData) internal tokenData;\r\n    bytes32[] internal tokenRatesCompactData;\r\n    uint public numTokensInCurrentCompactData = 0;\r\n    address public reserveContract;\r\n    uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14;\r\n    uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA));\r\n    uint constant internal MAX_STEPS_IN_FUNCTION = 10;\r\n    int  constant internal MAX_BPS_ADJUSTMENT = 10 ** 11; // 1B %\r\n    int  constant internal MIN_BPS_ADJUSTMENT = -100 * 100; // cannot go down by more than 100%\r\n\r\n    function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\r\n        { } // solhint-disable-line no-empty-blocks\r\n\r\n    function addToken(ERC20 token) public onlyAdmin {\r\n\r\n        require(!tokenData[token].listed);\r\n        tokenData[token].listed = true;\r\n        listedTokens.push(token);\r\n\r\n        if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length\u002B\u002B; // add new structure\r\n        }\r\n\r\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\r\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\r\n\r\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData \u002B 1) % NUM_TOKENS_IN_COMPACT_DATA;\r\n\r\n        setGarbageToVolumeRecorder(token);\r\n\r\n        setDecimals(token);\r\n    }\r\n\r\n    function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\r\n\r\n        require(buy.length == sell.length);\r\n        require(indices.length == buy.length);\r\n        require(blockNumber \u003C= 0xFFFFFFFF);\r\n\r\n        uint bytes14Offset = BYTES_14_OFFSET;\r\n\r\n        for (uint i = 0; i \u003C indices.length; i\u002B\u002B) {\r\n            require(indices[i] \u003C tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }\r\n    }\r\n\r\n    function setBaseRate(\r\n        ERC20[] tokens,\r\n        uint[] baseBuy,\r\n        uint[] baseSell,\r\n        bytes14[] buy,\r\n        bytes14[] sell,\r\n        uint blockNumber,\r\n        uint[] indices\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(tokens.length == baseBuy.length);\r\n        require(tokens.length == baseSell.length);\r\n        require(sell.length == buy.length);\r\n        require(sell.length == indices.length);\r\n\r\n        for (uint ind = 0; ind \u003C tokens.length; ind\u002B\u002B) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }\r\n\r\n        setCompactData(buy, sell, blockNumber, indices);\r\n    }\r\n\r\n    function setQtyStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(xBuy.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(xSell.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setImbalanceStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(xBuy.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(xSell.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\r\n        validRateDurationInBlocks = duration;\r\n    }\r\n\r\n    function enableTokenTrade(ERC20 token) public onlyAdmin {\r\n        require(tokenData[token].listed);\r\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\r\n        tokenData[token].enabled = true;\r\n    }\r\n\r\n    function disableTokenTrade(ERC20 token) public onlyAlerter {\r\n        require(tokenData[token].listed);\r\n        tokenData[token].enabled = false;\r\n    }\r\n\r\n    function setReserveAddress(address reserve) public onlyAdmin {\r\n        reserveContract = reserve;\r\n    }\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public\r\n    {\r\n        require(msg.sender == reserveContract);\r\n\r\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\r\n\r\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\r\n    }\r\n\r\n    /* solhint-disable function-max-lines */\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber \u003E= updateRateBlock \u002B validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance \u002B= imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance \u002B= imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }\r\n\r\n        if (abs(totalImbalance) \u003E= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance \u002B imbalanceQty) \u003E= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }\r\n    /* solhint-enable function-max-lines */\r\n\r\n    function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\r\n        if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate;\r\n    }\r\n\r\n    function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\r\n        require(tokenData[token].listed);\r\n\r\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n\r\n        return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        );\r\n    }\r\n\r\n    function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\r\n        return (tokenData[token].listed, tokenData[token].enabled);\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\r\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\r\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\r\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\r\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\r\n\r\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\r\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\r\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\r\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\r\n\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\r\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\r\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\r\n\r\n        revert();\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getRateUpdateBlock(ERC20 token) public view returns(uint) {\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n        return getLast4Bytes(compactData);\r\n    }\r\n\r\n    function getListedTokens() public view returns(ERC20[]) {\r\n        return listedTokens;\r\n    }\r\n\r\n    function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\r\n        uint dstDecimals = getDecimals(token);\r\n        uint srcDecimals = ETH_DECIMALS;\r\n\r\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getLast4Bytes(bytes32 b) internal pure returns(uint) {\r\n        // cannot trust compiler with not turning bit operations into EXP opcode\r\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\r\n    }\r\n\r\n    function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n        uint byteOffset;\r\n        if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA \u002B fieldOffset;\r\n        else\r\n            byteOffset = 4 \u002B fieldOffset;\r\n\r\n        return int8(data[byteOffset]);\r\n    }\r\n\r\n    function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\r\n        uint len = f.y.length;\r\n        for (uint ind = 0; ind \u003C len; ind\u002B\u002B) {\r\n            if (x \u003C= f.x[ind]) return f.y[ind];\r\n        }\r\n\r\n        return f.y[len-1];\r\n    }\r\n\r\n    function addBps(uint rate, int bps) internal pure returns(uint) {\r\n        require(rate \u003C= MAX_RATE);\r\n        require(bps \u003E= MIN_BPS_ADJUSTMENT);\r\n        require(bps \u003C= MAX_BPS_ADJUSTMENT);\r\n\r\n        uint maxBps = 100 * 100;\r\n        return (rate * uint(int(maxBps) \u002B bps)) / maxBps;\r\n    }\r\n\r\n    function abs(int x) internal pure returns(uint) {\r\n        if (x \u003C 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x);\r\n    }\r\n}\r\n\r\n// File: contracts/reserves/fprConversionRate/ConversionRateEnhancedSteps.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n/// @title EnhancedStepFunctions contract - new ConversionRates contract with step function enhancement\r\n/// Removed qty step function overhead\r\n/// Also fixed following issues:\r\n/// https://github.com/KyberNetwork/smart-contracts/issues/291\r\n/// https://github.com/KyberNetwork/smart-contracts/issues/241\r\n/// https://github.com/KyberNetwork/smart-contracts/issues/240\r\n\r\n\r\ncontract ConversionRateEnhancedSteps is ConversionRates {\r\n\r\n    uint constant internal MAX_STEPS_IN_FUNCTION = 16;\r\n    int constant internal MAX_IMBALANCE = 2 ** 255 - 1;\r\n    uint constant internal POW_2_128 = 2 ** 128;\r\n    int128 constant internal MAX_STEP_VALUE = 2 ** 127 - 1;\r\n    int128 constant internal MIN_STEP_VALUE = -1 * 2 ** 127;\r\n    int constant internal MAX_BPS_ADJUSTMENT = 100 * 100;\r\n\r\n    function ConversionRateEnhancedSteps(address _admin) public ConversionRates(_admin)\r\n        { } // solhint-disable-line no-empty-blocks\r\n\r\n    // Blocking set qty step func as we won\u0027t use\r\n    function setQtyStepFunction(\r\n        ERC20,\r\n        int[],\r\n        int[],\r\n        int[],\r\n        int[]\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        revert();\r\n    }\r\n\r\n    function setImbalanceStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length \u002B 1 == yBuy.length);\r\n        require(xSell.length \u002B 1 == ySell.length);\r\n        require(yBuy.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(ySell.length \u003C= MAX_STEPS_IN_FUNCTION);\r\n        require(tokenData[token].listed);\r\n\r\n        uint i;\r\n\r\n        if (xBuy.length \u003E 1) {\r\n            // verify qty are increasing\r\n            for(i = 0; i \u003C xBuy.length - 1; i\u002B\u002B) {\r\n                require(xBuy[i] \u003C xBuy[i \u002B 1]);\r\n            }\r\n        }\r\n        // only need to check last value as it\u0027s sorted array\r\n        require(xBuy.length == 0 || xBuy[xBuy.length - 1] \u003C MAX_STEP_VALUE);\r\n\r\n        // verify yBuy\r\n        for(i = 0; i \u003C yBuy.length; i\u002B\u002B) {\r\n            require(yBuy[i] \u003E= MIN_BPS_ADJUSTMENT);\r\n            require(yBuy[i] \u003C= MAX_BPS_ADJUSTMENT);\r\n        }\r\n\r\n        if (xSell.length \u003E 1) {\r\n            // verify qty are increasing\r\n            for(i = 0; i \u003C xSell.length - 1; i\u002B\u002B) {\r\n                require(xSell[i] \u003C xSell[i \u002B 1]);\r\n            }\r\n        }\r\n        // only need to check last value as it\u0027s sorted array\r\n        require(xSell.length == 0 || xSell[xSell.length - 1] \u003C MAX_STEP_VALUE);\r\n\r\n        // verify ySell\r\n        for(i = 0; i \u003C ySell.length; i\u002B\u002B) {\r\n            require(ySell[i] \u003E= MIN_BPS_ADJUSTMENT);\r\n            require(ySell[i] \u003C= MAX_BPS_ADJUSTMENT);\r\n        }\r\n\r\n        int[] memory buyArray = new int[](yBuy.length);\r\n        for(i = 0; i \u003C yBuy.length; i\u002B\u002B) {\r\n            int128 xBuyVal = (i == yBuy.length - 1) ? MAX_STEP_VALUE : int128(xBuy[i]);\r\n            buyArray[i] = encodeStepFunctionData(xBuyVal, int128(yBuy[i]));\r\n        }\r\n\r\n        int[] memory sellArray = new int[](ySell.length);\r\n        for(i = 0; i \u003C ySell.length; i\u002B\u002B) {\r\n            int128 xSellVal = (i == ySell.length - 1) ? MAX_STEP_VALUE : int128(xSell[i]);\r\n            sellArray[i] = encodeStepFunctionData(xSellVal, int128(ySell[i]));\r\n        }\r\n\r\n        int[] memory emptyArr = new int[](0);\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(buyArray, emptyArr);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(sellArray, emptyArr);\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length - 1);\r\n\r\n        int stepXValue;\r\n        int stepYValue;\r\n\r\n        if (command == 9) {\r\n            (stepXValue, stepYValue) = decodeStepFunctionData(tokenData[token].buyRateImbalanceStepFunction.x[param]);\r\n            return stepXValue;\r\n        }\r\n\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 11) {\r\n            (stepXValue, stepYValue) = decodeStepFunctionData(tokenData[token].buyRateImbalanceStepFunction.x[param]);\r\n            return stepYValue;\r\n        }\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length - 1);\r\n        if (command == 13) {\r\n            (stepXValue, stepYValue) = decodeStepFunctionData(tokenData[token].sellRateImbalanceStepFunction.x[param]);\r\n            return stepXValue;\r\n        }\r\n\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 15) {\r\n            (stepXValue, stepYValue) = decodeStepFunctionData(tokenData[token].sellRateImbalanceStepFunction.x[param]);\r\n            return stepYValue;\r\n        }\r\n\r\n        revert();\r\n    }\r\n\r\n    /* solhint-disable function-max-lines */\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber \u003E= updateRateBlock \u002B validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, qty, rate);\r\n            imbalanceQty = int(qty);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(\r\n                tokenData[token].buyRateImbalanceStepFunction,\r\n                totalImbalance,\r\n                totalImbalance \u002B imbalanceQty\r\n            );\r\n            rate = addBps(rate, extraBps);\r\n            totalImbalance \u002B= imbalanceQty;\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(\r\n                tokenData[token].sellRateImbalanceStepFunction,\r\n                totalImbalance \u002B imbalanceQty,\r\n                totalImbalance\r\n            );\r\n            rate = addBps(rate, extraBps);\r\n            totalImbalance \u002B= imbalanceQty;\r\n        }\r\n\r\n        if (abs(totalImbalance) \u003E= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance \u002B imbalanceQty) \u003E= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }\r\n\r\n    // Override function getImbalance to fix #240\r\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        if (!checkMultOverflow(totalImbalance, resolution)) {\r\n            totalImbalance *= resolution;\r\n        } else {\r\n            totalImbalance = MAX_IMBALANCE;\r\n        }\r\n\r\n        if (!checkMultOverflow(currentBlockImbalance, resolution)) {\r\n            currentBlockImbalance *= resolution;\r\n        } else {\r\n            currentBlockImbalance = MAX_IMBALANCE;\r\n        }\r\n    }\r\n\r\n    function getImbalancePerToken(ERC20 token, uint whichBlock)\r\n        public view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n        uint rateUpdateBlock = getRateUpdateBlock(token);\r\n        // if whichBlock = 0, use latest block, otherwise use whichBlock\r\n        uint usedBlock = whichBlock == 0 ? block.number : whichBlock;\r\n        return getImbalance(token, rateUpdateBlock, usedBlock);\r\n    }\r\n\r\n    function executeStepFunction(StepFunction storage f, int from, int to) internal view returns(int) {\r\n\r\n        uint len = f.x.length;\r\n\r\n        if (len == 0 || from == to) { return 0; }\r\n\r\n        int fromVal = from; // avoid modifying function parameters\r\n        int change = 0; // amount change from initial amount when applying bps for each step\r\n        int stepXValue;\r\n        int stepYValue;\r\n\r\n        for(uint ind = 0; ind \u003C len; ind\u002B\u002B) {\r\n            (stepXValue, stepYValue) = decodeStepFunctionData(f.x[ind]);\r\n            if (stepXValue \u003C= fromVal) { continue; }\r\n            // if it falls into step with y \u003C= -10000, rate must be 0\r\n            if (stepYValue == MIN_BPS_ADJUSTMENT) { return MIN_BPS_ADJUSTMENT; }\r\n            // from here, from \u003C stepXValue,\r\n            // if from \u003C to \u003C= stepXValue, take [from, to] and return, else take [from, stepXValue]\r\n            if (stepXValue \u003E= to) {\r\n                change \u002B= (to - fromVal) * stepYValue;\r\n                return change / (to - from);\r\n            } else {\r\n                change \u002B= (stepXValue - fromVal) * stepYValue;\r\n                fromVal = stepXValue;\r\n            }\r\n        }\r\n\r\n        return change / (to - from);\r\n    }\r\n\r\n    // first 128 bits is value for x, next 128 bits is value for y\r\n    function encodeStepFunctionData(int128 x, int128 y) internal pure returns(int data) {\r\n        require(x \u003C= MAX_STEP_VALUE \u0026\u0026 x \u003E= MIN_STEP_VALUE);\r\n        require(y \u003C= MAX_STEP_VALUE \u0026\u0026 y \u003E= MIN_STEP_VALUE);\r\n        data = int(uint(y) \u0026 (POW_2_128 - 1));\r\n        data |= int((uint(x) \u0026 (POW_2_128 - 1)) * POW_2_128);\r\n    }\r\n\r\n    function decodeStepFunctionData(int val) internal pure returns (int x, int y) {\r\n        y = int(int128(uint(val) \u0026 (POW_2_128 - 1)));\r\n        x = int(int128((uint(val) / POW_2_128) \u0026 (POW_2_128 - 1)));\r\n        // default to be max value\r\n        if (x == int(MAX_STEP_VALUE)) { x = MAX_IMBALANCE; }\r\n    }\r\n\r\n    function checkMultOverflow(int x, int y) internal pure returns(bool) {\r\n        if (y == 0) return false;\r\n        return (((x*y) / y) != x);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022alerter\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeAlerter\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022reserve\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setReserveAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022disableTokenTrade\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022validRateDurationInBlocks\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022baseBuy\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022baseSell\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022buy\u0022,\u0022type\u0022:\u0022bytes14[]\u0022},{\u0022name\u0022:\u0022sell\u0022,\u0022type\u0022:\u0022bytes14[]\u0022},{\u0022name\u0022:\u0022blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022indices\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022setBaseRate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022enableTokenTrade\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pendingAdmin\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getOperators\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getListedTokens\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022sendTo\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022withdrawToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newAlerter\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addAlerter\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022numTokensInCurrentCompactData\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022whichBlock\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getImbalancePerToken\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022totalImbalance\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022name\u0022:\u0022currentBlockImbalance\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022command\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022param\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getStepFunctionData\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022buy\u0022,\u0022type\u0022:\u0022bytes14[]\u0022},{\u0022name\u0022:\u0022sell\u0022,\u0022type\u0022:\u0022bytes14[]\u0022},{\u0022name\u0022:\u0022blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022indices\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022setCompactData\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022duration\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setValidRateDurationInBlocks\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getTokenBasicData\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newAdmin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022claimAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newAdmin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferAdminQuickly\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAlerters\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getRateUpdateBlock\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256[]\u0022}],\u0022name\u0022:\u0022setQtyStepFunction\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOperator\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022reserveContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenImbalanceData\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022operator\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022currentBlockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022buy\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022qty\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getRate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022xBuy\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022yBuy\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022xSell\u0022,\u0022type\u0022:\u0022int256[]\u0022},{\u0022name\u0022:\u0022ySell\u0022,\u0022type\u0022:\u0022int256[]\u0022}],\u0022name\u0022:\u0022setImbalanceStepFunction\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022minimalRecordResolution\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxPerBlockImbalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxTotalImbalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setTokenControlInfo\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022buyAmount\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022name\u0022:\u0022rateUpdateBlock\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022currentBlock\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022recordImbalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022sendTo\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022withdrawEther\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022buy\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022getBasicRate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getCompactData\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes1\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes1\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getTokenControlInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022admin\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_admin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sendTo\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TokenWithdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sendTo\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022EtherWithdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022pendingAdmin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TransferAdminPending\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newAdmin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022previousAdmin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AdminClaimed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newAlerter\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isAdd\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022AlerterAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newOperator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isAdd\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022OperatorAdded\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"ConversionRateEnhancedSteps","CompilerVersion":"v0.4.18\u002Bcommit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d3cc03c1d1e9d46f28aebc4ba26c5990c7ffbc3e","Library":"","SwarmSource":"bzzr://9626585cf1b9ec2bda916e3459c67e5815ddfe47ef8070184f50ae660eb9b34c"}]