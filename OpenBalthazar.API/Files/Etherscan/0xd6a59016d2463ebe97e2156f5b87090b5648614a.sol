[{"SourceCode":"pragma solidity ^0.5.7;\r\ncontract MarginSwap {\r\n  uint256 _code;\r\n  uint256 _owner;\r\n  uint256 _parent_address;\r\n  uint256 _run_state;\r\n  uint256 _comptroller_address;\r\n  uint256[2**160] _compound_lookup;\r\n  event Trade(\r\n    address indexed trade_contract,\r\n    address from_asset,\r\n    address to_asset,\r\n    uint256 input,\r\n    uint256 output,\r\n    uint256 input_fee\r\n  );\r\n  \r\n  function () external payable  {}\r\n  \r\n  function setComptrollerAddress(address comptroller) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(_comptroller_address_slot, comptroller)\r\n    }\r\n  }\r\n  \r\n  function comptrollerAddress() public view \r\n  returns (address comptroller) {\r\n    assembly {\r\n      comptroller := sload(_comptroller_address_slot)\r\n      if iszero(comptroller) {\r\n        comptroller := 0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b\r\n      }\r\n    }\r\n  }\r\n  \r\n  function lookupUnderlying(address cToken) public view \r\n  returns (address result) {\r\n    assembly {\r\n      result := sload(add(_compound_lookup_slot, cToken))\r\n    }\r\n  }\r\n  \r\n  function enterMarkets(address[] calldata cTokens) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 0)\r\n        revert(63, 1)\r\n      }\r\n      if xor(0x20, calldataload(4)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let array_length := calldataload(0x24)\r\n      let array_start := 0x44\r\n      if xor(add(0x44, mul(0x20, array_length)), calldatasize) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        let call_input := mload(0x40)\r\n        let call_input_size := calldatasize\r\n        calldatacopy(call_input, 0, call_input_size)\r\n        let comptroller_address := sload(_comptroller_address_slot)\r\n        if iszero(comptroller_address) {\r\n          comptroller_address := 0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b\r\n        }\r\n        let res := call(gas, comptroller_address, 0, call_input, call_input_size, call_input, sub(call_input_size, 4))\r\n        if iszero(res) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n        if xor(0x20, mload(call_input)) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        if xor(array_length, mload(add(call_input, 0x20))) {\r\n          mstore(32, 5)\r\n          revert(63, 1)\r\n        }\r\n        let has_error := 0\r\n        for {\r\n          let i := 0\r\n        } lt(i, array_length) {\r\n          i := add(i, 1)\r\n        } {\r\n          let value := mload(add(add(call_input, 0x40), mul(i, 0x20)))\r\n          has_error := or(has_error, value)\r\n        }\r\n        if has_error {\r\n          mstore(32, 6)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let array_end := add(array_start, mul(array_length, 0x20))\r\n      for {\r\n        let i := array_start\r\n      } lt(i, array_end) {\r\n        i := add(i, 0x20)\r\n      } {\r\n        let cToken_addr := calldataload(i)\r\n        let mem_ptr := mload(0x40)\r\n        let m_out := add(mem_ptr, 4)\r\n        {\r\n          mstore(m_out, 0)\r\n          mstore(mem_ptr, /* fn_hash(\u0022underlying()\u0022) */ 0x6f307dc300000000000000000000000000000000000000000000000000000000)\r\n          let res := staticcall(gas, cToken_addr, mem_ptr, 4, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 7)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        let underlying_addr := mload(m_out)\r\n        sstore(add(_compound_lookup_slot, underlying_addr), cToken_addr)\r\n        if underlying_addr {\r\n          mstore(mem_ptr, /* fn_hash(\u0022approve(address,uint256)\u0022) */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(mem_ptr, 4), cToken_addr)\r\n          mstore(add(mem_ptr, 0x24), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n          let mem_out := add(mem_ptr, 0x44)\r\n          mstore(mem_out, 0)\r\n          let res := call(gas, underlying_addr, 0, mem_ptr, 0x44, mem_out, 0x20)\r\n          if or(iszero(res), iszero(mload(mem_out))) {\r\n            mstore(32, 8)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function depositEth() external payable  {\r\n    deposit(address(0x0), msg.value);\r\n  }\r\n  \r\n  function deposit(address asset_address, uint256 amount) public payable  {\r\n    \r\n    uint256[4] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      if and(iszero(asset_address), xor(amount, callvalue)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      if asset_address {\r\n        if callvalue {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n        mstore(m_in, /* fn_hash(\u0022transferFrom(address,address,uint256)\u0022) */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), caller)\r\n        mstore(add(m_in, 0x24), address)\r\n        mstore(add(m_in, 0x44), amount)\r\n        mstore(m_out, 0)\r\n        let res := call(gas, asset_address, 0, m_in, 0x64, m_out, 0x20)\r\n        if or(iszero(res), iszero(mload(m_out))) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n    }\r\n    depositToCompound(asset_address, amount);\r\n  }\r\n  \r\n  function depositToCompound(address asset_address, uint256 amount) internal  {\r\n    \r\n    uint256[2] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      let c_address := sload(add(_compound_lookup_slot, asset_address))\r\n      if iszero(c_address) {\r\n        mstore(32, 100)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        mstore(m_in, /* fn_hash(\u0022borrowBalanceCurrent(address)\u0022) */ 0x17bfdfbc00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), address)\r\n        let res := call(gas, c_address, 0, m_in, 36, m_out, 32)\r\n        if iszero(res) {\r\n          mstore(32, 101)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let borrow_amount := mload(m_out)\r\n        let to_repay := borrow_amount\r\n        if lt(amount, to_repay) {\r\n          to_repay := amount\r\n        }\r\n        if to_repay {\r\n          mstore(m_in, /* fn_hash(\u0022repayBorrow()\u0022) */ 0x4e4d9fea00000000000000000000000000000000000000000000000000000000)\r\n          let m_in_size := 4\r\n          let wei_to_send := to_repay\r\n          if asset_address {\r\n            mstore(m_in, /* fn_hash(\u0022repayBorrow(uint256)\u0022) */ 0x0e75270200000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(m_in, 4), to_repay)\r\n            m_in_size := 36\r\n            wei_to_send := 0\r\n          }\r\n          let res := call(gas, c_address, wei_to_send, m_in, m_in_size, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 102)\r\n            revert(63, 1)\r\n          }\r\n          switch returndatasize\r\n            case 0 {\r\n              if asset_address {\r\n                mstore(32, 103)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            case 32 {\r\n              if mload(m_out) {\r\n                mstore(32, 104)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            default {\r\n              mstore(32, 105)\r\n              revert(63, 1)\r\n            }\r\n          amount := sub(amount, to_repay)\r\n        }\r\n      }\r\n      {\r\n        if amount {\r\n          mstore(m_in, /* fn_hash(\u0022mint()\u0022) */ 0x1249c58b00000000000000000000000000000000000000000000000000000000)\r\n          let m_in_size := 4\r\n          let wei_to_send := amount\r\n          if asset_address {\r\n            mstore(m_in, /* fn_hash(\u0022mint(uint256)\u0022) */ 0xa0712d6800000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(m_in, 4), amount)\r\n            m_in_size := 0x24\r\n            wei_to_send := 0\r\n          }\r\n          let res := call(gas, c_address, wei_to_send, m_in, m_in_size, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 106)\r\n            revert(63, 1)\r\n          }\r\n          switch returndatasize\r\n            case 0 {\r\n              if asset_address {\r\n                mstore(32, 107)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            case 32 {\r\n              if mload(m_out) {\r\n                mstore(32, 108)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            default {\r\n              mstore(32, 109)\r\n              revert(63, 1)\r\n            }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function withdraw(address asset, uint256 amount, address destination) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n    }\r\n    _withdraw(asset, amount, destination);\r\n  }\r\n  \r\n  function _withdraw(address asset, uint256 amount, address destination) internal  {\r\n    \r\n    uint256[2] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      let c_address := sload(add(_compound_lookup_slot, asset))\r\n      if iszero(c_address) {\r\n        mstore(32, 200)\r\n        revert(63, 1)\r\n      }\r\n      let remaining := amount\r\n      {\r\n        mstore(m_in, /* fn_hash(\u0022balanceOfUnderlying(address)\u0022) */ 0x3af9e66900000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), address)\r\n        let res := call(gas, c_address, 0, m_in, 36, m_out, 32)\r\n        if iszero(res) {\r\n          mstore(32, 201)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let available := mload(m_out)\r\n        let to_redeem := available\r\n        if lt(remaining, to_redeem) {\r\n          to_redeem := remaining\r\n        }\r\n        if to_redeem {\r\n          mstore(m_in, /* fn_hash(\u0022redeemUnderlying(uint256)\u0022) */ 0x852a12e300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), to_redeem)\r\n          let res := call(gas, c_address, 0, m_in, 36, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 202)\r\n            revert(63, 1)\r\n          }\r\n          if mload(m_out) {\r\n            mstore(32, 203)\r\n            revert(63, 1)\r\n          }\r\n          remaining := sub(remaining, to_redeem)\r\n        }\r\n      }\r\n      {\r\n        if remaining {\r\n          mstore(m_in, /* fn_hash(\u0022borrow(uint256)\u0022) */ 0xc5ebeaec00000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), remaining)\r\n          let res := call(gas, c_address, 0, m_in, 0x24, m_out, 0x20)\r\n          if or(iszero(res), mload(m_out)) {\r\n            mstore(32, 204)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      {\r\n        let m_in_size := 0\r\n        let wei_to_send := amount\r\n        let dest := destination\r\n        if asset {\r\n          mstore(m_in, /* fn_hash(\u0022transfer(address,uint256)\u0022) */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), destination)\r\n          mstore(add(m_in, 0x24), amount)\r\n          dest := asset\r\n          m_in_size := 0x44\r\n          wei_to_send := 0\r\n        }\r\n        let res := call(gas, dest, wei_to_send, m_in, m_in_size, m_out, 32)\r\n        if iszero(res) {\r\n          mstore(32, 205)\r\n          revert(63, 1)\r\n        }\r\n        if asset {\r\n          if iszero(mload(m_out)) {\r\n            mstore(32, 206)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function transferOut(address asset, uint256 amount, address destination) external  {\r\n    \r\n    uint256[3] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let m_in_size := 0\r\n      let wei_to_send := amount\r\n      let dest := destination\r\n      if asset {\r\n        mstore(m_in, /* fn_hash(\u0022transfer(address,uint256)\u0022) */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), destination)\r\n        mstore(add(m_in, 0x24), amount)\r\n        dest := asset\r\n        m_in_size := 0x44\r\n        wei_to_send := 0\r\n      }\r\n      let res := call(gas, dest, wei_to_send, m_in, m_in_size, m_out, 32)\r\n      if iszero(res) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      if asset {\r\n        if iszero(mload(m_out)) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function trade(address input_asset,\r\n                 uint256 input_amount,\r\n                 address output_asset,\r\n                 uint256 min_output_amount,\r\n                 address trade_contract,\r\n                 bytes memory trade_data) public  {\r\n    \r\n    uint256[3] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    uint256 output_amount;\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 0)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        if xor(sload(_run_state_slot), 1) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n        sstore(_run_state_slot, 2)\r\n      }\r\n      let capital_source := sload(_parent_address_slot)\r\n      {\r\n        mstore(m_in, /* fn_hash(\u0022getCapital(address,uint256)\u0022) */ 0x0a681c5900000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 0x04), input_asset)\r\n        mstore(add(m_in, 0x24), input_amount)\r\n        let res := call(gas, capital_source, 0, m_in, 0x44, 0, 0)\r\n        if iszero(res) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if input_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\u0022approve(address,uint256)\u0022) */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), trade_contract)\r\n          mstore(add(m_in, 0x24), input_amount)\r\n          mstore(m_out, 0)\r\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\r\n          if or(iszero(res), iszero(mload(m_out))) {\r\n            mstore(32, 4)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      let before_balance := balance(address)\r\n      if output_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\u0022balanceOf(address)\u0022) */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), address)\r\n          mstore(m_out, 0)\r\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\r\n          if iszero(res) {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        before_balance := mload(m_out)\r\n      }\r\n      {\r\n        if iszero(extcodesize(trade_contract)) {\r\n          mstore(32, 5)\r\n          revert(63, 1)\r\n        }\r\n        let wei_to_send := input_amount\r\n        if input_asset {\r\n          wei_to_send := 0\r\n        }\r\n        let res := call(gas, trade_contract, wei_to_send, add(trade_data, 0x20), mload(trade_data), 0, 0)\r\n        if iszero(res) {\r\n          mstore(32, 7)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if input_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\u0022approve(address,uint256)\u0022) */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), trade_contract)\r\n          mstore(add(m_in, 0x24), 0)\r\n          mstore(m_out, 0)\r\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\r\n          if or(iszero(res), iszero(mload(m_out))) {\r\n            mstore(32, 8)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      let after_balance := balance(address)\r\n      if output_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\u0022balanceOf(address)\u0022) */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), address)\r\n          mstore(m_out, 0)\r\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\r\n          if iszero(res) {\r\n            mstore(32, 9)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        after_balance := mload(m_out)\r\n      }\r\n      if lt(after_balance, before_balance) {\r\n        mstore(32, 10)\r\n        revert(63, 1)\r\n      }\r\n      output_amount := sub(after_balance, before_balance)\r\n      if lt(output_amount, min_output_amount) {\r\n        mstore(32, 11)\r\n        revert(63, 1)\r\n      }\r\n    }\r\n    depositToCompound(output_asset, output_amount);\r\n    uint256 fee;\r\n    uint256 return_amount;\r\n    assembly {\r\n      fee := div(input_amount, 200)\r\n      return_amount := add(fee, input_amount)\r\n    }\r\n    _withdraw(input_asset, return_amount, address(_parent_address));\r\n    assembly {\r\n      sstore(_run_state_slot, 1)\r\n      \r\n      /* Log event: Trade */\r\n      mstore(m_in, input_asset)\r\n      mstore(add(m_in, 32), output_asset)\r\n      mstore(add(m_in, 64), input_amount)\r\n      mstore(add(m_in, 96), output_amount)\r\n      mstore(add(m_in, 128), fee)\r\n      log2(m_in, 160, /* Trade */ 0x4a2af5744adbfadba82ab831aea212bad92f5a70fef2079562044f423e999851, trade_contract)\r\n    }\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022destination\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOut\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022depositEth\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022asset_address\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022cToken\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022lookupUnderlying\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022result\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022input_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022output_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022min_output_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022trade_contract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022trade_data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022trade\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022comptrollerAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022comptroller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022destination\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022comptroller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setComptrollerAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022cTokens\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022enterMarkets\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022trade_contract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022from_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022to_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022output\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022input_fee\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Trade\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"MarginSwap","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://edfc8fc4493a7d918713db4c7ff7cd5291bd25bdb7712eeda30e14ca06972a13"}]