[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/database/Database.sol\r\n\r\n// @title A shared storage contract for platform contracts to store and retrieve data\r\n// @notice This contract holds all long-term data for smart-contract systems\r\n// @dev The bytes32 hashes are derived from keccak256(variableName, uniqueID) =\u003E value\r\n// @dec Can enable upgradeable contracts by setting a contract manager\r\ncontract Database{\r\n\r\n    // Storage Variables\r\n    mapping(bytes32 =\u003E uint) public uintStorage;\r\n    mapping(bytes32 =\u003E string) public stringStorage;\r\n    mapping(bytes32 =\u003E address) public addressStorage;\r\n    mapping(bytes32 =\u003E bytes) public bytesStorage;\r\n    mapping(bytes32 =\u003E bytes32) public bytes32Storage;\r\n    mapping(bytes32 =\u003E bool) public boolStorage;\r\n    mapping(bytes32 =\u003E int) public intStorage;\r\n\r\n\r\n\r\n    // @notice Constructor: Sets the owners of the platform\r\n    // @dev Owners must set the contract manager to add more contracts\r\n    constructor(address[] _owners, bool _upgradeable)\r\n    public {\r\n      for(uint i=0; i\u003C_owners.length; i\u002B\u002B){\r\n        require(_owners[i] != address(0), \u0022Empty address\u0022);\r\n        boolStorage[keccak256(abi.encodePacked(\u0022owner\u0022, _owners[i]))] = true;\r\n        emit LogInitialized(_owners[i], _upgradeable);\r\n      }\r\n      if (_upgradeable){\r\n        boolStorage[keccak256(\u0022upgradeable\u0022)] = true;\r\n      }\r\n    }\r\n\r\n    // @notice ContractManager will be the only contract that can add/remove contracts on the platform.\r\n    // @param (address) _contractManager is the contract which can upgrade/remove contracts to platform\r\n    function enableContractManagement(address _contractManager)\r\n    external\r\n    returns (bool){\r\n        require(_contractManager != address(0), \u0022Empty address\u0022);\r\n        require(boolStorage[keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))], \u0022Not owner\u0022);\r\n        require(addressStorage[keccak256(abi.encodePacked(\u0022contract\u0022, \u0022ContractManager\u0022))] == address(0), \u0022There is already a contract manager\u0022);\r\n        addressStorage[keccak256(abi.encodePacked(\u0022contract\u0022, \u0022ContractManager\u0022))] = _contractManager;\r\n        boolStorage[keccak256(abi.encodePacked(\u0022contract\u0022, _contractManager))] = true;\r\n        return true;\r\n    }\r\n\r\n    // @notice Storage functions\r\n    function setAddress(bytes32 _key, address _value)\r\n    onlyApprovedContract\r\n    external {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    onlyApprovedContract\r\n    external {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    onlyApprovedContract\r\n    external {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    onlyApprovedContract\r\n    external {\r\n        bytesStorage[_key] = _value;\r\n    }\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    onlyApprovedContract\r\n    external {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    onlyApprovedContract\r\n    external {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    onlyApprovedContract\r\n    external {\r\n        intStorage[_key] = _value;\r\n    }\r\n\r\n\r\n    // Deletion functions: Can alternatively use setter functions and set to null value (ie. uint = 0)\r\n    function deleteAddress(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete addressStorage[_key];\r\n    }\r\n\r\n    function deleteUint(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete uintStorage[_key];\r\n    }\r\n\r\n    function deleteString(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete stringStorage[_key];\r\n    }\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete bytesStorage[_key];\r\n    }\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete bytes32Storage[_key];\r\n    }\r\n\r\n    function deleteBool(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete boolStorage[_key];\r\n    }\r\n\r\n    function deleteInt(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete intStorage[_key];\r\n    }\r\n\r\n\r\n    // --------------------------------------------------------------------------------------\r\n    //                                     Modifiers\r\n    // --------------------------------------------------------------------------------------\r\n\r\n    // Caller must be registered as a contract through ContractManager.sol\r\n    modifier onlyApprovedContract() {\r\n        require(boolStorage[keccak256(abi.encodePacked(\u0022contract\u0022, msg.sender))]);\r\n        _;\r\n    }\r\n\r\n    // --------------------------------------------------------------------------------------\r\n    //                                     Events\r\n    // --------------------------------------------------------------------------------------\r\n    event LogInitialized(address _owner, bool _upgradeable);\r\n}\r\n\r\n// File: contracts/interfaces/DBInterface.sol\r\n\r\n// Database interface\r\ninterface DBInterface {\r\n\r\n  function setContractManager(address _contractManager)\r\n  external;\r\n\r\n    // --------------------Set Functions------------------------\r\n\r\n    function setAddress(bytes32 _key, address _value)\r\n    external;\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    external;\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    external;\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    external;\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    external;\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    external;\r\n\r\n\r\n     // -------------- Deletion Functions ------------------\r\n\r\n    function deleteAddress(bytes32 _key)\r\n    external;\r\n\r\n    function deleteUint(bytes32 _key)\r\n    external;\r\n\r\n    function deleteString(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBool(bytes32 _key)\r\n    external;\r\n\r\n    function deleteInt(bytes32 _key)\r\n    external;\r\n\r\n    // ----------------Variable Getters---------------------\r\n\r\n    function uintStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (uint);\r\n\r\n    function stringStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n    function addressStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function bytesStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes);\r\n\r\n    function bytes32Storage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes32);\r\n\r\n    function boolStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n    function intStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/database/Events.sol\r\n\r\ncontract Events {\r\n  DBInterface public database;\r\n\r\n  constructor(address _database) public{\r\n    database = DBInterface(_database);\r\n  }\r\n\r\n  function message(string _message)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\r\n  }\r\n\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\r\n  }\r\n\r\n  function registration(string _message, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\r\n  }\r\n\r\n  function contractChange(string _message, address _account, string _name)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\r\n  }\r\n\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\r\n  }\r\n\r\n  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\r\n  }\r\n\r\n  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\r\n  }\r\n\r\n  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\r\n  }\r\n\r\n  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\r\n  }\r\n\r\n  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\r\n  external\r\n  onlyApprovedContract {\r\n    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\r\n  }\r\n\r\n  //Generalized events\r\n  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\r\n  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\r\n  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\r\n  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\r\n  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\r\n  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\r\n  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\r\n  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\r\n  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\r\n  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\r\n\r\n\r\n  // --------------------------------------------------------------------------------------\r\n  // Caller must be registered as a contract through ContractManager.sol\r\n  // --------------------------------------------------------------------------------------\r\n  modifier onlyApprovedContract() {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\u0022contract\u0022, msg.sender))));\r\n      _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/roles/Operators.sol\r\n\r\ncontract Operators {\r\n\r\n  Database public database;\r\n  Events public events;\r\n\r\n  constructor(address _database, address _events) public {\r\n    database = Database(_database);\r\n    events = Events(_events);\r\n  }\r\n\r\n  // @notice allows the platform owners to onboard a new operator.\r\n  // @notice operators will receive crowdfunding payments and are liable for producing/installing assets.\r\n  function registerOperator(address _operatorAddress, string _operatorURI, string _ipfs, address _referrerAddress)\r\n  external\r\n  onlyOwner {\r\n    require(_operatorAddress != address(0));\r\n    bytes32 operatorID = keccak256(abi.encodePacked(\u0022operator.uri\u0022, _operatorURI));\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\u0022operator\u0022, operatorID))) == address(0));\r\n    database.setBytes32(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorAddress)), operatorID);\r\n    database.setAddress(keccak256(abi.encodePacked(\u0022operator\u0022, operatorID)), _operatorAddress);\r\n    database.setString(keccak256(abi.encodePacked(\u0022operator.ipfs\u0022, operatorID)), _ipfs);\r\n    if(_referrerAddress == address(0)){\r\n      database.setAddress(keccak256(abi.encodePacked(\u0022referrer\u0022, operatorID)), database.addressStorage(keccak256(abi.encodePacked(\u0022platform.wallet.assets\u0022))));\r\n    } else {\r\n      database.setAddress(keccak256(abi.encodePacked(\u0022referrer\u0022, operatorID)), _referrerAddress);\r\n    }\r\n\r\n    events.operator(\u0027Operator registered\u0027, operatorID, _operatorURI, _ipfs, _operatorAddress);\r\n  }\r\n\r\n  // @notice owners can remove operators from the platform here\r\n  function removeOperator(bytes32 _operatorID)\r\n  external {\r\n    address operatorAddress = database.addressStorage(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorID)));\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))) || msg.sender == operatorAddress);\r\n    database.deleteBytes32(keccak256(abi.encodePacked(\u0022operator\u0022, operatorAddress)));\r\n    database.deleteAddress(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorID)));\r\n    database.deleteAddress(keccak256(abi.encodePacked(\u0022referrer\u0022, _operatorID)));\r\n    events.operator(\u0027Operator removed\u0027, _operatorID, \u0027\u0027, \u0027\u0027, msg.sender);\r\n  }\r\n\r\n\r\n  // @notice operator or owner can change the withdraw address of a registered operator\r\n  function changeOperatorAddress(bytes32 _operatorID, address _newAddress)\r\n  external {\r\n    address oldAddress = database.addressStorage(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorID)));\r\n    require(oldAddress != address(0));\r\n    require(msg.sender == oldAddress || database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))));\r\n    database.setAddress(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorID)), _newAddress);\r\n    database.deleteBytes32(keccak256(abi.encodePacked(\u0022operator\u0022, oldAddress)));\r\n    database.setBytes32(keccak256(abi.encodePacked(\u0022operator\u0022, _newAddress)), _operatorID);\r\n    events.operator(\u0027Operator address changed\u0027, _operatorID, \u0027\u0027, \u0027\u0027, _newAddress);\r\n  }\r\n\r\n  function changeReferrerAddress(bytes32 _operatorID, address _newAddress)\r\n  external {\r\n    address oldAddress = database.addressStorage(keccak256(abi.encodePacked(\u0022referrer\u0022, _operatorID)));\r\n    require(oldAddress != address(0));\r\n    require(msg.sender == oldAddress || database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))));\r\n    database.setAddress(keccak256(abi.encodePacked(\u0022referrer\u0022, _operatorID)), _newAddress);\r\n    events.operator(\u0027Referrer address changed\u0027, _operatorID, \u0027\u0027, \u0027\u0027, _newAddress);\r\n  }\r\n\r\n  function updateIPFS(bytes32 _operatorID, string _ipfs)\r\n  external\r\n  onlyOperator(_operatorID)\r\n  returns(bool){\r\n    database.setString(keccak256(abi.encodePacked(\u0022operator.ipfs\u0022, _operatorID)), _ipfs);\r\n    events.operator(\u0027Operator ipfs\u0027, _operatorID, \u0027\u0027, _ipfs, msg.sender);\r\n  }\r\n\r\n  function addAsset(bytes32 _operatorID, string _name, string _ipfs, bool _acceptCrypto, bool _payoutCrypto, address _token)\r\n  external\r\n  onlyOperator(_operatorID)\r\n  returns (bool) {\r\n    address operator = database.addressStorage(keccak256(abi.encodePacked(\u0022operator\u0022, _operatorID)));\r\n    bytes32 modelID = keccak256(abi.encodePacked(\u0027model.id\u0027, _operatorID, _name));\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\u0022model.operator\u0022, modelID))) == address(0));\r\n    database.setAddress(keccak256(abi.encodePacked(\u0022model.operator\u0022, modelID)), operator);\r\n    database.setString(keccak256(abi.encodePacked(\u0027model.ipfs\u0027, modelID)), _ipfs);\r\n    acceptToken(modelID, _token, _acceptCrypto);\r\n    payoutToken(modelID, _token, _payoutCrypto);\r\n    events.operator(\u0027Asset added\u0027, modelID, _name, _ipfs, operator);\r\n    return true;\r\n  }\r\n\r\n  function removeAsset(bytes32 _modelID)\r\n  external\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    database.deleteAddress(keccak256(abi.encodePacked(\u0022model.operator\u0022, _modelID)));\r\n    database.deleteString(keccak256(abi.encodePacked(\u0027model.ipfs\u0027, _modelID)));\r\n    events.operator(\u0027Asset removed\u0027, _modelID, \u0027\u0027, \u0027\u0027, msg.sender);\r\n  }\r\n\r\n  function updateModelIPFS(bytes32 _modelID, string _ipfs)\r\n  external\r\n  onlyOperator(_modelID)\r\n  returns(bool){\r\n    database.setString(keccak256(abi.encodePacked(\u0022model.ipfs\u0022, _modelID)), _ipfs);\r\n    events.operator(\u0027Model ipfs\u0027, _modelID, \u0027\u0027, _ipfs, msg.sender);\r\n  }\r\n\r\n  function updateModelOperator(bytes32 _modelID, address _newAddress)\r\n  external\r\n  onlyOperator(_modelID)\r\n  returns(bool){\r\n    database.setAddress(keccak256(abi.encodePacked(\u0022model.operator\u0022, _modelID)), _newAddress);\r\n    events.operator(\u0027Model operator\u0027, _modelID, \u0027\u0027, \u0027\u0027, _newAddress);\r\n  }\r\n\r\n  // @notice operator can choose which ERC20 tokens he\u0027s willing to accept as payment\r\n  function acceptToken(bytes32 _modelID, address _tokenAddress, bool _accept)\r\n  public\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    if(_tokenAddress == address(0)){\r\n      database.setBool(keccak256(abi.encodePacked(\u0022model.acceptsEther\u0022, _modelID)), _accept);\r\n    }\r\n    database.setBool(keccak256(abi.encodePacked(\u0022model.acceptsToken\u0022, _modelID, _tokenAddress)), _accept);\r\n    return true;\r\n  }\r\n\r\n\r\n  // @notice operator can choose which ERC20 tokens it pays out with\r\n  function payoutToken(bytes32 _modelID, address _tokenAddress, bool _payout)\r\n  public\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    if(_tokenAddress == address(0)){\r\n      database.setBool(keccak256(abi.encodePacked(\u0022model.payoutEther\u0022, _modelID)), _payout);\r\n    }\r\n    database.setBool(keccak256(abi.encodePacked(\u0022model.payoutToken\u0022, _modelID, _tokenAddress)), _payout);\r\n    return true;\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction(\u0027Operators destroyed\u0027, address(this), msg.sender, address(this).balance, address(0));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                                Modifiers                                                                     //\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))));\r\n    _;\r\n  }\r\n\r\n  // @notice Sender must be the operator address for this operatorID or modelID or owner of the contracts (this is required to allow an operator to make changes through the DAO app)\r\n  modifier onlyOperator(bytes32 _id) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\u0022operator\u0022, _id))) == msg.sender || database.addressStorage(keccak256(abi.encodePacked(\u0022model.operator\u0022, _id))) == msg.sender || database.boolStorage(keccak256(abi.encodePacked(\u0022owner\u0022, msg.sender))));\r\n    _;\r\n  }\r\n\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_modelID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_newAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022updateModelOperator\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_newAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeOperatorAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_modelID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_ipfs\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022updateModelIPFS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_newAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeReferrerAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorID\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022removeOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_operatorURI\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_ipfs\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_referrerAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022registerOperator\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_ipfs\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022updateIPFS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022database\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operatorID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_ipfs\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_acceptCrypto\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022_payoutCrypto\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addAsset\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022destroy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_modelID\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022removeAsset\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_modelID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_accept\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022acceptToken\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_modelID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_payout\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022payoutToken\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022events\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_database\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_events\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"Operators","CompilerVersion":"v0.4.24\u002Bcommit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f","Library":"","SwarmSource":"bzzr://240e96d56867a946444fd28f2b602e2f1d52ed08a73b589944fae10e1cc112c8"}]