[{"SourceCode":"// File: @gnosis.pm/util-contracts/contracts/Fixed192x64Math.sol\r\n\r\npragma solidity \u003E=0.4.24 ^0.5.1;\r\n\r\n\r\n/// @title Fixed192x64Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - \u003Calan.lu@gnosis.pm\u003E\r\n/// @author Stefan George - \u003Cstefan@gnosis.pm\u003E\r\nlibrary Fixed192x64Math {\r\n\r\n    enum EstimationMode { LowerBound, UpperBound, Midpoint }\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE =  0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // revert if x is \u003E MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x \u003C= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x \u003C= -818323753292969962227)\r\n            return 0;\r\n\r\n        // Transform so that e^x -\u003E 2^x\r\n        (uint lower, uint upper) = pow2Bounds(x * int(ONE) / int(LN2));\r\n        return (upper - lower) / 2 \u002B lower;\r\n    }\r\n\r\n    /// @dev Returns estimate of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of 2**x in fixed point\r\n    function pow2(int x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        (uint lower, uint upper) = pow2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 \u002B lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @return {\r\n    ///   \u0022lower\u0022: \u0022lower bound of 2**x in fixed point\u0022,\r\n    ///   \u0022upper\u0022: \u0022upper bound of 2**x in fixed point\u0022\r\n    /// }\r\n    function pow2Bounds(int x)\r\n        public\r\n        pure\r\n        returns (uint lower, uint upper)\r\n    {\r\n        // revert if x is \u003E MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE, 2) * ONE))\r\n        require(x \u003C= 3541774862152233910271);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE, 2) * ONE))\r\n        if (x \u003C -1180591620717411303424)\r\n            return (0, 1);\r\n\r\n        // 2^x = 2^(floor(x)) * 2^(x-floor(x))\r\n        //       ^^^^^^^^^^^^^^ is a bit shift of ceil(x)\r\n        // so Taylor expand on z = x-floor(x), z in [0, 1)\r\n        int shift;\r\n        int z;\r\n        if (x \u003E= 0) {\r\n            shift = x / int(ONE);\r\n            z = x % int(ONE);\r\n        }\r\n        else {\r\n            shift = (x\u002B1) / int(ONE) - 1;\r\n            z = x - (int(ONE) * shift);\r\n        }\r\n        assert(z \u003E= 0);\r\n        // 2^x = 1 \u002B (ln 2) x \u002B (ln 2)^2/2! x^2 \u002B ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // \u003E\u003E\u003E from mpmath import mp\r\n        // \u003E\u003E\u003E mp.dps = 100\r\n        // \u003E\u003E\u003E coeffs = [mp.log(2)**i / mp.factorial(i) for i in range(1, 21)]\r\n        // \u003E\u003E\u003E shifts = [64 - int(mp.log(c, 2)) for c in coeffs]\r\n        // \u003E\u003E\u003E print(\u0027\\n\u0027.join(hex(int(c * (1 \u003C\u003C s))) \u002B \u0027, \u0027 \u002B str(s) for c, s in zip(coeffs, shifts)))\r\n        int result = int(ONE) \u003C\u003C 64;\r\n        int zpow = z;\r\n        result \u002B= 0xb17217f7d1cf79ab * zpow;\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xf5fdeffc162c7543 * zpow \u003E\u003E (66 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xe35846b82505fc59 * zpow \u003E\u003E (68 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0x9d955b7dd273b94e * zpow \u003E\u003E (70 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xaec3ff3c53398883 * zpow \u003E\u003E (73 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xa184897c363c3b7a * zpow \u003E\u003E (76 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xffe5fe2c45863435 * zpow \u003E\u003E (80 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xb160111d2e411fec * zpow \u003E\u003E (83 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xda929e9caf3e1ed2 * zpow \u003E\u003E (87 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xf267a8ac5c764fb7 * zpow \u003E\u003E (91 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xf465639a8dd92607 * zpow \u003E\u003E (95 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xe1deb287e14c2f15 * zpow \u003E\u003E (99 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xc0b0c98b3687cb14 * zpow \u003E\u003E (103 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0x98a4b26ac3c54b9f * zpow \u003E\u003E (107 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xe1b7421d82010f33 * zpow \u003E\u003E (112 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0x9c744d73cfc59c91 * zpow \u003E\u003E (116 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result \u002B= 0xcc2225a0e12d3eab * zpow \u003E\u003E (121 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        zpow = 0xfb8bb5eda1b4aeb9 * zpow \u003E\u003E (126 - 64);\r\n        result \u002B= zpow;\r\n        zpow = int(8 * ONE);\r\n\r\n        shift -= 64;\r\n        if (shift \u003E= 0) {\r\n            if (result \u003E\u003E (256-shift) == 0) {\r\n                lower = uint(result) \u003C\u003C shift;\r\n                zpow \u003C\u003C= shift; // todo: is this safe?\r\n                if (lower \u002B uint(zpow) \u003E= lower)\r\n                    upper = lower \u002B uint(zpow);\r\n                else\r\n                    upper = 2**256-1;\r\n                return (lower, upper);\r\n            }\r\n            else\r\n                return (2**256-1, 2**256-1);\r\n        }\r\n        zpow = (zpow \u003E\u003E (-shift)) \u002B 1;\r\n        lower = uint(result) \u003E\u003E (-shift);\r\n        upper = lower \u002B uint(zpow);\r\n        return (lower, upper);\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        return ((upper - lower) / 2 \u002B lower) * int(ONE) / int(LOG2_E);\r\n    }\r\n\r\n    /// @dev Returns estimate of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of binaryLog(x) in fixed point\r\n    function binaryLog(uint x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 \u002B lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @return {\r\n    ///   \u0022lower\u0022: \u0022lower bound of binaryLog(x) in fixed point\u0022,\r\n    ///   \u0022upper\u0022: \u0022upper bound of binaryLog(x) in fixed point\u0022\r\n    /// }\r\n    function log2Bounds(uint x)\r\n        public\r\n        pure\r\n        returns (int lower, int upper)\r\n    {\r\n        require(x \u003E 0);\r\n        // compute \u230Alog\u2082x\u230B\r\n        lower = floorLog2(x);\r\n\r\n        uint y;\r\n        if (lower \u003C 0)\r\n            y = x \u003C\u003C uint(-lower);\r\n        else\r\n            y = x \u003E\u003E uint(lower);\r\n\r\n        lower *= int(ONE);\r\n\r\n        // y = x * 2^(-\u230Alog\u2082x\u230B)\r\n        // so 1 \u003C= y \u003C 2\r\n        // and log\u2082x = \u230Alog\u2082x\u230B \u002B log\u2082y\r\n        for (int m = 1; m \u003C= 64; m\u002B\u002B) {\r\n            if(y == ONE) {\r\n                break;\r\n            }\r\n            y = y * y / ONE;\r\n            if(y \u003E= 2 * ONE) {\r\n                lower \u002B= int(ONE \u003E\u003E m);\r\n                y /= 2;\r\n            }\r\n        }\r\n\r\n        return (lower, lower \u002B 4);\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x)\r\n        public\r\n        pure\r\n        returns (int lo)\r\n    {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi \u002B lo) \u003E\u003E 1;\r\n        while((lo \u002B 1) \u003C hi) {\r\n            if (mid \u003C 0 \u0026\u0026 x \u003C\u003C uint(-mid) \u003C ONE || mid \u003E= 0 \u0026\u0026 x \u003E\u003E uint(mid) \u003C ONE)\r\n                hi = mid;\r\n            else\r\n                lo = mid;\r\n            mid = (hi \u002B lo) \u003E\u003E 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] memory nums)\r\n        public\r\n        pure\r\n        returns (int maxNum)\r\n    {\r\n        require(nums.length \u003E 0);\r\n        maxNum = -2**255;\r\n        for (uint i = 0; i \u003C nums.length; i\u002B\u002B)\r\n            if (nums[i] \u003E maxNum)\r\n                maxNum = nums[i];\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022LN2\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022estimationMode\u0022,\u0022type\u0022:\u0022Fixed192x64Math.EstimationMode\u0022}],\u0022name\u0022:\u0022binaryLog\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022log2Bounds\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022lower\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022name\u0022:\u0022upper\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022name\u0022:\u0022estimationMode\u0022,\u0022type\u0022:\u0022Fixed192x64Math.EstimationMode\u0022}],\u0022name\u0022:\u0022pow2\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022LOG2_E\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ln\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022floorLog2\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022lo\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022name\u0022:\u0022pow2Bounds\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022lower\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022upper\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ONE\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022nums\u0022,\u0022type\u0022:\u0022int256[]\u0022}],\u0022name\u0022:\u0022max\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022maxNum\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022name\u0022:\u0022exp\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"Fixed192x64Math","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ea4753e10284cc276a52ddc4afa9e3f32cf6274d4f51d8b83785eddc7bf1361c"}]