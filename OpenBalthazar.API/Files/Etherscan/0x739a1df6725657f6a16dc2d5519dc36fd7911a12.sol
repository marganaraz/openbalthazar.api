[{"SourceCode":"/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \u0022user permissions\u0022.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if \u0060msg.sender\u0060 is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the \u0060onlyOwner\u0060\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Require.sol\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // \u00270\u0027\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // \u0027a\u0027 - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // \u0027x\u0027\r\n    bytes2 constant COLON = 0x3a20; // \u0027: \u0027\r\n    bytes2 constant COMMA = 0x2c20; // \u0027, \u0027\r\n    bytes2 constant LPAREN = 0x203c; // \u0027 \u003C\u0027\r\n    byte constant RPAREN = 0x3e; // \u0027\u003E\u0027\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i \u003E 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i \u002B 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \u00220\u0022;\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length\u002B\u002B;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i \u003E 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO \u002B (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \u00220x\u0022 followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \u00220x\u0022\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i \u003C 20; i\u002B\u002B) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z \u0026 FOUR_BIT_MASK);\r\n            z = z \u003E\u003E 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z \u0026 FOUR_BIT_MASK);\r\n            z = z \u003E\u003E 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input \u003C 10) {\r\n            return byte(uint8(input \u002B ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input \u002B ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \u0022Math\u0022;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \u0022Unsafe cast to uint128\u0022\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \u0022Unsafe cast to uint96\u0022\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \u0022Unsafe cast to uint32\u0022\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a \u003C b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a \u003E b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Types.sol\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value \u003E= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign \u0026\u0026 a.value \u003E 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign \u0026\u0026 a.value \u003E 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value \u003E= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign \u0026\u0026 a.value \u003E 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign \u0026\u0026 a.value \u003E 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Account.sol\r\n\r\n/**\r\n * @title Account\r\n * @author dYdX\r\n *\r\n * Library of structs and functions that represent an account\r\n */\r\nlibrary Account {\r\n    // ============ Enums ============\r\n\r\n    /*\r\n     * Most-recently-cached account status.\r\n     *\r\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\r\n     * Liquid: Can be liquidated no matter the account values.\r\n     *         Can be vaporized if there are no more positive account values.\r\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\r\n     *\r\n     */\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    // Represents the unique key that specifies an account\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    // The complete storage for any account\r\n    struct Storage {\r\n        mapping (uint256 =\u003E Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function equals(\r\n        Info memory a,\r\n        Info memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.owner == b.owner \u0026\u0026 a.number == b.number;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IAutoTrader.sol\r\n\r\n/**\r\n * @title IAutoTrader\r\n * @author dYdX\r\n *\r\n * Interface that Auto-Traders for Solo must implement in order to approve trades.\r\n */\r\ncontract IAutoTrader {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows traders to make trades approved by this smart contract. The active trader\u0027s account is\r\n     * the takerAccount and the passive account (for which this contract approves trades\r\n     * on-behalf-of) is the makerAccount.\r\n     *\r\n     * @param  inputMarketId   The market for which the trader specified the original amount\r\n     * @param  outputMarketId  The market for which the trader wants the resulting amount specified\r\n     * @param  makerAccount    The account for which this contract is making trades\r\n     * @param  takerAccount    The account requesting the trade\r\n     * @param  oldInputPar     The old principal amount for the makerAccount for the inputMarketId\r\n     * @param  newInputPar     The new principal amount for the makerAccount for the inputMarketId\r\n     * @param  inputWei        The change in token amount for the makerAccount for the inputMarketId\r\n     * @param  data            Arbitrary data passed in by the trader\r\n     * @return                 The AssetAmount for the makerAccount for the outputMarketId\r\n     */\r\n    function getTradeCost(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Account.Info memory makerAccount,\r\n        Account.Info memory takerAccount,\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.Wei memory inputWei,\r\n        bytes memory data\r\n    )\r\n        public\r\n        returns (Types.AssetAmount memory);\r\n}\r\n\r\n// File: contracts/protocol/interfaces/ICallee.sol\r\n\r\n/**\r\n * @title ICallee\r\n * @author dYdX\r\n *\r\n * Interface that Callees for Solo must implement in order to ingest data.\r\n */\r\ncontract ICallee {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows users to send this contract arbitrary data.\r\n     *\r\n     * @param  sender       The msg.sender to Solo\r\n     * @param  accountInfo  The account from which the data is being sent\r\n     * @param  data         Arbitrary data given by the sender\r\n     */\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory accountInfo,\r\n        bytes memory data\r\n    )\r\n        public;\r\n}\r\n\r\n// File: contracts/protocol/lib/Decimal.sol\r\n\r\n/**\r\n * @title Decimal\r\n * @author dYdX\r\n *\r\n * Library that defines a fixed-point number with 18 decimal places.\r\n */\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE = 10**18;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function one()\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: BASE });\r\n    }\r\n\r\n    function onePlus(\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: d.value.add(BASE) });\r\n    }\r\n\r\n    function mul(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, d.value, BASE);\r\n    }\r\n\r\n    function div(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, BASE, d.value);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Monetary.sol\r\n\r\n/**\r\n * @title Monetary\r\n * @author dYdX\r\n *\r\n * Library for types involving money\r\n */\r\nlibrary Monetary {\r\n\r\n    /*\r\n     * The price of a base-unit of an asset.\r\n     */\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * Total value of an some amount of an asset. Equal to (price * amount).\r\n     */\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Time.sol\r\n\r\n/**\r\n * @title Time\r\n * @author dYdX\r\n *\r\n * Library for dealing with time, assuming timestamps fit within 32 bits (valid until year 2106)\r\n */\r\nlibrary Time {\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function currentTime()\r\n        internal\r\n        view\r\n        returns (uint32)\r\n    {\r\n        return Math.to32(block.timestamp);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen \u003Cremco@2\u03C0.com\u003E, Eenae \u003Calexey@mixbytes.io\u003E\r\n * @dev If you mark a function \u0060nonReentrant\u0060, you should also\r\n * mark it \u0060external\u0060.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter \u002B= 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/Getters.sol\r\n\r\n/**\r\n * @title Getters\r\n * @author dYdX\r\n *\r\n * Public read-only functions that allow transparency into the state of Solo\r\n */\r\ncontract Getters {\r\n    // ============ Constants ============\r\n\r\n    bytes32 FILE = \u0022Getters\u0022;\r\n\r\n    // ============ Getters for Risk ============\r\n\r\n    /* ... */\r\n\r\n    // ============ Getters for Markets ============\r\n\r\n    /**\r\n     * Get the total number of markets.\r\n     *\r\n     * @return  The number of markets\r\n     */\r\n    function getNumMarkets()\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Get the ERC20 token address for a market.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The token address\r\n     */\r\n    function getMarketTokenAddress(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Get the total principal amounts (borrowed and supplied) for a market.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The total principal amounts\r\n     */\r\n    function getMarketTotalPar(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Types.TotalPar memory);\r\n\r\n    /* ... */\r\n\r\n    /**\r\n     * Get the margin premium for a market. A margin premium makes it so that any positions that\r\n     * include the market require a higher collateralization to avoid being liquidated.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The market\u0027s margin premium\r\n     */\r\n    function getMarketMarginPremium(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Decimal.D256 memory);\r\n\r\n    /**\r\n     * Get the spread premium for a market. A spread premium makes it so that any liquidations\r\n     * that include the market have a higher spread than the global default.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The market\u0027s spread premium\r\n     */\r\n    function getMarketSpreadPremium(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Decimal.D256 memory);\r\n\r\n    /**\r\n     * Return true if a particular market is in closing mode. Additional borrows cannot be taken\r\n     * from a market that is closing.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           True if the market is closing\r\n     */\r\n    function getMarketIsClosing(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Get the price of the token for a market.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The price of each atomic unit of the token\r\n     */\r\n    function getMarketPrice(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Price memory);\r\n\r\n    /* ... */\r\n\r\n    /**\r\n     * Get the adjusted liquidation spread for some market pair. This is equal to the global\r\n     * liquidation spread multiplied by (1 \u002B spreadPremium) for each of the two markets.\r\n     *\r\n     * @param  heldMarketId  The market for which the account has collateral\r\n     * @param  owedMarketId  The market for which the account has borrowed tokens\r\n     * @return               The adjusted liquidation spread\r\n     */\r\n    function getLiquidationSpreadForPair(\r\n        uint256 heldMarketId,\r\n        uint256 owedMarketId\r\n    )\r\n        public\r\n        view\r\n        returns (Decimal.D256 memory);\r\n\r\n    /* ... */\r\n\r\n    /**\r\n     * Get the number of excess tokens for a market. The number of excess tokens is calculated\r\n     * by taking the current number of tokens held in Solo, adding the number of tokens owed to Solo\r\n     * by borrowers, and subtracting the number of tokens owed to suppliers by Solo.\r\n     *\r\n     * @param  marketId  The market to query\r\n     * @return           The number of excess tokens\r\n     */\r\n    function getNumExcessTokens(\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Types.Wei memory);\r\n\r\n    // ============ Getters for Accounts ============\r\n\r\n    /**\r\n     * Get the principal value for a particular account and market.\r\n     *\r\n     * @param  account   The account to query\r\n     * @param  marketId  The market to query\r\n     * @return           The principal value\r\n     */\r\n    function getAccountPar(\r\n        Account.Info memory account,\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Types.Par memory);\r\n\r\n    /**\r\n     * Get the token balance for a particular account and market.\r\n     *\r\n     * @param  account   The account to query\r\n     * @param  marketId  The market to query\r\n     * @return           The token amount\r\n     */\r\n    function getAccountWei(\r\n        Account.Info memory account,\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (Types.Wei memory);\r\n\r\n    /**\r\n     * Get the status of an account (Normal, Liquidating, or Vaporizing).\r\n     *\r\n     * @param  account  The account to query\r\n     * @return          The account\u0027s status\r\n     */\r\n    function getAccountStatus(\r\n        Account.Info memory account\r\n    )\r\n        public\r\n        view\r\n        returns (Account.Status);\r\n\r\n    /**\r\n     * Get the total supplied and total borrowed value of an account.\r\n     *\r\n     * @param  account  The account to query\r\n     * @return          The following values:\r\n     *                   - The supplied value of the account\r\n     *                   - The borrowed value of the account\r\n     */\r\n    function getAccountValues(\r\n        Account.Info memory account\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Value memory, Monetary.Value memory);\r\n\r\n    /**\r\n     * Get the total supplied and total borrowed values of an account adjusted by the marginPremium\r\n     * of each market. Supplied values are divided by (1 \u002B marginPremium) for each market and\r\n     * borrowed values are multiplied by (1 \u002B marginPremium) for each market. Comparing these\r\n     * adjusted values gives the margin-ratio of the account which will be compared to the global\r\n     * margin-ratio when determining if the account can be liquidated.\r\n     *\r\n     * @param  account  The account to query\r\n     * @return          The following values:\r\n     *                   - The supplied value of the account (adjusted for marginPremium)\r\n     *                   - The borrowed value of the account (adjusted for marginPremium)\r\n     */\r\n    function getAdjustedAccountValues(\r\n        Account.Info memory account\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Value memory, Monetary.Value memory);\r\n\r\n    /**\r\n     * Get an account\u0027s summary for each market.\r\n     *\r\n     * @param  account  The account to query\r\n     * @return          The following values:\r\n     *                   - The ERC20 token address for each market\r\n     *                   - The account\u0027s principal value for each market\r\n     *                   - The account\u0027s (supplied or borrowed) number of tokens for each market\r\n     */\r\n    function getAccountBalances(\r\n        Account.Info memory account\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            Types.Par[] memory,\r\n            Types.Wei[] memory\r\n        );\r\n\r\n    // ============ Getters for Permissions ============\r\n\r\n    /**\r\n     * Return true if a particular address is approved as an operator for an owner\u0027s accounts.\r\n     * Approved operators can act on the accounts of the owner as if it were the operator\u0027s own.\r\n     *\r\n     * @param  owner     The owner of the accounts\r\n     * @param  operator  The possible operator\r\n     * @return           True if operator is approved for owner\u0027s accounts\r\n     */\r\n    function getIsLocalOperator(\r\n        address owner,\r\n        address operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return true if a particular address is approved as a global operator. Such an address can\r\n     * act on any account as if it were the operator\u0027s own.\r\n     *\r\n     * @param  operator  The address to query\r\n     * @return           True if operator is a global operator\r\n     */\r\n    function getIsGlobalOperator(\r\n        address operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/protocol/SoloMargin.sol\r\n\r\n/**\r\n * @title SoloMargin\r\n * @author dYdX\r\n *\r\n * Main contract that inherits from other contracts\r\n */\r\ncontract SoloMargin is\r\n    Getters\r\n{\r\n  /* ... */\r\n}\r\n\r\n// File: contracts/external/helpers/OnlySolo.sol\r\n\r\n/**\r\n * @title OnlySolo\r\n * @author dYdX\r\n *\r\n * Inheritable contract that restricts the calling of certain functions to Solo only\r\n */\r\ncontract OnlySolo {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \u0022OnlySolo\u0022;\r\n\r\n    // ============ Storage ============\r\n\r\n    SoloMargin public SOLO_MARGIN;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin\r\n    )\r\n        public\r\n    {\r\n        SOLO_MARGIN = SoloMargin(soloMargin);\r\n    }\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlySolo(address from) {\r\n        Require.that(\r\n            from == address(SOLO_MARGIN),\r\n            FILE,\r\n            \u0022Only Solo can call function\u0022,\r\n            from\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/external/traders/ExpiryV2.sol\r\n\r\n/**\r\n * @title ExpiryV2\r\n * @author dYdX\r\n *\r\n * Expiry contract that also allows approved senders to set expiry to be 28 days in the future.\r\n */\r\ncontract ExpiryV2 is\r\n    Ownable,\r\n    OnlySolo,\r\n    ICallee,\r\n    IAutoTrader\r\n{\r\n    using Math for uint256;\r\n    using SafeMath for uint32;\r\n    using SafeMath for uint256;\r\n    using Types for Types.Par;\r\n    using Types for Types.Wei;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \u0022ExpiryV2\u0022;\r\n\r\n    // ============ Enums ============\r\n\r\n    enum CallFunctionType {\r\n        SetExpiry,\r\n        SetApproval\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    struct SetExpiryArg {\r\n        Account.Info account;\r\n        uint256 marketId;\r\n        uint32 timeDelta;\r\n        bool forceUpdate;\r\n    }\r\n\r\n    struct SetApprovalArg {\r\n        address sender;\r\n        uint32 minTimeDelta;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event ExpirySet(\r\n        address owner,\r\n        uint256 number,\r\n        uint256 marketId,\r\n        uint32 time\r\n    );\r\n\r\n    event LogExpiryRampTimeSet(\r\n        uint256 expiryRampTime\r\n    );\r\n\r\n    event LogSenderApproved(\r\n        address approver,\r\n        address sender,\r\n        uint32 minTimeDelta\r\n    );\r\n\r\n    // ============ Storage ============\r\n\r\n    // owner =\u003E number =\u003E market =\u003E time\r\n    mapping (address =\u003E mapping (uint256 =\u003E mapping (uint256 =\u003E uint32))) g_expiries;\r\n\r\n    // owner =\u003E sender =\u003E minimum time delta\r\n    mapping (address =\u003E mapping (address =\u003E uint32)) public g_approvedSender;\r\n\r\n    // time over which the liquidation ratio goes from zero to maximum\r\n    uint256 public g_expiryRampTime;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin,\r\n        uint256 expiryRampTime\r\n    )\r\n        public\r\n        OnlySolo(soloMargin)\r\n    {\r\n        g_expiryRampTime = expiryRampTime;\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n    function ownerSetExpiryRampTime(\r\n        uint256 newExpiryRampTime\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        emit LogExpiryRampTimeSet(newExpiryRampTime);\r\n        g_expiryRampTime = newExpiryRampTime;\r\n    }\r\n\r\n    // ============ Approval Functions ============\r\n\r\n    function approveSender(\r\n        address sender,\r\n        uint32 minTimeDelta\r\n    )\r\n        external\r\n    {\r\n        setApproval(msg.sender, sender, minTimeDelta);\r\n    }\r\n\r\n    // ============ Only-Solo Functions ============\r\n\r\n    function callFunction(\r\n        address /* sender */,\r\n        Account.Info memory account,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlySolo(msg.sender)\r\n    {\r\n        CallFunctionType callType = abi.decode(data, (CallFunctionType));\r\n        if (callType == CallFunctionType.SetExpiry) {\r\n            callFunctionSetExpiry(account.owner, data);\r\n        } else {\r\n            callFunctionSetApproval(account.owner, data);\r\n        }\r\n    }\r\n\r\n    function getTradeCost(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Account.Info memory makerAccount,\r\n        Account.Info memory /* takerAccount */,\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.Wei memory inputWei,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlySolo(msg.sender)\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        // return zero if input amount is zero\r\n        if (inputWei.isZero()) {\r\n            return Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Par,\r\n                ref: Types.AssetReference.Delta,\r\n                value: 0\r\n            });\r\n        }\r\n\r\n        (uint256 owedMarketId, uint32 maxExpiry) = abi.decode(data, (uint256, uint32));\r\n\r\n        uint32 expiry = getExpiry(makerAccount, owedMarketId);\r\n\r\n        // validate expiry\r\n        Require.that(\r\n            expiry != 0,\r\n            FILE,\r\n            \u0022Expiry not set\u0022,\r\n            makerAccount.owner,\r\n            makerAccount.number,\r\n            owedMarketId\r\n        );\r\n        Require.that(\r\n            expiry \u003C= Time.currentTime(),\r\n            FILE,\r\n            \u0022Borrow not yet expired\u0022,\r\n            expiry\r\n        );\r\n        Require.that(\r\n            expiry \u003C= maxExpiry,\r\n            FILE,\r\n            \u0022Expiry past maxExpiry\u0022,\r\n            expiry\r\n        );\r\n\r\n        return getTradeCostInternal(\r\n            inputMarketId,\r\n            outputMarketId,\r\n            makerAccount,\r\n            oldInputPar,\r\n            newInputPar,\r\n            inputWei,\r\n            owedMarketId,\r\n            expiry\r\n        );\r\n    }\r\n\r\n    // ============ Getters ============\r\n\r\n    function getExpiry(\r\n        Account.Info memory account,\r\n        uint256 marketId\r\n    )\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        return g_expiries[account.owner][account.number][marketId];\r\n    }\r\n\r\n    function getSpreadAdjustedPrices(\r\n        uint256 heldMarketId,\r\n        uint256 owedMarketId,\r\n        uint32 expiry\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            Monetary.Price memory,\r\n            Monetary.Price memory\r\n        )\r\n    {\r\n        Decimal.D256 memory spread = SOLO_MARGIN.getLiquidationSpreadForPair(\r\n            heldMarketId,\r\n            owedMarketId\r\n        );\r\n\r\n        uint256 expiryAge = Time.currentTime().sub(expiry);\r\n\r\n        if (expiryAge \u003C g_expiryRampTime) {\r\n            spread.value = Math.getPartial(spread.value, expiryAge, g_expiryRampTime);\r\n        }\r\n\r\n        Monetary.Price memory heldPrice = SOLO_MARGIN.getMarketPrice(heldMarketId);\r\n        Monetary.Price memory owedPrice = SOLO_MARGIN.getMarketPrice(owedMarketId);\r\n        owedPrice.value = owedPrice.value.add(Decimal.mul(owedPrice.value, spread));\r\n\r\n        return (heldPrice, owedPrice);\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function callFunctionSetExpiry(\r\n        address sender,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        (\r\n            CallFunctionType callType,\r\n            SetExpiryArg[] memory expiries\r\n        ) = abi.decode(data, (CallFunctionType, SetExpiryArg[]));\r\n\r\n        assert(callType == CallFunctionType.SetExpiry);\r\n\r\n        for (uint256 i = 0; i \u003C expiries.length; i\u002B\u002B) {\r\n            SetExpiryArg memory exp = expiries[i];\r\n            if (exp.account.owner != sender) {\r\n                // don\u0027t do anything if sender is not approved for this action\r\n                uint32 minApprovedTimeDelta = g_approvedSender[exp.account.owner][sender];\r\n                if (minApprovedTimeDelta == 0 || exp.timeDelta \u003C minApprovedTimeDelta) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // if timeDelta is zero, interpret it as unset expiry\r\n            if (\r\n                exp.timeDelta != 0 \u0026\u0026\r\n                SOLO_MARGIN.getAccountPar(exp.account, exp.marketId).isNegative()\r\n            ) {\r\n                // only change non-zero values if forceUpdate is true\r\n                if (exp.forceUpdate || getExpiry(exp.account, exp.marketId) == 0) {\r\n                    uint32 newExpiryTime = Time.currentTime().add(exp.timeDelta).to32();\r\n                    setExpiry(exp.account, exp.marketId, newExpiryTime);\r\n                }\r\n            } else {\r\n                // timeDelta is zero or account has non-negative balance\r\n                setExpiry(exp.account, exp.marketId, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function callFunctionSetApproval(\r\n        address sender,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        (\r\n            CallFunctionType callType,\r\n            SetApprovalArg memory approvalArg\r\n        ) = abi.decode(data, (CallFunctionType, SetApprovalArg));\r\n        assert(callType == CallFunctionType.SetApproval);\r\n        setApproval(sender, approvalArg.sender, approvalArg.minTimeDelta);\r\n    }\r\n\r\n    function getTradeCostInternal(\r\n        uint256 inputMarketId,\r\n        uint256 outputMarketId,\r\n        Account.Info memory makerAccount,\r\n        Types.Par memory oldInputPar,\r\n        Types.Par memory newInputPar,\r\n        Types.Wei memory inputWei,\r\n        uint256 owedMarketId,\r\n        uint32 expiry\r\n    )\r\n        private\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        Types.AssetAmount memory output;\r\n        Types.Wei memory maxOutputWei = SOLO_MARGIN.getAccountWei(makerAccount, outputMarketId);\r\n\r\n        if (inputWei.isPositive()) {\r\n            Require.that(\r\n                inputMarketId == owedMarketId,\r\n                FILE,\r\n                \u0022inputMarket mismatch\u0022,\r\n                inputMarketId\r\n            );\r\n            Require.that(\r\n                !newInputPar.isPositive(),\r\n                FILE,\r\n                \u0022Borrows cannot be overpaid\u0022,\r\n                newInputPar.value\r\n            );\r\n            assert(oldInputPar.isNegative());\r\n            Require.that(\r\n                maxOutputWei.isPositive(),\r\n                FILE,\r\n                \u0022Collateral must be positive\u0022,\r\n                outputMarketId,\r\n                maxOutputWei.value\r\n            );\r\n            output = owedWeiToHeldWei(\r\n                inputWei,\r\n                outputMarketId,\r\n                inputMarketId,\r\n                expiry\r\n            );\r\n\r\n            // clear expiry if borrow is fully repaid\r\n            if (newInputPar.isZero()) {\r\n                setExpiry(makerAccount, owedMarketId, 0);\r\n            }\r\n        } else {\r\n            Require.that(\r\n                outputMarketId == owedMarketId,\r\n                FILE,\r\n                \u0022outputMarket mismatch\u0022,\r\n                outputMarketId\r\n            );\r\n            Require.that(\r\n                !newInputPar.isNegative(),\r\n                FILE,\r\n                \u0022Collateral cannot be overused\u0022,\r\n                newInputPar.value\r\n            );\r\n            assert(oldInputPar.isPositive());\r\n            Require.that(\r\n                maxOutputWei.isNegative(),\r\n                FILE,\r\n                \u0022Borrows must be negative\u0022,\r\n                outputMarketId,\r\n                maxOutputWei.value\r\n            );\r\n            output = heldWeiToOwedWei(\r\n                inputWei,\r\n                inputMarketId,\r\n                outputMarketId,\r\n                expiry\r\n            );\r\n\r\n            // clear expiry if borrow is fully repaid\r\n            if (output.value == maxOutputWei.value) {\r\n                setExpiry(makerAccount, owedMarketId, 0);\r\n            }\r\n        }\r\n\r\n        Require.that(\r\n            output.value \u003C= maxOutputWei.value,\r\n            FILE,\r\n            \u0022outputMarket too small\u0022,\r\n            output.value,\r\n            maxOutputWei.value\r\n        );\r\n        assert(output.sign != maxOutputWei.sign);\r\n\r\n        return output;\r\n    }\r\n\r\n    function setExpiry(\r\n        Account.Info memory account,\r\n        uint256 marketId,\r\n        uint32 time\r\n    )\r\n        private\r\n    {\r\n        g_expiries[account.owner][account.number][marketId] = time;\r\n        emit ExpirySet(\r\n            account.owner,\r\n            account.number,\r\n            marketId,\r\n            time\r\n        );\r\n    }\r\n\r\n    function setApproval(\r\n        address approver,\r\n        address sender,\r\n        uint32 minTimeDelta\r\n    )\r\n        private\r\n    {\r\n        g_approvedSender[approver][sender] = minTimeDelta;\r\n        emit LogSenderApproved(approver, sender, minTimeDelta);\r\n    }\r\n\r\n    function heldWeiToOwedWei(\r\n        Types.Wei memory heldWei,\r\n        uint256 heldMarketId,\r\n        uint256 owedMarketId,\r\n        uint32 expiry\r\n    )\r\n        private\r\n        view\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        (\r\n            Monetary.Price memory heldPrice,\r\n            Monetary.Price memory owedPrice\r\n        ) = getSpreadAdjustedPrices(\r\n            heldMarketId,\r\n            owedMarketId,\r\n            expiry\r\n        );\r\n\r\n        uint256 owedAmount = Math.getPartialRoundUp(\r\n            heldWei.value,\r\n            heldPrice.value,\r\n            owedPrice.value\r\n        );\r\n\r\n        return Types.AssetAmount({\r\n            sign: true,\r\n            denomination: Types.AssetDenomination.Wei,\r\n            ref: Types.AssetReference.Delta,\r\n            value: owedAmount\r\n        });\r\n    }\r\n\r\n    function owedWeiToHeldWei(\r\n        Types.Wei memory owedWei,\r\n        uint256 heldMarketId,\r\n        uint256 owedMarketId,\r\n        uint32 expiry\r\n    )\r\n        private\r\n        view\r\n        returns (Types.AssetAmount memory)\r\n    {\r\n        (\r\n            Monetary.Price memory heldPrice,\r\n            Monetary.Price memory owedPrice\r\n        ) = getSpreadAdjustedPrices(\r\n            heldMarketId,\r\n            owedMarketId,\r\n            expiry\r\n        );\r\n\r\n        uint256 heldAmount = Math.getPartial(\r\n            owedWei.value,\r\n            owedPrice.value,\r\n            heldPrice.value\r\n        );\r\n\r\n        return Types.AssetAmount({\r\n            sign: false,\r\n            denomination: Types.AssetDenomination.Wei,\r\n            ref: Types.AssetReference.Delta,\r\n            value: heldAmount\r\n        });\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022g_approvedSender\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022SOLO_MARGIN\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022name\u0022:\u0022marketId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getExpiry\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022minTimeDelta\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022approveSender\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022inputMarketId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022outputMarketId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022makerAccount\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022sign\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022oldInputPar\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022sign\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022newInputPar\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022sign\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022inputWei\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022getTradeCost\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022sign\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022denomination\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022ref\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022callFunction\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022heldMarketId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022owedMarketId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022expiry\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022getSpreadAdjustedPrices\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022g_expiryRampTime\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newExpiryRampTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ownerSetExpiryRampTime\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022soloMargin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022expiryRampTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022marketId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022ExpirySet\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022expiryRampTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogExpiryRampTimeSet\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022approver\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022minTimeDelta\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022LogSenderApproved\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"ExpiryV2","CompilerVersion":"v0.5.7\u002Bcommit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e0000000000000000000000000000000000000000000000000000000000000e10","Library":"","SwarmSource":"bzzr://1fb5cd76566f136dd46aeb846f717b0de53b65aa3702601b2fed00de2dcc85d5"}]