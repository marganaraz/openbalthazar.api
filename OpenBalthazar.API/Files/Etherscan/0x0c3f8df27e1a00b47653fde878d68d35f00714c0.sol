[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-05-07\r\n*/\r\n\r\n// File: contracts/CarefulMath.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Compound\r\n  * @notice Derived from OpenZeppelin\u0027s SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b \u003C= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a \u002B b;\r\n\r\n        if (c \u003E= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n// File: contracts/Exponential.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title Exponential module for storing fixed-decision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         \u0060Exp({mantissa: 5100000000000000000})\u0060.\r\n */\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (\u0060num\u0060 * 10e18) \u003E MAX_INT,\r\n     *            or if \u0060denom\u0060 is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          \u0060s / (a / b)\u0060 = \u0060b * s / a\u0060 and since for an Exp \u0060a = mantissa, b = expScale\u0060\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \u0022Listing 6\u0022 and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error \u0060div\u0060 can return is MathError.DIVISION_BY_ZERO but we control \u0060expScale\u0060 and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we\u0027re performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa \u003C right.mantissa; //TODO: Add some simple tests and this in another PR yo.\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp \u003C= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa \u003C= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/InterestRateModel.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n  * @title The Compound InterestRateModel Interface\r\n  * @author Compound\r\n  * @notice Any interest rate model should derive from this contract.\r\n  * @dev These functions are specifically not marked \u0060pure\u0060 as implementations of this\r\n  *      contract may read from storage variables.\r\n  */\r\ninterface InterestRateModel {\r\n    /**\r\n      * @notice Gets the current borrow interest rate based on the given asset, total cash, total borrows\r\n      *         and total reserves.\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      \u0060(true, 1000000000000)\u0060 implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param cash The total cash of the underlying asset in the CToken\r\n      * @param borrows The total borrows of the underlying asset in the CToken\r\n      * @param reserves The total reserves of the underlying asset in the CToken\r\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\r\n\r\n    /**\r\n      * @notice Marker function used for light validation when updating the interest rate model of a market\r\n      * @dev Marker function used for light validation when updating the interest rate model of a market. Implementations should simply return true.\r\n      * @return Success or failure\r\n      */\r\n    function isInterestRateModel() external view returns (bool);\r\n}\r\n\r\n// File: contracts/WhitePaperInterestRateModel.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n/**\r\n  * @title The Compound Standard Interest Rate Model with pluggable constants\r\n  * @author Compound\r\n  * @notice See Section 2.4 of the Compound Whitepaper\r\n  */\r\ncontract WhitePaperInterestRateModel is InterestRateModel, Exponential {\r\n    /**\r\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n     */\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint public multiplier;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint public baseRate;\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint public constant blocksPerYear = 2102400;\r\n\r\n    constructor(uint baseRate_, uint multiplier_) public {\r\n        baseRate = baseRate_;\r\n        multiplier = multiplier_;\r\n    }\r\n\r\n    enum IRError {\r\n        NO_ERROR,\r\n        FAILED_TO_ADD_CASH_PLUS_BORROWS,\r\n        FAILED_TO_GET_EXP,\r\n        FAILED_TO_MUL_UTILIZATION_RATE,\r\n        FAILED_TO_ADD_BASE_RATE\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization rate (borrows / (cash \u002B borrows)) as an Exp\r\n     */\r\n    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\r\n        if (borrows == 0) {\r\n            // Utilization rate is zero when there\u0027s no borrows\r\n            return (IRError.NO_ERROR, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err0, uint cashPlusBorrows) = addUInt(cash, borrows);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (IRError.NO_ERROR, utilizationRate);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization and borrow rates for use by getBorrowRate function\r\n     */\r\n    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\r\n        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        // Borrow Rate is 5% \u002B UtilizationRate * 45% (baseRate \u002B UtilizationRate * multiplier);\r\n        // 45% of utilizationRate, is \u0060rate * 45 / 100\u0060\r\n        (MathError err1, Exp memory utilizationRateMuled) = mulScalar(utilizationRate, multiplier);\r\n        // \u0060mulScalar\u0060 only overflows when the product is \u003E= 2^256.\r\n        // utilizationRate is a real number on the interval [0,1], which means that\r\n        // utilizationRate.mantissa is in the interval [0e18,1e18], which means that 45 times\r\n        // that is in the interval [0e18,45e18]. That interval has no intersection with 2^256, and therefore\r\n        // this can never overflow for the standard rates.\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (IRError.FAILED_TO_MUL_UTILIZATION_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, Exp memory utilizationRateScaled) = divScalar(utilizationRateMuled, mantissaOne);\r\n        // 100 is a constant, and therefore cannot be zero, which is the only error case of divScalar.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        // Add the 5% for (5% \u002B 45% * Ua)\r\n        (MathError err3, Exp memory annualBorrowRate) = addExp(utilizationRateScaled, Exp({mantissa: baseRate}));\r\n        // \u0060addExp\u0060 only fails when the addition of mantissas overflow.\r\n        // As per above, utilizationRateMuled is capped at 45e18,\r\n        // and utilizationRateScaled is capped at 4.5e17. mantissaFivePercent = 0.5e17, and thus the addition\r\n        // is capped at 5e17, which is less than 2^256. This only applies to the standard rates\r\n        if (err3 != MathError.NO_ERROR) {\r\n            return (IRError.FAILED_TO_ADD_BASE_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (IRError.NO_ERROR, utilizationRate, annualBorrowRate);\r\n    }\r\n\r\n    /**\r\n      * @notice Gets the current borrow interest rate based on the given asset, total cash, total borrows\r\n      *         and total reserves.\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      \u0060(true, 1000000000000)\u0060 implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param cash The total cash of the underlying asset in the CToken\r\n      * @param borrows The total borrows of the underlying asset in the CToken\r\n      * @param _reserves The total reserves of the underlying asset in the CToken\r\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\r\n        _reserves; // pragma ignore unused argument\r\n\r\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (uint(err0), 0);\r\n        }\r\n\r\n        // And then divide down by blocks per year.\r\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\r\n        // divScalar only fails when divisor is zero. This is clearly not the case.\r\n        assert(err1 == MathError.NO_ERROR);\r\n\r\n        _utilizationRate; // pragma ignore unused variable\r\n\r\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\r\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\r\n    }\r\n}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022baseRate_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022multiplier_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022baseRate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022blocksPerYear\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022cash\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022borrows\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_reserves\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getBorrowRate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isInterestRateModel\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022multiplier\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"WhitePaperInterestRateModel","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000470de4df820000000000000000000000000000000000000000000000000000016345785d8a0000","Library":"","SwarmSource":"bzzr://db1cd49d14548f9ddfed26af7ee2d44693261cc493d62972a7b588aae4fe7d94"}]