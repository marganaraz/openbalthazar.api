[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract SportCrypt {\r\n    address private owner;\r\n    mapping(address =\u003E bool) private admins;\r\n\r\n    function SportCrypt() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n\r\n    // Events\r\n\r\n    event LogBalanceChange(address indexed account, uint oldAmount, uint newAmount);\r\n    event LogDeposit(address indexed account);\r\n    event LogWithdraw(address indexed account);\r\n    event LogTrade(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint8 orderDirection, uint8 price, uint longAmount, int newLongPosition, uint shortAmount, int newShortPosition);\r\n    event LogTradeError(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint16 status);\r\n    event LogOrderCancel(address indexed account, uint indexed matchId, uint orderHash);\r\n    event LogFinalizeMatch(uint indexed matchId, uint8 finalPrice);\r\n    event LogClaim(address indexed account, uint indexed matchId, uint amount);\r\n\r\n\r\n    // Storage\r\n\r\n    struct Match {\r\n        mapping(address =\u003E int) positions;\r\n        uint64 firstTradeTimestamp;\r\n        bool finalized;\r\n        uint8 finalPrice;\r\n    }\r\n\r\n    mapping(address =\u003E uint) private balances;\r\n    mapping(uint =\u003E Match) private matches;\r\n    mapping(uint =\u003E uint) private filledAmounts;\r\n\r\n\r\n    // Memory\r\n\r\n    uint constant MAX_SANE_AMOUNT = 2**128;\r\n\r\n    enum Status {\r\n        OK,\r\n        MATCH_FINALIZED,\r\n        ORDER_EXPIRED,\r\n        ORDER_MALFORMED,\r\n        ORDER_BAD_SIG,\r\n        AMOUNT_MALFORMED,\r\n        SELF_TRADE,\r\n        ZERO_VALUE_TRADE\r\n    }\r\n\r\n    struct Order {\r\n        uint orderHash;\r\n        uint matchId;\r\n        uint amount;\r\n        uint expiry;\r\n        address addr;\r\n        uint8 price;\r\n        uint8 direction;\r\n    }\r\n\r\n    // [0]: match hash\r\n    // [1]: amount\r\n    // [2]: 5-byte expiry, 5-byte nonce, 1-byte price, 1-byte direction, 20-byte address\r\n\r\n    function parseOrder(uint[3] memory rawOrder) private constant returns(Order memory o) {\r\n        o.orderHash = uint(keccak256(this, rawOrder));\r\n\r\n        o.matchId = rawOrder[0];\r\n        o.amount = rawOrder[1];\r\n\r\n        uint packed = rawOrder[2];\r\n        o.expiry = packed \u003E\u003E (8*27);\r\n        o.addr = address(packed \u0026 0x00ffffffffffffffffffffffffffffffffffffffff);\r\n        o.price = uint8((packed \u003E\u003E (8*21)) \u0026 0xff);\r\n        o.direction = uint8((packed \u003E\u003E (8*20)) \u0026 0xff);\r\n    }\r\n\r\n    function validateOrderParams(Order memory o) private pure returns(bool) {\r\n        if (o.amount \u003E MAX_SANE_AMOUNT) return false;\r\n        if (o.price == 0 || o.price \u003E 99) return false;\r\n        if (o.direction \u003E 1) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateOrderSig(Order memory o, bytes32 r, bytes32 s, uint8 v) private pure returns(bool) {\r\n        if (ecrecover(keccak256(\u0022\\x19Ethereum Signed Message:\\n32\u0022, o.orderHash), v, r, s) != o.addr) return false;\r\n        return true;\r\n    }\r\n\r\n    struct Trade {\r\n        Status status;\r\n        address longAddr;\r\n        address shortAddr;\r\n        int newLongPosition;\r\n        int newShortPosition;\r\n        int longBalanceDelta;\r\n        int shortBalanceDelta;\r\n        uint shortAmount;\r\n        uint longAmount;\r\n    }\r\n\r\n\r\n    // User methods\r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    function deposit() external payable {\r\n        if (msg.value \u003E 0) {\r\n            uint origAmount = balances[msg.sender];\r\n            uint newAmount = safeAdd(origAmount, msg.value);\r\n            balances[msg.sender] = newAmount;\r\n\r\n            LogDeposit(msg.sender);\r\n            LogBalanceChange(msg.sender, origAmount, newAmount);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint amount) external {\r\n        uint origAmount = balances[msg.sender];\r\n        uint amountToWithdraw = minu256(origAmount, amount);\r\n\r\n        if (amountToWithdraw \u003E 0) {\r\n            uint newAmount = origAmount - amountToWithdraw;\r\n            balances[msg.sender] = newAmount;\r\n\r\n            LogWithdraw(msg.sender);\r\n            LogBalanceChange(msg.sender, origAmount, newAmount);\r\n\r\n            msg.sender.transfer(amountToWithdraw);\r\n        }\r\n    }\r\n\r\n    function cancelOrder(uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\r\n        Order memory o = parseOrder(order);\r\n\r\n        // Don\u0027t bother validating order params.\r\n        require(validateOrderSig(o, r, s, v));\r\n        require(o.addr == msg.sender);\r\n\r\n        if (block.timestamp \u003C o.expiry) {\r\n            filledAmounts[o.orderHash] = o.amount;\r\n            LogOrderCancel(msg.sender, o.matchId, o.orderHash);\r\n        }\r\n    }\r\n\r\n    function trade(uint amount, uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\r\n        Order memory o = parseOrder(order);\r\n\r\n        if (!validateOrderParams(o)) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_MALFORMED));\r\n            return;\r\n        }\r\n\r\n        if (!validateOrderSig(o, r, s, v)) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_BAD_SIG));\r\n            return;\r\n        }\r\n\r\n        Trade memory t = tradeCore(amount, o);\r\n\r\n        if (t.status != Status.OK) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(t.status));\r\n            return;\r\n        }\r\n\r\n        // Modify storage to reflect trade:\r\n\r\n        var m = matches[o.matchId];\r\n\r\n        if (m.firstTradeTimestamp == 0) {\r\n            assert(block.timestamp \u003E 0);\r\n            m.firstTradeTimestamp = uint64(block.timestamp);\r\n        }\r\n\r\n        m.positions[t.longAddr] = t.newLongPosition;\r\n        m.positions[t.shortAddr] = t.newShortPosition;\r\n\r\n        adjustBalance(t.longAddr, t.longBalanceDelta);\r\n        adjustBalance(t.shortAddr, t.shortBalanceDelta);\r\n\r\n        filledAmounts[o.orderHash] \u002B= (o.direction == 0 ? t.shortAmount : t.longAmount);\r\n\r\n        LogTrade(msg.sender, o.addr, o.matchId, o.orderHash, o.direction, o.price, t.longAmount, t.newLongPosition, t.shortAmount, t.newShortPosition);\r\n    }\r\n\r\n    function claim(uint matchId, uint8 finalPrice, bytes32 r, bytes32 s, uint8 v) external {\r\n        var m = matches[matchId];\r\n\r\n        if (m.finalized) {\r\n            require(m.finalPrice == finalPrice);\r\n        } else {\r\n            uint messageHash = uint(keccak256(this, matchId, finalPrice));\r\n            address signer = ecrecover(keccak256(\u0022\\x19Ethereum Signed Message:\\n32\u0022, messageHash), v, r, s);\r\n            require(admins[signer]);\r\n            require(finalPrice \u003C= 100);\r\n\r\n            m.finalized = true;\r\n            m.finalPrice = finalPrice;\r\n            LogFinalizeMatch(matchId, finalPrice);\r\n        }\r\n\r\n        // NOTE: final prices other than 0 and 100 may leave very small amounts of unrecoverable dust in the contract due to rounding.\r\n\r\n        int delta = 0;\r\n        int senderPosition = m.positions[msg.sender];\r\n\r\n        if (senderPosition \u003E 0) {\r\n            delta = priceDivide(senderPosition, finalPrice);\r\n        } else if (senderPosition \u003C 0) {\r\n            delta = priceDivide(-senderPosition, 100 - finalPrice);\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        assert(delta \u003E= 0);\r\n\r\n        m.positions[msg.sender] = 0;\r\n        adjustBalance(msg.sender, delta);\r\n\r\n        LogClaim(msg.sender, matchId, uint(delta));\r\n    }\r\n\r\n    function recoverFunds(uint matchId) external {\r\n        var m = matches[matchId];\r\n\r\n        if (m.finalized || m.firstTradeTimestamp == 0) {\r\n            return;\r\n        }\r\n\r\n        uint recoveryTimestamp = uint(m.firstTradeTimestamp) \u002B ((matchId \u0026 0xFF) * 7 * 86400);\r\n\r\n        if (uint(block.timestamp) \u003E recoveryTimestamp) {\r\n            uint8 finalPrice = uint8((matchId \u0026 0xFF00) \u003E\u003E 8);\r\n            require(finalPrice \u003C= 100);\r\n\r\n            m.finalized = true;\r\n            m.finalPrice = finalPrice;\r\n            LogFinalizeMatch(matchId, finalPrice);\r\n        }\r\n    }\r\n\r\n\r\n    // Private utilities\r\n\r\n    function adjustBalance(address addr, int delta) private {\r\n        uint origAmount = balances[addr];\r\n        uint newAmount = delta \u003E= 0 ? safeAdd(origAmount, uint(delta)) : safeSub(origAmount, uint(-delta));\r\n        balances[addr] = newAmount;\r\n\r\n        LogBalanceChange(addr, origAmount, newAmount);\r\n    }\r\n\r\n    function priceDivide(int amount, uint8 price) private pure returns(int) {\r\n        assert(amount \u003E= 0);\r\n        return int(safeMul(uint(amount), price) / 100);\r\n    }\r\n\r\n    function computeEffectiveBalance(uint balance, int position, uint8 price, bool isLong) private pure returns(uint) {\r\n        uint effectiveBalance = balance;\r\n\r\n        if (isLong) {\r\n            if (position \u003C 0) effectiveBalance \u002B= uint(priceDivide(-position, price));\r\n        } else {\r\n            if (position \u003E 0) effectiveBalance \u002B= uint(priceDivide(position, 100 - price));\r\n        }\r\n\r\n        return effectiveBalance;\r\n    }\r\n\r\n    function computePriceWeightedAmounts(uint longAmount, uint shortAmount, uint price) private pure returns(uint, uint) {\r\n        uint totalLongAmount;\r\n        uint totalShortAmount;\r\n\r\n        totalLongAmount = longAmount \u002B (safeMul(longAmount, 100 - price) / price);\r\n        totalShortAmount = shortAmount \u002B (safeMul(shortAmount, price) / (100 - price));\r\n\r\n        if (totalLongAmount \u003E totalShortAmount) {\r\n            return (totalShortAmount - shortAmount, shortAmount);\r\n        } else {\r\n            return (longAmount, totalLongAmount - longAmount);\r\n        }\r\n    }\r\n\r\n    function computeExposureDelta(int longBalanceDelta, int shortBalanceDelta, int oldLongPosition, int newLongPosition, int oldShortPosition, int newShortPosition) private pure returns(int) {\r\n        int positionDelta = 0;\r\n        if (newLongPosition \u003E 0) positionDelta \u002B= newLongPosition - max256(0, oldLongPosition);\r\n        if (oldShortPosition \u003E 0) positionDelta -= oldShortPosition - max256(0, newShortPosition);\r\n\r\n        return positionDelta \u002B longBalanceDelta \u002B shortBalanceDelta;\r\n    }\r\n\r\n    function tradeCore(uint amount, Order memory o) private constant returns(Trade t) {\r\n        var m = matches[o.matchId];\r\n\r\n        if (block.timestamp \u003E= o.expiry) {\r\n            t.status = Status.ORDER_EXPIRED;\r\n            return;\r\n        }\r\n\r\n        if (m.finalized) {\r\n            t.status = Status.MATCH_FINALIZED;\r\n            return;\r\n        }\r\n\r\n        if (msg.sender == o.addr) {\r\n            t.status = Status.SELF_TRADE;\r\n            return;\r\n        }\r\n\r\n        if (amount \u003E MAX_SANE_AMOUNT) {\r\n            t.status = Status.AMOUNT_MALFORMED;\r\n            return;\r\n        }\r\n\r\n        t.status = Status.OK;\r\n\r\n\r\n        uint longAmount;\r\n        uint shortAmount;\r\n\r\n        if (o.direction == 0) {\r\n            // maker short, taker long\r\n            t.longAddr = msg.sender;\r\n            longAmount = amount;\r\n\r\n            t.shortAddr = o.addr;\r\n            shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n        } else {\r\n            // maker long, taker short \r\n            t.longAddr = o.addr;\r\n            longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n\r\n            t.shortAddr = msg.sender;\r\n            shortAmount = amount;\r\n        }\r\n\r\n        int oldLongPosition = m.positions[t.longAddr];\r\n        int oldShortPosition = m.positions[t.shortAddr];\r\n\r\n        longAmount = minu256(longAmount, computeEffectiveBalance(balances[t.longAddr], oldLongPosition, o.price, true));\r\n        shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[t.shortAddr], oldShortPosition, o.price, false));\r\n\r\n        (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n\r\n        if (longAmount == 0 || shortAmount == 0) {\r\n            t.status = Status.ZERO_VALUE_TRADE;\r\n            return;\r\n        }\r\n\r\n\r\n        int newLongPosition = oldLongPosition \u002B (int(longAmount) \u002B int(shortAmount));\r\n        int newShortPosition = oldShortPosition - (int(longAmount) \u002B int(shortAmount));\r\n\r\n\r\n        t.longBalanceDelta = 0;\r\n        t.shortBalanceDelta = 0;\r\n\r\n        if (oldLongPosition \u003C 0) t.longBalanceDelta \u002B= priceDivide(-oldLongPosition \u002B min256(0, newLongPosition), 100 - o.price);\r\n        if (newLongPosition \u003E 0) t.longBalanceDelta -= priceDivide(newLongPosition - max256(0, oldLongPosition), o.price);\r\n\r\n        if (oldShortPosition \u003E 0) t.shortBalanceDelta \u002B= priceDivide(oldShortPosition - max256(0, newShortPosition), o.price);\r\n        if (newShortPosition \u003C 0) t.shortBalanceDelta -= priceDivide(-newShortPosition \u002B min256(0, oldShortPosition), 100 - o.price);\r\n\r\n        int exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\r\n\r\n        if (exposureDelta != 0) {\r\n            if (exposureDelta == 1) {\r\n                newLongPosition--;\r\n                newShortPosition\u002B\u002B;\r\n            } else if (exposureDelta == -1) {\r\n                t.longBalanceDelta\u002B\u002B; // one left-over wei: arbitrarily give it to long\r\n            } else {\r\n                assert(false);\r\n            }\r\n\r\n            exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\r\n            assert(exposureDelta == 0);\r\n        }\r\n\r\n\r\n        t.newLongPosition = newLongPosition;\r\n        t.newShortPosition = newShortPosition;\r\n        t.shortAmount = shortAmount;\r\n        t.longAmount = longAmount;\r\n    }\r\n\r\n\r\n    // External views\r\n\r\n    function getOwner() external view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n    function isAdmin(address addr) external view returns(bool) {\r\n        return admins[addr];\r\n    }\r\n\r\n    function getBalance(address addr) external view returns(uint) {\r\n        return balances[addr];\r\n    }\r\n\r\n    function getMatchInfo(uint matchId) external view returns(uint64, bool, uint8) {\r\n        var m = matches[matchId];\r\n        return (m.firstTradeTimestamp, m.finalized, m.finalPrice);\r\n    }\r\n\r\n    function getPosition(uint matchId, address addr) external view returns(int) {\r\n        return matches[matchId].positions[addr];\r\n    }\r\n\r\n    function getFilledAmount(uint orderHash) external view returns(uint) {\r\n        return filledAmounts[orderHash];\r\n    }\r\n\r\n    function checkMatchBatch(address myAddr, uint[16] matchIds) external view returns(int[16] myPosition, bool[16] finalized, uint8[16] finalPrice) {\r\n        for (uint i = 0; i \u003C 16; i\u002B\u002B) {\r\n            if (matchIds[i] == 0) break;\r\n\r\n            var m = matches[matchIds[i]];\r\n\r\n            myPosition[i] = m.positions[myAddr];\r\n            finalized[i] = m.finalized;\r\n            finalPrice[i] = m.finalPrice;\r\n        }\r\n    }\r\n\r\n    function checkOrderBatch(uint[48] input) external view returns(uint16[16] status, uint[16] amount) {\r\n        for (uint i = 0; i \u003C 16; i\u002B\u002B) {\r\n            uint[3] memory rawOrder;\r\n            rawOrder[0] = input[(i*3)];\r\n            rawOrder[1] = input[(i*3) \u002B 1];\r\n            rawOrder[2] = input[(i*3) \u002B 2];\r\n\r\n            if (rawOrder[0] == 0) break;\r\n\r\n            Order memory o = parseOrder(rawOrder);\r\n\r\n            if (!validateOrderParams(o)) {\r\n                status[i] = uint16(Status.ORDER_MALFORMED);\r\n                amount[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            // Not validating order signatures or timestamps: should be done by clients\r\n\r\n            var m = matches[o.matchId];\r\n\r\n            if (m.finalized) {\r\n                status[i] = uint16(Status.MATCH_FINALIZED);\r\n                amount[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            uint longAmount;\r\n            uint shortAmount;\r\n\r\n            if (o.direction == 0) {\r\n                shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n                longAmount = safeMul(shortAmount, 100);\r\n                shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, false));\r\n                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n                status[i] = uint16(Status.OK);\r\n                amount[i] = shortAmount;\r\n            } else {\r\n                longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n                shortAmount = safeMul(longAmount, 100);\r\n                longAmount = minu256(longAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, true));\r\n                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n                status[i] = uint16(Status.OK);\r\n                amount[i] = longAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Math utilities\r\n\r\n    function safeMul(uint a, uint b) private pure returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) private pure returns(uint) {\r\n        assert(b \u003C= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) private pure returns(uint) {\r\n        uint c = a \u002B b;\r\n        assert(c \u003E= a \u0026\u0026 c \u003E= b);\r\n        return c;\r\n    }\r\n\r\n    function minu256(uint a, uint b) private pure returns(uint) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n\r\n    function max256(int a, int b) private pure returns(int) {\r\n        return a \u003E= b ? a : b;\r\n    }\r\n\r\n    function min256(int a, int b) private pure returns(int) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isAdmin\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022myAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022matchIds\u0022,\u0022type\u0022:\u0022uint256[16]\u0022}],\u0022name\u0022:\u0022checkMatchBatch\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022myPosition\u0022,\u0022type\u0022:\u0022int256[16]\u0022},{\u0022name\u0022:\u0022finalized\u0022,\u0022type\u0022:\u0022bool[16]\u0022},{\u0022name\u0022:\u0022finalPrice\u0022,\u0022type\u0022:\u0022uint8[16]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022recoverFunds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getMatchInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022finalPrice\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022claim\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022order\u0022,\u0022type\u0022:\u0022uint256[3]\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022cancelOrder\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getFilledAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022order\u0022,\u0022type\u0022:\u0022uint256[3]\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022trade\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022input\u0022,\u0022type\u0022:\u0022uint256[48]\u0022}],\u0022name\u0022:\u0022checkOrderBatch\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022uint16[16]\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256[16]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getPosition\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022oldAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogBalanceChange\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogDeposit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogWithdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022takerAccount\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022makerAccount\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderDirection\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022price\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022longAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newLongPosition\u0022,\u0022type\u0022:\u0022int256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022shortAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022newShortPosition\u0022,\u0022type\u0022:\u0022int256\u0022}],\u0022name\u0022:\u0022LogTrade\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022takerAccount\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022makerAccount\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022uint16\u0022}],\u0022name\u0022:\u0022LogTradeError\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogOrderCancel\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022finalPrice\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022LogFinalizeMatch\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022matchId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogClaim\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"SportCrypt","CompilerVersion":"v0.4.18\u002Bcommit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bfd4321cd89f9a55d3e5a24c1474acb3f13e17e77ef9445e0b0647cfad375b4a"}]