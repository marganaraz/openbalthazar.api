[{"SourceCode":"// File: contracts/ERC1155/enjin/Common.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n    Note: Simple contract to use as base for const vals\r\n*/\r\ncontract CommonConstants {\r\n\r\n    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\u0022onERC1155Received(address,address,uint256,uint256,bytes)\u0022))\r\n    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\u0022onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\u0022))\r\n}\r\n\r\n// File: contracts/ERC1155/enjin/IEnjinERC1155.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\ninterface IEnjinERC1155 {\r\n  function acceptAssignment ( uint256 _id ) external;\r\n  function assign ( uint256 _id, address _creator ) external;\r\n  function balanceOf ( address _owner, uint256 _id ) external view returns ( uint256 );\r\n  function balanceOfBatch ( address[] calldata _owners, uint256[] calldata _ids ) external view returns ( uint256[] memory);\r\n  function create ( string calldata _name, uint256 _totalSupply, uint256 _initialReserve, address _supplyModel, uint256 _meltValue, uint16 _meltFeeRatio, uint8 _transferable, uint256[3] calldata _transferFeeSettings, bool _nonFungible ) external;\r\n  function isApprovedForAll ( address _owner, address _operator ) external view returns ( bool );\r\n  function melt ( uint256[] calldata _ids, uint256[] calldata _values ) external;\r\n  function mintFungibles ( uint256 _id, address[] calldata _to, uint256[] calldata _values ) external;\r\n  function mintNonFungibles ( uint256 _id, address[] calldata _to ) external;\r\n  function safeBatchTransferFrom ( address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data ) external;\r\n  function safeTransferFrom ( address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data ) external;\r\n  function setApprovalForAll ( address _operator, bool _approved ) external;\r\n  function setURI ( uint256 _id, string calldata _uri ) external;\r\n  function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool );\r\n  function uri ( uint256 _id ) external view returns ( string memory );\r\n}\r\n\r\n// File: contracts/ERC1155/enjin/IERC1155TokenReceiver.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\n*/\r\ninterface ERC1155TokenReceiver {\r\n    /**\r\n        @notice Handle the receipt of a single ERC1155 token type.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a \u0060safeTransferFrom\u0060 after the balance has been updated.\r\n        This function MUST return \u0060bytes4(keccak256(\u0022onERC1155Received(address,address,uint256,uint256,bytes)\u0022))\u0060 (i.e. 0xf23a6e61) if it accepts the transfer.\r\n        This function MUST revert if it rejects the transfer.\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _id        The ID of the token being transferred\r\n        @param _value     The amount of tokens being transferred\r\n        @param _data      Additional data with no specified format\r\n        @return           \u0060bytes4(keccak256(\u0022onERC1155Received(address,address,uint256,uint256,bytes)\u0022))\u0060\r\n    */\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n\r\n    /**\r\n        @notice Handle the receipt of multiple ERC1155 token types.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a \u0060safeBatchTransferFrom\u0060 after the balances have been updated.\r\n        This function MUST return \u0060bytes4(keccak256(\u0022onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\u0022))\u0060 (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n        This function MUST revert if it rejects the transfer(s).\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\r\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\r\n        @param _data      Additional data with no specified format\r\n        @return           \u0060bytes4(keccak256(\u0022onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\u0022))\u0060\r\n    */\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ERC721/el/forging/ForgeERC1155Operations.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ForgeERC1155Operations is ERC1155TokenReceiver, CommonConstants {\r\n\r\n    // The Enjin ERC-1155 smart contract\r\n    IEnjinERC1155 public enjinContract;\r\n\r\n    // The Enjin Coin ERC-20 smart contract\r\n    IERC20 public enjinCoinContract;\r\n\r\n    function safeTransferFungibleItemWithOptionalMelt(uint256 tokenId, address recipient, bool melt) internal {\r\n      bytes memory extraData = new bytes(0); \r\n      enjinContract.safeTransferFrom(msg.sender, melt ? address(this) : recipient, tokenId, 1, extraData);\r\n\r\n      if(melt) {\r\n        uint256 startingEnjinCoinBalance = enjinCoinContract.balanceOf(address(this));\r\n        uint256[] memory ids = new uint256[](1);\r\n        uint256[] memory values = new uint256[](1);\r\n        ids[0] = tokenId;\r\n        values[0] = 1;\r\n        enjinContract.melt(ids, values);\r\n        uint256 endingEnjinCoinBalance = enjinCoinContract.balanceOf(address(this));\r\n        uint256 changeInEnjinCoinBalance = endingEnjinCoinBalance - startingEnjinCoinBalance;\r\n\r\n        if(changeInEnjinCoinBalance \u003E 0) {\r\n          enjinCoinContract.transfer(msg.sender, changeInEnjinCoinBalance);\r\n        }\r\n      }\r\n    }    \r\n\r\n    function safeTransferNonFungibleItemWithOptionalMelt(uint256 tokenId, uint256 NFTIndex, address recipient, bool melt) internal {\r\n      uint256[] memory nftIds = new uint256[](1);\r\n      uint256[] memory values = new uint256[](1);\r\n      nftIds[0] = tokenId | NFTIndex;\r\n      values[0] = 1;\r\n\r\n      bytes memory extraData = new bytes(0);\r\n      enjinContract.safeBatchTransferFrom(msg.sender, melt ? address(this) : recipient, nftIds, values, extraData);\r\n\r\n      if(melt) {\r\n        uint256 startingEnjinCoinBalance = enjinCoinContract.balanceOf(address(this));\r\n        enjinContract.melt(nftIds, values);\r\n        uint256 endingEnjinCoinBalance = enjinCoinContract.balanceOf(address(this));\r\n        uint256 changeInEnjinCoinBalance = endingEnjinCoinBalance - startingEnjinCoinBalance;\r\n\r\n        if(changeInEnjinCoinBalance \u003E 0) {\r\n          enjinCoinContract.transfer(msg.sender, changeInEnjinCoinBalance);\r\n        }        \r\n      }      \r\n    }        \r\n\r\n    function onERC1155Received(address /*_operator*/, address /*_from*/, uint256 /*_id*/, uint256 /*_value*/, bytes calldata /*_data*/) external returns(bytes4) {\r\n      return ERC1155_ACCEPTED;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address /*_operator*/, address /*_from*/, uint256[] calldata /*_ids*/, uint256[] calldata /*_values*/, bytes calldata /*_data*/) external returns(bytes4) {        \r\n      return ERC1155_BATCH_ACCEPTED;        \r\n    }\r\n\r\n    // ERC165 interface support\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return  interfaceID == 0x01ffc9a7 ||    // ERC165\r\n                interfaceID == 0x4e2312e0;      // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\r\n    }\r\n}\r\n\r\n// File: contracts/ERC721/el/forging/IForgePathCatalogCombined.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\ninterface IForgePathCatalogCombined {        \r\n    function getNumberOfPathDefinitions() external view returns (uint256);\r\n    function getForgePathNameAtIndex(uint256 index) external view returns (string memory);\r\n    function getForgePathIdAtIndex(uint256 index) external view returns (uint256);\r\n\r\n    function getForgeType(uint256 pathId) external view returns (uint8);\r\n    function getForgePathDetailsCommon(uint256 pathId) external view returns (uint256, uint256, uint256);\r\n    function getForgePathDetailsTwoGen1Tokens(uint256 pathId) external view returns (uint256, uint256, bool, bool);\r\n    function getForgePathDetailsTwoERC721Addresses(uint256 pathId) external view returns (address, address);\r\n    function getForgePathDetailsERC721AddressWithGen1Token(uint256 pathId) external view returns (address, uint256, bool);\r\n    function getForgePathDetailsTwoERC1155Tokens(uint256 pathId) external view returns (uint256, uint256, bool, bool, bool, bool);\r\n    function getForgePathDetailsERC1155WithGen1Token(uint256 pathId) external view returns (uint256, uint256, bool, bool, bool);\r\n    function getForgePathDetailsERC1155WithERC721Address(uint256 pathId) external view returns (uint256, address, bool, bool);\r\n}\r\n\r\n// File: contracts/ERC721/el/IBurnableEtherLegendsToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\ninterface IBurnableEtherLegendsToken {        \r\n    function burn(uint256 tokenId) external;\r\n}\r\n\r\n// File: contracts/ERC721/el/IMintableEtherLegendsToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\ninterface IMintableEtherLegendsToken {        \r\n    function mintTokenOfType(address to, uint256 idOfTokenType) external;\r\n}\r\n\r\n// File: contracts/ERC721/el/ITokenDefinitionManager.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\ninterface ITokenDefinitionManager {        \r\n    function getNumberOfTokenDefinitions() external view returns (uint256);\r\n    function hasTokenDefinition(uint256 tokenTypeId) external view returns (bool);\r\n    function getTokenTypeNameAtIndex(uint256 index) external view returns (string memory);\r\n    function getTokenTypeName(uint256 tokenTypeId) external view returns (string memory);\r\n    function getTokenTypeId(string calldata name) external view returns (uint256);\r\n    function getCap(uint256 tokenTypeId) external view returns (uint256);\r\n    function getAbbreviation(uint256 tokenTypeId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (\u0060ERC165Checker\u0060).\r\n *\r\n * For an implementation, see \u0060ERC165\u0060.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * \u0060interfaceId\u0060. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in \u0060owner\u0060\u0027s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by \u0060tokenId\u0060.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * \r\n     *\r\n     * Requirements:\r\n     * - \u0060from\u0060, \u0060to\u0060 cannot be zero.\r\n     * - \u0060tokenId\u0060 must be owned by \u0060from\u0060.\r\n     * - If the caller is not \u0060from\u0060, it must be have been allowed to move this\r\n     * NFT by either \u0060approve\u0060 or \u0060setApproveForAll\u0060.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not \u0060from\u0060, it must be approved to move this NFT by\r\n     * either \u0060approve\u0060 or \u0060setApproveForAll\u0060.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {\r\n    // solhint-disable-previous-line no-empty-blocks\r\n}\r\n\r\n// File: contracts/ERC721/el/IEtherLegendsToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract IEtherLegendsToken is IERC721Full, IMintableEtherLegendsToken, IBurnableEtherLegendsToken, ITokenDefinitionManager {\r\n    function totalSupplyOfType(uint256 tokenTypeId) external view returns (uint256);\r\n    function getTypeIdOfToken(uint256 tokenId) external view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * \u003E Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from \u0060ReentrancyGuard\u0060 will make the \u0060nonReentrant\u0060 modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single \u0060nonReentrant\u0060 guard, functions marked as\r\n * \u0060nonReentrant\u0060 may not call one another. This can be worked around by making\r\n * those functions \u0060private\u0060, and then adding \u0060external\u0060 \u0060nonReentrant\u0060 entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter \u002B= 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \u0022ReentrancyGuard: reentrant call\u0022);\r\n    }\r\n}\r\n\r\n// File: contracts/ERC721/el/forging/ForgeCombined.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ForgeCombined is ForgeERC1155Operations, Ownable, ReentrancyGuard {    \r\n\r\n    // Address to which elementeum and ETH are transferred\r\n    address public payee;    \r\n\r\n    // Address to which non-melted items are transferred\r\n    address public lootWallet;    \r\n\r\n    // The forge catalog smart contract\r\n    IForgePathCatalogCombined public catalogContract;    \r\n\r\n    // The Elementeum ERC-20 token smart contract\r\n    IERC20 public elementeumContract;\r\n\r\n    // The Ether Legends Gen 1 ERC-721 token smart contract\r\n    IEtherLegendsToken public etherLegendsGen1;    \r\n\r\n    constructor() public \r\n      Ownable()\r\n      ReentrancyGuard()\r\n    {\r\n      \r\n    }    \r\n\r\n    function() external payable {\r\n        revert(\u0022Fallback function not permitted.\u0022);\r\n    }\r\n\r\n    function destroyContract() external {\r\n      _requireOnlyOwner();\r\n      address payable payableOwner = address(uint160(owner()));\r\n      selfdestruct(payableOwner);\r\n    }\r\n\r\n    function setPayee(address addr) external {\r\n      _requireOnlyOwner();\r\n      payee = addr;\r\n    }\r\n\r\n    function setLootWallet(address addr) external {\r\n      _requireOnlyOwner();\r\n      lootWallet = addr;\r\n    }\r\n\r\n    function setCatalogContractAddress(address addr) external {\r\n      _requireOnlyOwner();\r\n      catalogContract = IForgePathCatalogCombined(addr);\r\n    }\r\n\r\n    function setElementeumERC20ContractAddress(address addr) external {\r\n      _requireOnlyOwner();\r\n      elementeumContract = IERC20(addr);\r\n    }    \r\n\r\n    function setEtherLegendsGen1(address addr) external {\r\n      _requireOnlyOwner();\r\n      etherLegendsGen1 = IEtherLegendsToken(addr);\r\n    }  \r\n\r\n    function setEnjinERC1155ContractAddress(address addr) external {\r\n      _requireOnlyOwner();\r\n      enjinContract = IEnjinERC1155(addr);\r\n    }\r\n\r\n    function setEnjinERC20ContractAddress(address addr) external {\r\n      _requireOnlyOwner();\r\n      enjinCoinContract = IERC20(addr);\r\n    }\r\n\r\n    function forge(uint256 pathId, uint256 material1TokenId, uint256 material2TokenId) external payable nonReentrant {\r\n      _requireOnlyHuman();      \r\n\r\n      uint8 forgeType = catalogContract.getForgeType(pathId);\r\n      (uint256 weiCost, uint256 elementeumCost, uint256 forgedItem) = catalogContract.getForgePathDetailsCommon(pathId);\r\n\r\n      require(msg.value \u003E= weiCost, \u0022Insufficient ETH\u0022);\r\n\r\n      if(forgeType == 1) {\r\n        require(material1TokenId != material2TokenId, \u0022NFT ids must be unique\u0022);  \r\n        (uint256 material1, \r\n         uint256 material2, \r\n         bool burnMaterial1, \r\n         bool burnMaterial2) = catalogContract.getForgePathDetailsTwoGen1Tokens(pathId);\r\n         _forgeGen1Token(material1, material1TokenId, burnMaterial1);\r\n         _forgeGen1Token(material2, material2TokenId, burnMaterial2);\r\n      } else if(forgeType == 2) {\r\n        (address material1, address material2) = catalogContract.getForgePathDetailsTwoERC721Addresses(pathId);\r\n        if(material1 == material2) {\r\n          require(material1TokenId != material2TokenId, \u0022NFT ids must be unique\u0022);\r\n        }\r\n        _forgeERC721Token(material1, material1TokenId);\r\n        _forgeERC721Token(material2, material2TokenId);\r\n      } else if(forgeType == 3) {\r\n        (address material1, \r\n         uint256 material2, \r\n         bool burnMaterial2) = catalogContract.getForgePathDetailsERC721AddressWithGen1Token(pathId);\r\n         _forgeERC721Token(material1, material1TokenId);\r\n         _forgeGen1Token(material2, material2TokenId, burnMaterial2);\r\n      } else if(forgeType == 4) {\r\n        (uint256 material1,\r\n         uint256 material2,\r\n         bool meltMaterial1,\r\n         bool meltMaterial2,\r\n         bool material1IsNonFungible,\r\n         bool material2IsNonFungible) = catalogContract.getForgePathDetailsTwoERC1155Tokens(pathId);\r\n        if(material1 == material2 \u0026\u0026 material1IsNonFungible \u0026\u0026 material2IsNonFungible) {\r\n          require(material1TokenId != material2TokenId, \u0022NFT ids must be unique\u0022);\r\n        }\r\n        _forgeERC1155Token(material1, material1TokenId, meltMaterial1, material1IsNonFungible);\r\n        _forgeERC1155Token(material2, material2TokenId, meltMaterial2, material2IsNonFungible);\r\n      } else if(forgeType == 5) {\r\n        (uint256 material1,\r\n         uint256 material2,\r\n         bool meltMaterial1,\r\n         bool burnMaterial2,\r\n         bool material1IsNonFungible) = catalogContract.getForgePathDetailsERC1155WithGen1Token(pathId);\r\n         _forgeERC1155Token(material1, material1TokenId, meltMaterial1, material1IsNonFungible);\r\n         _forgeGen1Token(material2, material2TokenId, burnMaterial2);\r\n      } else if(forgeType == 6) {\r\n        (uint256 material1,\r\n         address material2,\r\n         bool meltMaterial1,\r\n         bool material1IsNonFungible) = catalogContract.getForgePathDetailsERC1155WithERC721Address(pathId);\r\n         _forgeERC1155Token(material1, material1TokenId, meltMaterial1, material1IsNonFungible);\r\n         _forgeERC721Token(material2, material2TokenId);\r\n      } else {\r\n        revert(\u0022Non-existent forge type\u0022);\r\n      }\r\n\r\n      if(elementeumCost \u003E 0) {\r\n        elementeumContract.transferFrom(msg.sender, payee, elementeumCost);      \r\n      }                    \r\n\r\n      if(msg.value \u003E 0) {                \r\n        address payable payableWallet = address(uint160(payee));\r\n        payableWallet.transfer(weiCost);\r\n\r\n        uint256 change = msg.value - weiCost;\r\n        if(change \u003E 0) {\r\n          msg.sender.transfer(change);\r\n        }\r\n      }\r\n\r\n      etherLegendsGen1.mintTokenOfType(msg.sender, forgedItem);            \r\n    }\r\n\r\n    function _forgeGen1Token(uint256 material, uint256 tokenId, bool burnMaterial) internal {\r\n      _verifyOwnershipAndApprovalERC721(address(etherLegendsGen1), tokenId);\r\n      require(material == etherLegendsGen1.getTypeIdOfToken(tokenId), \u0022Incorrect material type\u0022);\r\n      burnMaterial ? etherLegendsGen1.burn(tokenId) : _safeTransferERC721(address(etherLegendsGen1), tokenId);\r\n    } \r\n\r\n    function _forgeERC721Token(address material, uint256 tokenId) internal {\r\n      _verifyOwnershipAndApprovalERC721(material, tokenId);\r\n      _safeTransferERC721(material, tokenId);\r\n    }       \r\n\r\n    function _forgeERC1155Token(uint256 material, uint256 materialNFTIndex, bool meltMaterial, bool materialIsNonFungible) internal {\r\n      require(enjinContract.isApprovedForAll(msg.sender, address(this)), \u0022Not approved to spend user\u0027s ERC1155 tokens\u0022);      \r\n      require(enjinContract.balanceOf(msg.sender, materialIsNonFungible ? ( material | materialNFTIndex ) : material) \u003E 0, \u0022Insufficient material balance\u0022);  \r\n      materialIsNonFungible ? \r\n      safeTransferNonFungibleItemWithOptionalMelt(material, materialNFTIndex, lootWallet, meltMaterial) :\r\n      safeTransferFungibleItemWithOptionalMelt(material, lootWallet, meltMaterial);\r\n    }                 \r\n\r\n    function _verifyOwnershipAndApprovalERC721(address tokenAddress, uint256 tokenId) internal view {\r\n      IERC721Full tokenContract = IERC721Full(tokenAddress);\r\n      require(tokenContract.ownerOf(tokenId) == msg.sender, \u0022Token not owned by user\u0022);\r\n      require(tokenContract.getApproved(tokenId) == address(this) || tokenContract.isApprovedForAll(msg.sender, address(this)), \u0022Token not approved\u0022);      \r\n    }    \r\n\r\n    function _safeTransferERC721(address tokenAddress, uint256 tokenId) internal {\r\n      IERC721Full tokenContract = IERC721Full(tokenAddress);\r\n      tokenContract.safeTransferFrom(msg.sender, lootWallet, tokenId);\r\n    }    \r\n\r\n    function _requireOnlyOwner() internal view {\r\n      require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n    }\r\n\r\n    function _requireOnlyHuman() internal view {\r\n      require(msg.sender == tx.origin, \u0022Caller must be human user\u0022);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022interfaceID\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022supportsInterface\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022destroyContract\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022pathId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022material1TokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022material2TokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022forge\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setEtherLegendsGen1\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setPayee\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setEnjinERC20ContractAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022elementeumContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022catalogContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setEnjinERC1155ContractAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022lootWallet\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setLootWallet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022payee\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022onERC1155BatchReceived\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022etherLegendsGen1\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setElementeumERC20ContractAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCatalogContractAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022enjinContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022onERC1155Received\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022enjinCoinContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"ForgeCombined","CompilerVersion":"v0.5.0\u002Bcommit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aa58ec00dea08e05690ab442bdedbe57ed3dd4a4f526f6897c724ab66c8e475b"}]