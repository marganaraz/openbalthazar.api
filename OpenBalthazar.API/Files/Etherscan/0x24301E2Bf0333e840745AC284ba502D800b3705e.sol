[{"SourceCode":"// File: contracts/extensions/BrokerExtension.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\ninterface Broker {\r\n    function owner() external returns (address);\r\n    function isAdmin(address _user) external returns(bool);\r\n    function markNonce(uint256 _nonce) external;\r\n}\r\n\r\ncontract BrokerExtension {\r\n    Broker public broker;\r\n\r\n    modifier onlyAdmin() {\r\n        require(broker.isAdmin(msg.sender), \u0022Invalid msg.sender\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(broker.owner() == msg.sender, \u0022Invalid msg.sender\u0022);\r\n        _;\r\n    }\r\n\r\n    function initializeBroker(address _brokerAddress) external {\r\n        require(_brokerAddress != address(0), \u0022Invalid _brokerAddress\u0022);\r\n        require(address(broker) == address(0), \u0022Broker already set\u0022);\r\n        broker = Broker(_brokerAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/math/SafeMath.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface MarketDapp {\r\n    // Returns the address to approve tokens for\r\n    function tokenReceiver(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses) external view returns(address);\r\n    function trade(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses, address payable recipient) external payable;\r\n}\r\n\r\n/// @title Util functions for the BrokerV2 contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice Functions were moved from the BrokerV2 contract into this contract\r\n/// so that the BrokerV2 contract would not exceed the maximum contract size of\r\n/// 24 KB.\r\nlibrary Utils {\r\n    using SafeMath for uint256;\r\n\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    //\r\n    // bytes32 public constant CONTRACT_NAME = keccak256(\u0022Switcheo Exchange\u0022);\r\n    // bytes32 public constant CONTRACT_VERSION = keccak256(\u00222\u0022);\r\n    // uint256 public constant CHAIN_ID = 3; // TODO: update this before deployment\r\n    // address public constant VERIFYING_CONTRACT = address(0x7CFbeEa553784500394c878D4f4f79d3B79B9d41); // TODO: pre-calculate and update this before deployment\r\n    // bytes32 public constant SALT = keccak256(\u0022switcheo-eth-salt\u0022);\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \u0022EIP712Domain(\u0022,\r\n    //         \u0022string name,\u0022,\r\n    //         \u0022string version,\u0022,\r\n    //         \u0022uint256 chainId,\u0022,\r\n    //         \u0022address verifyingContract,\u0022,\r\n    //         \u0022bytes32 salt\u0022,\r\n    //     \u0022)\u0022\r\n    // ));\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    // bytes32 public constant DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n    //     EIP712_DOMAIN_TYPEHASH,\r\n    //     CONTRACT_NAME,\r\n    //     CONTRACT_VERSION,\r\n    //     CHAIN_ID,\r\n    //     VERIFYING_CONTRACT,\r\n    //     SALT\r\n    // ));\r\n    bytes32 public constant DOMAIN_SEPARATOR = 0x376a22e062fefdc56ac08f9a26f925278e5cc27dd2ef7880765327cadbb4fa5a;\r\n\r\n    // bytes32 public constant OFFER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \u0022Offer(\u0022,\r\n    //         \u0022address maker,\u0022,\r\n    //         \u0022address offerAssetId,\u0022,\r\n    //         \u0022uint256 offerAmount,\u0022,\r\n    //         \u0022address wantAssetId,\u0022,\r\n    //         \u0022uint256 wantAmount,\u0022,\r\n    //         \u0022address feeAssetId,\u0022,\r\n    //         \u0022uint256 feeAmount,\u0022,\r\n    //         \u0022uint256 nonce\u0022,\r\n    //     \u0022)\u0022\r\n    // ));\r\n    bytes32 public constant OFFER_TYPEHASH = 0xf845c83a8f7964bc8dd1a092d28b83573b35be97630a5b8a3b8ae2ae79cd9260;\r\n\r\n    // bytes32 public constant FILL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \u0022Fill(\u0022,\r\n    //         \u0022address filler,\u0022,\r\n    //         \u0022address offerAssetId,\u0022,\r\n    //         \u0022uint256 offerAmount,\u0022,\r\n    //         \u0022address wantAssetId,\u0022,\r\n    //         \u0022uint256 wantAmount,\u0022,\r\n    //         \u0022address feeAssetId,\u0022,\r\n    //         \u0022uint256 feeAmount,\u0022,\r\n    //         \u0022uint256 nonce\u0022,\r\n    //     \u0022)\u0022\r\n    // ));\r\n    bytes32 public constant FILL_TYPEHASH = 0x5f59dbc3412a4575afed909d028055a91a4250ce92235f6790c155a4b2669e99;\r\n\r\n    // The Ether token address is set as the constant 0x00 for backwards\r\n    // compatibility\r\n    address private constant ETHER_ADDR = address(0);\r\n\r\n    /// @dev Validates \u0060BrokerV2.trade\u0060 parameters to ensure trade fairness,\r\n    /// see \u0060BrokerV2.trade\u0060 for param details.\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _hashes Hashes from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    function validateTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateMatches(_values, _addresses);\r\n        _validateFillAmounts(_values);\r\n        _validateTradeData(_values, _addresses);\r\n\r\n        // validate signatures of all fills\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            FILL_TYPEHASH,\r\n            _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8), // numOffers\r\n            (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) \u002B ((_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8) // numOffers \u002B numFills\r\n        );\r\n\r\n        // validate signatures of all offers\r\n        return _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8) // numOffers\r\n        );\r\n    }\r\n\r\n    /// @dev Validates \u0060BrokerV2.networkTrade\u0060 parameters to ensure trade fairness,\r\n    /// see \u0060BrokerV2.networkTrade\u0060 for param details.\r\n    /// @param _values Values from \u0060networkTrade\u0060\r\n    /// @param _hashes Hashes from \u0060networkTrade\u0060\r\n    /// @param _addresses Addresses from \u0060networkTrade\u0060\r\n    /// @param _operator Address of the \u0060BrokerV2.operator\u0060\r\n    function validateNetworkTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateNetworkTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateNetworkMatches(_values, _addresses, _operator);\r\n        _validateOfferData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        return _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8) // numOffers\r\n        );\r\n    }\r\n\r\n    /// @dev Executes trades against external markets,\r\n    /// see \u0060BrokerV2.networkTrade\u0060 for param details.\r\n    /// @param _values Values from \u0060networkTrade\u0060\r\n    /// @param _addresses Addresses from \u0060networkTrade\u0060\r\n    /// @param _marketDapps See \u0060BrokerV2.marketDapps\u0060\r\n    function performNetworkTrades(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps\r\n    )\r\n        public\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\r\n        // i = 1 \u002B numOffers * 2\r\n        uint256 i = 1 \u002B (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i \u003C end; i\u002B\u002B) {\r\n            uint256[] memory data = new uint256[](9);\r\n            data[0] = _values[i]; // match data\r\n            data[1] = data[0] \u0026 ~(~uint256(0) \u003C\u003C 8); // offerIndex\r\n            data[2] = (data[0] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16; // operator.surplusAssetIndex\r\n            data[3] = _values[data[1] * 2 \u002B 1]; // offer.dataA\r\n            data[4] = _values[data[1] * 2 \u002B 2]; // offer.dataB\r\n            data[5] = ((data[3] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8); // maker.offerAssetIndex\r\n            data[6] = ((data[3] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16); // maker.wantAssetIndex\r\n            // amount of offerAssetId to take from offer is equal to the match.takeAmount\r\n            data[7] = data[0] \u003E\u003E 128;\r\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[8] = data[7].mul(data[4] \u003E\u003E 128).div(data[4] \u0026 ~(~uint256(0) \u003C\u003C 128));\r\n\r\n            address[] memory assetIds = new address[](3);\r\n            assetIds[0] = _addresses[data[5] * 2 \u002B 1]; // offer.offerAssetId\r\n            assetIds[1] = _addresses[data[6] * 2 \u002B 1]; // offer.wantAssetId\r\n            assetIds[2] = _addresses[data[2] * 2 \u002B 1]; // surplusAssetId\r\n\r\n            uint256[] memory dataValues = new uint256[](3);\r\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\r\n            dataValues[1] = data[8]; // the propotionate wantAmount of the offer\r\n            dataValues[2] = data[0]; // match data\r\n\r\n            increments[data[2]] = _performNetworkTrade(\r\n                assetIds,\r\n                dataValues,\r\n                _marketDapps,\r\n                _addresses\r\n            );\r\n        }\r\n\r\n        return increments;\r\n    }\r\n\r\n    /// @notice Approves a token transfer\r\n    /// @param _assetId The address of the token to approve\r\n    /// @param _spender The address of the spender to approve\r\n    /// @param _amount The number of tokens to approve\r\n    function approveTokenTransfer(\r\n        address _assetId,\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have an \u0060approve\u0060 which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \u0022approve(address,uint256)\u0022,\r\n            _spender,\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Transfers tokens into the contract\r\n    /// @param _user The address to transfer the tokens from\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    /// @param _expectedAmount The number of tokens expected to be received,\r\n    /// this may not match \u0060_amount\u0060, for example, tokens which have a\r\n    /// propotion burnt on transfer will have a different amount received.\r\n    function transferTokensIn(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _expectedAmount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        uint256 initialBalance = tokenBalance(_assetId);\r\n\r\n        // Some tokens have a \u0060transferFrom\u0060 which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \u0022transferFrom(address,address,uint256)\u0022,\r\n            _user,\r\n            address(this),\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n\r\n        uint256 finalBalance = tokenBalance(_assetId);\r\n        uint256 transferredAmount = finalBalance.sub(initialBalance);\r\n\r\n        require(transferredAmount == _expectedAmount, \u0022Invalid transfer\u0022);\r\n    }\r\n\r\n    /// @notice Transfers tokens from the contract to a user\r\n    /// @param _receivingAddress The address to transfer the tokens to\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    function transferTokensOut(\r\n        address _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have a \u0060transfer\u0060 which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n                                   \u0022transfer(address,uint256)\u0022,\r\n                                   _receivingAddress,\r\n                                   _amount\r\n                               );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract\r\n    /// @param _assetId The address of the token to query\r\n    function externalBalance(address _assetId) public view returns (uint256) {\r\n        if (_assetId == ETHER_ADDR) {\r\n            return address(this).balance;\r\n        }\r\n        return tokenBalance(_assetId);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract.\r\n    /// @dev This will not work for Ether tokens, use \u0060externalBalance\u0060 for\r\n    /// Ether tokens.\r\n    /// @param _assetId The address of the token to query\r\n    function tokenBalance(address _assetId) public view returns (uint256) {\r\n        return ERC20(_assetId).balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Validates that the specified \u0060_hash\u0060 was signed by the specified \u0060_user\u0060.\r\n    /// This method supports the EIP712 specification, the older Ethereum\r\n    /// signed message specification is also supported for backwards compatibility.\r\n    /// @param _hash The original hash that was signed by the user\r\n    /// @param _user The user who signed the hash\r\n    /// @param _v The \u0060v\u0060 component of the \u0060_user\u0060\u0027s signature\r\n    /// @param _r The \u0060r\u0060 component of the \u0060_user\u0060\u0027s signature\r\n    /// @param _s The \u0060s\u0060 component of the \u0060_user\u0060\u0027s signature\r\n    /// @param _prefixed If true, the signature will be verified\r\n    /// against the Ethereum signed message specification instead of the\r\n    /// EIP712 specification\r\n    function validateSignature(\r\n        bytes32 _hash,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixed\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 eip712Hash = keccak256(abi.encodePacked(\r\n            \u0022\\x19\\x01\u0022,\r\n            DOMAIN_SEPARATOR,\r\n            _hash\r\n        ));\r\n\r\n        if (_prefixed) {\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(\r\n                \u0022\\x19Ethereum Signed Message:\\n32\u0022,\r\n                eip712Hash\r\n            ));\r\n            require(_user == ecrecover(prefixedHash, _v, _r, _s), \u0022Invalid signature\u0022);\r\n        } else {\r\n            require(_user == ecrecover(eip712Hash, _v, _r, _s), \u0022Invalid signature\u0022);\r\n        }\r\n    }\r\n\r\n    /// @dev Ensures that \u0060_address\u0060 is not the zero address\r\n    /// @param _address The address to check\r\n    function validateAddress(address _address) public pure {\r\n        require(_address != address(0), \u0022Invalid address\u0022);\r\n    }\r\n\r\n    /// @notice Executes a trade against an external market.\r\n    /// @dev The initial Ether or token balance is compared with the\r\n    /// balance after the trade to ensure that the appropriate amounts of\r\n    /// tokens were taken and an appropriate amount received.\r\n    /// The trade will fail if the number of tokens received is less than\r\n    /// expected. If the number of tokens received is more than expected than\r\n    /// the excess tokens are transferred to the \u0060BrokerV2.operator\u0060.\r\n    /// @param _assetIds[0] The offerAssetId of the offer\r\n    /// @param _assetIds[2] The wantAssetId of the offer\r\n    /// @param _assetIds[3] The surplusAssetId\r\n    /// @param _dataValues[0] The number of tokens offerred\r\n    /// @param _dataValues[1] The number of tokens expected to be received\r\n    /// @param _dataValues[2] Match data\r\n    /// @param _marketDapps See \u0060BrokerV2.marketDapps\u0060\r\n    /// @param _addresses Addresses from \u0060networkTrade\u0060\r\n    function _performNetworkTrade(\r\n        address[] memory _assetIds,\r\n        uint256[] memory _dataValues,\r\n        address[] memory _marketDapps,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 dappIndex = (_dataValues[2] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n        MarketDapp marketDapp = MarketDapp(_marketDapps[dappIndex]);\r\n\r\n        uint256[] memory funds = new uint256[](6);\r\n        funds[0] = externalBalance(_assetIds[0]); // initialOfferTokenBalance\r\n        funds[1] = externalBalance(_assetIds[1]); // initialWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] \u0026\u0026 _assetIds[2] != _assetIds[1]) {\r\n            funds[2] = externalBalance(_assetIds[2]); // initialSurplusTokenBalance\r\n        }\r\n\r\n        uint256 ethValue = 0;\r\n        address tokenReceiver;\r\n\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            tokenReceiver = marketDapp.tokenReceiver(_assetIds, _dataValues, _addresses);\r\n            approveTokenTransfer(\r\n                _assetIds[0], // offerAssetId\r\n                tokenReceiver,\r\n                _dataValues[0] // offerAmount\r\n            );\r\n        } else {\r\n            ethValue = _dataValues[0]; // offerAmount\r\n        }\r\n\r\n        marketDapp.trade.value(ethValue)(\r\n            _assetIds,\r\n            _dataValues,\r\n            _addresses,\r\n            // use uint160 to cast \u0060address\u0060 to \u0060address payable\u0060\r\n            address(uint160(address(this))) // destAddress\r\n        );\r\n\r\n        funds[3] = externalBalance(_assetIds[0]); // finalOfferTokenBalance\r\n        funds[4] = externalBalance(_assetIds[1]); // finalWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] \u0026\u0026 _assetIds[2] != _assetIds[1]) {\r\n            funds[5] = externalBalance(_assetIds[2]); // finalSurplusTokenBalance\r\n        }\r\n\r\n        uint256 surplusAmount = 0;\r\n\r\n        // validate that the appropriate offerAmount was deducted\r\n        // surplusAssetId == offerAssetId\r\n        if (_assetIds[2] == _assetIds[0]) {\r\n            // surplusAmount = finalOfferTokenBalance - (initialOfferTokenBalance - offerAmount)\r\n            surplusAmount = funds[3].sub(funds[0].sub(_dataValues[0]));\r\n        } else {\r\n            // finalOfferTokenBalance == initialOfferTokenBalance - offerAmount\r\n            require(funds[3] == funds[0].sub(_dataValues[0]), \u0022Invalid offer asset balance\u0022);\r\n        }\r\n\r\n        // validate that the appropriate wantAmount was credited\r\n        // surplusAssetId == wantAssetId\r\n        if (_assetIds[2] == _assetIds[1]) {\r\n            // surplusAmount = finalWantTokenBalance - (initialWantTokenBalance \u002B wantAmount)\r\n            surplusAmount = funds[4].sub(funds[1].add(_dataValues[1]));\r\n        } else {\r\n            // finalWantTokenBalance == initialWantTokenBalance \u002B wantAmount\r\n            require(funds[4] == funds[1].add(_dataValues[1]), \u0022Invalid want asset balance\u0022);\r\n        }\r\n\r\n        // surplusAssetId != offerAssetId \u0026\u0026 surplusAssetId != wantAssetId\r\n        if (_assetIds[2] != _assetIds[0] \u0026\u0026 _assetIds[2] != _assetIds[1]) {\r\n            // surplusAmount = finalSurplusTokenBalance - initialSurplusTokenBalance\r\n            surplusAmount = funds[5].sub(funds[2]);\r\n        }\r\n\r\n        // set the approved token amount back to zero\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            approveTokenTransfer(\r\n                _assetIds[0],\r\n                tokenReceiver,\r\n                0\r\n            );\r\n        }\r\n\r\n        return surplusAmount;\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the \u0060trade\u0060 method.\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _hashes Hashes from \u0060trade\u0060\r\n    function _validateTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n        uint256 numFills = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n        uint256 numMatches = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] \u003E\u003E 24 == 0, \u0022Invalid trade input\u0022);\r\n\r\n        // It is enforced by other checks that if a fill is present\r\n        // then it must be completely filled so there must be at least one offer\r\n        // and at least one match in this case.\r\n        // It is possible to have one offer with no matches and no fills\r\n        // but that is blocked by this check as there is no foreseeable use\r\n        // case for it.\r\n        require(\r\n            numOffers \u003E 0 \u0026\u0026 numFills \u003E 0 \u0026\u0026 numMatches \u003E 0,\r\n            \u0022Invalid trade input\u0022\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 \u002B numOffers * 2 \u002B numFills * 2 \u002B numMatches,\r\n            \u0022Invalid _values.length\u0022\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers \u002B numFills) * 2,\r\n            \u0022Invalid _hashes.length\u0022\r\n        );\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the \u0060networkTrade\u0060 method.\r\n    /// @param _values Values from \u0060networkTrade\u0060\r\n    /// @param _hashes Hashes from \u0060networkTrade\u0060\r\n    function _validateNetworkTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n        uint256 numFills = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n        uint256 numMatches = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] \u003E\u003E 24 == 0, \u0022Invalid networkTrade input\u0022);\r\n\r\n        // Validate that numFills is zero because the offers\r\n        // should be filled against external orders\r\n        require(\r\n            numOffers \u003E 0 \u0026\u0026 numMatches \u003E 0 \u0026\u0026 numFills == 0,\r\n            \u0022Invalid networkTrade input\u0022\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 \u002B numOffers * 2 \u002B numFills * 2 \u002B numMatches,\r\n            \u0022Invalid _values.length\u0022\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers \u002B numFills) * 2,\r\n            \u0022Invalid _hashes.length\u0022\r\n        );\r\n    }\r\n\r\n    /// @dev See the \u0060BrokerV2.trade\u0060 method for an explanation of why offer\r\n    /// uniquness is required.\r\n    /// The set of offers in \u0060_values\u0060 must be sorted such that offer nonces\u0027\r\n    /// are arranged in a strictly ascending order.\r\n    /// This allows the validation of offer uniqueness to be done in O(N) time,\r\n    /// with N being the number of offers.\r\n    /// @param _values Values from \u0060trade\u0060\r\n    function _validateUniqueOffers(uint256[] memory _values) private pure {\r\n        uint256 numOffers = _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n\r\n        uint256 prevNonce;\r\n        uint256 mask = ~(~uint256(0) \u003C\u003C 128);\r\n\r\n        for(uint256 i = 0; i \u003C numOffers; i\u002B\u002B) {\r\n            uint256 nonce = (_values[i * 2 \u002B 1] \u0026 mask) \u003E\u003E 56;\r\n\r\n            if (i == 0) {\r\n                // Set the value of the first nonce\r\n                prevNonce = nonce;\r\n                continue;\r\n            }\r\n\r\n            require(nonce \u003E prevNonce, \u0022Invalid offer nonces\u0022);\r\n            prevNonce = nonce;\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. fillIndexes falls within the range of fills\r\n    /// 3. offer.offerAssetId == fill.wantAssetId\r\n    /// 4. offer.wantAssetId == fill.offerAssetId\r\n    /// 5. takeAmount \u003E 0\r\n    /// 6. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    function _validateMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n        uint256 numFills = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n\r\n        uint256 i = 1 \u002B numOffers * 2 \u002B numFills * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i \u003C end; i\u002B\u002B) {\r\n            uint256 offerIndex = _values[i] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n            uint256 fillIndex = (_values[i] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n\r\n            require(offerIndex \u003C numOffers, \u0022Invalid match.offerIndex\u0022);\r\n\r\n            require(fillIndex \u003E= numOffers \u0026\u0026 fillIndex \u003C numOffers \u002B numFills, \u0022Invalid match.fillIndex\u0022);\r\n\r\n            uint256 makerOfferAssetIndex = (_values[1 \u002B offerIndex * 2] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n            uint256 makerWantAssetIndex = (_values[1 \u002B offerIndex * 2] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16;\r\n            uint256 fillerOfferAssetIndex = (_values[1 \u002B fillIndex * 2] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n            uint256 fillerWantAssetIndex = (_values[1 \u002B fillIndex * 2] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16;\r\n\r\n            require(\r\n                _addresses[makerOfferAssetIndex * 2 \u002B 1] == _addresses[fillerWantAssetIndex * 2 \u002B 1],\r\n                \u0022offer.offerAssetId does not match fill.wantAssetId\u0022\r\n            );\r\n\r\n            require(\r\n                _addresses[makerWantAssetIndex * 2 \u002B 1] == _addresses[fillerOfferAssetIndex * 2 \u002B 1],\r\n                \u0022offer.wantAssetId does not match fill.offerAssetId\u0022\r\n            );\r\n\r\n            // require that bits(16..128) are all zero for every match\r\n            require((_values[i] \u0026 ~(~uint256(0) \u003C\u003C 128)) \u003E\u003E 16 == uint256(0), \u0022Invalid match data\u0022);\r\n\r\n            uint256 takeAmount = _values[i] \u003E\u003E 128;\r\n            require(takeAmount \u003E 0, \u0022Invalid match.takeAmount\u0022);\r\n\r\n            uint256 offerDataB = _values[2 \u002B offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB \u003E\u003E 128).mul(takeAmount).mod(offerDataB \u0026 ~(~uint256(0) \u003C\u003C 128)) == 0,\r\n                \u0022Invalid amounts\u0022\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. _addresses[surplusAssetIndexes * 2] matches the operator address\r\n    /// 3. takeAmount \u003E 0\r\n    /// 4. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    /// @param _operator Address of the \u0060BrokerV2.operator\u0060\r\n    function _validateNetworkMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n\r\n        // 1 \u002B numOffers * 2\r\n        uint256 i = 1 \u002B (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i \u003C end; i\u002B\u002B) {\r\n            uint256 offerIndex = _values[i] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n            uint256 surplusAssetIndex = (_values[i] \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16;\r\n\r\n            require(offerIndex \u003C numOffers, \u0022Invalid match.offerIndex\u0022);\r\n            require(_addresses[surplusAssetIndex * 2] == _operator, \u0022Invalid operator address\u0022);\r\n\r\n            uint256 takeAmount = _values[i] \u003E\u003E 128;\r\n            require(takeAmount \u003E 0, \u0022Invalid match.takeAmount\u0022);\r\n\r\n            uint256 offerDataB = _values[2 \u002B offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB \u003E\u003E 128).mul(takeAmount).mod(offerDataB \u0026 ~(~uint256(0) \u003C\u003C 128)) == 0,\r\n                \u0022Invalid amounts\u0022\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that all fills will be completely filled by the specified\r\n    /// matches. See the \u0060BrokerV2.trade\u0060 method for an explanation of why\r\n    /// fills must be completely filled.\r\n    /// @param _values Values from \u0060trade\u0060\r\n    function _validateFillAmounts(uint256[] memory _values) private pure {\r\n        // \u0022filled\u0022 is used to store the sum of \u0060takeAmount\u0060s and \u0060giveAmount\u0060s.\r\n        // While a fill\u0027s \u0060offerAmount\u0060 and \u0060wantAmount\u0060 are combined to share\r\n        // a single uint256 value, each sum of \u0060takeAmount\u0060s and \u0060giveAmount\u0060s\r\n        // for a fill is tracked with an individual uint256 value.\r\n        // This is to prevent the verification from being vulnerable to overflow\r\n        // issues.\r\n        uint256[] memory filled = new uint256[](_values.length);\r\n\r\n        uint256 i = 1;\r\n        // i \u002B= numOffers * 2\r\n        i \u002B= (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) * 2;\r\n        // i \u002B= numFills * 2\r\n        i \u002B= ((_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i \u003C end; i\u002B\u002B) {\r\n            uint256 offerIndex = _values[i] \u0026 ~(~uint256(0) \u003C\u003C 8);\r\n            uint256 fillIndex = (_values[i] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8;\r\n            uint256 takeAmount = _values[i] \u003E\u003E 128;\r\n            uint256 wantAmount = _values[2 \u002B offerIndex * 2] \u003E\u003E 128;\r\n            uint256 offerAmount = _values[2 \u002B offerIndex * 2] \u0026 ~(~uint256(0) \u003C\u003C 128);\r\n            // giveAmount = takeAmount * wantAmount / offerAmount\r\n            uint256 giveAmount = takeAmount.mul(wantAmount).div(offerAmount);\r\n\r\n            // (1 \u002B fillIndex * 2) would give the index of the first part\r\n            // of the data for the fill at fillIndex within \u0060_values\u0060,\r\n            // and (2 \u002B fillIndex * 2) would give the index of the second part\r\n            filled[1 \u002B fillIndex * 2] = filled[1 \u002B fillIndex * 2].add(giveAmount);\r\n            filled[2 \u002B fillIndex * 2] = filled[2 \u002B fillIndex * 2].add(takeAmount);\r\n        }\r\n\r\n        // numOffers\r\n        i = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8));\r\n        // i \u002B numFills\r\n        end = i \u002B ((_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8);\r\n\r\n        // loop fills\r\n        for(i; i \u003C end; i\u002B\u002B) {\r\n            require(\r\n                // fill.offerAmount == (sum of given amounts for fill)\r\n                _values[i * 2 \u002B 2] \u0026 ~(~uint256(0) \u003C\u003C 128) == filled[i * 2 \u002B 1] \u0026\u0026\r\n                // fill.wantAmount == (sum of taken amounts for fill)\r\n                _values[i * 2 \u002B 2] \u003E\u003E 128 == filled[i * 2 \u002B 2],\r\n                \u0022Invalid fills\u0022\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer / fill:\r\n    /// 1. offerAssetId != wantAssetId\r\n    /// 2. offerAmount \u003E 0 \u0026\u0026 wantAmount \u003E 0\r\n    /// 3. The referenced \u0060operator\u0060 address is the zero address\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    function _validateTradeData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers \u002B numFills\r\n        uint256 end = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) \u002B\r\n                      ((_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8);\r\n\r\n        for (uint256 i = 0; i \u003C end; i\u002B\u002B) {\r\n            uint256 dataA = _values[i * 2 \u002B 1];\r\n            uint256 dataB = _values[i * 2 \u002B 2];\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8) * 2 \u002B 1] !=\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16) * 2 \u002B 1],\r\n                \u0022Invalid trade assets\u0022\r\n            );\r\n\r\n            require(\r\n                // offerAmount \u003E 0 \u0026\u0026 wantAmount \u003E 0\r\n                (dataB \u0026 ~(~uint256(0) \u003C\u003C 128)) \u003E 0 \u0026\u0026 (dataB \u003E\u003E 128) \u003E 0,\r\n                \u0022Invalid trade amounts\u0022\r\n            );\r\n\r\n             require(\r\n                // _addresses[operator address index] == address(0)\r\n                // The actual operator address will be read directly from\r\n                // the contract\u0027s storage\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 40)) \u003E\u003E 32) * 2] == address(0),\r\n                \u0022Invalid operator address placeholder\u0022\r\n            );\r\n\r\n             require(\r\n                // _addresses[operator fee asset ID index] == address(1)\r\n                // address(1) is used to differentiate from the ETHER_ADDR which is address(0)\r\n                // The actual fee asset ID will be read from the filler / maker feeAssetId\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 40)) \u003E\u003E 32) * 2 \u002B 1] == address(1),\r\n                \u0022Invalid operator fee asset ID placeholder\u0022\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer\r\n    /// 1. offerAssetId != wantAssetId\r\n    /// 2. offerAmount \u003E 0 \u0026\u0026 wantAmount \u003E 0\r\n    /// 3. Specified \u0060operator\u0060 address matches the expected \u0060operator\u0060 address,\r\n    /// 4. Specified \u0060operator.feeAssetId\u0060 matches the offer\u0027s feeAssetId\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    function _validateOfferData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers\r\n        uint256 i = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8));\r\n        // numOffers \u002B numFills\r\n        uint256 end = (_values[0] \u0026 ~(~uint256(0) \u003C\u003C 8)) \u002B\r\n                      ((_values[0] \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8);\r\n\r\n        for (i; i \u003C end; i\u002B\u002B) {\r\n            uint256 dataA = _values[i * 2 \u002B 1];\r\n            uint256 dataB = _values[i * 2 \u002B 2];\r\n            uint256 feeAssetIndex = ((dataA \u0026 ~(~uint256(0) \u003C\u003C 40)) \u003E\u003E 32) * 2;\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8) * 2 \u002B 1] !=\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16) * 2 \u002B 1],\r\n                \u0022Invalid trade assets\u0022\r\n            );\r\n\r\n            require(\r\n                // offerAmount \u003E 0 \u0026\u0026 wantAmount \u003E 0\r\n                (dataB \u0026 ~(~uint256(0) \u003C\u003C 128)) \u003E 0 \u0026\u0026 (dataB \u003E\u003E 128) \u003E 0,\r\n                \u0022Invalid trade amounts\u0022\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex] == _operator,\r\n                \u0022Invalid operator address\u0022\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex \u002B 1] == _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 32)) \u003E\u003E 24) * 2 \u002B 1],\r\n                \u0022Invalid operator fee asset ID\u0022\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates signatures for a set of offers or fills\r\n    /// @param _values Values from \u0060trade\u0060\r\n    /// @param _hashes Hashes from \u0060trade\u0060\r\n    /// @param _addresses Addresses from \u0060trade\u0060\r\n    /// @param _typehash The typehash used to construct the signed hash\r\n    /// @param _i The starting index to verify\r\n    /// @param _end The ending index to verify\r\n    /// @return An array of hash keys if _i started as 0, because only\r\n    /// the hash keys of offers are needed\r\n    function _validateTradeSignatures(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        bytes32 _typehash,\r\n        uint256 _i,\r\n        uint256 _end\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory hashKeys;\r\n        if (_i == 0) {\r\n            hashKeys = new bytes32[](_end - _i);\r\n        }\r\n\r\n        for (_i; _i \u003C _end; _i\u002B\u002B) {\r\n            uint256 dataA = _values[_i * 2 \u002B 1];\r\n            uint256 dataB = _values[_i * 2 \u002B 2];\r\n\r\n            bytes32 hashKey = keccak256(abi.encode(\r\n                _typehash,\r\n                _addresses[(dataA \u0026 ~(~uint256(0) \u003C\u003C 8)) * 2], // user\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 16)) \u003E\u003E 8) * 2 \u002B 1], // offerAssetId\r\n                dataB \u0026 ~(~uint256(0) \u003C\u003C 128), // offerAmount\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 24)) \u003E\u003E 16) * 2 \u002B 1], // wantAssetId\r\n                dataB \u003E\u003E 128, // wantAmount\r\n                _addresses[((dataA \u0026 ~(~uint256(0) \u003C\u003C 32)) \u003E\u003E 24) * 2 \u002B 1], // feeAssetId\r\n                dataA \u003E\u003E 128, // feeAmount\r\n                (dataA \u0026 ~(~uint256(0) \u003C\u003C 128)) \u003E\u003E 56 // nonce\r\n            ));\r\n\r\n            // To reduce gas costs, each bit of _values[0] after the 24th bit\r\n            // is used to indicate whether the Ethereum signed message prefix\r\n            // should be prepended for signature verification of the offer / fill\r\n            // at that index\r\n            bool prefixedSignature = ((dataA \u0026 ~(~uint256(0) \u003C\u003C 56)) \u003E\u003E 48) != 0;\r\n\r\n            validateSignature(\r\n                hashKey,\r\n                _addresses[(dataA \u0026 ~(~uint256(0) \u003C\u003C 8)) * 2], // user\r\n                uint8((dataA \u0026 ~(~uint256(0) \u003C\u003C 48)) \u003E\u003E 40), // The \u0060v\u0060 component of the user\u0027s signature\r\n                _hashes[_i * 2], // The \u0060r\u0060 component of the user\u0027s signature\r\n                _hashes[_i * 2 \u002B 1], // The \u0060s\u0060 component of the user\u0027s signature\r\n                prefixedSignature\r\n            );\r\n\r\n            if (hashKeys.length \u003E 0) { hashKeys[_i] = hashKey; }\r\n        }\r\n\r\n        return hashKeys;\r\n    }\r\n\r\n    /// @dev Ensure that the address is a deployed contract\r\n    /// @param _contract The address to check\r\n    function _validateContractAddress(address _contract) private view {\r\n        assembly {\r\n            if iszero(extcodesize(_contract)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @dev A thin wrapper around the native \u0060call\u0060 function, to\r\n    /// validate that the contract \u0060call\u0060 must be successful.\r\n    /// See https://solidity.readthedocs.io/en/v0.5.1/050-breaking-changes.html\r\n    /// for details on constructing the \u0060_payload\u0060\r\n    /// @param _contract Address of the contract to call\r\n    /// @param _payload The data to call the contract with\r\n    /// @return The data returned from the contract call\r\n    function _callContract(\r\n        address _contract,\r\n        bytes memory _payload\r\n    )\r\n        private\r\n        returns (bytes memory)\r\n    {\r\n        bool success;\r\n        bytes memory returnData;\r\n\r\n        (success, returnData) = _contract.call(_payload);\r\n        require(success, \u0022Contract call failed\u0022);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\r\n    /// See: https://github.com/ethereum/solidity/issues/4116\r\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\r\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\r\n    /// @param _data The data returned from a transfer call\r\n    function _validateContractCallResult(bytes memory _data) private pure {\r\n        require(\r\n            _data.length == 0 ||\r\n            (_data.length == 32 \u0026\u0026 _getUint256FromBytes(_data) != 0),\r\n            \u0022Invalid contract call result\u0022\r\n        );\r\n    }\r\n\r\n    /// @dev Converts data of type \u0060bytes\u0060 into its corresponding \u0060uint256\u0060 value\r\n    /// @param _data The data in bytes\r\n    /// @return The corresponding \u0060uint256\u0060 value\r\n    function _getUint256FromBytes(\r\n        bytes memory _data\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 parsed;\r\n        assembly { parsed := mload(add(_data, 32)) }\r\n        return parsed;\r\n    }\r\n}\r\n\r\n// File: contracts/extensions/TokenList.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n/// @title The TokenList extension for the BrokerV2 contract\r\n/// @author Switcheo Network\r\n/// @notice This contract maintains a list of whitelisted tokens.\r\n/// @dev Whitelisted tokens are permitted to call the \u0060tokenFallback\u0060 and\r\n/// \u0060tokensReceived\u0060 methods in the BrokerV2 contract.\r\ncontract TokenList is BrokerExtension {\r\n    // A record of whitelisted tokens: tokenAddress =\u003E isWhitelisted.\r\n    // This controls token permission to invoke \u0060tokenFallback\u0060 and \u0060tokensReceived\u0060 callbacks\r\n    // on this contract.\r\n    mapping(address =\u003E bool) public tokenWhitelist;\r\n\r\n    /// @notice Whitelists a token contract\r\n    /// @dev This enables the token contract to call \u0060tokensReceived\u0060 or \u0060tokenFallback\u0060\r\n    /// on this contract.\r\n    /// This layer of management is to prevent misuse of \u0060tokensReceived\u0060 and \u0060tokenFallback\u0060\r\n    /// methods by unvetted tokens.\r\n    /// @param _assetId The token address to whitelist\r\n    function whitelistToken(address _assetId) external onlyOwner {\r\n        Utils.validateAddress(_assetId);\r\n        require(!tokenWhitelist[_assetId], \u0022Token already whitelisted\u0022);\r\n        tokenWhitelist[_assetId] = true;\r\n    }\r\n\r\n    /// @notice Removes a token contract from the token whitelist\r\n    /// @param _assetId The token address to remove from the token whitelist\r\n    function unwhitelistToken(address _assetId) external onlyOwner {\r\n        Utils.validateAddress(_assetId);\r\n        require(tokenWhitelist[_assetId], \u0022Token not whitelisted\u0022);\r\n        delete tokenWhitelist[_assetId];\r\n    }\r\n\r\n    /// @notice Validates if a token has been whitelisted\r\n    /// @param _assetId The token address to validate\r\n    function validateToken(address _assetId) external view {\r\n        require(tokenWhitelist[_assetId], \u0022Invalid token\u0022);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetId\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022whitelistToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_brokerAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022initializeBroker\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022tokenWhitelist\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetId\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022validateToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022broker\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_assetId\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022unwhitelistToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"TokenList","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"Utils:93d4c213c6d6d9978fb1cb5052f8bae693fdb9a4","SwarmSource":"bzzr://61a9cb552323faa8319b12a4c1e7be5ee5b16368834c6a638d4333b25027dd17"}]