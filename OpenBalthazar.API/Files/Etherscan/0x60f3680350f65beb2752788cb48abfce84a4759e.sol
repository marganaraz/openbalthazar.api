[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n    /**\r\n     *\r\n     *     ****      *****   **         *****   *******     ****    **     **    ** *******   **     **   ****   \r\n     *   **    **  **     ** **       **     ** **     ** **    **  **      **  **  **     ** **     ** **    ** \r\n     *   **        **     ** **       **     ** **     ** **        **       ****   **     ** **     ** **       \r\n     *   **        **     ** **       **     ** *******   **   **** **        **    *******   *********   ****   \r\n     *   **        **     ** **       **     ** **   **   **    **  **        **    **        **     **       ** \r\n     *   **    **  **     ** **       **     ** **    **  **    **  **        **    **        **     ** **    ** \r\n     *     ****      *****   ********   *****   **     **   ****    ********  **    **        **     **   ****   \r\n     *\r\n     *\r\n     *                                                                by Daniel Viau\r\n     *\r\n     * Colorglyphs extends Autoglyphs.\r\n     * Quoting from Autoglyphs:\r\n     *  The output of the \u0027tokenURI\u0027 function is a set of instructions to make a drawing.\r\n     *  Each symbol in the output corresponds to a cell, and there are 64x64 cells arranged in a square grid.\r\n     *  The drawing can be any size, and the pen\u0027s stroke width should be between 1/5th to 1/10th the size of a cell.\r\n     *  The drawing instructions for the nine different symbols are as follows:\r\n     *\r\n     *    .  Draw nothing in the cell.\r\n     *    O  Draw a circle bounded by the cell.\r\n     *    \u002B  Draw centered lines vertically and horizontally the length of the cell.\r\n     *    X  Draw diagonal lines connecting opposite corners of the cell.\r\n     *    |  Draw a centered vertical line the length of the cell.\r\n     *    -  Draw a centered horizontal line the length of the cell.\r\n     *    \\  Draw a line connecting the top left corner of the cell to the bottom right corner.\r\n     *    /  Draw a line connecting the bottom left corner of teh cell to the top right corner.\r\n     *    #  Fill in the cell completely.\r\n     *\r\n     * The \u0027tokenURI\u0027 function of colorglyphs adds two pieces of information to the response provided by autoglyphs:\r\n     *  1) The color scheme to apply to the Colorglyph.\r\n     *  2) The address of the Colorglyph\u0027s creator, from which colors are derived.\r\n     *\r\n     * The address of the Colorglyph\u0027s creator is split up into 35 6 digit chunks.\r\n     * For example, the first three chunks of 0xb189f76323678E094D4996d182A792E52369c005 are: b189f7, 189f76, and 89f763.\r\n     * The last chunk is 69c005.\r\n     * Each Colorglyph is an Autoglyph with a color scheme applied to it.\r\n     * Each Colorglyph takes the same shape as the Autoglyph of the corresponding ID.\r\n     * If the Colorglyph\u0027s ID is higher than 512, it takes the shape of the Autoglyph with its Colorglyphs ID - 512.\r\n     * Each black element in the Autoglyph is assigned a new color.\r\n     * The background color of the Autoglyph is changed to either black or one of the address colors.\r\n     * Visual implementations of Colorglyphs may exercise a substantial degree of flexibility.\r\n     * Color schemes that use multiple colors may apply any permitted color to any element,\r\n     * but no color should appear more than 16 times as often as the color with the lowest number of incidences.\r\n     * In the event that a color meets two conditions (reddest and orangest, for example),\r\n     * it may be used for both purposes.  The previous guideline establishing a threshold ratio of occurances\r\n     * treats the reddest color and the orangest color as two different colors, even if they have the same actual value.\r\n\r\n     * lightest address color = chunk with the lowest value resulting from red value \u002B green value \u002B blue value\r\n     * second lightest address color = second lightest chunk in relevant address\r\n     * third lightest address color = third lightest chunk in relevant address\r\n     * fourth lightest address color = fourth lightest chunk in relevant address\r\n     * fifth lightest address color = fifth lightest chunk in relevant address\r\n     * reddest address color = chunk with the lowest value resulting from red value - green value - blue value\r\n     * orangest address color = chunk with the highest value resulting from red value - blue value\r\n     * yellowest address color = chunk with higest value resulting from red value \u002B green value - blue value\r\n     * greenest address color = chunk with higest value resulting from green value - red value - blue value\r\n     * bluest address color = chunk with higest value resulting from blue value - green value - red value\r\n     * darkest address color = darkest chunk in relevant address\r\n     * white = ffffff\r\n     * black = 020408\r\n\r\n     * scheme 1 = lightest address color, third lightest address color, and fifth lightest address color on black\r\n     * scheme 2 = lighest 4 address colors on black                            \r\n     * scheme 3 = reddest address color, orangest address color, and yellowest address color on black                                             \r\n     * scheme 4 = reddest address color, yellowest address color, greenest address color, and white on black                                      \r\n     * scheme 5 = lightest address color, reddest address color, yellowest address color, greenest address color, and bluest address color on black                                      \r\n     * scheme 6 = reddest address color and white on black                     \r\n     * scheme 7 = greenest address color on black                              \r\n     * scheme 8 = lightest address color on darkest address color              \r\n     * scheme 9 = greenest address color on reddest address color                                        \r\n     * scheme 10 = reddest address color, yellowest address color, bluest address color, lightest address color, and black on white\r\n     */\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n      bytes memory _ba = bytes(_a);\r\n      bytes memory _bb = bytes(_b);\r\n      bytes memory _bc = bytes(_c);\r\n      bytes memory _bd = bytes(_d);\r\n      bytes memory _be = bytes(_e);\r\n      string memory abcde = new string(_ba.length \u002B _bb.length \u002B _bc.length \u002B _bd.length \u002B _be.length);\r\n      bytes memory babcde = bytes(abcde);\r\n      uint k = 0;\r\n      for (uint i = 0; i \u003C _ba.length; i\u002B\u002B) babcde[k\u002B\u002B] = _ba[i];\r\n      for (i = 0; i \u003C _bb.length; i\u002B\u002B) babcde[k\u002B\u002B] = _bb[i];\r\n      for (i = 0; i \u003C _bc.length; i\u002B\u002B) babcde[k\u002B\u002B] = _bc[i];\r\n      for (i = 0; i \u003C _bd.length; i\u002B\u002B) babcde[k\u002B\u002B] = _bd[i];\r\n      for (i = 0; i \u003C _be.length; i\u002B\u002B) babcde[k\u002B\u002B] = _be[i];\r\n      return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \u0022\u0022);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \u0022\u0022, \u0022\u0022);\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \u0022\u0022, \u0022\u0022, \u0022\u0022);\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \u00220\u0022;\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len\u002B\u002B;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 \u002B i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n\r\n}\r\n\r\ncontract Autoglyphs { \r\n  function draw(uint id) public view returns (string);\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n}\r\n\r\ncontract Colorglyphs {\r\n\r\n    event Generated(uint indexed index, address indexed a, string value);\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (\u0060from\u0060 == 0) and destroyed\r\n    ///  (\u0060to\u0060 == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    uint public constant CLAIMABLE_TOKEN_LIMIT = 512;\r\n    uint public constant CREATEABLE_TOKEN_LIMIT = 512;\r\n    uint public constant TOTAL_TOKEN_LIMIT = 1024;\r\n    uint public constant ARTIST_PRINTS = 32;\r\n\r\n    uint public constant PRICE = 50 finney;\r\n\r\n    // The beneficiary is eff.org\r\n    address public constant BENEFICIARY = 0xb189f76323678E094D4996d182A792E52369c005;\r\n\r\n    address public autoglyphsAddress = 0xd4e4078ca3495de5b1d4db434bebc5a986197782;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to a boolean representing whether an owner of the corresponding Autoglyph has claimed it.\r\n     */\r\n    mapping (uint256 =\u003E bool) private idToGlyphIsClaimed;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the address that created it.\r\n     */\r\n    mapping (uint =\u003E address) private idToCreator;\r\n    /**\r\n     * @dev A mapping from NFT ID to the color scheme that applies it.\r\n     */\r\n    mapping (uint =\u003E string) private idToColorScheme;\r\n\r\n    // ERC 165\r\n    mapping(bytes4 =\u003E bool) internal supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the address that owns it.\r\n     */\r\n    mapping (uint256 =\u003E address) internal idToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the seed used to make it.\r\n     */\r\n    mapping (uint256 =\u003E uint256) internal idToSeed;\r\n    mapping (uint256 =\u003E uint256) internal seedToId;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to approved address.\r\n     */\r\n    mapping (uint256 =\u003E address) internal idToApproval;\r\n\r\n    /**\r\n     * @dev Mapping from owner address to mapping of operator addresses.\r\n     */\r\n    mapping (address =\u003E mapping (address =\u003E bool)) internal ownerToOperators;\r\n\r\n    /**\r\n     * @dev Mapping from owner to list of owned NFT IDs.\r\n     */\r\n    mapping(address =\u003E uint256[]) internal ownerToIds;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n     */\r\n    mapping(uint256 =\u003E uint256) internal idToOwnerIndex;\r\n\r\n    /**\r\n     * @dev Total number of createablw tokens. Range 1-512.\r\n     */\r\n    uint internal numCreatedTokens = 0;\r\n\r\n    /**\r\n     * @dev Total number of claimable tokens. Range 513-1024.\r\n     */\r\n    uint internal numClaimedTokens = 0;\r\n\r\n    /**\r\n     * @dev Total number of tokens.\r\n     */\r\n    uint internal numTotalTokens = 0;\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n     * @param _tokenId ID of the NFT to transfer.\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || idToApproval[_tokenId] == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender]\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that _tokenId is a valid Token.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     */\r\n    constructor() public {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n    }\r\n\r\n    string internal nftName = \u0022Colorglyphs\u0022;\r\n    string internal nftSymbol = \u0022\u2632\u0022;\r\n\r\n    ///////////////////\r\n    //// GENERATOR ////\r\n    ///////////////////\r\n\r\n    function draw(uint256 _tokenId) public view returns (string memory) {\r\n        Autoglyphs autoglyphs = Autoglyphs(autoglyphsAddress);\r\n        uint autoglyphsTokenId;\r\n        if (_tokenId \u003E 512) {\r\n            autoglyphsTokenId = _tokenId - 512;\r\n        } else {\r\n            autoglyphsTokenId = _tokenId;\r\n        }\r\n        string memory drawing = autoglyphs.draw(autoglyphsTokenId);\r\n        string memory scheme = idToColorScheme[_tokenId];\r\n        string memory creator_address = toAsciiString(idToCreator[_tokenId]);\r\n        return Strings.strConcat(\r\n            drawing,\r\n            scheme,\r\n            creator_address\r\n        );\r\n    }\r\n\r\n    function getScheme(uint a) internal pure returns (string) {\r\n        uint index = a % 83;\r\n        string memory scheme;\r\n        if (index \u003C 20) {\r\n            scheme = \u0027 1 \u0027;\r\n        } else if (index \u003C 35) {\r\n            scheme = \u0027 2 \u0027;\r\n        } else if (index \u003C 48) {\r\n            scheme = \u0027 3 \u0027;\r\n        } else if (index \u003C 59) {\r\n            scheme = \u0027 4 \u0027;\r\n        } else if (index \u003C 68) {\r\n            scheme = \u0027 5 \u0027;\r\n        } else if (index \u003C 73) {\r\n            scheme = \u0027 6 \u0027;\r\n        } else if (index \u003C 77) {\r\n            scheme = \u0027 7 \u0027;\r\n        } else if (index \u003C 80) {\r\n            scheme = \u0027 8 \u0027;\r\n        } else if (index \u003C 82) {\r\n            scheme = \u0027 9 \u0027;\r\n        } else {\r\n            scheme = \u0027 10 \u0027;\r\n        }\r\n        return scheme;\r\n    }\r\n\r\n    function toAsciiString(address x) returns (string) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i \u003C 20; i\u002B\u002B) {\r\n        byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n        byte hi = byte(uint8(b) / 16);\r\n        byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n        s[2*i] = char(hi);\r\n        s[2*i\u002B1] = char(lo);            \r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function char(byte b) returns (byte c) {\r\n        if (b \u003C 10) return byte(uint8(b) \u002B 0x30);\r\n        else return byte(uint8(b) \u002B 0x57);\r\n    }\r\n\r\n    function creator(uint _id) external view returns (address) {\r\n        return idToCreator[_id];\r\n    }\r\n\r\n    function colorScheme(uint _id) external view returns (string) {\r\n        return idToColorScheme[_id];\r\n    }\r\n\r\n    function createGlyph(uint seed) external payable returns (string) {\r\n        return _mint(msg.sender, seed, false, 0);\r\n    }\r\n\r\n    function claimGlyph(uint seed, uint idBeingClaimed) external payable returns (string) {\r\n        return _mint(msg.sender, seed, true, idBeingClaimed);\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Returns whether the target address is a contract.\r\n     * @param _addr Address to check.\r\n     * @return True if _addr is a contract, false if not.\r\n     */\r\n    function isContract(address _addr) internal view returns (bool addressCheck) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(_addr) } // solhint-disable-line\r\n        addressCheck = size \u003E 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check which interfaces are suported by this contract.\r\n     * @param _interfaceID Id of the interface.\r\n     * @return True if _interfaceID is supported, false otherwise.\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice Throws unless \u0060msg.sender\u0060 is the current owner, an authorized operator, or the\r\n     * approved address for this NFT. Throws if \u0060_from\u0060 is not the current owner. Throws if \u0060_to\u0060 is\r\n     * the zero address. Throws if \u0060_tokenId\u0060 is not a valid NFT. When transfer is complete, this\r\n     * function checks if \u0060_to\u0060 is a smart contract (code size \u003E 0). If so, it calls\r\n     * \u0060onERC721Received\u0060 on \u0060_to\u0060 and throws if the return value is not\r\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,uint256,bytes)\u0022))\u0060.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to \u0060_to\u0060.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice This works identically to the other function with an extra data parameter, except this\r\n     * function just sets data to \u0022\u0022\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \u0022\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws unless \u0060msg.sender\u0060 is the current owner, an authorized operator, or the approved\r\n     * address for this NFT. Throws if \u0060_from\u0060 is not the current owner. Throws if \u0060_to\u0060 is the zero\r\n     * address. Throws if \u0060_tokenId\u0060 is not a valid NFT. This function can be changed to payable.\r\n     * @notice The caller is responsible to confirm that \u0060_to\u0060 is capable of receiving NFTs or else\r\n     * they maybe be permanently lost.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n     * @notice The zero address indicates there is no approved address. Throws unless \u0060msg.sender\u0060 is\r\n     * the current NFT owner, or an authorized operator of the current owner.\r\n     * @param _approved Address to be approved for the given NFT ID.\r\n     * @param _tokenId ID of the token to be approved.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables approval for a third party (\u0022operator\u0022) to manage all of\r\n     * \u0060msg.sender\u0060\u0027s assets. It also emits the ApprovalForAll event.\r\n     * @notice This works even if sender doesn\u0027t own any tokens at the time.\r\n     * @param _operator Address to add to the set of authorized operators.\r\n     * @param _approved True if the operators is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs owned by \u0060_owner\u0060. NFTs assigned to the zero address are\r\n     * considered invalid, and this function throws for queries about the zero address.\r\n     * @param _owner Address for whom to query the balance.\r\n     * @return Balance of _owner.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n     * invalid, and queries about them do throw.\r\n     * @param _tokenId The identifier for an NFT.\r\n     * @return Address of _tokenId owner.\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the approved address for a single NFT.\r\n     * @notice Throws if \u0060_tokenId\u0060 is not a valid NFT.\r\n     * @param _tokenId ID of the NFT to query the approval of.\r\n     * @return Address that _tokenId is approved for.\r\n     */\r\n    function getApproved(uint256 _tokenId) external view validNFToken(_tokenId) returns (address) {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if \u0060_operator\u0060 is an approved operator for \u0060_owner\u0060.\r\n     * @param _owner The address that owns the NFTs.\r\n     * @param _operator The address that acts on behalf of the owner.\r\n     * @return True if approved for all, false otherwise.\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Actually preforms the transfer.\r\n     * @notice Does NO checks.\r\n     * @param _to Address of a new owner.\r\n     * @param _tokenId The NFT that is being transferred.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints a new NFT.\r\n     * @notice This is an internal function which should be called from user-implemented external\r\n     * mint function. Its purpose is to show and properly initialize data structures when using this\r\n     * implementation.\r\n     * @param _to The address that will own the minted NFT.\r\n     */\r\n    function _mint(address _to, uint seed, bool autoglyphOwnerIsClaimingToken, uint idBeingClaimed) internal returns (string) {\r\n        require(_to != address(0));\r\n        require(numCreatedTokens \u003C CREATEABLE_TOKEN_LIMIT);\r\n        require(numClaimedTokens \u003C CLAIMABLE_TOKEN_LIMIT);\r\n        require(numTotalTokens \u003C TOTAL_TOKEN_LIMIT);\r\n        if (autoglyphOwnerIsClaimingToken) {\r\n            Autoglyphs autoglyphs = Autoglyphs(autoglyphsAddress);\r\n            require(idToGlyphIsClaimed[idBeingClaimed] == false);\r\n            require(autoglyphs.ownerOf(idBeingClaimed) == msg.sender);\r\n        }\r\n        uint amount = 0;\r\n        if (numCreatedTokens \u003E= ARTIST_PRINTS \u0026\u0026 autoglyphOwnerIsClaimingToken == false) {\r\n            amount = PRICE;\r\n            require(msg.value \u003E= amount);\r\n        }\r\n        require(seedToId[seed] == 0);\r\n        uint id;\r\n        if (autoglyphOwnerIsClaimingToken) {\r\n            id = idBeingClaimed \u002B 512;\r\n        } else {\r\n            id = numCreatedTokens \u002B 1;\r\n        }\r\n\r\n        idToCreator[id] = _to;\r\n        idToSeed[id] = seed;\r\n        seedToId[seed] = id;\r\n        uint a = uint(uint160(keccak256(abi.encodePacked(seed))));\r\n        idToColorScheme[id] = getScheme(a);\r\n        string memory uri = draw(id);\r\n        emit Generated(id, _to, uri);\r\n\r\n        numTotalTokens = numTotalTokens \u002B 1;\r\n        if (autoglyphOwnerIsClaimingToken) {\r\n            numClaimedTokens = numClaimedTokens \u002B 1;\r\n        } else {\r\n            numCreatedTokens = numCreatedTokens \u002B 1;\r\n        }\r\n        _addNFToken(_to, id);\r\n\r\n        if (msg.value \u003E amount) {\r\n            msg.sender.transfer(msg.value - amount);\r\n        }\r\n        if (amount \u003E 0) {\r\n            BENEFICIARY.transfer(amount);\r\n        }\r\n\r\n        emit Transfer(address(0), _to, id);\r\n        return uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new NFT to an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _to Address to which we want to add the NFT.\r\n     * @param _tokenId Which NFT we want to add.\r\n     */\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0));\r\n        idToOwner[_tokenId] = _to;\r\n\r\n        uint256 length = ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = length - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a NFT from an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _from Address from wich we want to remove the NFT.\r\n     * @param _tokenId Which NFT we want to remove.\r\n     */\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from);\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].length--;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n     * extension to remove double storage (gas optimization) of owner nft count.\r\n     * @param _owner Address for whom to query the count.\r\n     * @return Number of _owner NFTs.\r\n     */\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Actually perform the safeTransferFrom.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to \u0060_to\u0060.\r\n     */\r\n    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Clears the current approval of a given NFT ID.\r\n     * @param _tokenId ID of the NFT to be transferred.\r\n     */\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    //// Enumerable\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTotalTokens;\r\n    }\r\n\r\n    function totalCreatedSupply() public view returns (uint256) {\r\n        return numCreatedTokens;\r\n    }\r\n\r\n    function totalClaimedSupply() public view returns (uint256) {\r\n        return numClaimedTokens;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index \u003C TOTAL_TOKEN_LIMIT);\r\n        if (index \u003C CREATEABLE_TOKEN_LIMIT) {\r\n            require(index \u003C numCreatedTokens);\r\n        } else {\r\n            require(idToGlyphIsClaimed[index]);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the n-th NFT ID from a list of owner\u0027s tokens.\r\n     * @param _owner Token owner\u0027s address.\r\n     * @param _index Index number representing n-th token in owner\u0027s list of tokens.\r\n     * @return Token id.\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index \u003C ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n    //// Metadata\r\n\r\n    /**\r\n      * @dev Returns a descriptive name for a collection of NFTokens.\r\n      * @return Representing name.\r\n      */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     * @return Representing symbol.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n\r\n    /**\r\n     * @dev A distinct URI (RFC 3986) for a given NFT.\r\n     * @param _tokenId Id for which we want uri.\r\n     * @return URI of _tokenId.\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\r\n        return draw(_tokenId);\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_interfaceID\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022supportsInterface\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getApproved\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_approved\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ARTIST_PRINTS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022CREATEABLE_TOKEN_LIMIT\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022toAsciiString\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenOfOwnerByIndex\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022BENEFICIARY\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022draw\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022safeTransferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022autoglyphsAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenByIndex\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022creator\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022CLAIMABLE_TOKEN_LIMIT\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ownerOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022b\u0022,\u0022type\u0022:\u0022bytes1\u0022}],\u0022name\u0022:\u0022char\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022c\u0022,\u0022type\u0022:\u0022bytes1\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalCreatedSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022TOTAL_TOKEN_LIMIT\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022seed\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022idBeingClaimed\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022claimGlyph\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022PRICE\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_symbol\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_operator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_approved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022setApprovalForAll\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022colorScheme\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022safeTransferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenURI\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalClaimedSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022seed\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022createGlyph\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_operator\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isApprovedForAll\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022a\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022Generated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_approved\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_operator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_approved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022ApprovalForAll\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Colorglyphs","CompilerVersion":"v0.4.24\u002Bcommit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8bfae894c7b106d69dafffd5efde9e5bf2bcaf7e63797217130d922ec6ee26bd"}]