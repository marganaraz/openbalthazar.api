[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-06-11\r\n*/\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b \u003E 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b \u003C= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        assert(c \u003E= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes calldata  _data) external;\r\n}\r\n\r\n/// @dev The actual token contract, the default owner is the msg.sender\r\ncontract LIBRAToken is Ownable {\r\n\r\n    string public name;                //The Token\u0027s name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n\r\n    /// @dev \u0060Checkpoint\u0060 is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n\r\n        // \u0060fromBlock\u0060 is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // \u0060value\u0060 is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // \u0060creationBlock\u0060 is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // \u0060balances\u0060 is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address =\u003E Checkpoint[]) balances;\r\n\r\n    // \u0060allowed\u0060 tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) allowed;\r\n\r\n    // Tracks the history of the \u0060totalSupply\u0060 of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n    Checkpoint[] totalSupplyHolders;\r\n    mapping (address =\u003E bool) public holders;\r\n    uint public minHolderAmount = 20000 ether;\r\n\r\n    ////////////////\r\n    // Events\r\n    ////////////////\r\n    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n\r\n\r\n    modifier whenTransfersEnabled() {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n\r\n\r\n    constructor () public {\r\n        name = \u0022LIBRA\u0022;\r\n        symbol = \u0022Libra Network\u0022;\r\n        decimals = 18;\r\n        creationBlock = block.number;\r\n        transfersEnabled = true;\r\n\r\n        //initial emission\r\n        uint _amount = 800000000 * (10 ** uint256(decimals));\r\n        updateValueAtNow(totalSupplyHistory, _amount);\r\n        updateValueAtNow(balances[msg.sender], _amount);\r\n\r\n        holders[msg.sender] = true;\r\n        updateValueAtNow(totalSupplyHolders, _amount);\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n\r\n    /// @notice The fallback function\r\n    function () external payable {}\r\n\r\n    ///////////////////\r\n    // ERC20 Methods\r\n    ///////////////////\r\n\r\n    /// @notice Send \u0060_amount\u0060 tokens to \u0060_to\u0060 from \u0060msg.sender\u0060\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) whenTransfersEnabled external returns (bool) {\r\n        doTransfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send \u0060_amount\u0060 tokens to \u0060_to\u0060 from \u0060_from\u0060 on the condition it\r\n    ///  is approved by \u0060_from\u0060\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount) whenTransfersEnabled external returns (bool) {\r\n        // The standard ERC 20 transferFrom functionality\r\n        require(allowed[_from][msg.sender] \u003E= _amount);\r\n        allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount) internal {\r\n\r\n        if (_amount == 0) {\r\n            emit Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\r\n            return;\r\n        }\r\n\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((_to != address(0)) \u0026\u0026 (_to != address(this)));\r\n\r\n        // If the amount being transfered is more than the balance of the\r\n        //  account the transfer throws\r\n        uint previousBalanceFrom = balanceOfAt(_from, block.number);\r\n\r\n        require(previousBalanceFrom \u003E= _amount);\r\n\r\n        // First update the balance array with the new value for the address\r\n        //  sending the tokens\r\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n        // Then update the balance array with the new value for the address\r\n        //  receiving the tokens\r\n        uint previousBalanceTo = balanceOfAt(_to, block.number);\r\n        require(previousBalanceTo \u002B _amount \u003E= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(balances[_to], previousBalanceTo \u002B _amount);\r\n\r\n        // An event to make the transfer easy to find on the blockchain\r\n        emit Transfer(_from, _to, _amount);\r\n\r\n\r\n        uint curTotalSupplyHolders = totalSupplyHoldersAt(block.number);\r\n\r\n        if (holders[_from]) {\r\n            if (previousBalanceFrom - _amount \u003C minHolderAmount) {\r\n                delete holders[_from];\r\n                require(curTotalSupplyHolders \u003E= previousBalanceFrom);\r\n                curTotalSupplyHolders = curTotalSupplyHolders - previousBalanceFrom;\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders);\r\n            } else {\r\n                require(curTotalSupplyHolders \u003E= _amount);\r\n                curTotalSupplyHolders = curTotalSupplyHolders - _amount;\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders);\r\n            }\r\n        }\r\n\r\n        if (previousBalanceTo \u002B _amount \u003E= minHolderAmount) {\r\n            if (holders[_to]) {\r\n                require(curTotalSupplyHolders \u002B _amount \u003E= curTotalSupplyHolders); // Check for overflow\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders \u002B _amount);\r\n            }\r\n\r\n            if (!holders[_to]) {\r\n                holders[_to] = true;\r\n                require(curTotalSupplyHolders \u002B previousBalanceTo \u002B _amount \u003E= curTotalSupplyHolders); // Check for overflow\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders \u002B previousBalanceTo \u002B _amount);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /// @param _owner The address that\u0027s balance is being requested\r\n    /// @return The balance of \u0060_owner\u0060 at the current block\r\n    function balanceOf(address _owner) external view returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice \u0060msg.sender\u0060 approves \u0060_spender\u0060 to spend \u0060_amount\u0060 tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) whenTransfersEnabled public returns (bool) {\r\n        // To change the approve amount you first have to reduce the addresses\u0060\r\n        //  allowance to zero by calling \u0060approve(_spender,0)\u0060 if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowance[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedAmount The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedAmount) external returns (bool) {\r\n        require(allowed[msg.sender][_spender] \u002B _addedAmount \u003E= allowed[msg.sender][_spender]); // Check for overflow\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] \u002B _addedAmount;\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowance[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedAmount The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedAmount) external returns (bool)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedAmount \u003E= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue - _subtractedAmount;\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev This function makes it easy to read the \u0060allowed[]\u0060 map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice \u0060msg.sender\u0060 approves \u0060_spender\u0060 to send \u0060_amount\u0060 tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, \u0060_spender\u0060. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            address(this),\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() external view returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    function currentTotalSupplyHolders() external view returns (uint) {\r\n        return totalSupplyHoldersAt(block.number);\r\n    }\r\n\r\n    ////////////////\r\n    // Query balance and totalSupply in History\r\n    ////////////////\r\n\r\n    /// @dev Queries the balance of \u0060_owner\u0060 at a specific \u0060_blockNumber\u0060\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at \u0060_blockNumber\u0060\r\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\r\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock \u003E _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific \u0060_blockNumber\u0060.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at \u0060_blockNumber\u0060\r\n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\r\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock \u003E _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\r\n    function totalSupplyHoldersAt(uint _blockNumber) public view returns(uint) {\r\n        if ((totalSupplyHolders.length == 0) || (totalSupplyHolders[0].fromBlock \u003E _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHolders, _blockNumber);\r\n        }\r\n    }\r\n\r\n    function isHolder(address _holder) external view returns(bool) {\r\n        return holders[_holder];\r\n    }\r\n\r\n\r\n    function destroyTokens(uint _amount) onlyOwner public returns (bool) {\r\n        uint curTotalSupply = totalSupplyAt(block.number);\r\n        require(curTotalSupply \u003E= _amount);\r\n        uint previousBalanceFrom = balanceOfAt(msg.sender, block.number);\r\n\r\n        require(previousBalanceFrom \u003E= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[msg.sender], previousBalanceFrom - _amount);\r\n        emit Transfer(msg.sender, address(0), _amount);\r\n\r\n        uint curTotalSupplyHolders = totalSupplyHoldersAt(block.number);\r\n        if (holders[msg.sender]) {\r\n            if (previousBalanceFrom - _amount \u003C minHolderAmount) {\r\n                delete holders[msg.sender];\r\n                require(curTotalSupplyHolders \u003E= previousBalanceFrom);\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders - previousBalanceFrom);\r\n            } else {\r\n                require(curTotalSupplyHolders \u003E= _amount);\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders - _amount);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Enable tokens transfers\r\n    ////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) public onlyOwner {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    ////////////////\r\n    // Internal helper functions to query and set a value in a snapshot array\r\n    ////////////////\r\n\r\n    /// @dev \u0060getValueAt\u0060 retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block \u003E= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block \u003C checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max \u003E min) {\r\n            uint mid = (max \u002B min \u002B 1)/ 2;\r\n            if (checkpoints[mid].fromBlock\u003C=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev \u0060updateValueAtNow\u0060 used to update the \u0060balances\u0060 map and the\r\n    ///  \u0060totalSupplyHistory\u0060\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {\r\n        if ((checkpoints.length == 0)\r\n            || (checkpoints[checkpoints.length -1].fromBlock \u003C block.number)) {\r\n            Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length\u002B\u002B ];\r\n            newCheckPoint.fromBlock =  uint128(block.number);\r\n            newCheckPoint.value = uint128(_value);\r\n        } else {\r\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n\r\n\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address payable _token) external onlyOwner {\r\n        if (_token == address(0)) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        LIBRAToken token = LIBRAToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n        token.transfer(owner, balance);\r\n        emit ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n\r\n    function setMinHolderAmount(uint _minHolderAmount) external onlyOwner {\r\n        minHolderAmount = _minHolderAmount;\r\n    }\r\n}\r\n\r\n\r\ncontract DividendManager is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    event DividendDeposited(address indexed _depositor, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex);\r\n    event DividendClaimed(address indexed _claimer, uint256 _dividendIndex, uint256 _claim);\r\n    event DividendRecycled(address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex);\r\n\r\n    LIBRAToken public token;\r\n\r\n    uint256 public RECYCLE_TIME = 365 days;\r\n    uint public minHolderAmount = 20000 ether;\r\n\r\n    struct Dividend {\r\n        uint256 blockNumber;\r\n        uint256 timestamp;\r\n        uint256 amount;\r\n        uint256 claimedAmount;\r\n        uint256 totalSupply;\r\n        bool recycled;\r\n        mapping (address =\u003E bool) claimed;\r\n    }\r\n\r\n    Dividend[] public dividends;\r\n\r\n    mapping (address =\u003E uint256) dividendsClaimed;\r\n\r\n    struct NotClaimed {\r\n        uint listIndex;\r\n        bool exists;\r\n    }\r\n\r\n    mapping (address =\u003E NotClaimed) public notClaimed;\r\n    address[] public notClaimedList;\r\n\r\n    modifier validDividendIndex(uint256 _dividendIndex) {\r\n        require(_dividendIndex \u003C dividends.length);\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _token) public {\r\n        token = LIBRAToken(_token);\r\n    }\r\n\r\n    function depositDividend() payable public {\r\n        uint256 currentSupply = token.totalSupplyHoldersAt(block.number);\r\n\r\n        uint i;\r\n        for( i = 0; i \u003C notClaimedList.length; i\u002B\u002B) {\r\n            if (token.isHolder(notClaimedList[i])) {\r\n                currentSupply = currentSupply.sub(token.balanceOf(notClaimedList[i]));\r\n            }\r\n        }\r\n\r\n        uint256 dividendIndex = dividends.length;\r\n        uint256 blockNumber = SafeMath.sub(block.number, 1);\r\n        dividends.push(\r\n            Dividend(\r\n                blockNumber,\r\n                getNow(),\r\n                msg.value,\r\n                0,\r\n                currentSupply,\r\n                false\r\n            )\r\n        );\r\n        emit DividendDeposited(msg.sender, blockNumber, msg.value, currentSupply, dividendIndex);\r\n    }\r\n\r\n\r\n    function claimDividend(uint256 _dividendIndex) public validDividendIndex(_dividendIndex)\r\n    {\r\n        require(!notClaimed[msg.sender].exists);\r\n\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n\r\n        require(dividend.claimed[msg.sender] == false);\r\n        require(dividend.recycled == false);\r\n\r\n        uint256 balance = token.balanceOfAt(msg.sender, dividend.blockNumber);\r\n        require(balance \u003E= minHolderAmount);\r\n\r\n        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\r\n        dividend.claimed[msg.sender] = true;\r\n        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\r\n\r\n        if (claim \u003E 0) {\r\n            msg.sender.transfer(claim);\r\n            emit DividendClaimed(msg.sender, _dividendIndex, claim);\r\n        }\r\n    }\r\n\r\n    function claimDividendAll() public {\r\n        require(dividendsClaimed[msg.sender] \u003C dividends.length);\r\n        for (uint i = dividendsClaimed[msg.sender]; i \u003C dividends.length; i\u002B\u002B) {\r\n            if ((dividends[i].claimed[msg.sender] == false) \u0026\u0026 (dividends[i].recycled == false)) {\r\n                dividendsClaimed[msg.sender] = SafeMath.add(i, 1);\r\n                claimDividend(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function recycleDividend(uint256 _dividendIndex) public\r\n    onlyOwner\r\n    validDividendIndex(_dividendIndex)\r\n    {\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        require(dividend.recycled == false);\r\n        require(dividend.timestamp \u003C SafeMath.sub(getNow(), RECYCLE_TIME));\r\n        dividends[_dividendIndex].recycled = true;\r\n        uint256 currentSupply = token.totalSupplyAt(block.number);\r\n        uint256 remainingAmount = SafeMath.sub(dividend.amount, dividend.claimedAmount);\r\n        uint256 dividendIndex = dividends.length;\r\n        uint256 blockNumber = SafeMath.sub(block.number, 1);\r\n        dividends.push(\r\n            Dividend(\r\n                blockNumber,\r\n                getNow(),\r\n                remainingAmount,\r\n                0,\r\n                currentSupply,\r\n                false\r\n            )\r\n        );\r\n        emit DividendRecycled(msg.sender, blockNumber, remainingAmount, currentSupply, dividendIndex);\r\n    }\r\n\r\n    //Function is mocked for tests\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function dividendsCount() external view returns (uint) {\r\n        return dividends.length;\r\n    }\r\n\r\n\r\n    function registerNotClaimed(address _notClaimed) onlyOwner public {\r\n        require(_notClaimed != address(0));\r\n        if (!notClaimed[_notClaimed].exists) {\r\n            notClaimed[_notClaimed] = NotClaimed({\r\n                listIndex: notClaimedList.length,\r\n                exists: true\r\n                });\r\n            notClaimedList.push(_notClaimed);\r\n        }\r\n    }\r\n\r\n\r\n    function unregisterNotClaimed(address _notClaimed) onlyOwner public {\r\n        require(notClaimed[_notClaimed].exists \u0026\u0026 notClaimedList.length \u003E 0);\r\n        uint lastIdx = notClaimedList.length - 1;\r\n        notClaimed[notClaimedList[lastIdx]].listIndex = notClaimed[_notClaimed].listIndex;\r\n        notClaimedList[notClaimed[_notClaimed].listIndex] = notClaimedList[lastIdx];\r\n        notClaimedList.length--;\r\n        delete notClaimed[_notClaimed];\r\n    }\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address payable _token) external onlyOwner {\r\n        //        if (_token == 0x0) {\r\n        //            owner.transfer(address(this).balance);\r\n        //            return;\r\n        //        }\r\n\r\n        LIBRAToken claimToken = LIBRAToken(_token);\r\n        uint balance = claimToken.balanceOf(address(this));\r\n        claimToken.transfer(owner, balance);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022creationBlock\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022holders\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022currentTotalSupplyHolders\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022balanceOfAt\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_subtractedAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseApproval\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022destroyTokens\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022totalSupplyHoldersAt\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022totalSupplyAt\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minHolderAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022transfersEnabled\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_minHolderAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMinHolderAmount\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_extraData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022approveAndCall\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_holder\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isHolder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_addedAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseApproval\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022remaining\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022claimTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_transfersEnabled\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022enableTransfers\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ClaimedTokens\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"LIBRAToken","CompilerVersion":"v0.5.9\u002Bcommit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d9da2cceebe930572898a036112a90ed5d7694c8a274b10621c78858c046f1e"}]