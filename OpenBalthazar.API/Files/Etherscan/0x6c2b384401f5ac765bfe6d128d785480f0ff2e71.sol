[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n\r\ninterface DharmaSmartWalletInterface {\r\n  enum ActionType {\r\n    Cancel, SetUserSigningKey, Generic, GenericAtomicBatch, SAIWithdrawal,\r\n    USDCWithdrawal, ETHWithdrawal, SetEscapeHatch, RemoveEscapeHatch,\r\n    DisableEscapeHatch, DAIWithdrawal, _ELEVEN, _TWELVE, _THIRTEEN,\r\n    _FOURTEEN, _FIFTEEN, _SIXTEEN, _SEVENTEEN, _EIGHTEEN, _NINETEEN, _TWENTY\r\n  }\r\n  function getVersion() external pure returns (uint256 version);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletFactoryV1Interface {\r\n  function newSmartWallet(\r\n    address userSigningKey\r\n  ) external returns (address wallet);\r\n  \r\n  function getNextSmartWallet(\r\n    address userSigningKey\r\n  ) external view returns (address wallet);\r\n}\r\n\r\ninterface DharmaKeyRingFactoryV2Interface {\r\n  function newKeyRing(\r\n    address userSigningKey, address targetKeyRing\r\n  ) external returns (address keyRing);\r\n\r\n  function getNextKeyRing(\r\n    address userSigningKey\r\n  ) external view returns (address targetKeyRing);\r\n}\r\n\r\n\r\ninterface DharmaKeyRegistryInterface {\r\n  function getKeyForUser(address account) external view returns (address key);\r\n}\r\n\r\n\r\ncontract DharmaDeploymentHelper {\r\n  DharmaSmartWalletFactoryV1Interface internal constant _WALLET_FACTORY = (\r\n    DharmaSmartWalletFactoryV1Interface(\r\n      0xfc00C80b0000007F73004edB00094caD80626d8D\r\n    )\r\n  );\r\n  \r\n  DharmaKeyRingFactoryV2Interface internal constant _KEYRING_FACTORY = (\r\n    DharmaKeyRingFactoryV2Interface(\r\n      0x2484000059004afB720000dc738434fA6200F49D\r\n    )\r\n  );\r\n\r\n  DharmaKeyRegistryInterface internal constant _KEY_REGISTRY = (\r\n    DharmaKeyRegistryInterface(\r\n      0x000000000D38df53b45C5733c7b34000dE0BDF52\r\n    )\r\n  );\r\n  \r\n  address internal constant beacon = 0x000000000026750c571ce882B17016557279ADaa;\r\n\r\n  // Use the smart wallet instance runtime code hash to verify expected targets.\r\n  bytes32 internal constant _SMART_WALLET_INSTANCE_RUNTIME_HASH = bytes32(\r\n    0xe25d4f154acb2394ee6c18d64fb5635959ba063d57f83091ec9cf34be16224d7\r\n  );\r\n\r\n  // The keyring instance runtime code hash is used to verify expected targets.\r\n  bytes32 internal constant _KEY_RING_INSTANCE_RUNTIME_HASH = bytes32(\r\n    0xb15b24278e79e856d35b262e76ff7d3a759b17e625ff72adde4116805af59648\r\n  );\r\n  \r\n  // Deploy a smart wallet and call it with arbitrary data.\r\n  function deployWalletAndCall(\r\n    address userSigningKey, // the key ring\r\n    address smartWallet,\r\n    bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    _deployNewSmartWalletIfNeeded(userSigningKey, smartWallet);\r\n    (ok, returnData) = smartWallet.call(data);\r\n  }\r\n\r\n  // Deploy a key ring and a smart wallet, then call the smart wallet\r\n  // with arbitrary data.\r\n  function deployKeyRingAndWalletAndCall(\r\n    address initialSigningKey, // the initial key on the keyring\r\n    address keyRing,\r\n    address smartWallet,\r\n    bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    _deployNewKeyRingIfNeeded(initialSigningKey, keyRing);\r\n    _deployNewSmartWalletIfNeeded(keyRing, smartWallet);\r\n    (ok, returnData) = smartWallet.call(data);\r\n  }\r\n \r\n  // Get an actionID for the first action on a smart wallet before it\r\n  // has been deployed.\r\n  // no argument: empty string - abi.encode();\r\n  // one argument, like setUserSigningKey: abi.encode(argument)\r\n  // withdrawals: abi.encode(amount, recipient)\r\n  // generics: abi.encode(to, data)\r\n  // generic batch: abi.encode(calls) -\u003E array of {address to, bytes data}\r\n  function getInitialActionID(\r\n    address smartWallet,\r\n    address initialUserSigningKey, // the key ring\r\n    DharmaSmartWalletInterface.ActionType actionType,\r\n    uint256 minimumActionGas,\r\n    bytes calldata arguments\r\n  ) external view returns (bytes32 actionID) {\r\n    actionID = keccak256(\r\n      abi.encodePacked(\r\n        smartWallet,\r\n        _getVersion(),\r\n        initialUserSigningKey,\r\n        _KEY_REGISTRY.getKeyForUser(smartWallet),\r\n        uint256(0), // nonce starts at 0\r\n        minimumActionGas,\r\n        actionType,\r\n        arguments\r\n      )\r\n    );\r\n  }\r\n \r\n  function _deployNewKeyRingIfNeeded(\r\n    address initialSigningKey, address expectedKeyRing\r\n  ) internal returns (address keyRing) {\r\n    // Only deploy if a smart wallet doesn\u0027t already exist at expected address.\r\n    bytes32 hash;\r\n    assembly { hash := extcodehash(expectedKeyRing) }\r\n    if (hash != _KEY_RING_INSTANCE_RUNTIME_HASH) {\r\n      require(\r\n        _KEYRING_FACTORY.getNextKeyRing(initialSigningKey) == expectedKeyRing,\r\n        \u0022Key ring to be deployed does not match expected key ring.\u0022\r\n      );\r\n      keyRing = _KEYRING_FACTORY.newKeyRing(initialSigningKey, expectedKeyRing);\r\n    } else {\r\n      // Note: the key ring at the expected address may have been modified so that\r\n      // the supplied user signing key is no longer a valid key - therefore, treat\r\n      // this helper as a way to protect against race conditions, not as a primary\r\n      // mechanism for interacting with key ring contracts.\r\n      keyRing = expectedKeyRing;\r\n    }\r\n  } \r\n  \r\n  function _deployNewSmartWalletIfNeeded(\r\n    address userSigningKey, // the key ring\r\n    address expectedSmartWallet\r\n  ) internal returns (address smartWallet) {\r\n    // Only deploy if a smart wallet doesn\u0027t already exist at expected address.\r\n    bytes32 hash;\r\n    assembly { hash := extcodehash(expectedSmartWallet) }\r\n    if (hash != _SMART_WALLET_INSTANCE_RUNTIME_HASH) {\r\n      require(\r\n        _WALLET_FACTORY.getNextSmartWallet(userSigningKey) == expectedSmartWallet,\r\n        \u0022Smart wallet to be deployed does not match expected smart wallet.\u0022\r\n      );\r\n      smartWallet = _WALLET_FACTORY.newSmartWallet(userSigningKey);\r\n    } else {\r\n      // Note: the smart wallet at the expected address may have been modified\r\n      // so that the supplied user signing key is no longer a valid key.\r\n      // Therefore, treat this helper as a way to protect against race\r\n      // conditions, not as a primary mechanism for interacting with smart\r\n      // wallet contracts.\r\n      smartWallet = expectedSmartWallet;\r\n    }\r\n  }\r\n\r\n  function _getVersion() internal view returns (uint256 version) {\r\n    (, bytes memory data) = beacon.staticcall(\u0022\u0022);\r\n    address implementation = abi.decode(data, (address));\r\n    version = DharmaSmartWalletInterface(implementation).getVersion();\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022smartWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022initialUserSigningKey\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022enum DharmaSmartWalletInterface.ActionType\u0022,\u0022name\u0022:\u0022actionType\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022minimumActionGas\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022getInitialActionID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022actionID\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022initialSigningKey\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022keyRing\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022smartWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022deployKeyRingAndWalletAndCall\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022ok\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022returnData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022userSigningKey\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022smartWallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022deployWalletAndCall\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022ok\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022returnData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"DharmaDeploymentHelper","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://50418e06cd254da9f75fd965a3e1a61334c1cf98f57b75bf9a25719ae39fcdee"}]