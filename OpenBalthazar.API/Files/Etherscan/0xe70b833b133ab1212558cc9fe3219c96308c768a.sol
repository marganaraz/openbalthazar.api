[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Eternal Storage for the Reserve Token\r\n *\r\n * @dev Eternal Storage facilitates future upgrades.\r\n *\r\n * If Reserve chooses to release an upgraded contract for the Reserve  in the future, Reserve\r\n * will have the option of reusing the deployed version of this data contract to simplify migration.\r\n *\r\n * The use of this contract does not imply that Reserve will choose to do a future upgrade, nor that\r\n * any future upgrades will necessarily re-use this storage. It merely provides option value.\r\n */\r\ncontract ReserveEternalStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    // ===== auth =====\r\n\r\n    address public owner;\r\n    address public escapeHatch;\r\n\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n    event EscapeHatchTransferred(address indexed oldEscapeHatch, address indexed newEscapeHatch);\r\n\r\n    /// On construction, set auth fields.\r\n    constructor(address escapeHatchAddress) public {\r\n        owner = msg.sender;\r\n        escapeHatch = escapeHatchAddress;\r\n    }\r\n\r\n    /// Only run modified function if sent by \u0060owner\u0060.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \u0022onlyOwner\u0022);\r\n        _;\r\n    }\r\n\r\n    /// Set \u0060owner\u0060.\r\n    function transferOwnership(address newOwner) external {\r\n        require(msg.sender == owner || msg.sender == escapeHatch, \u0022not authorized\u0022);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /// Set \u0060escape hatch\u0060.\r\n    function transferEscapeHatch(address newEscapeHatch) external {\r\n        require(msg.sender == escapeHatch, \u0022not authorized\u0022);\r\n        emit EscapeHatchTransferred(escapeHatch, newEscapeHatch);\r\n        escapeHatch = newEscapeHatch;\r\n    }\r\n\r\n\r\n\r\n    // ===== balance =====\r\n\r\n    mapping(address =\u003E uint256) public balance;\r\n\r\n    /// Add \u0060value\u0060 to \u0060balance[key]\u0060, unless this causes integer overflow.\r\n    ///\r\n    /// @dev This is a slight divergence from the strict Eternal Storage pattern, but it reduces the gas\r\n    /// for the by-far most common token usage, it\u0027s a *very simple* divergence, and \u0060setBalance\u0060 is\r\n    /// available anyway.\r\n    function addBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].add(value);\r\n    }\r\n\r\n    /// Subtract \u0060value\u0060 from \u0060balance[key]\u0060, unless this causes integer underflow.\r\n    function subBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].sub(value);\r\n    }\r\n\r\n    /// Set \u0060balance[key]\u0060 to \u0060value\u0060.\r\n    function setBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== allowed =====\r\n\r\n    mapping(address =\u003E mapping(address =\u003E uint256)) public allowed;\r\n\r\n    /// Set \u0060to\u0060\u0027s allowance of \u0060from\u0060\u0027s tokens to \u0060value\u0060.\r\n    function setAllowed(address from, address to, uint256 value) external onlyOwner {\r\n        allowed[from][to] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== frozenTime =====\r\n\r\n    /// @dev When \u0060frozenTime[addr] == 0\u0060, \u0060addr\u0060 is not frozen. This is the normal state.\r\n    /// When \u0060frozenTime[addr] == t\u0060 and \u0060t \u003E 0\u0060, \u0060addr\u0060 was last frozen at timestamp \u0060t\u0060.\r\n    /// So, to unfreeze an address \u0060addr\u0060, set \u0060frozenTime[addr] = 0\u0060.\r\n    mapping(address =\u003E uint256) public frozenTime;\r\n\r\n    /// Set \u0060frozenTime[who]\u0060 to \u0060time\u0060.\r\n    function setFrozenTime(address who, uint256 time) external onlyOwner {\r\n        frozenTime[who] = time;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022escapeHatch\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022key\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022addBalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setAllowed\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowed\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newEscapeHatch\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferEscapeHatch\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022frozenTime\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setFrozenTime\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022key\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022subBalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022key\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setBalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022escapeHatchAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022oldOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022oldEscapeHatch\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newEscapeHatch\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022EscapeHatchTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"ReserveEternalStorage","CompilerVersion":"v0.5.9\u002Bcommit.e560f70d","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000004c664c88304156470c05357708253d8d122d88e9","Library":"","SwarmSource":"bzzr://d6530ad21e43247255ce5c6488a991b7905d2c68bb772d109067b2e0d16ba58b"}]