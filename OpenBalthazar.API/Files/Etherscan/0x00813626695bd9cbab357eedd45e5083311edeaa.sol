[{"SourceCode":"pragma solidity \u003E=0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary AbstractERC20 {\r\n\r\n    function abstractReceive(IERC20 token, uint256 amount) internal returns(uint256) {\r\n        if (token == IERC20(0)) {\r\n            require(msg.value == amount);\r\n            return amount;\r\n        } else {\r\n            uint256 balance = abstractBalanceOf(token, address(this));\r\n            token.transferFrom(msg.sender, address(this), amount);\r\n            uint256 cmp_amount = abstractBalanceOf(token, address(this)) - balance;\r\n            require(cmp_amount != 0);\r\n            return cmp_amount;\r\n        }\r\n    }\r\n\r\n    function abstractTransfer(IERC20 token, address to, uint256 amount) internal returns(uint256) {\r\n        if (token == IERC20(0)) {\r\n            payable(to).transfer(amount);\r\n            return amount;\r\n        } else {\r\n            uint256 balance = abstractBalanceOf(token, address(this));\r\n            token.transfer(to, amount);\r\n            uint256 cmp_amount = balance - abstractBalanceOf(token, address(this));\r\n            require(cmp_amount != 0);\r\n            return cmp_amount;\r\n        }\r\n    }\r\n\r\n    function abstractBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        if (token == IERC20(0)) {\r\n            return who.balance;\r\n        } else {\r\n            return token.balanceOf(who);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Groth16Verifier {\r\n  uint constant q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n  uint constant r = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n\r\n  struct G1Point {\r\n    uint X;\r\n    uint Y;\r\n  }\r\n  // Encoding of field elements is: X[0] * z \u002B X[1]\r\n  struct G2Point {\r\n    uint[2] X;\r\n    uint[2] Y;\r\n  }\r\n\r\n  /// @return the sum of two points of G1\r\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory) {\r\n    G1Point memory t;\r\n    uint[4] memory input;\r\n    input[0] = p1.X;\r\n    input[1] = p1.Y;\r\n    input[2] = p2.X;\r\n    input[3] = p2.Y;\r\n    bool success;\r\n    /* solium-disable-next-line */\r\n    assembly {\r\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, t, 0x60)\r\n      // Use \u0022invalid\u0022 to make gas estimation work\r\n      switch success case 0 { invalid() }\r\n    }\r\n    require(success);\r\n    return t;\r\n  }\r\n\r\n  /// @return the product of a point on G1 and a scalar, i.e.\r\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\r\n  function scalar_mul(G1Point memory p, uint s) internal view returns (G1Point memory) {\r\n    if(s==0) return G1Point(0,0);\r\n    if(s==1) return p;\r\n    G1Point memory t;\r\n    uint[3] memory input;\r\n    input[0] = p.X;\r\n    input[1] = p.Y;\r\n    input[2] = s;\r\n    bool success;\r\n    /* solium-disable-next-line */\r\n    assembly {\r\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, t, 0x60)\r\n      // Use \u0022invalid\u0022 to make gas estimation work\r\n      switch success case 0 { invalid() }\r\n    }\r\n    require (success);\r\n    return t;\r\n  }\r\n\r\n\r\n  function verify(uint[] memory input, uint[8] memory proof, uint[] memory vk) internal view returns (bool) {\r\n    uint nsignals = (vk.length-16)/2;\r\n    require((nsignals\u003E0) \u0026\u0026 (input.length == nsignals) \u0026\u0026 (proof.length == 8) \u0026\u0026 (vk.length == 16 \u002B 2*nsignals));\r\n\r\n    for(uint i=0; i\u003Cinput.length; i\u002B\u002B)\r\n      require(input[i]\u003Cr);\r\n\r\n\r\n    uint[] memory p_input = new uint[](24);\r\n\r\n    p_input[0] = proof[0];\r\n    p_input[1] = q-(proof[1]%q);  //proof.A negation\r\n    p_input[2] = proof[2];\r\n    p_input[3] = proof[3];\r\n    p_input[4] = proof[4];\r\n    p_input[5] = proof[5];\r\n\r\n    // alpha1 computation\r\n    p_input[6] = vk[0];     //vk.alfa1 == G1Point(vk[0], vk[1])\r\n    p_input[7] = vk[1];\r\n\r\n\r\n    p_input[8] = vk[2];\r\n    p_input[9] = vk[3];\r\n    p_input[10] = vk[4];\r\n    p_input[11] = vk[5];\r\n\r\n    //vk_x computation\r\n    G1Point memory t = G1Point(vk[14], vk[15]);  //vk.IC[0] == G1Point(vk[14], vk[15])\r\n    for(uint j = 0; j \u003C nsignals; j\u002B\u002B)\r\n      t = addition(t, scalar_mul(G1Point(vk[16\u002B2*j], vk[17\u002B2*j]), input[j]));  //vk.IC[j \u002B 1] == G1Point(vk[16\u002B2*j], vk[17\u002B2*j])\r\n\r\n    p_input[12] = t.X;\r\n    p_input[13] = t.Y;\r\n\r\n    p_input[14] = vk[6];\r\n    p_input[15] = vk[7];\r\n    p_input[16] = vk[8];\r\n    p_input[17] = vk[9];\r\n\r\n    //C computation\r\n    p_input[18] = proof[6];   //proof.C == G1Point(proof[6], proof[7])\r\n    p_input[19] = proof[7];\r\n\r\n    p_input[20] = vk[10];\r\n    p_input[21] = vk[11];\r\n    p_input[22] = vk[12];\r\n    p_input[23] = vk[13];\r\n\r\n\r\n    uint[1] memory out;\r\n    bool success;\r\n    // solium-disable-next-line \r\n    assembly {\r\n      success := staticcall(sub(gas(), 2000), 8, add(p_input, 0x20), 768, out, 0x20)\r\n      // Use \u0022invalid\u0022 to make gas estimation work\r\n      switch success case 0 { invalid() }\r\n    }\r\n\r\n    require(success);\r\n    return out[0] != 0;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\nlibrary MerkleProof {\r\n    function keccak256MerkleProof(\r\n        bytes32[8] memory proof,\r\n        uint256 path,\r\n        bytes32 leaf\r\n    ) internal pure returns (bytes32) {\r\n        bytes32 root = leaf;\r\n        for (uint256 i = 0; i \u003C 8; i\u002B\u002B) {\r\n            root = (path \u003E\u003E i) \u0026 1 == 0\r\n                ? keccak256(abi.encode(leaf, proof[i]))\r\n                : keccak256(abi.encode(proof[i], leaf));\r\n        }\r\n        return root;\r\n    }\r\n\r\n    //compute merkle tree for up to 256 leaves\r\n    function keccak256MerkleTree(bytes32[] memory buff)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        uint256 buffsz = buff.length;\r\n        bytes32 last_tx = buff[buffsz - 1];\r\n        for (uint8 level = 1; level \u003C 8; level\u002B\u002B) {\r\n            bool buffparity = (buffsz \u0026 1 == 0);\r\n            buffsz = (buffsz \u003E\u003E 1) \u002B (buffsz \u0026 1);\r\n\r\n            for (uint256 i = 0; i \u003C buffsz - 1; i\u002B\u002B) {\r\n                buff[i] = keccak256(abi.encode(buff[2 * i], buff[2 * i \u002B 1]));\r\n            }\r\n            buff[buffsz - 1] = buffparity\r\n                ? keccak256(\r\n                    abi.encode(buff[2 * buffsz - 2], buff[2 * buffsz - 1])\r\n                )\r\n                : keccak256(abi.encode(buff[2 * buffsz - 2], last_tx));\r\n            last_tx = keccak256(abi.encode(last_tx, last_tx));\r\n        }\r\n        return buff[0];\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract UnstructuredStorage {\r\n    function set_uint256(bytes32 pos, uint256 value) internal {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            sstore(pos, value)\r\n        }\r\n    }\r\n\r\n    function get_uint256(bytes32 pos) internal view returns(uint256 value) {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            value:=sload(pos)\r\n        }\r\n    }\r\n\r\n    function set_address(bytes32 pos, address value) internal {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            sstore(pos, value)\r\n        }\r\n    }\r\n\r\n    function get_address(bytes32 pos) internal view returns(address value) {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            value:=sload(pos)\r\n        }\r\n    }\r\n\r\n\r\n    function set_bool(bytes32 pos, bool value) internal {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            sstore(pos, value)\r\n        }\r\n    }\r\n\r\n    function get_bool(bytes32 pos) internal view returns(bool value) {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            value:=sload(pos)\r\n        }\r\n    }\r\n\r\n    function set_bytes32(bytes32 pos, bytes32 value) internal {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            sstore(pos, value)\r\n        }\r\n    }\r\n\r\n    function get_bytes32(bytes32 pos) internal view returns(bytes32 value) {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            value:=sload(pos)\r\n        }\r\n    }\r\n\r\n\r\n    function set_uint256(bytes32 pos, uint256 offset, uint256 value) internal {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            sstore(add(pos, offset), value)\r\n        }\r\n    }\r\n\r\n    function get_uint256(bytes32 pos, uint256 offset) internal view returns(uint256 value) {\r\n        // solium-disable-next-line\r\n        assembly {\r\n            value:=sload(add(pos, offset))\r\n        }\r\n    }\r\n\r\n    function set_uint256_list(bytes32 pos, uint256[] memory list) internal {\r\n        uint256 sz = list.length;\r\n        set_uint256(pos, sz);\r\n        for(uint256 i = 0; i\u003Csz; i\u002B\u002B) {\r\n            set_uint256(pos, i\u002B1, list[i]);\r\n        }\r\n    }\r\n\r\n    function get_uint256_list(bytes32 pos) internal view returns (uint256[] memory list) {\r\n        uint256 sz = get_uint256(pos);\r\n        list = new uint256[](sz);\r\n        for(uint256 i = 0; i \u003C sz; i\u002B\u002B) {\r\n            list[i] = get_uint256(pos, i\u002B1);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract OptimisticRollup is UnstructuredStorage {\r\n    struct Message {\r\n        uint256[4] data;\r\n    }\r\n\r\n    struct TxExternalFields {\r\n        address owner;\r\n        Message[2] message;\r\n    }\r\n\r\n    struct Proof {\r\n        uint256[8] data;\r\n    }\r\n\r\n    struct VK {\r\n        uint256[] data;\r\n    }\r\n\r\n    struct Tx {\r\n        uint256 rootptr;\r\n        uint256[2] nullifier;\r\n        uint256[2] utxo;\r\n        IERC20 token;\r\n        uint256 delta;\r\n        TxExternalFields ext;\r\n        Proof proof;\r\n    }\r\n\r\n    struct BlockItem {\r\n        Tx ctx;\r\n        uint256 new_root;\r\n        uint256 deposit_blocknumber;\r\n    }\r\n    struct BlockItemNote {\r\n        bytes32[8] proof;\r\n        uint256 id;\r\n        BlockItem item;\r\n    }\r\n\r\n    struct UTXO {\r\n        address owner;\r\n        IERC20 token;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct PayNote {\r\n        UTXO utxo;\r\n        uint256 blocknumber;\r\n        uint256 txhash;\r\n    }\r\n\r\n    bytes32 constant PTR_ROLLUP_BLOCK = 0xd790c52c075936677813beed5aa36e1fce5549c1b511bc0277a6ae4213ee93d8; // zeropool.instance.rollup_block\r\n    bytes32 constant PTR_DEPOSIT_STATE = 0xc9bc9b91da46ecf8158f48c23ddba2c34e9b3dffbc3fcfd2362158d58383f80b; //zeropool.instance.deposit_state\r\n    bytes32 constant PTR_WITHDRAW_STATE = 0x7ad39ce31882298a63a0da3c9e2d38db2b34986c4be4550da17577edc0078639; //zeropool.instance.withdraw_state\r\n\r\n    bytes32 constant PTR_ROLLUP_TX_NUM = 0xeeb5c14c43ac322ae6567adef70b1c44e69fe064f5d4a67d8c5f0323c138f65e; //zeropool.instance.rollup_tx_num\r\n    bytes32 constant PTR_ALIVE = 0x58feb0c2bb14ff08ed56817b2d673cf3457ba1799ad05b4e8739e57359eaecc8; //zeropool.instance.alive\r\n    bytes32 constant PTR_TX_VK = 0x08cff3e7425cd7b0e33f669dbfb21a086687d7980e87676bf3641c97139fcfd3; //zeropool.instance.tx_vk\r\n    bytes32 constant PTR_TREE_UPDATE_VK = 0xf0f9fc4bf95155a0eed7d21afd3dfd94fade350663e7e1beccf42b5109244d86; //zeropool.instance.tree_update_vk\r\n    bytes32 constant PTR_VERSION = 0x0bf0574ec126ccd99fc2670d59004335a5c88189b4dc4c4736ba2c1eced3519c; //zeropool.instance.version\r\n    bytes32 constant PTR_RELAYER = 0xa6c0702dad889760bc0a910159487cf57ece87c3aff39b866b8eaec3ef42f09b; //zeropool.instance.relayer\r\n\r\n    function get_rollup_block(uint256 x) internal view returns(bytes32 value) {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_ROLLUP_BLOCK, x));\r\n        value = get_bytes32(pos);\r\n    }\r\n\r\n    function set_rollup_block(uint256 x, bytes32 value) internal {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_ROLLUP_BLOCK, x));\r\n        set_bytes32(pos, value);\r\n    }\r\n\r\n    function get_deposit_state(bytes32 x) internal view returns(uint256 value) {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_DEPOSIT_STATE, x));\r\n        value = get_uint256(pos);\r\n    }\r\n\r\n    function set_deposit_state(bytes32 x, uint256 value) internal {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_DEPOSIT_STATE, x));\r\n        set_uint256(pos, value);\r\n    }\r\n\r\n\r\n\r\n    function get_withdraw_state(bytes32 x) internal view returns(uint256 value) {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_WITHDRAW_STATE, x));\r\n        value = get_uint256(pos);\r\n    }\r\n\r\n    function set_withdraw_state(bytes32 x, uint256 value) internal {\r\n        bytes32 pos = keccak256(abi.encodePacked(PTR_WITHDRAW_STATE, x));\r\n        set_uint256(pos, value);\r\n    }\r\n\r\n\r\n\r\n    function get_rollup_tx_num() internal view returns(uint256 value) {\r\n        value = get_uint256(PTR_ROLLUP_TX_NUM);\r\n    }\r\n\r\n    function set_rollup_tx_num(uint256 value) internal {\r\n        set_uint256(PTR_ROLLUP_TX_NUM, value);\r\n    }\r\n\r\n    function get_alive() internal view returns(bool value) {\r\n        value = get_bool(PTR_ALIVE);\r\n    }\r\n\r\n    function set_alive(bool x) internal {\r\n        set_bool(PTR_ALIVE, x);\r\n    }\r\n\r\n    function get_tx_vk() internal view virtual returns(VK memory vk) {\r\n        vk.data = get_uint256_list(PTR_TX_VK);\r\n    }\r\n\r\n    function set_tx_vk(VK memory vk) internal {\r\n        set_uint256_list(PTR_TX_VK, vk.data);\r\n    }\r\n\r\n    function get_tree_update_vk() internal view virtual returns(VK memory vk) {\r\n        vk.data = get_uint256_list(PTR_TREE_UPDATE_VK);\r\n    }\r\n\r\n    function set_tree_update_vk(VK memory vk) internal {\r\n        set_uint256_list(PTR_TREE_UPDATE_VK, vk.data);\r\n    }\r\n\r\n    function get_version() internal view returns(uint256 value) {\r\n        value = get_uint256(PTR_VERSION);\r\n    }\r\n\r\n    function set_version(uint256 value) internal {\r\n        set_uint256(PTR_VERSION, value);\r\n    }\r\n\r\n    function get_relayer() internal view returns(address value) {\r\n        value = get_address(PTR_RELAYER);\r\n    }\r\n\r\n    function set_relayer(address value) internal {\r\n        set_address(PTR_RELAYER, value);\r\n    }\r\n\r\n\r\n    modifier onlyInitialized(uint256 version) {\r\n        require(get_version() == version, \u0022contract should be initialized\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlyUninitialized(uint256 version) {\r\n        require(get_version() \u003C version, \u0022contract should be uninitialized\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRelayer() {\r\n        require(msg.sender == get_relayer(), \u0022This is relayer-only action\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlive() {\r\n        require(get_alive(), \u0022Contract stopped\u0022);\r\n        _;\r\n    }\r\n\r\n\r\n    function blockItemNoteVerify(BlockItemNote memory note)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        (bytes32 itemhash, ) = blockItemHash(note.item);\r\n        return\r\n            MerkleProof.keccak256MerkleProof(\r\n                note.proof,\r\n                note.id \u0026 0xff,\r\n                itemhash\r\n            ) == get_rollup_block(note.id \u003E\u003E 8);\r\n    }\r\n\r\n    function blockItemNoteVerifyPair(\r\n        BlockItemNote memory note0,\r\n        BlockItemNote memory note1\r\n    ) internal view returns (bool) {\r\n        (bytes32 itemhash0,) = blockItemHash(note0.item);\r\n        (bytes32 itemhash1,) = blockItemHash(note1.item);\r\n\r\n\r\n        return\r\n            MerkleProof.keccak256MerkleProof(\r\n                note0.proof,\r\n                note0.id \u0026 0xff,\r\n                itemhash0\r\n            ) ==\r\n            get_rollup_block(note0.id \u003E\u003E 8) \u0026\u0026\r\n            MerkleProof.keccak256MerkleProof(\r\n                note1.proof,\r\n                note1.id \u0026 0xff,\r\n                itemhash1\r\n            ) ==\r\n            get_rollup_block(note1.id \u003E\u003E 8) \u0026\u0026\r\n            itemhash0 != itemhash1;\r\n    }\r\n\r\n    function blockItemHash(BlockItem memory item)\r\n        internal\r\n        pure\r\n        returns (bytes32 itemhash, bytes32 txhash)\r\n    {\r\n        txhash = keccak256(abi.encode(item.ctx));\r\n        itemhash = keccak256(\r\n            abi.encode(txhash, item.new_root, item.deposit_blocknumber)\r\n        );\r\n    }\r\n\r\n    function groth16verify(\r\n        VK memory vk,\r\n        Proof memory proof,\r\n        uint256[] memory inputs\r\n    ) internal view returns (bool) {\r\n        return Groth16Verifier.verify(vk.data, proof.data, inputs);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Zeropool is OptimisticRollup {\r\n    using AbstractERC20 for IERC20;\r\n\r\n    uint256 constant DEPOSIT_EXISTS = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant DEPOSIT_EXPIRES_BLOCKS = 480;\r\n    uint256 constant CHALLENGE_EXPIRES_BLOCKS = 480;\r\n    uint256 constant BN254_ORDER = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 constant MAX_AMOUNT = 1766847064778384329583297500742918515827483896875618958121606201292619776;\r\n\r\n    uint256 constant VERSION = 1;\r\n\r\n    event Deposit();\r\n    event DepositCancel();\r\n    event NewBlockPack();\r\n    event Withdraw();\r\n\r\n    function rollup_block(uint x) external view returns(bytes32) {\r\n        return get_rollup_block(x);\r\n    }\r\n\r\n    function deposit_state(bytes32 x) external view returns(uint256) {\r\n        return get_deposit_state(x);\r\n    }\r\n\r\n    function withdraw_state(bytes32 x) external view returns(uint256) {\r\n        return get_withdraw_state(x);\r\n    }\r\n\r\n    function rollup_tx_num() external view returns(uint256) {\r\n        return get_rollup_tx_num();\r\n    }\r\n\r\n    function alive() external view returns(bool) {\r\n        return get_alive();\r\n    }\r\n\r\n    function tx_vk() external view returns(VK memory) {\r\n        return get_tx_vk();\r\n    }\r\n\r\n    function tree_update_vk() external view returns(VK memory) {\r\n        return get_tree_update_vk();\r\n    }\r\n\r\n    function relayer() external view returns(address) {\r\n        return get_relayer();\r\n    }\r\n\r\n    function initialized() external view returns(bool) {\r\n        return get_version() \u003C VERSION;\r\n    }\r\n\r\n    function version() external view returns(uint256) {\r\n        return VERSION;\r\n    }\r\n\r\n    function challenge_expires_blocks() external view returns(uint256) {\r\n        return CHALLENGE_EXPIRES_BLOCKS;\r\n    }\r\n\r\n    function deposit_expires_blocks() external view returns(uint256) {\r\n        return DEPOSIT_EXPIRES_BLOCKS;\r\n    }\r\n\r\n    \r\n    function init(address relayer) external onlyUninitialized(VERSION) {\r\n        set_alive(true);\r\n        set_relayer(relayer);\r\n        set_version(VERSION);\r\n    }\r\n\r\n\r\n    function deposit(IERC20 token, uint256 amount, bytes32 txhash)\r\n        public\r\n        payable\r\n        returns (bool)\r\n    {\r\n        uint256 _amount = token.abstractReceive(amount);\r\n        bytes32 deposit_hash = keccak256(\r\n            abi.encode(msg.sender, token, _amount, block.number, txhash)\r\n        );\r\n        set_deposit_state(deposit_hash, DEPOSIT_EXISTS);\r\n        emit Deposit();\r\n        return true;\r\n    }\r\n\r\n    function depositCancel(PayNote memory d) public returns (bool) {\r\n        bytes32 deposit_hash = keccak256(abi.encode(d));\r\n        require(get_deposit_state(deposit_hash) \u003E= get_rollup_tx_num());\r\n        require(d.blocknumber \u003C block.number - DEPOSIT_EXPIRES_BLOCKS);\r\n        set_deposit_state(deposit_hash, 0);\r\n        d.utxo.token.abstractTransfer(d.utxo.owner, d.utxo.amount);\r\n        emit DepositCancel();\r\n        return true;\r\n    }\r\n\r\n    function withdraw(PayNote memory w) public returns (bool) {\r\n        bytes32 withdraw_hash = keccak256(abi.encode(w));\r\n        uint256 state = get_withdraw_state(withdraw_hash);\r\n        require(state \u003C get_rollup_tx_num() \u0026\u0026 state != 0);\r\n        require(w.blocknumber \u003C block.number - CHALLENGE_EXPIRES_BLOCKS);\r\n        set_withdraw_state(withdraw_hash, 0);\r\n        w.utxo.token.abstractTransfer(w.utxo.owner, w.utxo.amount);\r\n        emit Withdraw();\r\n        return true;\r\n    }\r\n\r\n    function publishBlock(\r\n        uint256 protocol_version,\r\n        BlockItem[] memory items,\r\n        uint256 rollup_cur_block_num,\r\n        uint256 blocknumber_expires\r\n    ) public onlyRelayer onlyAlive returns (bool) {\r\n        uint256 cur_rollup_tx_num = get_rollup_tx_num();\r\n\r\n        require(rollup_cur_block_num == cur_rollup_tx_num \u003E\u003E 8, \u0022wrong block number\u0022);\r\n        require(protocol_version == get_version(), \u0022wrong protocol version\u0022);\r\n        require(block.number \u003C blocknumber_expires, \u0022blocknumber is already expires\u0022);\r\n        uint256 nitems = items.length;\r\n        require(nitems \u003E 0 \u0026\u0026 nitems \u003C= 256, \u0022wrong number of items\u0022);\r\n        bytes32[] memory hashes = new bytes32[](nitems); \r\n        for (uint256 i = 0; i \u003C nitems; i\u002B\u002B) {\r\n            BlockItem memory item = items[i];\r\n            bytes32 itemhash = keccak256(abi.encode(item));\r\n            if (item.ctx.delta == 0) {\r\n                require(item.deposit_blocknumber == 0, \u0022deposit_blocknumber should be zero in transfer case\u0022);\r\n                require(item.ctx.token == IERC20(0), \u0022token should be zero in transfer case\u0022);\r\n                require(item.ctx.ext.owner == address(0), \u0022owner should be zero in tranfer case\u0022);\r\n            } else if (item.ctx.delta \u003C MAX_AMOUNT) {\r\n                bytes32 txhash = keccak256(abi.encode(item.ctx));\r\n                bytes32 deposit_hash = keccak256(\r\n                    abi.encode(\r\n                        item.ctx.ext.owner,\r\n                        item.ctx.token,\r\n                        item.ctx.delta,\r\n                        item.deposit_blocknumber,\r\n                        txhash\r\n                    )\r\n                );\r\n                require(get_deposit_state(deposit_hash) == DEPOSIT_EXISTS, \u0022unexisted deposit\u0022);\r\n                set_deposit_state(deposit_hash, cur_rollup_tx_num \u002B i);\r\n            } else if (\r\n                item.ctx.delta \u003E BN254_ORDER - MAX_AMOUNT \u0026\u0026\r\n                item.ctx.delta \u003C BN254_ORDER\r\n            ) {\r\n                require(item.deposit_blocknumber == 0, \u0022deposit blocknumber should be zero\u0022);\r\n                bytes32 txhash = keccak256(abi.encode(item.ctx));\r\n                bytes32 withdraw_hash = keccak256(\r\n                    abi.encode(\r\n                        item.ctx.ext.owner,\r\n                        item.ctx.token,\r\n                        BN254_ORDER - item.ctx.delta,\r\n                        block.number,\r\n                        txhash\r\n                    )\r\n                );\r\n                require(get_withdraw_state(withdraw_hash) == 0, \u0022withdrawal already published\u0022);\r\n                set_withdraw_state(withdraw_hash, cur_rollup_tx_num \u002B i);\r\n            } else revert(\u0022wrong behavior\u0022);\r\n\r\n            hashes[i] = itemhash;\r\n        }\r\n        set_rollup_block(cur_rollup_tx_num \u003E\u003E 8, MerkleProof.keccak256MerkleTree(hashes));\r\n        set_rollup_tx_num(cur_rollup_tx_num\u002B256);\r\n        emit NewBlockPack();\r\n        return true;\r\n    }\r\n\r\n    function stopRollup(uint256 lastvalid) internal returns (bool) {\r\n        set_alive(false);\r\n        if (get_rollup_tx_num() \u003E lastvalid) set_rollup_tx_num(lastvalid);\r\n    }\r\n\r\n    function challengeTx(BlockItemNote memory cur, BlockItemNote memory base)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(blockItemNoteVerifyPair(cur, base));\r\n        require(cur.item.ctx.rootptr == base.id);\r\n        uint256[] memory inputs = new uint256[](8);\r\n        inputs[0] = base.item.new_root;\r\n        inputs[1] = cur.item.ctx.nullifier[0];\r\n        inputs[2] = cur.item.ctx.nullifier[1];\r\n        inputs[3] = cur.item.ctx.utxo[0];\r\n        inputs[4] = cur.item.ctx.utxo[1];\r\n        inputs[5] = uint256(address(cur.item.ctx.token));\r\n        inputs[6] = cur.item.ctx.delta;\r\n        inputs[7] = uint256(keccak256(abi.encode(cur.item.ctx.ext))) % BN254_ORDER;\r\n        require(\r\n            !groth16verify(get_tx_vk(), cur.item.ctx.proof, inputs) ||\r\n                cur.item.ctx.rootptr \u003E= cur.id\r\n        );\r\n        stopRollup(\r\n            cur.id \u0026\r\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function challengeUTXOTreeUpdate(\r\n        BlockItemNote memory cur,\r\n        BlockItemNote memory prev,\r\n        uint256 right_root\r\n    ) public returns (bool) {\r\n        require(blockItemNoteVerifyPair(cur, prev));\r\n        require(right_root != cur.item.new_root);\r\n        require(cur.id == prev.id \u002B 1);\r\n        uint256[] memory inputs = new uint256[](5);\r\n        inputs[0] = prev.item.new_root;\r\n        inputs[1] = right_root;\r\n        inputs[2] = cur.id;\r\n        inputs[3] = cur.item.ctx.utxo[0];\r\n        inputs[4] = cur.item.ctx.utxo[1];\r\n        require(groth16verify(get_tree_update_vk(), cur.item.ctx.proof, inputs));\r\n        stopRollup(\r\n            cur.id \u0026\r\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n        );\r\n        return true;\r\n    }\r\n\r\n\r\n    function challengeDoubleSpend(\r\n        BlockItemNote memory cur,\r\n        BlockItemNote memory prev\r\n    ) public returns (bool) {\r\n        require(blockItemNoteVerifyPair(cur, prev));\r\n        require(cur.id \u003E prev.id);\r\n        require(\r\n            cur.item.ctx.nullifier[0] == prev.item.ctx.nullifier[0] ||\r\n                cur.item.ctx.nullifier[0] == prev.item.ctx.nullifier[1] ||\r\n                cur.item.ctx.nullifier[1] == prev.item.ctx.nullifier[0] ||\r\n                cur.item.ctx.nullifier[1] == prev.item.ctx.nullifier[1]\r\n        );\r\n        stopRollup(\r\n            cur.id \u0026\r\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function get_tx_vk() internal view override returns(VK memory vk) {\r\n        vk.data = new uint256[](32);\r\n        vk.data[0]=19083586676618588181241121022189148302115143846265274057634178515789425541522;\r\n        vk.data[1]=81734682709379119351827372382537914395894451632304720162641755645366983798;\r\n        vk.data[2]=16679280894448720904271619622322935704907133145325731398178004167577694529227;\r\n        vk.data[3]=18903228601511502126689470199990445541001999715180404375185816963613836226871;\r\n        vk.data[4]=13663046271244275377110314674352295289375922770501900119517982950566589877684;\r\n        vk.data[5]=483564168571897182620192451626088133502163507143046326440329211112918462121;\r\n        vk.data[6]=16559501001022932569082979771706263430444179087536500138963585085420349463423;\r\n        vk.data[7]=9623523168201514583905748483990657180016245907539253075218220414153350351588;\r\n        vk.data[8]=15229833583426402205040012031514697850254522821399893249033342086777726726387;\r\n        vk.data[9]=470744398001273857874068942689229495046933554389747311037076260496752269445;\r\n        vk.data[10]=7673153833418048608469768353079552808897009992555599048955952346794508568713;\r\n        vk.data[11]=20379255055398732280007411055330162490556363195411029740820409749858706847271;\r\n        vk.data[12]=14010980108123452341370355032177269282369172322265972028032623852596015548054;\r\n        vk.data[13]=2010602694298321371261220080637523955877174725166197144793463796546935369505;\r\n        vk.data[14]=11827331641970848249018791507060402639646550381469697186630320984054879658051;\r\n        vk.data[15]=19932135227873747734819495633162631095088044686013642058128603008109991517122;\r\n        vk.data[16]=546122717728821753109262933924329929044483964972534585973243989084670247618;\r\n        vk.data[17]=19197882504173222291305676798186060802889772643656145364396607969858777473240;\r\n        vk.data[18]=3079025494427420850726249161830635142714776092295867140934586860665303421073;\r\n        vk.data[19]=1746154312538307698308659684236359377970307266169477233342774307494313734528;\r\n        vk.data[20]=1750668962583592559453347582962590422049028854549021550631836347968156757666;\r\n        vk.data[21]=2931884338830192964620366885212045740331032389508054587765082964515210137243;\r\n        vk.data[22]=11609728864371463760676563597128352259642122426143489337585644580377141052931;\r\n        vk.data[23]=1866277750873051808146539269994848083702239908128741416703314476768274967681;\r\n        vk.data[24]=465030135085710467652667684166181145297022174953119695491126249786799875357;\r\n        vk.data[25]=17668359420526036744621277058559131057906391358066238174656362416578048367407;\r\n        vk.data[26]=3940679183641598670389691491834622231072482332882496391070085402176937010683;\r\n        vk.data[27]=12694154800574632930051430635795823357916331205102627903153800201217894579182;\r\n        vk.data[28]=12563334585418485878062402673132487192719820069663338406400779005058051755705;\r\n        vk.data[29]=5209903608427988355675301381596891515874164017265170558927935483532854452720;\r\n        vk.data[30]=4711050179634069730545115815176569247145595365948880376685610817304093187820;\r\n        vk.data[31]=21460592003295140913387788532402788293301885890452135973712845209086748235272;\r\n\r\n    }\r\n\r\n    function get_tree_update_vk() internal view override returns(VK memory vk) {\r\n        vk.data = new uint256[](26);\r\n        vk.data[0]=9927341460547029852728753500861773344387749035454992176911679192877917614326;\r\n        vk.data[1]=310328084359652166416267459817042255667278116507978414962149299352000101062;\r\n        vk.data[2]=493386504816853366900876821815568508001070316137556861279567937498920001698;\r\n        vk.data[3]=16050960967588593014951452003751705261313151560742102282632329345311357239925;\r\n        vk.data[4]=18156825847965851663862032625267397386086907754120404739408152740543974835318;\r\n        vk.data[5]=13176645693861093810865249899400529123699743741662616180305647975362184695600;\r\n        vk.data[6]=3391499851638059043956782863656586962612506772240835221934169170634234404332;\r\n        vk.data[7]=18268392206599546967104090708600896194600052410608389302726346605813459216009;\r\n        vk.data[8]=9098516986151439176894052362065284716471176875021298523969161367191564971456;\r\n        vk.data[9]=21885959143027836841302233615802174732603365104028875126092282165099265354414;\r\n        vk.data[10]=7670129283807378608625935909491095310213110566554408388065601560701095056703;\r\n        vk.data[11]=7130671474784991141182176526112718975966743466548387852301799633388110224168;\r\n        vk.data[12]=7937204630097084792238930540546978973700729757604694893164413509926070951259;\r\n        vk.data[13]=8407545396818988186449632509683943447654086022799995289006209791993391255704;\r\n        vk.data[14]=14664733377421451839490066683507349204055901257585797506684042433113436019171;\r\n        vk.data[15]=15840252407256494288533360651859793129109626723586685795424274635231317501541;\r\n        vk.data[16]=8032564315529499388720047507429189045976255560471359137390391762122700869379;\r\n        vk.data[17]=11808348160251057184662622624151545848292988533362288568600116898463819914493;\r\n        vk.data[18]=17498019560129459819857213920026201288274979451999480899071607815743841786851;\r\n        vk.data[19]=17384624495734085926685188734246885503312994753956080725596119437833880269858;\r\n        vk.data[20]=1931156580513819053647675364989716628750838477923695514965816971171051219699;\r\n        vk.data[21]=14867384809644522547574123774078983448833920647089298299288805612229559369381;\r\n        vk.data[22]=9168948929820716748276018995954887992460226156428826222193421889623724755643;\r\n        vk.data[23]=18179132919376470282821059367416443269176558413791609646146920482342253978853;\r\n        vk.data[24]=13165221823254245976824310993558969475591080705095640808847370569633878849829;\r\n        vk.data[25]=9543821152288846320507592056661134387108520634609559855537650326371475631556;\r\n\r\n    }\r\n\r\n\r\n}","ABI":"[{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022Deposit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022DepositCancel\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022NewBlockPack\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022Withdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022alive\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022cur\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022prev\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022challengeDoubleSpend\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022cur\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022base\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022challengeTx\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022cur\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022bytes32[8]\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[8]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem\u0022,\u0022name\u0022:\u0022item\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItemNote\u0022,\u0022name\u0022:\u0022prev\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022right_root\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022challengeUTXOTreeUpdate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022challenge_expires_blocks\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022txhash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.UTXO\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022txhash\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.PayNote\u0022,\u0022name\u0022:\u0022d\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022depositCancel\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022deposit_expires_blocks\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022deposit_state\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022init\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022initialized\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022protocol_version\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rootptr\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022nullifier\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022uint256[2]\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022uint256[2]\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022delta\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[4]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[4]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Message[2]\u0022,\u0022name\u0022:\u0022message\u0022,\u0022type\u0022:\u0022tuple[2]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.TxExternalFields\u0022,\u0022name\u0022:\u0022ext\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[8]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[8]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Proof\u0022,\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.Tx\u0022,\u0022name\u0022:\u0022ctx\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022new_root\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit_blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.BlockItem[]\u0022,\u0022name\u0022:\u0022items\u0022,\u0022type\u0022:\u0022tuple[]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rollup_cur_block_num\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022blocknumber_expires\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022publishBlock\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022relayer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022rollup_block\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022rollup_tx_num\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022tree_update_vk\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.VK\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022tx_vk\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.VK\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022version\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.UTXO\u0022,\u0022name\u0022:\u0022utxo\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022blocknumber\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022txhash\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct OptimisticRollup.PayNote\u0022,\u0022name\u0022:\u0022w\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022withdraw_state\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"Zeropool","CompilerVersion":"v0.6.1\u002Bcommit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"ipfs://e383d81fb9da06af7418e14537a055143d87650016d65494daa5f4d9d62a9d1d"}]