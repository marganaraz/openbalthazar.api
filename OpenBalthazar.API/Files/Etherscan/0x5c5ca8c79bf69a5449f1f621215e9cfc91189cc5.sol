[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n\r\n/*\r\n0x5c5cA8c79bf69a5449F1F621215E9Cfc91189Cc5\r\n\r\n\r\nLAVAWALLET is a Meta Transaction Solution using EIP 712\r\n\r\n\r\nSimply approve your tokens to this contract to give them super powers!\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b \u003E 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b \u003C= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    assert(c \u003E= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v \u003C 27) {\r\n      v \u002B= 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 \u0026\u0026 v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n\r\ncontract RelayAuthorityInterface {\r\n    function getRelayAuthority() public returns (address);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LavaWallet is ECRecovery{\r\n\r\n  using SafeMath for uint;\r\n\r\n   mapping(bytes32 =\u003E uint256) burnedSignatures;\r\n\r\n\r\n\r\n  struct LavaPacket {\r\n    string methodName;\r\n    address relayAuthority; //either a contract or an account\r\n    address from;\r\n    address to;\r\n    address wallet;  //this contract address\r\n    address token;\r\n    uint256 tokens;\r\n    uint256 relayerRewardTokens;\r\n    uint256 expires;\r\n    uint256 nonce;\r\n  }\r\n\r\n\r\n  /*\r\n      MUST update these if architecture changes !!\r\n      MAKE SURE there are NO spaces !\r\n  */\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n          \u0022EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)\u0022\r\n      );\r\n\r\n   function getLavaDomainTypehash() public pure returns (bytes32) {\r\n      return EIP712DOMAIN_TYPEHASH;\r\n   }\r\n\r\n    function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\r\n\r\n      return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(contractName)),\r\n            keccak256(bytes(version)),\r\n            chainId,\r\n            verifyingContract\r\n        ));\r\n    }\r\n\r\n\r\n\r\n\r\n  bytes32 constant LAVAPACKET_TYPEHASH = keccak256(\r\n      \u0022LavaPacket(string methodName,address relayAuthority,address from,address to,address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce)\u0022\r\n  );\r\n\r\n\r\n\r\n    function getLavaPacketTypehash()  public pure returns (bytes32) {\r\n      return LAVAPACKET_TYPEHASH;\r\n  }\r\n\r\n\r\n\r\n   function getLavaPacketHash(string memory methodName, address relayAuthority,address from,address to, address wallet, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public pure returns (bytes32) {\r\n          return keccak256(abi.encode(\r\n              LAVAPACKET_TYPEHASH,\r\n              keccak256(bytes(methodName)),\r\n              relayAuthority,\r\n              from,\r\n              to,\r\n              wallet,\r\n              token,\r\n              tokens,\r\n              relayerRewardTokens,\r\n              expires,\r\n              nonce\r\n          ));\r\n      }\r\n\r\n\r\n   constructor(  ) public {\r\n\r\n\r\n  }\r\n\r\n\r\n  //do not allow ether to enter\r\n  function() external payable {\r\n      revert();\r\n  }\r\n\r\n\r\n\r\n    // Make sure the change the chainID here if deploying to a testnet\r\n      function getLavaTypedDataHash(string memory methodName, address relayAuthority,address from,address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public view returns (bytes32) {\r\n\r\n\r\n              // Note: we need to use \u0060encodePacked\u0060 here instead of \u0060encode\u0060.\r\n              bytes32 digest = keccak256(abi.encodePacked(\r\n                  \u0022\\x19\\x01\u0022,\r\n                  getEIP712DomainHash(\u0027Lava Wallet\u0027,\u00271\u0027,1,address(this)),\r\n                  getLavaPacketHash(methodName,relayAuthority,from,to,wallet,token,tokens,relayerRewardTokens,expires,nonce)\r\n              ));\r\n              return digest;\r\n          }\r\n\r\n\r\n\r\n        /*\r\n        This uses the metaTX signature and the fact that the ERC20 tokens are Approved to this contract to send them out via the relays eth TX.\r\n\r\n        */\r\n\r\n   function _validatePacketSignature(  string memory methodName, address relayAuthority,address from,address to, address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) internal returns (bool success)\r\n   {\r\n       address wallet = address(this);\r\n\r\n\r\n\r\n       /*\r\n        Always allow relaying if the specified relayAuthority is 0.\r\n        If the authority address is not a contract, allow it to relay\r\n        If the authority address is a contract, allow its defined \u0027getAuthority()\u0027 delegate to relay\r\n       */\r\n\r\n       require( relayAuthority == address(0x0)\r\n         || (!addressContainsContract(relayAuthority) \u0026\u0026 msg.sender == relayAuthority)\r\n         || (addressContainsContract(relayAuthority) \u0026\u0026 msg.sender == RelayAuthorityInterface(relayAuthority).getRelayAuthority())  );\r\n\r\n\r\n         //check to make sure that signature == ecrecover signature\r\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n\r\n         address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n\r\n          //make sure the signer is the depositor of the tokens\r\n          require(from == recoveredSignatureSigner);\r\n\r\n\r\n          //make sure the signature has not expired\r\n          require(block.number \u003C expires || expires == 0);\r\n\r\n          uint burnedSignature = burnedSignatures[sigHash];\r\n          burnedSignatures[sigHash] = 0x1; //spent\r\n          require(burnedSignature == 0x0 );\r\n\r\n\r\n         //remember to tip your relayer!\r\n         require( ERC20Interface(token).transferFrom(from, msg.sender, relayerRewardTokens )  );\r\n\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n   //why wont this work w approve ??\r\n   function _transferTokens(address to, address token, uint tokens) internal returns (bool success) {\r\n         ERC20Interface(token).transfer(to, tokens );\r\n\r\n         return true;\r\n    }\r\n\r\n\r\n    ///transfer tokens within the lava balances\r\n    //Requires approval\r\n   function _transferTokensFrom( address from, address to,address token,  uint tokens) internal returns (bool success) {\r\n        ERC20Interface(token).transferFrom(from, to, tokens );  //??\r\n\r\n       return true;\r\n   }\r\n\r\n\r\n\r\n   /*\r\n    Approves lava tokens for another smart contract (\u0027TO field\u0027) and call the contracts receiveApproval method all in one fell swoop\r\n\r\n    */\r\n\r\n    function approveAndCallWithSignature( string memory methodName, address relayAuthority,address from,address to,   address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature ) public returns (bool success)   {\r\n\r\n       require(!bytesEqual(\u0027transfer\u0027,bytes(methodName)));\r\n\r\n\r\n       require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\r\n\r\n       bytes memory method = bytes(methodName);\r\n\r\n       _sendApproveAndCall(from,to,token,tokens,method);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _sendApproveAndCall(address from, address to, address token, uint tokens, bytes memory methodName) internal\r\n    {\r\n        ApproveAndCallFallBack(to).receiveApproval(from, tokens, token, bytes(methodName));\r\n    }\r\n\r\n\r\n\r\n   function transferTokensWithSignature(string memory methodName, address relayAuthority, address from, address to, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)\r\n {\r\n\r\n     require(bytesEqual(\u0027transfer\u0027,bytes(methodName)));\r\n\r\n\r\n     require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\r\n\r\n     require( ERC20Interface(token).transferFrom(from,  to, tokens )  );\r\n\r\n\r\n     return true;\r\n\r\n }\r\n\r\n function burnSignature(string memory methodName, address relayAuthority, address from, address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) public returns (bool success)\r\n      {\r\n\r\n\r\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\r\n\r\n          address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n          //make sure the invalidator is the signer\r\n          require(recoveredSignatureSigner == from);\r\n\r\n          //only the original packet owner can burn signature, not a relay\r\n          require(from == msg.sender);\r\n\r\n          //make sure this signature has never been used\r\n          uint burnedSignature = burnedSignatures[sigHash];\r\n          burnedSignatures[sigHash] = 0x2; //invalidated\r\n          require(burnedSignature == 0x0);\r\n\r\n          return true;\r\n      }\r\n\r\n\r\n\r\n     function signatureBurnStatus(bytes32 digest) public view returns (uint)\r\n     {\r\n       return (burnedSignatures[digest]);\r\n     }\r\n\r\n     function signatureIsValid(string memory methodName, address relayAuthority,address from,address to, address wallet,address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public view returns (bool success)\r\n   {\r\n\r\n        //check to make sure that signature == ecrecover signature\r\n       bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\r\n\r\n\r\n       address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n\r\n       return  (from == recoveredSignatureSigner) ;\r\n\r\n   }\r\n\r\n\r\n       /*\r\n         Receive approval to spend tokens and perform any action all in one transaction\r\n       */\r\n     /*function receiveApproval(address from, uint256 tokens, address token, bytes data) public returns (bool success) {\r\n\r\n\r\n        // do something ?\r\n\r\n     }*/\r\n \r\n\r\n\r\n     function addressContainsContract(address _to) view internal returns (bool)\r\n     {\r\n       uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n         return (codeLength\u003E0);\r\n     }\r\n\r\n\r\n     function bytesEqual(bytes memory b1,bytes memory b2) pure internal returns (bool)\r\n        {\r\n          if(b1.length != b2.length) return false;\r\n\r\n          for (uint i=0; i\u003Cb1.length; i\u002B\u002B) {\r\n            if(b1[i] != b2[i]) return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n\r\n}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022approveAndCallWithSignature\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022burnSignature\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022contractName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022version\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022chainId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022verifyingContract\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getEIP712DomainHash\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLavaDomainTypehash\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getLavaPacketHash\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLavaPacketTypehash\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getLavaTypedDataHash\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022digest\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022signatureBurnStatus\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022signatureIsValid\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022methodName\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022relayAuthority\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022relayerRewardTokens\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022transferTokensWithSignature\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"LavaWallet","CompilerVersion":"v0.5.16\u002Bcommit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://608421ca71d0c3f32b57dc88735f8f85c46e47c014d4098de6e2c69c64fff354"}]