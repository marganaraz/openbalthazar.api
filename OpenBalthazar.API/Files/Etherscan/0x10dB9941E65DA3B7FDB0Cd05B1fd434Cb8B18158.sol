[{"SourceCode":"#------------------------------------------------------------------------------\r\n#\r\n#   Copyright 2019 Fetch.AI Limited\r\n#\r\n#   Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n#   you may not use this file except in compliance with the License.\r\n#   You may obtain a copy of the License at\r\n#\r\n#       http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n#   Unless required by applicable law or agreed to in writing, software\r\n#   distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n#   See the License for the specific language governing permissions and\r\n#   limitations under the License.\r\n#\r\n#------------------------------------------------------------------------------\r\nfrom vyper.interfaces import ERC20\r\n\r\nunits: {\r\n    tok: \u0022smallest ERC20 token unit\u0022,\r\n}\r\n\r\n# maximum possible number of stakers a new auction can specify\r\nMAX_SLOTS: constant(uint256) = 300\r\n# number of blocks during which the auction remains open at reserve price\r\nRESERVE_PRICE_DURATION: constant(uint256) = 25  # number of blocks\r\n# number of seconds before deletion of the contract becomes possible after last lockupEnd() call\r\nDELETE_PERIOD: constant(timedelta) = 60 * (3600 * 24)\r\n# defining the decimals supported in pool rewards per token\r\nREWARD_PER_TOK_DENOMINATOR: constant(uint256(tok)) = 100000\r\n\r\n# Structs\r\nstruct Auction:\r\n    finalPrice: uint256(tok)\r\n    lockupEnd: uint256\r\n    slotsSold: uint256\r\n    start: uint256\r\n    end: uint256\r\n    startStake: uint256(tok)\r\n    reserveStake: uint256(tok)\r\n    declinePerBlock: uint256(tok)\r\n    slotsOnSale: uint256\r\n    uniqueStakers: uint256\r\n\r\nstruct Pledge:\r\n    amount: uint256(tok)\r\n    AID: uint256\r\n\r\nstruct Pool:\r\n    remainingReward: uint256(tok)\r\n    rewardPerTok: uint256(tok)\r\n    AID: uint256\r\n\r\n# Events\r\nBid: event({AID: uint256, _from: indexed(address), currentPrice: uint256(tok), amount: uint256(tok)})\r\nNewAuction: event({AID: uint256, start: uint256, end: uint256,\r\n    lockupEnd: uint256, startStake: uint256(tok), reserveStake: uint256(tok),\r\n    declinePerBlock: uint256(tok), slotsOnSale: uint256,\r\n    rewardPerSlot: uint256(tok)})\r\nPoolRegistration: event({AID: uint256, _address: address,\r\n    maxStake: uint256(tok), rewardPerTok: uint256(tok)})\r\nNewPledge: event({AID: uint256, _from: indexed(address), operator: address, amount: uint256(tok)})\r\nAuctionFinalised: event({AID: uint256, finalPrice: uint256(tok), slotsSold: uint256(tok)})\r\nLockupEnded: event({AID: uint256})\r\nAuctionAborted: event({AID: uint256, rewardsPaid: bool})\r\n\r\n# Contract state\r\ntoken: ERC20\r\nowner: public(address)\r\nearliestDelete: public(timestamp)\r\n# address -\u003E uint256 Slots a staker has won in the current auction (cleared at endLockup())\r\nstakerSlots: map(address, uint256)\r\n# auction winners\r\nstakers: address[MAX_SLOTS]\r\n\r\n# pledged stake \u002B committed pool reward, excl. selfStakerDeposit; pool -\u003E deposits\r\npledgedDeposits: public(map(address, uint256(tok)))\r\n# staker (through pool) -\u003E Pledge{pool, amount}\r\npoolStakerDeposits: public(map(address, Pledge))\r\n# staker (directly) -\u003E amount\r\nselfStakerDeposits: public(map(address, uint256(tok)))\r\n# staker (directly) -\u003E price at which the bid was made\r\nbidAtPrice: public(map(address, uint256(tok)))\r\n# pool address -\u003E Pool\r\nregisteredPools: public(map(address, Pool))\r\n\r\n# Auction details\r\ncurrentAID: public(uint256)\r\nauction: public(Auction)\r\ntotalAuctionRewards: public(uint256(tok))\r\nrewardPerSlot: public(uint256(tok))\r\n\r\n################################################################################\r\n# Constant functions\r\n################################################################################\r\n# @notice True from auction initialisation until either we hit the lower bound on being clear or\r\n#   the auction finalised through finaliseAuction()\r\n@private\r\n@constant\r\ndef _isBiddingPhase() -\u003E bool:\r\n    return ((self.auction.lockupEnd \u003E 0)\r\n            and (block.number \u003C self.auction.end)\r\n            and (self.auction.slotsSold \u003C self.auction.slotsOnSale)\r\n            and (self.auction.finalPrice == 0))\r\n\r\n# @notice Returns true if either the auction has been finalised or the lockup has ended\r\n# @dev self.auction will be cleared in endLockup() call\r\n# @dev reserveStake \u003E 0 condition in initialiseAuction() guarantees that finalPrice = 0 can never be\r\n#   a valid final price\r\n@private\r\n@constant\r\ndef _isFinalised() -\u003E bool:\r\n    return (self.auction.finalPrice \u003E 0) or (self.auction.lockupEnd == 0)\r\n\r\n# @notice Calculate the scheduled, linearly declining price of the dutch auction\r\n@private\r\n@constant\r\ndef _getScheduledPrice() -\u003E uint256(tok):\r\n    startStake_: uint256(tok) = self.auction.startStake\r\n    start: uint256 = self.auction.start\r\n    if (block.number \u003C= start):\r\n        return startStake_\r\n    else:\r\n        # do not calculate max(startStake - decline, reserveStake) as that could throw on negative startStake - decline\r\n        decline: uint256(tok) = min(self.auction.declinePerBlock * (block.number - start),\r\n                                    startStake_ - self.auction.reserveStake)\r\n        return startStake_ - decline\r\n\r\n# @notice Returns the scheduled price of the auction until the auction is finalised. Then returns\r\n#   the final price.\r\n# @dev Auction price declines linearly from auction.start over _duration, then\r\n# stays at _reserveStake for RESERVE_PRICE_DURATION\r\n# @dev Returns zero If no auction is in bidding or lock-up phase\r\n@private\r\n@constant\r\ndef _getCurrentPrice() -\u003E (uint256(tok)):\r\n    if self._isFinalised():\r\n        return self.auction.finalPrice\r\n    else:\r\n        scheduledPrice: uint256(tok) = self._getScheduledPrice()\r\n        return scheduledPrice\r\n\r\n# @notice Returns the lockup needed by an address that stakes directly\r\n# @dev Will throw if _address is a bidder in current auction \u0026 auciton not yet finalised, as the\r\n#   slot number \u0026 price are not final yet\r\n# @dev Calling endLockup() will clear all stakerSlots flags and thereby set the required\r\n#   lockups to 0 for all participants\r\n@private\r\n@constant\r\ndef _calculateSelfStakeNeeded(_address: address) -\u003E uint256(tok):\r\n    selfStakeNeeded: uint256(tok)\r\n    # these slots can be outdated if auction is not yet finalised / lockup hasn\u0027t ended yet\r\n    slotsWon: uint256 = self.stakerSlots[_address]\r\n\r\n    if slotsWon \u003E 0:\r\n        assert self._isFinalised(), \u0022Is bidder and auction not finalised yet\u0022\r\n        pledgedDeposit: uint256(tok) = self.pledgedDeposits[_address]\r\n        currentPrice: uint256(tok) = self._getCurrentPrice()\r\n\r\n        if (slotsWon * currentPrice) \u003E pledgedDeposit:\r\n            selfStakeNeeded \u002B= (slotsWon * currentPrice) - pledgedDeposit\r\n    return selfStakeNeeded\r\n\r\n################################################################################\r\n# Main functions\r\n################################################################################\r\n@public\r\ndef __init__(_ERC20Address: address):\r\n    self.owner = msg.sender\r\n    self.token = ERC20(_ERC20Address)\r\n\r\n# @notice Owner can initialise new auctions\r\n# @dev First auction starts with AID 1\r\n# @dev Requires the transfer of _reward to the contract to be approved with the\r\n#   underlying ERC20 token\r\n# @param _start: start of the price decay\r\n# @param _startStake: initial auction price\r\n# @param _reserveStake: lowest possible auction price \u003E= 1\r\n# @param _duration: duration over which the auction price declines. Total bidding\r\n#   duration is _duration \u002B RESERVE_PRICE_DURATION\r\n# @param _lockup_duration: number of blocks the lockup phase will last\r\n# @param _slotsOnSale: size of the assembly in this cycle\r\n# @param _reward: added to any remaining reward of past auctions\r\n@public\r\ndef initialiseAuction(_start: uint256,\r\n                      _startStake: uint256(tok),\r\n                      _reserveStake: uint256(tok),\r\n                      _duration: uint256,\r\n                      _lockup_duration: uint256,\r\n                      _slotsOnSale: uint256,\r\n                      _reward: uint256(tok)):\r\n    assert msg.sender == self.owner, \u0022Owner only\u0022\r\n    assert _startStake \u003E _reserveStake, \u0022Invalid startStake\u0022\r\n    assert (_slotsOnSale \u003E 0) and (_slotsOnSale \u003C= MAX_SLOTS), \u0022Invald slot number\u0022\r\n    assert _start \u003E= block.number, \u0022Start before current block\u0022\r\n    # NOTE: _isFinalised() relies on this requirement\r\n    assert _reserveStake \u003E 0, \u0022Reserve stake has to be at least 1\u0022\r\n    assert self.auction.lockupEnd == 0, \u0022End current auction\u0022\r\n\r\n    self.currentAID \u002B= 1\r\n\r\n    # Use integer-ceil() of the fraction with (\u002B _duration - 1)\r\n    declinePerBlock: uint256(tok) = (_startStake - _reserveStake \u002B _duration - 1) / _duration\r\n    end: uint256 = _start \u002B _duration \u002B RESERVE_PRICE_DURATION\r\n    self.auction.start = _start\r\n    self.auction.end = end\r\n    self.auction.lockupEnd = end \u002B _lockup_duration\r\n    self.auction.startStake = _startStake\r\n    self.auction.reserveStake = _reserveStake\r\n    self.auction.declinePerBlock = declinePerBlock\r\n    self.auction.slotsOnSale = _slotsOnSale\r\n    # Also acts as the last checked price in _updatePrice()\r\n    self.auction.finalPrice = 0\r\n\r\n    # add auction rewards\r\n    self.totalAuctionRewards \u002B= _reward\r\n    self.rewardPerSlot = self.totalAuctionRewards / self.auction.slotsOnSale\r\n    success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(_reward))\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n    log.NewAuction(self.currentAID, _start, end, end \u002B _lockup_duration, _startStake,\r\n                   _reserveStake, declinePerBlock, _slotsOnSale, self.rewardPerSlot)\r\n\r\n# @notice Move unclaimed auction rewards back to the contract owner\r\n# @dev Requires that no auction is in bidding or lockup phase\r\n@public\r\ndef retrieveUndistributedAuctionRewards():\r\n    assert msg.sender == self.owner, \u0022Owner only\u0022\r\n    assert self._isBiddingPhase() == False, \u0022In bidding phase\u0022\r\n    assert self.auction.lockupEnd == 0, \u0022Lockup ongoing\u0022\r\n    undistributed: uint256(tok) = self.totalAuctionRewards\r\n    clear(self.totalAuctionRewards)\r\n\r\n    success: bool = self.token.transfer(self.owner, as_unitless_number(undistributed))\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n# @notice The owner can clear the auction and all recorded slots in the case of an emergency and\r\n# thereby immediately lift any lockups and allow the immediate withdrawal of any made deposits.\r\n# @param payoutRewards: whether rewards get distributed to bidders\r\n@public\r\ndef abortAuction(payoutRewards: bool):\r\n    assert msg.sender == self.owner, \u0022Owner only\u0022\r\n    assert self.auction.lockupEnd \u003E 0, \u0022Nothing to abort\u0022\r\n\r\n    staker: address\r\n    rewardPerSlot_: uint256(tok)\r\n    slotsSold: uint256 = self.auction.slotsSold\r\n\r\n    if payoutRewards:\r\n        assert self._isFinalised(), \u0022Not finalised\u0022\r\n        rewardPerSlot_ = self.rewardPerSlot\r\n        self.totalAuctionRewards -= slotsSold * rewardPerSlot_\r\n\r\n    for i in range(MAX_SLOTS):\r\n        staker = self.stakers[i]\r\n        if staker == ZERO_ADDRESS:\r\n            break\r\n\r\n        if payoutRewards:\r\n            self.selfStakerDeposits[staker] \u002B= self.stakerSlots[staker] * rewardPerSlot_\r\n        clear(self.stakerSlots[staker])\r\n\r\n    clear(self.stakers)\r\n    clear(self.auction)\r\n    clear(self.rewardPerSlot)\r\n\r\n    log.AuctionAborted(self.currentAID, payoutRewards)\r\n\r\n\r\n# @notice Enter a bid into the auction. Requires the sender\u0027s deposits \u002B _topup \u003E= currentPrice or\r\n#   specify _topup = 0 to automatically calculate and transfer the topup needed to make a bid at the\r\n#   current price. Beforehand the sender must have approved the ERC20 contract to allow the transfer\r\n#   of at least the topup to the auction contract via ERC20.approve(auctionContract.address, amount)\r\n# @param _topup: Set to 0 to bid current price (automatically calculating and transfering required topup),\r\n#   o/w it will be interpreted as a topup to the existing deposits\r\n# @dev Only one bid per address and auction allowed, as time of bidding also specifies the priority\r\n#   in slot allocation\r\n# @dev No bids below current auction price allowed\r\n@public\r\ndef bid(_topup: uint256(tok)):\r\n    assert self._isBiddingPhase(), \u0022Not in bidding phase\u0022\r\n    assert self.stakerSlots[msg.sender] == 0, \u0022Sender already bid\u0022\r\n\r\n    _currentAID: uint256 = self.currentAID\r\n    currentPrice: uint256(tok) = self._getCurrentPrice()\r\n    totDeposit: uint256(tok) = self.pledgedDeposits[msg.sender] \u002B self.selfStakerDeposits[msg.sender]\r\n\r\n    # cannot modify input argument\r\n    topup: uint256(tok) = _topup\r\n    if (currentPrice \u003E totDeposit) and(_topup == 0):\r\n        topup = currentPrice - totDeposit\r\n    else:\r\n        assert totDeposit \u002B topup \u003E= currentPrice, \u0022Bid below current price\u0022\r\n\r\n    # Update deposits \u0026 stakers\r\n    self.bidAtPrice[msg.sender] = currentPrice\r\n    self.selfStakerDeposits[msg.sender] \u002B= topup\r\n    slots: uint256 = min((totDeposit \u002B topup) / currentPrice, self.auction.slotsOnSale - self.auction.slotsSold)\r\n    self.stakerSlots[msg.sender] = slots\r\n    self.auction.slotsSold \u002B= slots\r\n    self.stakers[self.auction.uniqueStakers] = msg.sender\r\n    self.auction.uniqueStakers \u002B= 1\r\n\r\n    # If pool: move unclaimed rewards and clear\r\n    if self.registeredPools[msg.sender].AID == _currentAID:\r\n        unclaimed: uint256(tok) = self.registeredPools[msg.sender].remainingReward\r\n        clear(self.registeredPools[msg.sender])\r\n        self.pledgedDeposits[msg.sender] -= unclaimed\r\n        self.selfStakerDeposits[msg.sender] \u002B= unclaimed\r\n\r\n    # Transfer topup if necessary\r\n    if topup \u003E 0:\r\n        success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(topup))\r\n        assert success, \u0022Transfer failed\u0022\r\n    log.Bid(_currentAID, msg.sender, currentPrice, totDeposit \u002B topup)\r\n\r\n# @Notice Anyone can supply the correct final price to finalise the auction and calculate the number of slots each\r\n#   staker has won. Required before lock-up can be ended or withdrawals can be made\r\n# @param finalPrice: proposed solution for the final price. Throws if not the correct solution\r\n# @dev Allows to move the calculation of the price that clear the auction off-chain\r\n@public\r\ndef finaliseAuction(finalPrice: uint256(tok)):\r\n    currentPrice: uint256(tok) = self._getCurrentPrice()\r\n    assert finalPrice \u003E= currentPrice, \u0022Suggested solution below current price\u0022\r\n    assert self.auction.finalPrice == 0, \u0022Auction already finalised\u0022\r\n    assert self.auction.lockupEnd \u003E= 0, \u0022Lockup has already ended\u0022\r\n\r\n    slotsOnSale: uint256 = self.auction.slotsOnSale\r\n    slotsRemaining: uint256 = slotsOnSale\r\n    slotsRemainingP1: uint256 = slotsOnSale\r\n    finalPriceP1: uint256(tok) = finalPrice \u002B 1\r\n\r\n    uniqueStakers_int128: int128 = convert(self.auction.uniqueStakers, int128)\r\n    staker: address\r\n    totDeposit: uint256(tok)\r\n    slots: uint256\r\n    currentSlots: uint256\r\n    _bidAtPrice: uint256(tok)\r\n\r\n    for i in range(MAX_SLOTS):\r\n        if i \u003E= uniqueStakers_int128:\r\n            break\r\n\r\n        staker = self.stakers[i]\r\n        _bidAtPrice = self.bidAtPrice[staker]\r\n        slots = 0\r\n\r\n        if finalPrice \u003C= _bidAtPrice:\r\n            totDeposit = self.selfStakerDeposits[staker] \u002B self.pledgedDeposits[staker]\r\n\r\n            if slotsRemaining \u003E 0:\r\n                # finalPrice will always be \u003E 0 as reserveStake required to be \u003E 0\r\n                slots = min(totDeposit / finalPrice, slotsRemaining)\r\n                currentSlots = self.stakerSlots[staker]\r\n                if slots != currentSlots:\r\n                    self.stakerSlots[staker] = slots\r\n                slotsRemaining -= slots\r\n\r\n            if finalPriceP1 \u003C= _bidAtPrice:\r\n                slotsRemainingP1 -= min(totDeposit / finalPriceP1, slotsRemainingP1)\r\n\r\n        # later bidders dropping out of slot-allocation as earlier bidders already claim all slots at the final price\r\n        if slots == 0:\r\n            clear(self.stakerSlots[staker])\r\n            clear(self.stakers[i])\r\n\r\n    if (finalPrice == self.auction.reserveStake) and (self._isBiddingPhase() == False):\r\n        # a) reserveStake clears the auction and reserveStake \u002B 1 does not\r\n        doesClear: bool = (slotsRemaining == 0) and (slotsRemainingP1 \u003E 0)\r\n        # b) reserveStake does not clear the auction, accordingly neither will any other higher price\r\n        assert (doesClear or (slotsRemaining \u003E 0)), \u0022reserveStake is not the best solution\u0022\r\n    else:\r\n        assert slotsRemaining == 0, \u0022finalPrice does not clear auction\u0022\r\n        assert slotsRemainingP1 \u003E 0, \u0022Not largest price clearing the auction\u0022\r\n\r\n    self.auction.finalPrice = finalPrice\r\n    self.auction.slotsSold = slotsOnSale - slotsRemaining\r\n    log.AuctionFinalised(self.currentAID, finalPrice, slotsOnSale - slotsRemaining)\r\n\r\n# @notice Anyone can end the lock-up of an auction, thereby allowing everyone to\r\n#   withdraw their stakes and rewards. Auction must first be finalised through finaliseAuction().\r\n@public\r\ndef endLockup():\r\n    # Prevents repeated calls of this function as self.auction will get reset here\r\n    assert self.auction.finalPrice \u003E 0, \u0022Auction not finalised yet or no auction to end\u0022\r\n    assert block.number \u003E= self.auction.lockupEnd, \u0022Lockup not over\u0022\r\n\r\n    slotsSold: uint256 = self.auction.slotsSold\r\n    rewardPerSlot_: uint256(tok) = self.rewardPerSlot\r\n    self.totalAuctionRewards -= slotsSold * rewardPerSlot_\r\n    self.earliestDelete = block.timestamp \u002B DELETE_PERIOD\r\n\r\n    # distribute rewards \u0026 cleanup\r\n    staker: address\r\n\r\n    for i in range(MAX_SLOTS):\r\n        staker = self.stakers[i]\r\n        if staker == ZERO_ADDRESS:\r\n            break\r\n\r\n        self.selfStakerDeposits[staker] \u002B= self.stakerSlots[staker] * rewardPerSlot_\r\n        clear(self.stakerSlots[staker])\r\n\r\n    clear(self.stakers)\r\n    clear(self.auction)\r\n    clear(self.rewardPerSlot)\r\n\r\n    log.LockupEnded(self.currentAID)\r\n\r\n# @param AID: auction ID, has to match self.currentAID\r\n# @param _totalReward: total reward committed to stakers, has to be paid upon\r\n#   calling this and be approved with the ERC20 token\r\n# @param _rewardPerTok: _rewardPerTok / REWARD_PER_TOK_DENOMINATOR will be paid\r\n#   for each stake pledged to the pool. Meaning _rewardPerTok should equal\r\n#   reward per token * REWARD_PER_TOK_DENOMINATOR (see getDenominator())\r\n@public\r\ndef registerPool(AID: uint256,\r\n                 _totalReward: uint256(tok),\r\n                 _rewardPerTok: uint256(tok)):\r\n    assert AID == self.currentAID, \u0022Not current auction\u0022\r\n    assert self._isBiddingPhase(), \u0022Not in bidding phase\u0022\r\n    assert self.registeredPools[msg.sender].AID \u003C AID, \u0022Pool already exists\u0022\r\n    assert self.registeredPools[msg.sender].remainingReward == 0, \u0022Unclaimed rewards\u0022\r\n\r\n    self.registeredPools[msg.sender] = Pool({remainingReward: _totalReward,\r\n                                             rewardPerTok: _rewardPerTok,\r\n                                             AID: AID})\r\n    # overwrite any pledgedDeposits that existed for the last auction\r\n    self.pledgedDeposits[msg.sender] = _totalReward\r\n\r\n    success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(_totalReward))\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n    maxStake: uint256(tok) = (_totalReward * REWARD_PER_TOK_DENOMINATOR) / _rewardPerTok\r\n    log.PoolRegistration(AID, msg.sender, maxStake, _rewardPerTok)\r\n\r\n# @notice Move pool rewards that were not claimed by anyone into\r\n#   selfStakerDeposits. Automatically done if pool enters a bid.\r\n# @dev Requires that the auction has passed the bidding phase\r\n@public\r\ndef retrieveUnclaimedPoolRewards():\r\n    assert ((self._isBiddingPhase() == False)\r\n             or (self.registeredPools[msg.sender].AID \u003C self.currentAID)), \u0022Bidding phase of AID not over\u0022\r\n\r\n    unclaimed: uint256(tok) = self.registeredPools[msg.sender].remainingReward\r\n    clear(self.registeredPools[msg.sender])\r\n\r\n    self.pledgedDeposits[msg.sender] -= unclaimed\r\n    self.selfStakerDeposits[msg.sender] \u002B= unclaimed\r\n\r\n# @notice Pledge stake to a staking pool. Possible from auction intialisation\r\n#   until the end of the bidding phase or until the pool has made a bid.\r\n#   Stake from the last auction can be taken over to the next auction. If amount\r\n#   exceeds the previous stake, this contract must be approved with the ERC20 token\r\n#   to transfer the difference to this contract.\r\n# @dev Only one pledge per address and auction allowed\r\n# @dev If decreasing the pledge, the difference is immediately paid out\r\n# @dev If the pool operator has already bid, this will throw with \u0022Rewards depleted\u0022\r\n# @param AID: The auction ID\r\n# @pool: The address of the pool\r\n# @param amount: The new total amount, not the difference to existing pledges\r\n@public\r\ndef pledgeStake(AID: uint256, pool: address, amount: uint256(tok)):\r\n    assert AID == self.currentAID, \u0022Not current AID\u0022\r\n    assert self._isBiddingPhase(), \u0022Not in bidding phase\u0022\r\n    assert self.registeredPools[pool].AID == AID, \u0022Not a registered pool\u0022\r\n\r\n    existingPledgeAmount: uint256(tok) = self.poolStakerDeposits[msg.sender].amount\r\n    assert self.poolStakerDeposits[msg.sender].AID \u003C AID, \u0022Already pledged\u0022\r\n\r\n    reward: uint256(tok) = ((self.registeredPools[pool].rewardPerTok * amount)\r\n                            / REWARD_PER_TOK_DENOMINATOR)\r\n    assert self.registeredPools[pool].remainingReward \u003E= reward, \u0022Rewards depleted\u0022\r\n    self.registeredPools[pool].remainingReward -= reward\r\n\r\n    # pool reward is already included in pledgedDeposits\r\n    self.pledgedDeposits[pool] \u002B= amount\r\n    self.poolStakerDeposits[msg.sender] = Pledge({amount: amount \u002B reward,\r\n                                                  AID: AID})\r\n\r\n    if amount \u003E existingPledgeAmount:\r\n        success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(amount - existingPledgeAmount))\r\n        assert success, \u0022Transfer failed\u0022\r\n    elif amount \u003C existingPledgeAmount:\r\n        success: bool = self.token.transfer(msg.sender, as_unitless_number(existingPledgeAmount - amount))\r\n        assert success, \u0022Transfer failed\u0022\r\n\r\n    log.NewPledge(AID, msg.sender, pool, amount)\r\n\r\n# @notice Withdraw any self-stake exceeding the required lockup. In case sender is a bidder in the\r\n#   current auction, this requires the auction to be finalised through finaliseAuction(),\r\n#   o/w _calculateSelfStakeNeeded() will throw\r\n@public\r\ndef withdrawSelfStake() -\u003E uint256(tok):\r\n    selfStake: uint256(tok) = self.selfStakerDeposits[msg.sender]\r\n    selfStakeNeeded: uint256(tok) = self._calculateSelfStakeNeeded(msg.sender)\r\n    # not guaranteed to be initialised to 0 without setting it explicitly\r\n    withdrawal: uint256(tok) = 0\r\n\r\n    if selfStake \u003E selfStakeNeeded:\r\n        withdrawal = selfStake - selfStakeNeeded\r\n        self.selfStakerDeposits[msg.sender] -= withdrawal\r\n    elif selfStake \u003C selfStakeNeeded:\r\n        assert False, \u0022Critical failure\u0022\r\n\r\n    success: bool = self.token.transfer(msg.sender, as_unitless_number(withdrawal))\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n    return withdrawal\r\n\r\n# @notice Withdraw pledged stake after the lock-up has ended\r\n@public\r\ndef withdrawPledgedStake() -\u003E uint256(tok):\r\n    withdrawal: uint256(tok)\r\n    if ((self.poolStakerDeposits[msg.sender].AID \u003C self.currentAID)\r\n        or (self.auction.lockupEnd == 0)):\r\n        withdrawal \u002B= self.poolStakerDeposits[msg.sender].amount\r\n        clear(self.poolStakerDeposits[msg.sender])\r\n\r\n    success: bool = self.token.transfer(msg.sender, as_unitless_number(withdrawal))\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n    return withdrawal\r\n\r\n# @notice Allow the owner to remove the contract, given that no auction is\r\n#   active and at least DELETE_PERIOD blocks have past since the last lock-up end.\r\n@public\r\ndef deleteContract():\r\n    assert msg.sender == self.owner, \u0022Owner only\u0022\r\n    assert self.auction.lockupEnd == 0, \u0022In lockup phase\u0022\r\n    assert block.timestamp \u003E= self.earliestDelete, \u0022earliestDelete not reached\u0022\r\n\r\n    contractBalance: uint256 = self.token.balanceOf(self)\r\n    success: bool = self.token.transfer(self.owner, contractBalance)\r\n    assert success, \u0022Transfer failed\u0022\r\n\r\n    selfdestruct(self.owner)\r\n\r\n################################################################################\r\n# Getters\r\n################################################################################\r\n@public\r\n@constant\r\ndef getERC20Address() -\u003E address:\r\n    return self.token\r\n\r\n@public\r\n@constant\r\ndef getDenominator() -\u003E uint256(tok):\r\n    return REWARD_PER_TOK_DENOMINATOR\r\n\r\n@public\r\n@constant\r\ndef getFinalStakerSlots(staker: address) -\u003E uint256:\r\n    assert self._isFinalised(), \u0022Slots not yet final\u0022\r\n    return self.stakerSlots[staker]\r\n\r\n# @dev Always returns an array of MAX_SLOTS with elements \u003E unique bidders = zero\r\n@public\r\n@constant\r\ndef getFinalStakers() -\u003E address[MAX_SLOTS]:\r\n    assert self._isFinalised(), \u0022Stakers not yet final\u0022\r\n    return self.stakers\r\n\r\n@public\r\n@constant\r\ndef getFinalSlotsSold() -\u003E uint256:\r\n    assert self._isFinalised(), \u0022Slots not yet final\u0022\r\n    return self.auction.slotsSold\r\n\r\n@public\r\n@constant\r\ndef isBiddingPhase() -\u003E bool:\r\n    return self._isBiddingPhase()\r\n\r\n@public\r\n@constant\r\ndef isFinalised() -\u003E bool:\r\n    return self._isFinalised()\r\n\r\n@public\r\n@constant\r\ndef getCurrentPrice() -\u003E uint256(tok):\r\n    return self._getCurrentPrice()\r\n\r\n@public\r\n@constant\r\ndef calculateSelfStakeNeeded(_address: address) -\u003E uint256(tok):\r\n    return self._calculateSelfStakeNeeded(_address)","ABI":"[{\u0022name\u0022:\u0022Bid\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022indexed\u0022:true},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022currentPrice\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022NewAuction\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022start\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022end\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lockupEnd\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022startStake\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022reserveStake\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022declinePerBlock\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022slotsOnSale\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rewardPerSlot\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022PoolRegistration\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022maxStake\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rewardPerTok\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022NewPledge\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022indexed\u0022:true},{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022operator\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022AuctionFinalised\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022finalPrice\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022slotsSold\u0022,\u0022indexed\u0022:false,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022LockupEnded\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022name\u0022:\u0022AuctionAborted\u0022,\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022,\u0022indexed\u0022:false},{\u0022type\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022rewardsPaid\u0022,\u0022indexed\u0022:false}],\u0022anonymous\u0022:false,\u0022type\u0022:\u0022event\u0022},{\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_ERC20Address\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022constructor\u0022},{\u0022name\u0022:\u0022initialiseAuction\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_start\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_startStake\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_reserveStake\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_duration\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_lockup_duration\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_slotsOnSale\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_reward\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:386461},{\u0022name\u0022:\u0022retrieveUndistributedAuctionRewards\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:26235},{\u0022name\u0022:\u0022abortAuction\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022payoutRewards\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:24099326},{\u0022name\u0022:\u0022bid\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_topup\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:368596},{\u0022name\u0022:\u0022finaliseAuction\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022finalPrice\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:23924246},{\u0022name\u0022:\u0022endLockup\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:24116206},{\u0022name\u0022:\u0022registerPool\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_totalReward\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022_rewardPerTok\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:150483},{\u0022name\u0022:\u0022retrieveUnclaimedPoolRewards\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:135406},{\u0022name\u0022:\u0022pledgeStake\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022AID\u0022},{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022pool\u0022},{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022amount\u0022}],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:154847},{\u0022name\u0022:\u0022withdrawSelfStake\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:64851},{\u0022name\u0022:\u0022withdrawPledgedStake\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:45458},{\u0022name\u0022:\u0022deleteContract\u0022,\u0022outputs\u0022:[],\u0022inputs\u0022:[],\u0022constant\u0022:false,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:31604},{\u0022name\u0022:\u0022getERC20Address\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1023},{\u0022name\u0022:\u0022getDenominator\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:853},{\u0022name\u0022:\u0022getFinalStakerSlots\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022staker\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:2327},{\u0022name\u0022:\u0022getFinalStakers\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022address[300]\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:91041},{\u0022name\u0022:\u0022getFinalSlotsSold\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:2311},{\u0022name\u0022:\u0022isBiddingPhase\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:2770},{\u0022name\u0022:\u0022isFinalised\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1943},{\u0022name\u0022:\u0022getCurrentPrice\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:11041},{\u0022name\u0022:\u0022calculateSelfStakeNeeded\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_address\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:26381},{\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1293},{\u0022name\u0022:\u0022earliestDelete\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022sec\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1323},{\u0022name\u0022:\u0022pledgedDeposits\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1507},{\u0022name\u0022:\u0022poolStakerDeposits__amount\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1609},{\u0022name\u0022:\u0022poolStakerDeposits__AID\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1645},{\u0022name\u0022:\u0022selfStakerDeposits\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1597},{\u0022name\u0022:\u0022bidAtPrice\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1627},{\u0022name\u0022:\u0022registeredPools__remainingReward\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1729},{\u0022name\u0022:\u0022registeredPools__rewardPerTok\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1765},{\u0022name\u0022:\u0022registeredPools__AID\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[{\u0022type\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arg0\u0022}],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1795},{\u0022name\u0022:\u0022currentAID\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1593},{\u0022name\u0022:\u0022auction__finalPrice\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1695},{\u0022name\u0022:\u0022auction__lockupEnd\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1731},{\u0022name\u0022:\u0022auction__slotsSold\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1761},{\u0022name\u0022:\u0022auction__start\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1791},{\u0022name\u0022:\u0022auction__end\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1821},{\u0022name\u0022:\u0022auction__startStake\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1851},{\u0022name\u0022:\u0022auction__reserveStake\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1881},{\u0022name\u0022:\u0022auction__declinePerBlock\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1911},{\u0022name\u0022:\u0022auction__slotsOnSale\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1941},{\u0022name\u0022:\u0022auction__uniqueStakers\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1971},{\u0022name\u0022:\u0022totalAuctionRewards\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1923},{\u0022name\u0022:\u0022rewardPerSlot\u0022,\u0022outputs\u0022:[{\u0022type\u0022:\u0022uint256\u0022,\u0022unit\u0022:\u0022smallest ERC20 token unit\u0022,\u0022name\u0022:\u0022out\u0022}],\u0022inputs\u0022:[],\u0022constant\u0022:true,\u0022payable\u0022:false,\u0022type\u0022:\u0022function\u0022,\u0022gas\u0022:1953}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001d287cc25dad7ccaf76a26bc660c5f7c8e2a05bd","Library":"","SwarmSource":""}]