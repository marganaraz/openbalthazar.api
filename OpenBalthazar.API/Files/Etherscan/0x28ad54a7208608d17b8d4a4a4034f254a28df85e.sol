[{"SourceCode":"// File: contracts/reserves/orderBookReserve/permissionless/OrderListInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ninterface OrderListInterface {\r\n    function getOrderDetails(uint32 orderId) public view returns (address, uint128, uint128, uint32, uint32);\r\n    function add(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function remove(uint32 orderId) public returns (bool);\r\n    function update(uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function getFirstOrder() public view returns(uint32 orderId, bool isEmpty);\r\n    function allocateIds(uint32 howMany) public returns(uint32);\r\n    function findPrevOrderId(uint128 srcAmount, uint128 dstAmount) public view returns(uint32);\r\n\r\n    function addAfterId(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns (bool);\r\n\r\n    function updateWithPositionHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns(bool, uint);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderIdManager.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ncontract OrderIdManager {\r\n    struct OrderIdData {\r\n        uint32 firstOrderId;\r\n        uint takenBitmap;\r\n    }\r\n\r\n    uint constant public NUM_ORDERS = 32;\r\n\r\n    function fetchNewOrderId(OrderIdData storage freeOrders)\r\n        internal\r\n        returns(uint32)\r\n    {\r\n        uint orderBitmap = freeOrders.takenBitmap;\r\n        uint bitPointer = 1;\r\n\r\n        for (uint i = 0; i \u003C NUM_ORDERS; \u002B\u002Bi) {\r\n\r\n            if ((orderBitmap \u0026 bitPointer) == 0) {\r\n                freeOrders.takenBitmap = orderBitmap | bitPointer;\r\n                return(uint32(uint(freeOrders.firstOrderId) \u002B i));\r\n            }\r\n\r\n            bitPointer *= 2;\r\n        }\r\n\r\n        revert();\r\n    }\r\n\r\n    /// @dev mark order as free to use.\r\n    function releaseOrderId(OrderIdData storage freeOrders, uint32 orderId)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(orderId \u003E= freeOrders.firstOrderId);\r\n        require(orderId \u003C (freeOrders.firstOrderId \u002B NUM_ORDERS));\r\n\r\n        uint orderBitNum = uint(orderId) - uint(freeOrders.firstOrderId);\r\n        uint bitPointer = uint(1) \u003C\u003C orderBitNum;\r\n\r\n        require(bitPointer \u0026 freeOrders.takenBitmap \u003E 0);\r\n\r\n        freeOrders.takenBitmap \u0026= ~bitPointer;\r\n        return true;\r\n    }\r\n\r\n    function allocateOrderIds(\r\n        OrderIdData storage makerOrders,\r\n        uint32 firstAllocatedId\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        if (makerOrders.firstOrderId \u003E 0) {\r\n            return false;\r\n        }\r\n\r\n        makerOrders.firstOrderId = firstAllocatedId;\r\n        makerOrders.takenBitmap = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    function orderAllocationRequired(OrderIdData storage freeOrders) internal view returns (bool) {\r\n\r\n        if (freeOrders.firstOrderId == 0) return true;\r\n        return false;\r\n    }\r\n\r\n    function getNumActiveOrderIds(OrderIdData storage makerOrders) internal view returns (uint numActiveOrders) {\r\n        for (uint i = 0; i \u003C NUM_ORDERS; \u002B\u002Bi) {\r\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003C\u003C i)) \u003E 0) numActiveOrders\u002B\u002B;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderListFactoryInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface OrderListFactoryInterface {\r\n    function newOrdersContract(address admin) public returns(OrderListInterface);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderbookReserveInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface OrderbookReserveInterface {\r\n    function init() public returns(bool);\r\n    function kncRateBlocksTrade() public view returns(bool);\r\n}\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=\u003Euint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty \u003C= MAX_QTY);\r\n        require(rate \u003C= MAX_RATE);\r\n\r\n        if (dstDecimals \u003E= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) \u003C= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) \u003C= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty \u003C= MAX_QTY);\r\n        require(rate \u003C= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals \u003E= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) \u003C= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) \u003C= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator \u002B denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/Utils2.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount \u003C= MAX_QTY);\r\n        require(destAmount \u003C= MAX_QTY);\r\n\r\n        if (dstDecimals \u003E= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) \u003C= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) \u003C= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/KyberReserveInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\n// File: contracts/reserves/orderBookReserve/permissionless/OrderbookReserve.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FeeBurnerRateInterface {\r\n    uint public kncPerEthRatePrecision;\r\n}\r\n\r\n\r\ninterface MedianizerInterface {\r\n    function peek() public view returns (bytes32, bool);\r\n}\r\n\r\n\r\ncontract OrderbookReserve is OrderIdManager, Utils2, KyberReserveInterface, OrderbookReserveInterface {\r\n\r\n    uint public constant BURN_TO_STAKE_FACTOR = 5;      // stake per order must be xfactor expected burn amount.\r\n    uint public constant MAX_BURN_FEE_BPS = 100;        // 1%\r\n    uint public constant MIN_REMAINING_ORDER_RATIO = 2; // Ratio between min new order value and min order value.\r\n    uint public constant MAX_USD_PER_ETH = 100000;      // Above this value price is surely compromised.\r\n\r\n    uint32 constant public TAIL_ID = 1;         // tail Id in order list contract\r\n    uint32 constant public HEAD_ID = 2;         // head Id in order list contract\r\n\r\n    struct OrderLimits {\r\n        uint minNewOrderSizeUsd; // Basis for setting min new order size Eth\r\n        uint maxOrdersPerTrade;     // Limit number of iterated orders per trade / getRate loops.\r\n        uint minNewOrderSizeWei;    // Below this value can\u0027t create new order.\r\n        uint minOrderSizeWei;       // below this value order will be removed.\r\n    }\r\n\r\n    uint public kncPerEthBaseRatePrecision; // according to base rate all stakes are calculated.\r\n\r\n    struct ExternalContracts {\r\n        ERC20 kncToken;          // not constant. to enable testing while not on main net\r\n        ERC20 token;             // only supported token.\r\n        FeeBurnerRateInterface feeBurner;\r\n        address kyberNetwork;\r\n        MedianizerInterface medianizer; // price feed Eth - USD from maker DAO.\r\n        OrderListFactoryInterface orderListFactory;\r\n    }\r\n\r\n    //struct for getOrderData() return value. used only in memory.\r\n    struct OrderData {\r\n        address maker;\r\n        uint32 nextId;\r\n        bool isLastOrder;\r\n        uint128 srcAmount;\r\n        uint128 dstAmount;\r\n    }\r\n\r\n    OrderLimits public limits;\r\n    ExternalContracts public contracts;\r\n\r\n    // sorted lists of orders. one list for token to Eth, other for Eth to token.\r\n    // Each order is added in the correct position in the list to keep it sorted.\r\n    OrderListInterface public tokenToEthList;\r\n    OrderListInterface public ethToTokenList;\r\n\r\n    //funds data\r\n    mapping(address =\u003E mapping(address =\u003E uint)) public makerFunds; // deposited maker funds.\r\n    mapping(address =\u003E uint) public makerKnc;            // for knc staking.\r\n    mapping(address =\u003E uint) public makerTotalOrdersWei; // per maker how many Wei in orders, for stake calculation.\r\n\r\n    uint public makerBurnFeeBps;    // knc burn fee per order that is taken.\r\n\r\n    //each maker will have orders that will be reused.\r\n    mapping(address =\u003E OrderIdData) public makerOrdersTokenToEth;\r\n    mapping(address =\u003E OrderIdData) public makerOrdersEthToToken;\r\n\r\n    function OrderbookReserve(\r\n        ERC20 knc,\r\n        ERC20 reserveToken,\r\n        address burner,\r\n        address network,\r\n        MedianizerInterface medianizer,\r\n        OrderListFactoryInterface factory,\r\n        uint minNewOrderUsd,\r\n        uint maxOrdersPerTrade,\r\n        uint burnFeeBps\r\n    )\r\n        public\r\n    {\r\n\r\n        require(knc != address(0));\r\n        require(reserveToken != address(0));\r\n        require(burner != address(0));\r\n        require(network != address(0));\r\n        require(medianizer != address(0));\r\n        require(factory != address(0));\r\n        require(burnFeeBps != 0);\r\n        require(burnFeeBps \u003C= MAX_BURN_FEE_BPS);\r\n        require(maxOrdersPerTrade != 0);\r\n        require(minNewOrderUsd \u003E 0);\r\n\r\n        contracts.kyberNetwork = network;\r\n        contracts.feeBurner = FeeBurnerRateInterface(burner);\r\n        contracts.medianizer = medianizer;\r\n        contracts.orderListFactory = factory;\r\n        contracts.kncToken = knc;\r\n        contracts.token = reserveToken;\r\n\r\n        makerBurnFeeBps = burnFeeBps;\r\n        limits.minNewOrderSizeUsd = minNewOrderUsd;\r\n        limits.maxOrdersPerTrade = maxOrdersPerTrade;\r\n\r\n        require(setMinOrderSizeEth());\r\n    \r\n        require(contracts.kncToken.approve(contracts.feeBurner, (2**255)));\r\n\r\n        //can only support tokens with decimals() API\r\n        setDecimals(contracts.token);\r\n\r\n        kncPerEthBaseRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\r\n    }\r\n\r\n    ///@dev separate init function for this contract, if this init is in the C\u0027tor. gas consumption too high.\r\n    function init() public returns(bool) {\r\n        if ((tokenToEthList != address(0)) \u0026\u0026 (ethToTokenList != address(0))) return true;\r\n        if ((tokenToEthList != address(0)) || (ethToTokenList != address(0))) revert();\r\n\r\n        tokenToEthList = contracts.orderListFactory.newOrdersContract(this);\r\n        ethToTokenList = contracts.orderListFactory.newOrdersContract(this);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setKncPerEthBaseRate() public {\r\n        uint kncPerEthRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\r\n        if (kncPerEthRatePrecision \u003C kncPerEthBaseRatePrecision) {\r\n            kncPerEthBaseRatePrecision = kncPerEthRatePrecision;\r\n        }\r\n    }\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dst, uint srcQty, uint blockNumber) public view returns(uint) {\r\n        require((src == ETH_TOKEN_ADDRESS) || (dst == ETH_TOKEN_ADDRESS));\r\n        require((src == contracts.token) || (dst == contracts.token));\r\n        require(srcQty \u003C= MAX_QTY);\r\n\r\n        if (kncRateBlocksTrade() || (srcQty == 0)) return 0;\r\n\r\n        blockNumber; // in this reserve no order expiry == no use for blockNumber. here to avoid compiler warning.\r\n\r\n        //user order ETH -\u003E token is matched with maker order token -\u003E ETH\r\n        OrderListInterface list = (src == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        uint32 orderId;\r\n        OrderData memory orderData;\r\n\r\n        uint128 userRemainingSrcQty = uint128(srcQty);\r\n        uint128 totalUserDstAmount = 0;\r\n        uint maxOrders = limits.maxOrdersPerTrade;\r\n\r\n        for (\r\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n            ((userRemainingSrcQty \u003E 0) \u0026\u0026 (!orderData.isLastOrder) \u0026\u0026 (maxOrders-- \u003E 0));\r\n            orderId = orderData.nextId\r\n        ) {\r\n            orderData = getOrderData(list, orderId);\r\n            // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\r\n            // so user src quantity is matched with maker dst quantity\r\n            if (orderData.dstAmount \u003C= userRemainingSrcQty) {\r\n                totalUserDstAmount \u002B= orderData.srcAmount;\r\n                userRemainingSrcQty -= orderData.dstAmount;\r\n            } else {\r\n                totalUserDstAmount \u002B= uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\r\n                    uint(orderData.dstAmount));\r\n                userRemainingSrcQty = 0;\r\n            }\r\n        }\r\n\r\n        if (userRemainingSrcQty != 0) return 0; //not enough tokens to exchange.\r\n\r\n        return calcRateFromQty(srcQty, totalUserDstAmount, getDecimals(src), getDecimals(dst));\r\n    }\r\n\r\n    event OrderbookReserveTrade(ERC20 srcToken, ERC20 dstToken, uint srcAmount, uint dstAmount);\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 dstToken,\r\n        address dstAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(msg.sender == contracts.kyberNetwork);\r\n        require((srcToken == ETH_TOKEN_ADDRESS) || (dstToken == ETH_TOKEN_ADDRESS));\r\n        require((srcToken == contracts.token) || (dstToken == contracts.token));\r\n        require(srcAmount \u003C= MAX_QTY);\r\n\r\n        conversionRate;\r\n        validate;\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcAmount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }\r\n\r\n        uint totalDstAmount = doTrade(\r\n                srcToken,\r\n                srcAmount,\r\n                dstToken\r\n            );\r\n\r\n        require(conversionRate \u003C= calcRateFromQty(srcAmount, totalDstAmount, getDecimals(srcToken),\r\n            getDecimals(dstToken)));\r\n\r\n        //all orders were successfully taken. send to dstAddress\r\n        if (dstToken == ETH_TOKEN_ADDRESS) {\r\n            dstAddress.transfer(totalDstAmount);\r\n        } else {\r\n            require(dstToken.transfer(dstAddress, totalDstAmount));\r\n        }\r\n\r\n        OrderbookReserveTrade(srcToken, dstToken, srcAmount, totalDstAmount);\r\n        return true;\r\n    }\r\n\r\n    function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 dstToken\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        OrderListInterface list = (srcToken == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        uint32 orderId;\r\n        OrderData memory orderData;\r\n        uint128 userRemainingSrcQty = uint128(srcAmount);\r\n        uint128 totalUserDstAmount = 0;\r\n\r\n        for (\r\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n            ((userRemainingSrcQty \u003E 0) \u0026\u0026 (!orderData.isLastOrder));\r\n            orderId = orderData.nextId\r\n        ) {\r\n        // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\r\n        // so user src quantity is matched with maker dst quantity\r\n            orderData = getOrderData(list, orderId);\r\n            if (orderData.dstAmount \u003C= userRemainingSrcQty) {\r\n                totalUserDstAmount \u002B= orderData.srcAmount;\r\n                userRemainingSrcQty -= orderData.dstAmount;\r\n                require(takeFullOrder({\r\n                    maker: orderData.maker,\r\n                    orderId: orderId,\r\n                    userSrc: srcToken,\r\n                    userDst: dstToken,\r\n                    userSrcAmount: orderData.dstAmount,\r\n                    userDstAmount: orderData.srcAmount\r\n                }));\r\n            } else {\r\n                uint128 partialDstQty = uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\r\n                    uint(orderData.dstAmount));\r\n                totalUserDstAmount \u002B= partialDstQty;\r\n                require(takePartialOrder({\r\n                    maker: orderData.maker,\r\n                    orderId: orderId,\r\n                    userSrc: srcToken,\r\n                    userDst: dstToken,\r\n                    userPartialSrcAmount: userRemainingSrcQty,\r\n                    userTakeDstAmount: partialDstQty,\r\n                    orderSrcAmount: orderData.srcAmount,\r\n                    orderDstAmount: orderData.dstAmount\r\n                }));\r\n                userRemainingSrcQty = 0;\r\n            }\r\n        }\r\n\r\n        require(userRemainingSrcQty == 0 \u0026\u0026 totalUserDstAmount \u003E 0);\r\n\r\n        return totalUserDstAmount;\r\n    }\r\n\r\n    ///@param srcAmount is the token amount that will be payed. must be deposited before hand in the makers account.\r\n    ///@param dstAmount is the eth amount the maker expects to get for his tokens.\r\n    function submitTokenToEthOrder(uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return submitTokenToEthOrderWHint(srcAmount, dstAmount, 0);\r\n    }\r\n\r\n    function submitTokenToEthOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        uint32 newId = fetchNewOrderId(makerOrdersTokenToEth[msg.sender]);\r\n        return addOrder(false, newId, srcAmount, dstAmount, hintPrevOrder);\r\n    }\r\n\r\n    ///@param srcAmount is the Ether amount that will be payed, must be deposited before hand.\r\n    ///@param dstAmount is the token amount the maker expects to get for his Ether.\r\n    function submitEthToTokenOrder(uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return submitEthToTokenOrderWHint(srcAmount, dstAmount, 0);\r\n    }\r\n\r\n    function submitEthToTokenOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        uint32 newId = fetchNewOrderId(makerOrdersEthToToken[msg.sender]);\r\n        return addOrder(true, newId, srcAmount, dstAmount, hintPrevOrder);\r\n    }\r\n\r\n    ///@dev notice here a batch of orders represented in arrays. order x is represented by x cells of all arrays.\r\n    ///@dev all arrays expected to the same length.\r\n    ///@param isEthToToken per each order. is order x eth to token (= src is Eth) or vice versa.\r\n    ///@param srcAmount per each order. source amount for order x.\r\n    ///@param dstAmount per each order. destination amount for order x.\r\n    ///@param hintPrevOrder per each order what is the order it should be added after in ordered list. 0 for no hint.\r\n    ///@param isAfterPrevOrder per each order, set true if should be added in list right after previous added order.\r\n    function addOrderBatch(bool[] isEthToToken, uint128[] srcAmount, uint128[] dstAmount,\r\n        uint32[] hintPrevOrder, bool[] isAfterPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(isEthToToken.length == hintPrevOrder.length);\r\n        require(isEthToToken.length == dstAmount.length);\r\n        require(isEthToToken.length == srcAmount.length);\r\n        require(isEthToToken.length == isAfterPrevOrder.length);\r\n\r\n        address maker = msg.sender;\r\n        uint32 prevId;\r\n        uint32 newId = 0;\r\n\r\n        for (uint i = 0; i \u003C isEthToToken.length; \u002B\u002Bi) {\r\n            prevId = isAfterPrevOrder[i] ? newId : hintPrevOrder[i];\r\n            newId = fetchNewOrderId(isEthToToken[i] ? makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker]);\r\n            require(addOrder(isEthToToken[i], newId, srcAmount[i], dstAmount[i], prevId));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateTokenToEthOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateTokenToEthOrderWHint(orderId, newSrcAmount, newDstAmount, 0));\r\n        return true;\r\n    }\r\n\r\n    function updateTokenToEthOrderWHint(\r\n        uint32 orderId,\r\n        uint128 newSrcAmount,\r\n        uint128 newDstAmount,\r\n        uint32 hintPrevOrder\r\n    )\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateOrder(false, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\r\n        return true;\r\n    }\r\n\r\n    function updateEthToTokenOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\r\n        public\r\n        returns(bool)\r\n    {\r\n        return updateEthToTokenOrderWHint(orderId, newSrcAmount, newDstAmount, 0);\r\n    }\r\n\r\n    function updateEthToTokenOrderWHint(\r\n        uint32 orderId,\r\n        uint128 newSrcAmount,\r\n        uint128 newDstAmount,\r\n        uint32 hintPrevOrder\r\n    )\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(updateOrder(true, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\r\n        return true;\r\n    }\r\n\r\n    function updateOrderBatch(bool[] isEthToToken, uint32[] orderId, uint128[] newSrcAmount,\r\n        uint128[] newDstAmount, uint32[] hintPrevOrder)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(isEthToToken.length == orderId.length);\r\n        require(isEthToToken.length == newSrcAmount.length);\r\n        require(isEthToToken.length == newDstAmount.length);\r\n        require(isEthToToken.length == hintPrevOrder.length);\r\n\r\n        for (uint i = 0; i \u003C isEthToToken.length; \u002B\u002Bi) {\r\n            require(updateOrder(isEthToToken[i], orderId[i], newSrcAmount[i], newDstAmount[i],\r\n                hintPrevOrder[i]));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    event TokenDeposited(address indexed maker, uint amount);\r\n\r\n    function depositToken(address maker, uint amount) public {\r\n        require(maker != address(0));\r\n        require(amount \u003C MAX_QTY);\r\n\r\n        require(contracts.token.transferFrom(msg.sender, this, amount));\r\n\r\n        makerFunds[maker][contracts.token] \u002B= amount;\r\n        TokenDeposited(maker, amount);\r\n    }\r\n\r\n    event EtherDeposited(address indexed maker, uint amount);\r\n\r\n    function depositEther(address maker) public payable {\r\n        require(maker != address(0));\r\n\r\n        makerFunds[maker][ETH_TOKEN_ADDRESS] \u002B= msg.value;\r\n        EtherDeposited(maker, msg.value);\r\n    }\r\n\r\n    event KncFeeDeposited(address indexed maker, uint amount);\r\n\r\n    // knc will be staked per order. part of the amount will be used as fee.\r\n    function depositKncForFee(address maker, uint amount) public {\r\n        require(maker != address(0));\r\n        require(amount \u003C MAX_QTY);\r\n\r\n        require(contracts.kncToken.transferFrom(msg.sender, this, amount));\r\n\r\n        makerKnc[maker] \u002B= amount;\r\n\r\n        KncFeeDeposited(maker, amount);\r\n\r\n        if (orderAllocationRequired(makerOrdersTokenToEth[maker])) {\r\n            require(allocateOrderIds(\r\n                makerOrdersTokenToEth[maker], /* makerOrders */\r\n                tokenToEthList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\r\n            ));\r\n        }\r\n\r\n        if (orderAllocationRequired(makerOrdersEthToToken[maker])) {\r\n            require(allocateOrderIds(\r\n                makerOrdersEthToToken[maker], /* makerOrders */\r\n                ethToTokenList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\r\n            ));\r\n        }\r\n    }\r\n\r\n    function withdrawToken(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        uint makerFreeAmount = makerFunds[maker][contracts.token];\r\n\r\n        require(makerFreeAmount \u003E= amount);\r\n\r\n        makerFunds[maker][contracts.token] -= amount;\r\n\r\n        require(contracts.token.transfer(maker, amount));\r\n    }\r\n\r\n    function withdrawEther(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        uint makerFreeAmount = makerFunds[maker][ETH_TOKEN_ADDRESS];\r\n\r\n        require(makerFreeAmount \u003E= amount);\r\n\r\n        makerFunds[maker][ETH_TOKEN_ADDRESS] -= amount;\r\n\r\n        maker.transfer(amount);\r\n    }\r\n\r\n    function withdrawKncFee(uint amount) public {\r\n\r\n        address maker = msg.sender;\r\n        \r\n        require(makerKnc[maker] \u003E= amount);\r\n        require(makerUnlockedKnc(maker) \u003E= amount);\r\n\r\n        makerKnc[maker] -= amount;\r\n\r\n        require(contracts.kncToken.transfer(maker, amount));\r\n    }\r\n\r\n    function cancelTokenToEthOrder(uint32 orderId) public returns(bool) {\r\n        require(cancelOrder(false, orderId));\r\n        return true;\r\n    }\r\n\r\n    function cancelEthToTokenOrder(uint32 orderId) public returns(bool) {\r\n        require(cancelOrder(true, orderId));\r\n        return true;\r\n    }\r\n\r\n    function setMinOrderSizeEth() public returns(bool) {\r\n        //get eth to $ from maker dao;\r\n        bytes32 usdPerEthInWei;\r\n        bool valid;\r\n        (usdPerEthInWei, valid) = contracts.medianizer.peek();\r\n        require(valid);\r\n\r\n        // ensuring that there is no underflow or overflow possible,\r\n        // even if the price is compromised\r\n        uint usdPerEth = uint(usdPerEthInWei) / (1 ether);\r\n        require(usdPerEth != 0);\r\n        require(usdPerEth \u003C MAX_USD_PER_ETH);\r\n\r\n        // set Eth order limits according to price\r\n        uint minNewOrderSizeWei = limits.minNewOrderSizeUsd * PRECISION * (1 ether) / uint(usdPerEthInWei);\r\n\r\n        limits.minNewOrderSizeWei = minNewOrderSizeWei;\r\n        limits.minOrderSizeWei = limits.minNewOrderSizeWei / MIN_REMAINING_ORDER_RATIO;\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev Each maker stakes per order KNC that is factor of the required burn amount.\r\n    ///@dev If Knc per Eth rate becomes lower by more then factor, stake will not be enough and trade will be blocked.\r\n    function kncRateBlocksTrade() public view returns (bool) {\r\n        return (contracts.feeBurner.kncPerEthRatePrecision() \u003E kncPerEthBaseRatePrecision * BURN_TO_STAKE_FACTOR);\r\n    }\r\n\r\n    function getTokenToEthAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\r\n        require(dstAmount \u003E= limits.minNewOrderSizeWei);\r\n        return tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\r\n    }\r\n\r\n    function getEthToTokenAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\r\n        require(srcAmount \u003E= limits.minNewOrderSizeWei);\r\n        return ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\r\n    }\r\n\r\n    function getTokenToEthUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        require(dstAmount \u003E= limits.minNewOrderSizeWei);\r\n        uint32 prevId = tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\r\n        address add;\r\n        uint128 noUse;\r\n        uint32 next;\r\n\r\n        if (prevId == orderId) {\r\n            (add, noUse, noUse, prevId, next) = tokenToEthList.getOrderDetails(orderId);\r\n        }\r\n\r\n        return prevId;\r\n    }\r\n\r\n    function getEthToTokenUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        require(srcAmount \u003E= limits.minNewOrderSizeWei);\r\n        uint32 prevId = ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\r\n        address add;\r\n        uint128 noUse;\r\n        uint32 next;\r\n\r\n        if (prevId == orderId) {\r\n            (add, noUse, noUse, prevId, next) = ethToTokenList.getOrderDetails(orderId);\r\n        }\r\n\r\n        return prevId;\r\n    }\r\n\r\n    function getTokenToEthOrder(uint32 orderId)\r\n        public view\r\n        returns (\r\n            address _maker,\r\n            uint128 _srcAmount,\r\n            uint128 _dstAmount,\r\n            uint32 _prevId,\r\n            uint32 _nextId\r\n        )\r\n    {\r\n        return tokenToEthList.getOrderDetails(orderId);\r\n    }\r\n\r\n    function getEthToTokenOrder(uint32 orderId)\r\n        public view\r\n        returns (\r\n            address _maker,\r\n            uint128 _srcAmount,\r\n            uint128 _dstAmount,\r\n            uint32 _prevId,\r\n            uint32 _nextId\r\n        )\r\n    {\r\n        return ethToTokenList.getOrderDetails(orderId);\r\n    }\r\n\r\n    function makerRequiredKncStake(address maker) public view returns (uint) {\r\n        return(calcKncStake(makerTotalOrdersWei[maker]));\r\n    }\r\n\r\n    function makerUnlockedKnc(address maker) public view returns (uint) {\r\n        uint requiredKncStake = makerRequiredKncStake(maker);\r\n        if (requiredKncStake \u003E makerKnc[maker]) return 0;\r\n        return (makerKnc[maker] - requiredKncStake);\r\n    }\r\n\r\n    function calcKncStake(uint weiAmount) public view returns(uint) {\r\n        return(calcBurnAmount(weiAmount) * BURN_TO_STAKE_FACTOR);\r\n    }\r\n\r\n    function calcBurnAmount(uint weiAmount) public view returns(uint) {\r\n        return(weiAmount * makerBurnFeeBps * kncPerEthBaseRatePrecision / (10000 * PRECISION));\r\n    }\r\n\r\n    function calcBurnAmountFromFeeBurner(uint weiAmount) public view returns(uint) {\r\n        return(weiAmount * makerBurnFeeBps * contracts.feeBurner.kncPerEthRatePrecision() / (10000 * PRECISION));\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getEthToTokenMakerOrderIds(address maker) public view returns(uint32[] orderList) {\r\n        OrderIdData storage makerOrders = makerOrdersEthToToken[maker];\r\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\r\n        uint activeOrder = 0;\r\n\r\n        for (uint32 i = 0; i \u003C NUM_ORDERS; \u002B\u002Bi) {\r\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003C\u003C i) \u003E 0)) orderList[activeOrder\u002B\u002B] = makerOrders.firstOrderId \u002B i;\r\n        }\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getTokenToEthMakerOrderIds(address maker) public view returns(uint32[] orderList) {\r\n        OrderIdData storage makerOrders = makerOrdersTokenToEth[maker];\r\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\r\n        uint activeOrder = 0;\r\n\r\n        for (uint32 i = 0; i \u003C NUM_ORDERS; \u002B\u002Bi) {\r\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003C\u003C i) \u003E 0)) orderList[activeOrder\u002B\u002B] = makerOrders.firstOrderId \u002B i;\r\n        }\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getEthToTokenOrderList() public view returns(uint32[] orderList) {\r\n        OrderListInterface list = ethToTokenList;\r\n        return getList(list);\r\n    }\r\n\r\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\r\n    function getTokenToEthOrderList() public view returns(uint32[] orderList) {\r\n        OrderListInterface list = tokenToEthList;\r\n        return getList(list);\r\n    }\r\n\r\n    event NewLimitOrder(\r\n        address indexed maker,\r\n        uint32 orderId,\r\n        bool isEthToToken,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        bool addedWithHint\r\n    );\r\n\r\n    function addOrder(bool isEthToToken, uint32 newId, uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(srcAmount \u003C MAX_QTY);\r\n        require(dstAmount \u003C MAX_QTY);\r\n        address maker = msg.sender;\r\n\r\n        require(secureAddOrderFunds(maker, isEthToToken, srcAmount, dstAmount));\r\n        require(validateLegalRate(srcAmount, dstAmount, isEthToToken));\r\n\r\n        bool addedWithHint = false;\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n\r\n        if (hintPrevOrder != 0) {\r\n            addedWithHint = list.addAfterId(maker, newId, srcAmount, dstAmount, hintPrevOrder);\r\n        }\r\n\r\n        if (!addedWithHint) {\r\n            require(list.add(maker, newId, srcAmount, dstAmount));\r\n        }\r\n\r\n        NewLimitOrder(maker, newId, isEthToToken, srcAmount, dstAmount, addedWithHint);\r\n\r\n        return true;\r\n    }\r\n\r\n    event OrderUpdated(\r\n        address indexed maker,\r\n        bool isEthToToken,\r\n        uint orderId,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        bool updatedWithHint\r\n    );\r\n\r\n    function updateOrder(bool isEthToToken, uint32 orderId, uint128 newSrcAmount,\r\n        uint128 newDstAmount, uint32 hintPrevOrder)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(newSrcAmount \u003C MAX_QTY);\r\n        require(newDstAmount \u003C MAX_QTY);\r\n        address maker;\r\n        uint128 currDstAmount;\r\n        uint128 currSrcAmount;\r\n        uint32 noUse;\r\n        uint noUse2;\r\n\r\n        require(validateLegalRate(newSrcAmount, newDstAmount, isEthToToken));\r\n\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n\r\n        (maker, currSrcAmount, currDstAmount, noUse, noUse) = list.getOrderDetails(orderId);\r\n        require(maker == msg.sender);\r\n\r\n        if (!secureUpdateOrderFunds(maker, isEthToToken, currSrcAmount, currDstAmount, newSrcAmount, newDstAmount)) {\r\n            return false;\r\n        }\r\n\r\n        bool updatedWithHint = false;\r\n\r\n        if (hintPrevOrder != 0) {\r\n            (updatedWithHint, noUse2) = list.updateWithPositionHint(orderId, newSrcAmount, newDstAmount, hintPrevOrder);\r\n        }\r\n\r\n        if (!updatedWithHint) {\r\n            require(list.update(orderId, newSrcAmount, newDstAmount));\r\n        }\r\n\r\n        OrderUpdated(maker, isEthToToken, orderId, newSrcAmount, newDstAmount, updatedWithHint);\r\n\r\n        return true;\r\n    }\r\n\r\n    event OrderCanceled(address indexed maker, bool isEthToToken, uint32 orderId, uint128 srcAmount, uint dstAmount);\r\n\r\n    function cancelOrder(bool isEthToToken, uint32 orderId) internal returns(bool) {\r\n\r\n        address maker = msg.sender;\r\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\r\n        OrderData memory orderData = getOrderData(list, orderId);\r\n\r\n        require(orderData.maker == maker);\r\n\r\n        uint weiAmount = isEthToToken ? orderData.srcAmount : orderData.dstAmount;\r\n        require(releaseOrderStakes(maker, weiAmount, 0));\r\n\r\n        require(removeOrder(list, maker, isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token, orderId));\r\n\r\n        //funds go back to makers account\r\n        makerFunds[maker][isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token] \u002B= orderData.srcAmount;\r\n\r\n        OrderCanceled(maker, isEthToToken, orderId, orderData.srcAmount, orderData.dstAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@param maker is the maker of this order\r\n    ///@param isEthToToken which order type the maker is updating / adding\r\n    ///@param srcAmount is the orders src amount (token or ETH) could be negative if funds are released.\r\n    function bindOrderFunds(address maker, bool isEthToToken, int srcAmount)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        address fundsAddress = isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token;\r\n\r\n        if (srcAmount \u003C 0) {\r\n            makerFunds[maker][fundsAddress] \u002B= uint(-srcAmount);\r\n        } else {\r\n            require(makerFunds[maker][fundsAddress] \u003E= uint(srcAmount));\r\n            makerFunds[maker][fundsAddress] -= uint(srcAmount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@param maker is the maker address\r\n    ///@param weiAmount is the wei amount inside order that should result in knc staking\r\n    function bindOrderStakes(address maker, int weiAmount) internal returns(bool) {\r\n\r\n        if (weiAmount \u003C 0) {\r\n            uint decreaseWeiAmount = uint(-weiAmount);\r\n            if (decreaseWeiAmount \u003E makerTotalOrdersWei[maker]) decreaseWeiAmount = makerTotalOrdersWei[maker];\r\n            makerTotalOrdersWei[maker] -= decreaseWeiAmount;\r\n            return true;\r\n        }\r\n\r\n        require(makerKnc[maker] \u003E= calcKncStake(makerTotalOrdersWei[maker] \u002B uint(weiAmount)));\r\n\r\n        makerTotalOrdersWei[maker] \u002B= uint(weiAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev if totalWeiAmount is 0 we only release stakes.\r\n    ///@dev if totalWeiAmount == weiForBurn. all staked amount will be burned. so no knc returned to maker\r\n    ///@param maker is the maker address\r\n    ///@param totalWeiAmount is total wei amount that was released from order - including taken wei amount.\r\n    ///@param weiForBurn is the part in order wei amount that was taken and should result in burning.\r\n    function releaseOrderStakes(address maker, uint totalWeiAmount, uint weiForBurn) internal returns(bool) {\r\n\r\n        require(weiForBurn \u003C= totalWeiAmount);\r\n\r\n        if (totalWeiAmount \u003E makerTotalOrdersWei[maker]) {\r\n            makerTotalOrdersWei[maker] = 0;\r\n        } else {\r\n            makerTotalOrdersWei[maker] -= totalWeiAmount;\r\n        }\r\n\r\n        if (weiForBurn == 0) return true;\r\n\r\n        uint burnAmount = calcBurnAmountFromFeeBurner(weiForBurn);\r\n\r\n        require(makerKnc[maker] \u003E= burnAmount);\r\n        makerKnc[maker] -= burnAmount;\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev funds are valid only when required knc amount can be staked for this order.\r\n    function secureAddOrderFunds(address maker, bool isEthToToken, uint128 srcAmount, uint128 dstAmount)\r\n        internal returns(bool)\r\n    {\r\n        uint weiAmount = isEthToToken ? srcAmount : dstAmount;\r\n\r\n        require(weiAmount \u003E= limits.minNewOrderSizeWei);\r\n        require(bindOrderFunds(maker, isEthToToken, int(srcAmount)));\r\n        require(bindOrderStakes(maker, int(weiAmount)));\r\n\r\n        return true;\r\n    }\r\n\r\n    ///@dev funds are valid only when required knc amount can be staked for this order.\r\n    function secureUpdateOrderFunds(address maker, bool isEthToToken, uint128 prevSrcAmount, uint128 prevDstAmount,\r\n        uint128 newSrcAmount, uint128 newDstAmount)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint weiAmount = isEthToToken ? newSrcAmount : newDstAmount;\r\n        int weiDiff = isEthToToken ? (int(newSrcAmount) - int(prevSrcAmount)) :\r\n            (int(newDstAmount) - int(prevDstAmount));\r\n\r\n        require(weiAmount \u003E= limits.minNewOrderSizeWei);\r\n\r\n        require(bindOrderFunds(maker, isEthToToken, int(newSrcAmount) - int(prevSrcAmount)));\r\n\r\n        require(bindOrderStakes(maker, weiDiff));\r\n\r\n        return true;\r\n    }\r\n\r\n    event FullOrderTaken(address maker, uint32 orderId, bool isEthToToken);\r\n\r\n    function takeFullOrder(\r\n        address maker,\r\n        uint32 orderId,\r\n        ERC20 userSrc,\r\n        ERC20 userDst,\r\n        uint128 userSrcAmount,\r\n        uint128 userDstAmount\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n\r\n        //userDst == maker source\r\n        require(removeOrder(list, maker, userDst, orderId));\r\n\r\n        FullOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS);\r\n\r\n        return takeOrder(maker, userSrc, userSrcAmount, userDstAmount, 0);\r\n    }\r\n\r\n    event PartialOrderTaken(address maker, uint32 orderId, bool isEthToToken, bool isRemoved);\r\n\r\n    function takePartialOrder(\r\n        address maker,\r\n        uint32 orderId,\r\n        ERC20 userSrc,\r\n        ERC20 userDst,\r\n        uint128 userPartialSrcAmount,\r\n        uint128 userTakeDstAmount,\r\n        uint128 orderSrcAmount,\r\n        uint128 orderDstAmount\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        require(userPartialSrcAmount \u003C orderDstAmount);\r\n        require(userTakeDstAmount \u003C orderSrcAmount);\r\n\r\n        //must reuse parameters, otherwise stack too deep error.\r\n        orderSrcAmount -= userTakeDstAmount;\r\n        orderDstAmount -= userPartialSrcAmount;\r\n\r\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\r\n        uint weiValueNotReleasedFromOrder = (userSrc == ETH_TOKEN_ADDRESS) ? orderDstAmount : orderSrcAmount;\r\n        uint additionalReleasedWei = 0;\r\n\r\n        if (weiValueNotReleasedFromOrder \u003C limits.minOrderSizeWei) {\r\n            // remaining order amount too small. remove order and add remaining funds to free funds\r\n            makerFunds[maker][userDst] \u002B= orderSrcAmount;\r\n            additionalReleasedWei = weiValueNotReleasedFromOrder;\r\n\r\n            //for remove order we give makerSrc == userDst\r\n            require(removeOrder(list, maker, userDst, orderId));\r\n        } else {\r\n            bool isSuccess;\r\n\r\n            // update order values, taken order is always first order\r\n            (isSuccess,) = list.updateWithPositionHint(orderId, orderSrcAmount, orderDstAmount, HEAD_ID);\r\n            require(isSuccess);\r\n        }\r\n\r\n        PartialOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS, additionalReleasedWei \u003E 0);\r\n\r\n        //stakes are returned for unused wei value\r\n        return(takeOrder(maker, userSrc, userPartialSrcAmount, userTakeDstAmount, additionalReleasedWei));\r\n    }\r\n    \r\n    function takeOrder(\r\n        address maker,\r\n        ERC20 userSrc,\r\n        uint userSrcAmount,\r\n        uint userDstAmount,\r\n        uint additionalReleasedWei\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint weiAmount = userSrc == (ETH_TOKEN_ADDRESS) ? userSrcAmount : userDstAmount;\r\n\r\n        //token / eth already collected. just update maker balance\r\n        makerFunds[maker][userSrc] \u002B= userSrcAmount;\r\n\r\n        // send dst tokens in one batch. not here\r\n        //handle knc stakes and fee. releasedWeiValue was released and not traded.\r\n        return releaseOrderStakes(maker, (weiAmount \u002B additionalReleasedWei), weiAmount);\r\n    }\r\n\r\n    function removeOrder(\r\n        OrderListInterface list,\r\n        address maker,\r\n        ERC20 makerSrc,\r\n        uint32 orderId\r\n    )\r\n        internal returns(bool)\r\n    {\r\n        require(list.remove(orderId));\r\n        OrderIdData storage orders = (makerSrc == ETH_TOKEN_ADDRESS) ?\r\n            makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker];\r\n        require(releaseOrderId(orders, orderId));\r\n\r\n        return true;\r\n    }\r\n\r\n    function getList(OrderListInterface list) internal view returns(uint32[] memory orderList) {\r\n        OrderData memory orderData;\r\n        uint32 orderId;\r\n        bool isEmpty;\r\n\r\n        (orderId, isEmpty) = list.getFirstOrder();\r\n        if (isEmpty) return(new uint32[](0));\r\n\r\n        uint numOrders = 0;\r\n\r\n        for (; !orderData.isLastOrder; orderId = orderData.nextId) {\r\n            orderData = getOrderData(list, orderId);\r\n            numOrders\u002B\u002B;\r\n        }\r\n\r\n        orderList = new uint32[](numOrders);\r\n\r\n        (orderId, orderData.isLastOrder) = list.getFirstOrder();\r\n\r\n        for (uint i = 0; i \u003C numOrders; i\u002B\u002B) {\r\n            orderList[i] = orderId;\r\n            orderData = getOrderData(list, orderId);\r\n            orderId = orderData.nextId;\r\n        }\r\n    }\r\n\r\n    function getOrderData(OrderListInterface list, uint32 orderId) internal view returns (OrderData data) {\r\n        uint32 prevId;\r\n        (data.maker, data.srcAmount, data.dstAmount, prevId, data.nextId) = list.getOrderDetails(orderId);\r\n        data.isLastOrder = (data.nextId == TAIL_ID);\r\n    }\r\n\r\n    function validateLegalRate (uint srcAmount, uint dstAmount, bool isEthToToken)\r\n        internal view returns(bool)\r\n    {\r\n        uint rate;\r\n\r\n        /// notice, rate is calculated from taker perspective,\r\n        ///     for taker amounts are opposite. order srcAmount will be DstAmount for taker.\r\n        if (isEthToToken) {\r\n            rate = calcRateFromQty(dstAmount, srcAmount, getDecimals(contracts.token), ETH_DECIMALS);\r\n        } else {\r\n            rate = calcRateFromQty(dstAmount, srcAmount, ETH_DECIMALS, getDecimals(contracts.token));\r\n        }\r\n\r\n        if (rate \u003E MAX_RATE) return false;\r\n        return true;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022NUM_ORDERS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022submitEthToTokenOrderWHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022weiAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022calcBurnAmountFromFeeBurner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022getEthToTokenUpdateOrderHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerKnc\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerOrdersTokenToEth\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022firstOrderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022takenBitmap\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022depositToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022kncPerEthBaseRatePrecision\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdrawEther\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022getTokenToEthAddOrderHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022BURN_TO_STAKE_FACTOR\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdrawToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool[]\u0022},{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128[]\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128[]\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32[]\u0022},{\u0022name\u0022:\u0022isAfterPrevOrder\u0022,\u0022type\u0022:\u0022bool[]\u0022}],\u0022name\u0022:\u0022addOrderBatch\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022depositEther\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MIN_REMAINING_ORDER_RATIO\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerOrdersEthToToken\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022firstOrderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022takenBitmap\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022newSrcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022newDstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022updateEthToTokenOrderWHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022cancelTokenToEthOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getEthToTokenMakerOrderIds\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022orderList\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getTokenToEthOrderList\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022orderList\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022getEthToTokenAddOrderHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_USD_PER_ETH\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenToEthList\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022contracts\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022kncToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022feeBurner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022kyberNetwork\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022medianizer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022orderListFactory\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022getTokenToEthOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022_dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022_prevId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022_nextId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022dstToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022dstAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022conversionRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022validate\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022trade\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022submitTokenToEthOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022submitEthToTokenOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_BURN_FEE_BPS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022src\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022srcQty\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022blockNumber\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getConversionRate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022setKncPerEthBaseRate\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022weiAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022calcKncStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022newSrcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022newDstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022updateEthToTokenOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022weiAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022calcBurnAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022limits\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022minNewOrderSizeUsd\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxOrdersPerTrade\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022minNewOrderSizeWei\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022minOrderSizeWei\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerUnlockedKnc\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022getTokenToEthUpdateOrderHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022newSrcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022newDstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022updateTokenToEthOrderWHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdrawKncFee\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022newSrcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022newDstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022}],\u0022name\u0022:\u0022updateTokenToEthOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022submitTokenToEthOrderWHint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022setMinOrderSizeEth\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getTokenToEthMakerOrderIds\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022orderList\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerRequiredKncStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022getEthToTokenOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022_dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022name\u0022:\u0022_prevId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022_nextId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022HEAD_ID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerTotalOrdersWei\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022depositKncForFee\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022makerFunds\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022makerBurnFeeBps\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022TAIL_ID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022init\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022kncRateBlocksTrade\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool[]\u0022},{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32[]\u0022},{\u0022name\u0022:\u0022newSrcAmount\u0022,\u0022type\u0022:\u0022uint128[]\u0022},{\u0022name\u0022:\u0022newDstAmount\u0022,\u0022type\u0022:\u0022uint128[]\u0022},{\u0022name\u0022:\u0022hintPrevOrder\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022name\u0022:\u0022updateOrderBatch\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getEthToTokenOrderList\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022orderList\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022cancelEthToTokenOrder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ethToTokenList\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022knc\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022reserveToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022burner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022network\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022medianizer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022factory\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022minNewOrderUsd\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022maxOrdersPerTrade\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022burnFeeBps\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dstToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022OrderbookReserveTrade\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TokenDeposited\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022EtherDeposited\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022KncFeeDeposited\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022addedWithHint\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022NewLimitOrder\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022updatedWithHint\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022OrderUpdated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022srcAmount\u0022,\u0022type\u0022:\u0022uint128\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dstAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022OrderCanceled\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022FullOrderTaken\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022maker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022orderId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isEthToToken\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022isRemoved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022PartialOrderTaken\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"OrderbookReserve","CompilerVersion":"v0.4.18\u002Bcommit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd2000000000000000000000000000E8d6b471e332F140e7d9dbB99E5E3822F728DA60000000000000000000000008007aa43792A392b221DC091bdb2191E5fF626d100000000000000000000000065bF64Ff5f51272f729BDcD7AcFB00677ced86Cd000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b000000000000000000000000aba982e0190e27a32400a622fe016a44c4ffab6800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000019","Library":"","SwarmSource":"bzzr://7eb541f3d1a2548f0c8d7e0ff28ca2edb63374d5242dead60640e16d719ac99d"}]