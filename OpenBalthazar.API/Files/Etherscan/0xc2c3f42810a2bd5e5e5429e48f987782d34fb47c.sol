[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ncontract GeoRegistry {\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Variables Private\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  // set once in constructor()\r\n  //      geohashChar bitmask\r\n  mapping(bytes1 =\u003E bytes4) private charToBitmask;\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Variables Public\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  //      zoneCode isEnabled\r\n  mapping(bytes2 =\u003E bool) public zoneIsEnabled;\r\n\r\n  bytes2[] public enabledZone;\r\n\r\n  //      zoneCode       geohashFirst3 bitmaskLevel4\r\n  mapping(bytes2 =\u003E mapping(bytes3 =\u003E bytes4)) public level_2;\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Events\r\n  //\r\n  // ------------------------------------------------\r\n\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Constructor\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  constructor()\r\n    public\r\n  {\r\n\r\n    // TODO: improve below code? https://medium.com/@imolfar/bitwise-operations-and-bit-manipulation-in-solidity-ethereum-1751f3d2e216\r\n    charToBitmask[bytes1(\u0022v\u0022)] = hex\u002280000000\u0022; // 2147483648\r\n    charToBitmask[bytes1(\u0022y\u0022)] = hex\u002240000000\u0022; // 1073741824\r\n    charToBitmask[bytes1(\u0022z\u0022)] = hex\u002220000000\u0022; // 536870912\r\n    charToBitmask[bytes1(\u0022b\u0022)] = hex\u002210000000\u0022; // 268435456\r\n    charToBitmask[bytes1(\u0022c\u0022)] = hex\u002208000000\u0022; // 134217728\r\n    charToBitmask[bytes1(\u0022f\u0022)] = hex\u002204000000\u0022; // 67108864\r\n    charToBitmask[bytes1(\u0022g\u0022)] = hex\u002202000000\u0022; // 33554432\r\n    charToBitmask[bytes1(\u0022u\u0022)] = hex\u002201000000\u0022; // 16777216\r\n    charToBitmask[bytes1(\u0022t\u0022)] = hex\u002200800000\u0022; // 8388608\r\n    charToBitmask[bytes1(\u0022w\u0022)] = hex\u002200400000\u0022; // 4194304\r\n    charToBitmask[bytes1(\u0022x\u0022)] = hex\u002200200000\u0022; // 2097152\r\n    charToBitmask[bytes1(\u00228\u0022)] = hex\u002200100000\u0022; // 1048576\r\n    charToBitmask[bytes1(\u00229\u0022)] = hex\u002200080000\u0022; // 524288\r\n    charToBitmask[bytes1(\u0022d\u0022)] = hex\u002200040000\u0022; // 262144\r\n    charToBitmask[bytes1(\u0022e\u0022)] = hex\u002200020000\u0022; // 131072\r\n    charToBitmask[bytes1(\u0022s\u0022)] = hex\u002200010000\u0022; // 65536\r\n    charToBitmask[bytes1(\u0022m\u0022)] = hex\u002200008000\u0022; // 32768\r\n    charToBitmask[bytes1(\u0022q\u0022)] = hex\u002200004000\u0022; // 16384\r\n    charToBitmask[bytes1(\u0022r\u0022)] = hex\u002200002000\u0022; // 8192\r\n    charToBitmask[bytes1(\u00222\u0022)] = hex\u002200001000\u0022; // 4096\r\n    charToBitmask[bytes1(\u00223\u0022)] = hex\u002200000800\u0022; // 2048\r\n    charToBitmask[bytes1(\u00226\u0022)] = hex\u002200000400\u0022; // 1024\r\n    charToBitmask[bytes1(\u00227\u0022)] = hex\u002200000200\u0022; // 512\r\n    charToBitmask[bytes1(\u0022k\u0022)] = hex\u002200000100\u0022; // 256\r\n    charToBitmask[bytes1(\u0022j\u0022)] = hex\u002200000080\u0022; // 128\r\n    charToBitmask[bytes1(\u0022n\u0022)] = hex\u002200000040\u0022; // 64\r\n    charToBitmask[bytes1(\u0022p\u0022)] = hex\u002200000020\u0022; // 32\r\n    charToBitmask[bytes1(\u00220\u0022)] = hex\u002200000010\u0022; // 16\r\n    charToBitmask[bytes1(\u00221\u0022)] = hex\u002200000008\u0022; // 8\r\n    charToBitmask[bytes1(\u00224\u0022)] = hex\u002200000004\u0022; // 4\r\n    charToBitmask[bytes1(\u00225\u0022)] = hex\u002200000002\u0022; // 2\r\n    charToBitmask[bytes1(\u0022h\u0022)] = hex\u002200000001\u0022; // 1\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Private Getters\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  function toBytes1(bytes memory _bytes, uint _start)\r\n    private\r\n    pure\r\n    returns (bytes1)\r\n  {\r\n    require(_bytes.length \u003E= (_start \u002B 1), \u0022 not long enough\u0022);\r\n    bytes1 tempBytes1;\r\n\r\n    assembly {\r\n        tempBytes1 := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempBytes1;\r\n  }\r\n\r\n  function toBytes3(bytes memory _bytes, uint _start)\r\n    private\r\n    pure\r\n    returns (bytes3)\r\n  {\r\n    require(_bytes.length \u003E= (_start \u002B 3), \u0022 not long enough\u0022);\r\n    bytes3 tempBytes3;\r\n\r\n    assembly {\r\n        tempBytes3 := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempBytes3;\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Public Getters\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  function validGeohashChars(bytes memory _bytes)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_bytes.length \u003E 0, \u0022_bytes geohash chars is empty array\u0022);\r\n\r\n    for (uint i = 0; i \u003C _bytes.length; i \u002B= 1) {\r\n      // find the first occurence of a byte which is not valid geohash character\r\n      if (charToBitmask[toBytes1(_bytes, i)] == bytes4(0)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  function validGeohashChars12(bytes12 _bytes)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    for (uint i = 0; i \u003C 12; i \u002B= 1) {\r\n      // find the first occurence of a byte which is not valid geohash character\r\n      if (charToBitmask[bytes1(_bytes[i])] == bytes4(0)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // @NOTE: _zone can be any length of bytes\r\n  function zoneInsideBiggerZone(bytes2 _zoneCode, bytes4 _zone)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    bytes3 level2key = bytes3(_zone);\r\n    bytes4 level3bits = level_2[_zoneCode][level2key];\r\n\r\n    bytes1 fourthByte = bytes1(_zone[3]);\r\n    bytes4 fourthByteBitPosMask = charToBitmask[fourthByte];\r\n\r\n    if (level3bits \u0026 fourthByteBitPosMask != 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Setters Public\r\n  //\r\n  // ------------------------------------------------\r\n  function updateLevel2(bytes2 _zoneCode, bytes3 _letter, bytes4 _subLetters)\r\n    public\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \u0022zone must not be enabled\u0022);\r\n    level_2[_zoneCode][_letter] = _subLetters;\r\n  }\r\n  function updateLevel2batch(bytes2 _zoneCode, bytes3[] memory _letters, bytes4[] memory _subLetters)\r\n    public\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \u0022zone must not be enabled\u0022);\r\n    for (uint i = 0; i \u003C _letters.length; i\u002B\u002B) {\r\n      level_2[_zoneCode][_letters[i]] = _subLetters[i];\r\n    }\r\n  }\r\n  function endInit(bytes2 _zoneCode)\r\n    external\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \u0022zone must not be enabled\u0022);\r\n    zoneIsEnabled[_zoneCode] = true;\r\n    enabledZone.push(_zoneCode);\r\n  }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_bytes\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022validGeohashChars\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_zoneCode\u0022,\u0022type\u0022:\u0022bytes2\u0022},{\u0022name\u0022:\u0022_zone\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022zoneInsideBiggerZone\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes2\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes3\u0022}],\u0022name\u0022:\u0022level_2\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_zoneCode\u0022,\u0022type\u0022:\u0022bytes2\u0022},{\u0022name\u0022:\u0022_letter\u0022,\u0022type\u0022:\u0022bytes3\u0022},{\u0022name\u0022:\u0022_subLetters\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022updateLevel2\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes2\u0022}],\u0022name\u0022:\u0022zoneIsEnabled\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_zoneCode\u0022,\u0022type\u0022:\u0022bytes2\u0022}],\u0022name\u0022:\u0022endInit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_bytes\u0022,\u0022type\u0022:\u0022bytes12\u0022}],\u0022name\u0022:\u0022validGeohashChars12\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_zoneCode\u0022,\u0022type\u0022:\u0022bytes2\u0022},{\u0022name\u0022:\u0022_letters\u0022,\u0022type\u0022:\u0022bytes3[]\u0022},{\u0022name\u0022:\u0022_subLetters\u0022,\u0022type\u0022:\u0022bytes4[]\u0022}],\u0022name\u0022:\u0022updateLevel2batch\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022enabledZone\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes2\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"GeoRegistry","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f3c69085c18b67fd4d62334ecc07dee588deb7ffde029453821c1ccc8d1c2932"}]