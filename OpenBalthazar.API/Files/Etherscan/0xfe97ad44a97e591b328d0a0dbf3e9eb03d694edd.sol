[{"SourceCode":"/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external;\r\n  function transferFrom(address from, address to, uint256 value) external;\r\n  function approve(address spender, uint256 value) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003E 0);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003C= a);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    require(c \u003E= a);\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary Types {\r\n\r\n  struct RequestFee {\r\n    address feeRecipient;\r\n    address feeToken;\r\n    uint feeAmount;\r\n  }\r\n\r\n  struct RequestSignature {\r\n    uint8 v; \r\n    bytes32 r; \r\n    bytes32 s;\r\n  }\r\n\r\n  enum RequestType { Update, Transfer, Approve, Perform }\r\n\r\n  struct Request {\r\n    address owner;\r\n    address target;\r\n    RequestType requestType;\r\n    bytes payload;\r\n    uint nonce;\r\n    RequestFee fee;\r\n    RequestSignature signature;\r\n  }\r\n\r\n  struct TransferRequest {\r\n    address token;\r\n    address recipient;\r\n    uint amount;\r\n    bool unwrap;\r\n  }\r\n}\r\n\r\nlibrary LoopringTypes {\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    address tokenS;\r\n    address tokenB;\r\n    address feeToken;\r\n    uint totalFillAmountB;\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n}\r\n\r\ninterface IBrokerDelegate {\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest calldata request) external returns (bool);\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport calldata fillReport) external;\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n  function brokerMarginGetTrader(address owner, bytes calldata orderData) external view returns (address);\r\n}\r\n\r\ninterface IVersionable {\r\n  \r\n  /*\r\n   * Is called by IDepositContractRegistry when this version\r\n   * is being upgraded to. Will call \u0060versionEndUsage\u0060 on the\r\n   * old contract before calling this one\r\n   */\r\n  function versionBeginUsage(\r\n    address owner, \r\n    address payable depositAddress, \r\n    address oldVersion, \r\n    bytes calldata additionalData\r\n  ) external;\r\n\r\n  /*\r\n   * Is called by IDepositContractRegistry when this version is\r\n   * being upgraded from. IDepositContractRegistry will then call\r\n   * \u0060versionBeginUsage\u0060 on the new contract\r\n   */\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external;\r\n}\r\n\r\ninterface IDepositContract {  \r\n  function perform(\r\n    address addr, \r\n    string calldata signature, \r\n    bytes calldata encodedParams,\r\n    uint value\r\n  ) external returns (bytes memory);\r\n}\r\n\r\ninterface IDepositContractRegistry {\r\n  function depositAddressOf(address owner) external view returns (address payable);\r\n  function operatorOf(address owner, address operator) external returns (bool);\r\n}\r\n\r\nlibrary DepositContractHelper {\r\n\r\n  function wrapAndTransferToken(IDepositContract self, address token, address recipient, uint amount, address wethAddress) internal {\r\n    if (token == wethAddress) {\r\n      uint etherBalance = address(self).balance;\r\n      if (etherBalance \u003E 0) wrapEth(self, token, etherBalance);\r\n    }\r\n    transferToken(self, token, recipient, amount);\r\n  }\r\n\r\n  function transferToken(IDepositContract self, address token, address recipient, uint amount) internal {\r\n    self.perform(token, \u0022transfer(address,uint256)\u0022, abi.encode(recipient, amount), 0);\r\n  }\r\n\r\n  function transferEth(IDepositContract self, address recipient, uint amount) internal {\r\n    self.perform(recipient, \u0022\u0022, abi.encode(), amount);\r\n  }\r\n\r\n  function approveToken(IDepositContract self, address token, address broker, uint amount) internal {\r\n    self.perform(token, \u0022approve(address,uint256)\u0022, abi.encode(broker, amount), 0);\r\n  }\r\n\r\n  function wrapEth(IDepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \u0022deposit()\u0022, abi.encode(), amount);\r\n  }\r\n\r\n  function unwrapWeth(IDepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \u0022withdraw(uint256)\u0022, abi.encode(amount), 0);\r\n  }\r\n\r\n  function setDydxOperator(IDepositContract self, address dydxContract, address operator) internal {\r\n    bytes memory encodedParams = abi.encode(\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000020),\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000001),\r\n      operator,\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000001)\r\n    );\r\n    self.perform(dydxContract, \u0022setOperators((address,bool)[])\u0022, encodedParams, 0);\r\n  }\r\n}\r\n\r\nlibrary RequestHelper {\r\n\r\n  bytes constant personalPrefix = \u0022\\x19Ethereum Signed Message:\\n32\u0022;\r\n\r\n  function getSigner(Types.Request memory self) internal pure returns (address) {\r\n    bytes32 messageHash = keccak256(abi.encode(\r\n      self.owner,\r\n      self.target,\r\n      self.requestType,\r\n      self.payload,\r\n      self.nonce,\r\n      abi.encode(self.fee.feeRecipient, self.fee.feeToken, self.fee.feeAmount)\r\n    ));\r\n\r\n    bytes32 prefixedHash = keccak256(abi.encodePacked(personalPrefix, messageHash));\r\n    return ecrecover(prefixedHash, self.signature.v, self.signature.r, self.signature.s);\r\n  }\r\n\r\n  function decodeTransferRequest(Types.Request memory self) \r\n    internal \r\n    pure \r\n    returns (Types.TransferRequest memory transferRequest) \r\n  {\r\n    require(self.requestType == Types.RequestType.Transfer, \u0022INVALID_REQUEST_TYPE\u0022);\r\n\r\n    (\r\n      transferRequest.token,\r\n      transferRequest.recipient,\r\n      transferRequest.amount,\r\n      transferRequest.unwrap\r\n    ) = abi.decode(self.payload, (address, address, uint, bool));\r\n  }\r\n}\r\n\r\ncontract Requestable {\r\n  using RequestHelper for Types.Request;\r\n\r\n  mapping(address =\u003E uint) nonces;\r\n\r\n  function validateRequest(Types.Request memory request) internal {\r\n    require(request.target == address(this), \u0022INVALID_TARGET\u0022);\r\n    require(request.getSigner() == request.owner, \u0022INVALID_SIGNATURE\u0022);\r\n    require(nonces[request.owner] \u002B 1 == request.nonce, \u0022INVALID_NONCE\u0022);\r\n    \r\n    if (request.fee.feeAmount \u003E 0) {\r\n      require(balanceOf(request.owner, request.fee.feeToken) \u003E= request.fee.feeAmount, \u0022INSUFFICIENT_FEE_BALANCE\u0022);\r\n    }\r\n\r\n    nonces[request.owner] \u002B= 1;\r\n  }\r\n\r\n  function completeRequest(Types.Request memory request) internal {\r\n    if (request.fee.feeAmount \u003E 0) {\r\n      _payRequestFee(request.owner, request.fee.feeToken, request.fee.feeRecipient, request.fee.feeAmount);\r\n    }\r\n  }\r\n\r\n  function nonceOf(address owner) public view returns (uint) {\r\n    return nonces[owner];\r\n  }\r\n\r\n  // Abtract functions\r\n  function balanceOf(address owner, address token) public view returns (uint);\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal;\r\n}\r\n\r\n/**\r\n * @title DolomiteDirectV1\r\n * @author Zack Rubenstein\r\n *\r\n * Interfaces with the IDepositContractRegistry and individual \r\n * IDepositContracts to enable smart-wallet functionality as well\r\n * as spot and margin trading on Dolomite (through Loopring \u0026 Dy/dx)\r\n */\r\ncontract DolomiteDirectV1 is Requestable, IVersionable, IBrokerDelegate, IDolomiteMarginTradingBroker {\r\n  using DepositContractHelper for IDepositContract;\r\n  using SafeMath for uint;\r\n\r\n  IDepositContractRegistry public registry;\r\n  address public loopringProtocolAddress;\r\n  address public dolomiteMarginProtocolAddress;\r\n  address public dydxProtocolAddress;\r\n  address public wethTokenAddress;\r\n\r\n  constructor(\r\n    address _depositContractRegistry,\r\n    address _loopringRingSubmitter,\r\n    address _dolomiteMarginProtocol,\r\n    address _dydxProtocolAddress,\r\n    address _wethTokenAddress\r\n  ) public {\r\n    registry = IDepositContractRegistry(_depositContractRegistry);\r\n    loopringProtocolAddress = _loopringRingSubmitter;\r\n    dolomiteMarginProtocolAddress = _dolomiteMarginProtocol;\r\n    dydxProtocolAddress = _dydxProtocolAddress;\r\n    wethTokenAddress = _wethTokenAddress;\r\n  }\r\n\r\n  /*\r\n   * Returns the available balance for an owner that this contract manages.\r\n   * If the token is WETH, it returns the sum of the ETH and WETH balance,\r\n   * as ETH is automatically wrapped upon transfers (unless the unwrap option is\r\n   * set to true in the transfer request)\r\n   */\r\n  function balanceOf(address owner, address token) public view returns (uint) {\r\n    address depositAddress = registry.depositAddressOf(owner);\r\n    uint tokenBalance = IERC20(token).balanceOf(depositAddress);\r\n    if (token == wethTokenAddress) tokenBalance = tokenBalance.add(depositAddress.balance);\r\n    return tokenBalance;\r\n  }\r\n\r\n  /*\r\n   * Send up a signed transfer request and the given amount tokens\r\n   * is transfered to the specified recipient.\r\n   */\r\n  function transfer(Types.Request memory request) public {\r\n    validateRequest(request);\r\n    \r\n    Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\r\n    address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n    _transfer(\r\n      transferRequest.token, \r\n      depositAddress, \r\n      transferRequest.recipient, \r\n      transferRequest.amount, \r\n      transferRequest.unwrap\r\n    );\r\n\r\n    completeRequest(request);\r\n  }\r\n\r\n  // =============================\r\n\r\n  function _transfer(address token, address payable depositAddress, address recipient, uint amount, bool unwrap) internal {\r\n    IDepositContract depositContract = IDepositContract(depositAddress);\r\n    \r\n    if (token == wethTokenAddress \u0026\u0026 unwrap) {\r\n      if (depositAddress.balance \u003C amount) {\r\n        depositContract.unwrapWeth(wethTokenAddress, amount.sub(depositAddress.balance));\r\n      }\r\n\r\n      depositContract.transferEth(recipient, amount);\r\n      return;\r\n    }\r\n\r\n    depositContract.wrapAndTransferToken(token, recipient, amount, wethTokenAddress);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Loopring Broker Delegate\r\n\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest memory request) public returns (bool) {\r\n    require(msg.sender == loopringProtocolAddress);\r\n\r\n    LoopringTypes.BrokerOrder[] memory mergedOrders = new LoopringTypes.BrokerOrder[](request.orders.length);\r\n    uint numMergedOrders = 1;\r\n\r\n    mergedOrders[0] = request.orders[0];\r\n    \r\n    if (request.orders.length \u003E 1) {\r\n      for (uint i = 1; i \u003C request.orders.length; i\u002B\u002B) {\r\n        bool isDuplicate = false;\r\n\r\n        for (uint b = 0; b \u003C numMergedOrders; b\u002B\u002B) {\r\n          if (request.orders[i].owner == mergedOrders[b].owner) {\r\n            mergedOrders[b].requestedAmountS \u002B= request.orders[i].requestedAmountS;\r\n            mergedOrders[b].requestedFeeAmount \u002B= request.orders[i].requestedFeeAmount;\r\n            isDuplicate = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!isDuplicate) {\r\n          mergedOrders[numMergedOrders] = request.orders[i];\r\n          numMergedOrders \u002B= 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (uint j = 0; j \u003C numMergedOrders; j\u002B\u002B) {\r\n      LoopringTypes.BrokerOrder memory order = mergedOrders[j];\r\n      address payable depositAddress = registry.depositAddressOf(order.owner);\r\n      \r\n      _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\r\n      if (order.requestedFeeAmount \u003E 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\r\n    }\r\n\r\n    return false; // Does not use onOrderFillReport\r\n  }\r\n\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport memory fillReport) public {\r\n    // Do nothing\r\n  }\r\n\r\n  function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n    return balanceOf(owner, tokenAddress);\r\n  }\r\n\r\n  // ----------------------------\r\n  // Dolomite Margin Trading Broker\r\n\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) public {\r\n    require(msg.sender == dolomiteMarginProtocolAddress);\r\n\r\n    address payable depositAddress = registry.depositAddressOf(owner);\r\n    _transfer(token, depositAddress, address(this), amount, false);\r\n  }\r\n\r\n  function brokerMarginGetTrader(address owner, bytes memory orderData) public view returns (address) {\r\n    return registry.depositAddressOf(owner);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Requestable\r\n\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal {\r\n    _transfer(feeToken, registry.depositAddressOf(owner), feeRecipient, feeAmount, false);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Versionable\r\n\r\n  function versionBeginUsage(\r\n    address owner, \r\n    address payable depositAddress, \r\n    address oldVersion, \r\n    bytes calldata additionalData\r\n  ) external { \r\n    // Approve the DolomiteMarginProtocol as an operator for the deposit contract\u0027s dydx account\r\n    IDepositContract(depositAddress).setDydxOperator(dydxProtocolAddress, dolomiteMarginProtocolAddress);\r\n  }\r\n\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external { /* do nothing */ }\r\n\r\n\r\n  // =============================\r\n  // Administrative\r\n\r\n  /*\r\n   * Tokens are held in individual deposit contracts, the only time a trader\u0027s\r\n   * funds are held by this contract is when Loopring or Dy/dx requests a trader\u0027s\r\n   * tokens, and immediatly upon this contract moving funds into itself, Loopring\r\n   * or Dy/dx will move the funds out and into themselves. Thus, we can open this \r\n   * function up for anyone to call to set or reset the approval for Loopring and\r\n   * Dy/dx for a given token. The reason these approvals are set globally and not\r\n   * on an as-needed (per fill) basis is to reduce gas costs.\r\n   */\r\n  function enableTrading(address token) external {\r\n    IERC20(token).approve(loopringProtocolAddress, 10**70);\r\n    IERC20(token).approve(dolomiteMarginProtocolAddress, 10**70);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022enableTrading\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022wethTokenAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dolomiteMarginProtocolAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022depositAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022oldVersion\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022additionalData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022versionBeginUsage\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022brokerMarginRequestApproval\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022broker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022tokenB\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tokenS\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022feeToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022fillAmountB\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022spentAmountS\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022spentFeeAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenRecipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022extraData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022fillReport\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022onOrderFillReport\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022depositAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022newVersion\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022additionalData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022versionEndUsage\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022orderData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022brokerMarginGetTrader\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022registry\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022brokerBalanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022requestType\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022payload\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022feeRecipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022feeToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022feeAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022fee\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022components\u0022:[{\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022request\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022loopringProtocolAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dydxProtocolAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022orderHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022fillAmountB\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022requestedAmountS\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022requestedFeeAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenRecipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022extraData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022orders\u0022,\u0022type\u0022:\u0022tuple[]\u0022},{\u0022name\u0022:\u0022tokenS\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tokenB\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022feeToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022totalFillAmountB\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalRequestedAmountS\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalRequestedFeeAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022request\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022brokerRequestAllowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022nonceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_depositContractRegistry\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_loopringRingSubmitter\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_dolomiteMarginProtocol\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_dydxProtocolAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_wethTokenAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"DolomiteDirectV1","CompilerVersion":"v0.5.7\u002Bcommit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000ca8efcc93bca0bd89ad9bfffd050483dd80fdf07000000000000000000000000610c5e1eb8e97a38c1706af02b0caa778f74127c000000000000000000000000ade562b7f1344b325f4bd802139b0bcd6768b1cf0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"","SwarmSource":"bzzr://bcb36a75cd4a2515f237cbdd5009d03c12b7b625d5eb8b0870e577cd684e6e6f"}]