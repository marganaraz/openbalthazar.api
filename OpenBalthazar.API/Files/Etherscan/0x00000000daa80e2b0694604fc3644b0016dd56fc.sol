[{"SourceCode":"pragma solidity 0.5.13; // optimization runs: 65536, version: petersburg\r\n\r\n\r\n/**\r\n * @title IndestructibleRegistry\r\n * @author 0age \u002B flex \u002B smarx\r\n * @notice This contract determines if other contracts are incapable of being\r\n * destroyed by confirming that they do not contain any SELFDESTRUCT, CALLCODE,\r\n * or DELEGATECALL opcodes. Just because a contract is determined to potentially\r\n * be destructible does not necessarily mean that it IS destructible - in other\r\n * words, the check performed by this contract is contract is quite strict.\r\n * To register a contract as indestructible in the registry, provide the target\r\n * contract address to the \u0060registerAsIndestructible\u0060 function - it will throw\r\n * if the contract is potentially destructible. Then, anyone can call the\r\n * \u0060isRegisteredAsIndestructible\u0060 view function to confirm that the contract has\r\n * been successfully registered as an indestructible contract. You can also call\r\n * the \u0060isPotentiallyDestructible\u0060 view function to perform the destructibility\r\n * check without actually registering the contract. Note that future forks may\r\n * introduce new opcodes or other methods by which contracts can be destroyed;\r\n * in that case, this registry can no longer be relied on as a safeguard against\r\n * destructibility.\r\n */\r\ncontract IndestructibleRegistry {\r\n  // Maintain mapping of contracts that have been registered as indestructible.\r\n  mapping (address =\u003E bool) private _definitelyIndestructible;\r\n\r\n  /**\r\n   * @notice Register a target contract as indestructible. The attempt will\r\n   * revert if no code exists at the supplied target or if the target contract\r\n   * is potentially destructible (i.e. the code has reachable opcodes that could\r\n   * result in the contract being destroyed).\r\n   * @param target address The contract to check and register as indestructible.\r\n   */\r\n  function registerAsIndestructible(address target) external {\r\n    // Ensure that the target contract is not potentially destructible.\r\n    require(\r\n      !_isPotentiallyDestructible(target),\r\n      \u0022Supplied target is potentially destructible.\u0022\r\n    );\r\n\r\n    // Register the target as definitely indestructible (barring new opcodes).\r\n    _definitelyIndestructible[target] = true;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine if a target contract has been registered\r\n   * as indestructible.\r\n   * @param target address The contract to check for potential registration as\r\n   * an indestructible contract.\r\n   * @return A boolean signifying successful registration as an indestructable\r\n   * contract.\r\n   */\r\n  function isRegisteredAsIndestructible(\r\n    address target\r\n  ) external view returns (bool registeredAsIndestructible) {\r\n    registeredAsIndestructible = _definitelyIndestructible[target];\r\n  }\r\n\r\n  /**\r\n   * @notice View function to perform a scan of a target contract and determine\r\n   * whether it is potentially destructible or not. The call will revert if no\r\n   * code exists at the supplied target.\r\n   * @param target address The contract to check for potential destructibility.\r\n   * @return A boolean signifying whether or not the target contract is\r\n   * potentially destructible.\r\n   */\r\n  function isPotentiallyDestructible(\r\n    address target\r\n  ) external view returns (bool potentiallyDestructible) {\r\n    potentiallyDestructible = _isPotentiallyDestructible(target);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function that performs a scan of a target contract and\r\n   * determines whether it is potentially destructible or not. It first\r\n   * retrieves the runtime code size of the target contract and ensures that it\r\n   * is greater than zero. Then, it retrieves the actual runtime code from the\r\n   * target contract and places it into memory. Next, it iterates over the code,\r\n   * skipping over unreachable code and push data, and ensures no SELFDESTRUCT,\r\n   * DELEGATECALL, or CALLCODE opcodes are present in the code.\r\n   * @param target address The contract to check for potential destructibility.\r\n   * @return A boolean signifying whether or not the target contract is\r\n   * potentially destructible.\r\n   */\r\n  function _isPotentiallyDestructible(\r\n    address target\r\n  ) internal view returns (bool potentiallyDestructible) {\r\n    // Get the size of the target.\r\n    uint256 size;\r\n    assembly { size := extcodesize(target) }\r\n    require(size \u003E 0, \u0022No code at target.\u0022);\r\n    \r\n    // Get code at the target and the location data starts and ends in memory.\r\n    uint256 dataStart;\r\n    bytes memory extcode = new bytes(size);\r\n    assembly {\r\n      dataStart := add(extcode, 0x20)\r\n      extcodecopy(target, dataStart, 0, size)\r\n    }\r\n    uint256 dataEnd = dataStart \u002B size;\r\n    require (dataEnd \u003E dataStart, \u0022SafeMath: addition overflow.\u0022);\r\n    \r\n    // Look for any reachable, impermissible opcodes.\r\n    bool reachable = true;\r\n    uint256 op;\r\n    for (uint256 i = dataStart; i \u003C dataEnd; i\u002B\u002B) {\r\n      // Get the opcode in question.\r\n      assembly { op := shr(0xf8, mload(i)) }\r\n\r\n      // If the opcode is a PUSH, skip over the push data.\r\n      // Credit to @smarx for discovering an exploit in a prior version of this\r\n      // contract where this check only occurred as part of \u0022reachable\u0022 blocks.\r\n      if (op \u003E 95 \u0026\u0026 op \u003C 128) { // pushN\r\n        i \u002B= (op - 95);\r\n        continue;\r\n      }\r\n   \r\n      // Check the opcode if it is reachable (i.e. not a constant or metadata).\r\n      if (reachable) {\r\n        // If execution is halted, mark opcodes that follow as unreachable.\r\n        if (\r\n          op == 254 || // invalid\r\n          op == 243 || // return\r\n          op == 253 || // revert\r\n          op == 86  || // jump\r\n          op == 0      // stop\r\n        ) {\r\n          reachable = false;\r\n          continue;\r\n        }\r\n        \r\n        // If opcode is impermissible, return true - potential destructibility!\r\n        if (\r\n          op == 242 || // callcode\r\n          op == 244 || // delegatecall\r\n          op == 255    // selfdestruct\r\n        ) {\r\n          return true; // potentially destructible!\r\n        }\r\n      } else if (op == 91) { // jumpdest\r\n        // Whenever a JUMPDEST is found, mark opcodes that follow as reachable. \r\n        reachable = true;\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isPotentiallyDestructible\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022potentiallyDestructible\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isRegisteredAsIndestructible\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022registeredAsIndestructible\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022registerAsIndestructible\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"IndestructibleRegistry","CompilerVersion":"v0.5.13\u002Bcommit.5b0b510c","OptimizationUsed":"1","Runs":"65536","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5582dbe5e32e15eb60bae2d03fb67afba282cdf848f468a28f24b99a8ae14920"}]