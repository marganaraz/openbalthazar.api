[{"SourceCode":"/**\r\n * @title Decentralized Autonomous Trust\r\n * This contract is the reference implementation provided by Fairmint for a\r\n * Decentralized Autonomous Trust as described in the continuous\r\n * organization whitepaper (https://github.com/c-org/whitepaper) and\r\n * specified here: https://github.com/fairmint/c-org/wiki. Use at your own\r\n * risk. If you have question or if you\u0027re looking for a ready-to-use\r\n * solution using this contract, you might be interested in Fairmint\u0027s\r\n * offering. Do not hesitate to get in touch with us: https://fairmint.co\r\n */\r\n\r\n\r\n// File: contracts\\interfaces\\IWhitelist.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/**\r\n * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\r\n * With ERC-20 APIs removed (will be implemented as a separate contract).\r\n * And adding authorizeTransfer.\r\n */\r\ninterface IWhitelist\r\n{\r\n  /**\r\n   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n   * @param from Sending address\r\n   * @param to Receiving address\r\n   * @param value Amount of tokens being transferred\r\n   * @return Code by which to reference message for rejection reasoning\r\n   * @dev Overwrite with your custom transfer restriction logic\r\n   */\r\n  function detectTransferRestriction(\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) external view\r\n    returns (uint8);\r\n\r\n  /**\r\n   * @notice Returns a human-readable message for a given restriction code\r\n   * @param restrictionCode Identifier for looking up a message\r\n   * @return Text showing the restriction\u0027s reasoning\r\n   * @dev Overwrite with your custom message and restrictionCode handling\r\n   */\r\n  function messageForTransferRestriction(\r\n    uint8 restrictionCode\r\n  ) external pure\r\n    returns (string memory);\r\n\r\n  /**\r\n   * @notice Called by the DAT contract before a transfer occurs.\r\n   * @dev This call will revert when the transfer is not authorized.\r\n   * This is a mutable call to allow additional data to be recorded,\r\n   * such as when the user aquired their tokens.\r\n   */\r\n  function authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  ) external;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\math\\BigDiv.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\r\n * restores the proper size after division.\r\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\r\n * of a fraction, so long as the end result does not overflow as well.\r\n * @dev Results may be off by 1 \u002B 0.000001% for 2x1 calls and 2 \u002B 0.00001% for 2x2 calls.\r\n * Do not use if your contract expects very small result values to be accurate.\r\n */\r\nlibrary BigDiv\r\n{\r\n  using SafeMath for uint256;\r\n\r\n  /// @notice The max possible value\r\n  uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n  /// @notice When multiplying 2 terms \u003C= this value the result won\u0027t overflow\r\n  uint256 private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The max error target is off by 1 plus up to 0.000001% error\r\n  /// for bigDiv2x1 and that \u0060* 2\u0060 for bigDiv2x2\r\n  uint256 private constant MAX_ERROR = 100000000;\r\n\r\n  /// @notice A larger error threshold to use when multiple rounding errors may apply\r\n  uint256 private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\r\n\r\n  /**\r\n   * @notice Returns the approx result of \u0060a * b / d\u0060 so long as the result is \u003C= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 \u002B MAX_ERROR, rounding down if needed\r\n   */\r\n  function bigDiv2x1(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _den\r\n  ) internal pure\r\n    returns(uint256)\r\n  {\r\n    if(_numA == 0 || _numB == 0)\r\n    {\r\n      // would div by 0 or underflow if we don\u0027t special case 0\r\n      return 0;\r\n    }\r\n\r\n    uint256 value;\r\n\r\n    if(MAX_UINT / _numA \u003E= _numB)\r\n    {\r\n      // a*b does not overflow, return exact math\r\n      value = _numA * _numB;\r\n      value /= _den;\r\n      return value;\r\n    }\r\n\r\n    // Sort numerators\r\n    uint256 numMax = _numB;\r\n    uint256 numMin = _numA;\r\n    if(_numA \u003E _numB)\r\n    {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    value = numMax / _den;\r\n    if(value \u003E MAX_ERROR)\r\n    {\r\n      // _den is small enough to be MAX_ERROR or better w/o a factor\r\n      value = value.mul(numMin);\r\n      return value;\r\n    }\r\n\r\n    // formula = ((a / f) * b) / (d / f)\r\n    // factor \u003E= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint256 factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor \u002B= 1;\r\n    uint256 temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp \u002B= 1;\r\n    if(MAX_UINT / factor \u003E= temp)\r\n    {\r\n      factor *= temp;\r\n      value = numMax / factor;\r\n      if(value \u003E MAX_ERROR_BEFORE_DIV)\r\n      {\r\n        value = value.mul(numMin);\r\n        temp = _den - 1;\r\n        temp /= factor;\r\n        temp = temp.add(1);\r\n        value /= temp;\r\n        return value;\r\n      }\r\n    }\r\n\r\n    // formula: (a / (d / f)) * (b / f)\r\n    // factor: b / sqrt(MAX)\r\n    factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor \u002B= 1;\r\n    value = numMin / factor;\r\n    temp = _den - 1;\r\n    temp /= factor;\r\n    temp \u002B= 1;\r\n    temp = numMax / temp;\r\n    value = value.mul(temp);\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of \u0060a * b / d\u0060 so long as the result is \u003C= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 \u002B MAX_ERROR, rounding down if needed\r\n   * @dev roundUp is implemented by first rounding down and then adding the max error to the result\r\n   */\r\n  function bigDiv2x1RoundUp(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _den\r\n  ) internal pure\r\n    returns(uint256)\r\n  {\r\n    // first get the rounded down result\r\n    uint256 value = bigDiv2x1(_numA, _numB, _den);\r\n\r\n    if(value == 0)\r\n    {\r\n      // when the value rounds down to 0, assume up to an off by 1 error\r\n      return 1;\r\n    }\r\n\r\n    // round down has a max error of MAX_ERROR, add that to the result\r\n    // for a round up error of \u003C= MAX_ERROR\r\n    uint256 temp = value - 1;\r\n    temp /= MAX_ERROR;\r\n    temp \u002B= 1;\r\n    if(MAX_UINT - value \u003C temp)\r\n    {\r\n      // value \u002B error would overflow, return MAX\r\n      return MAX_UINT;\r\n    }\r\n\r\n    value \u002B= temp;\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of \u0060a * b / (c * d)\u0060 so long as the result is \u003C= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _denA the first denominator term\r\n   * @param _denB the second denominator term\r\n   * @return the approx result with up to off by 2 \u002B MAX_ERROR*10 error, rounding down if needed\r\n   * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\r\n   * formula is larger\r\n   */\r\n  function bigDiv2x2(\r\n    uint256 _numA,\r\n    uint256 _numB,\r\n    uint256 _denA,\r\n    uint256 _denB\r\n  ) internal pure\r\n    returns (uint256)\r\n  {\r\n    if(MAX_UINT / _denA \u003E= _denB)\r\n    {\r\n      // denA*denB does not overflow, use bigDiv2x1 instead\r\n      return bigDiv2x1(_numA, _numB, _denA * _denB);\r\n    }\r\n\r\n    if(_numA == 0 || _numB == 0)\r\n    {\r\n      // would div by 0 or underflow if we don\u0027t special case 0\r\n      return 0;\r\n    }\r\n\r\n    // Sort denominators\r\n    uint256 denMax = _denB;\r\n    uint256 denMin = _denA;\r\n    if(_denA \u003E _denB)\r\n    {\r\n      denMax = _denA;\r\n      denMin = _denB;\r\n    }\r\n\r\n    uint256 value;\r\n\r\n    if(MAX_UINT / _numA \u003E= _numB)\r\n    {\r\n      // a*b does not overflow, use \u0060a / d / c\u0060\r\n      value = _numA * _numB;\r\n      value /= denMin;\r\n      value /= denMax;\r\n      return value;\r\n    }\r\n\r\n    // \u0060ab / cd\u0060 where both \u0060ab\u0060 and \u0060cd\u0060 would overflow\r\n\r\n    // Sort numerators\r\n    uint256 numMax = _numB;\r\n    uint256 numMin = _numA;\r\n    if(_numA \u003E _numB)\r\n    {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    // formula = (a/d) * b / c\r\n    uint256 temp = numMax / denMin;\r\n    if(temp \u003E MAX_ERROR_BEFORE_DIV)\r\n    {\r\n      return bigDiv2x1(temp, numMin, denMax);\r\n    }\r\n\r\n    // formula: ((a/f) * b) / d then either * f / c or / c * f\r\n    // factor \u003E= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint256 factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor \u002B= 1;\r\n    temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp \u002B= 1;\r\n    if(MAX_UINT / factor \u003E= temp)\r\n    {\r\n      factor *= temp;\r\n\r\n      value = numMax / factor;\r\n      if(value \u003E MAX_ERROR_BEFORE_DIV)\r\n      {\r\n        value = value.mul(numMin);\r\n        value /= denMin;\r\n        if(value \u003E 0 \u0026\u0026 MAX_UINT / value \u003E= factor)\r\n        {\r\n          value *= factor;\r\n          value /= denMax;\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n\r\n    // formula: (a/f) * b / ((c*d)/f)\r\n    // factor \u003E= c / sqrt(MAX) * (d / sqrt(MAX))\r\n    factor = denMin;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    temp = denMax;\r\n    // \u002B 1 here prevents overflow of factor*temp\r\n    temp /= MAX_BEFORE_SQUARE \u002B 1;\r\n    factor *= temp;\r\n    return bigDiv2x1(numMax / factor, numMin, MAX_UINT);\r\n  }\r\n}\r\n\r\n// File: contracts\\math\\Sqrt.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Calculates the square root of a given value.\r\n * @dev Results may be off by 1.\r\n */\r\nlibrary Sqrt\r\n{\r\n  /// @notice The max possible value\r\n  uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n  // Source: https://github.com/ethereum/dapp-bin/pull/50\r\n  function sqrt(\r\n    uint x\r\n  ) internal pure\r\n    returns (uint y)\r\n  {\r\n    if (x == 0)\r\n    {\r\n      return 0;\r\n    }\r\n    else if (x \u003C= 3)\r\n    {\r\n      return 1;\r\n    }\r\n    else if (x == MAX_UINT)\r\n    {\r\n      // Without this we fail on x \u002B 1 below\r\n      return 2**128 - 1;\r\n    }\r\n\r\n    uint z = (x \u002B 1) / 2;\r\n    y = x;\r\n    while (z \u003C y)\r\n    {\r\n      y = z;\r\n      z = (x / z \u002B z) / 2;\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts-ethereum-package\\contracts\\utils\\Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract\u0027s constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. \u0060keccak256(\u0027\u0027)\u0060\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an \u0060address\u0060 into \u0060address payable\u0060. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s \u0060transfer\u0060: sends \u0060amount\u0060 wei to\r\n     * \u0060recipient\u0060, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by \u0060transfer\u0060, making them unable to receive funds via\r\n     * \u0060transfer\u0060. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to \u0060recipient\u0060, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003E= amount, \u0022Address: insufficient balance\u0022);\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\u0022\u0022);\r\n        require(success, \u0022Address: unable to send value, recipient may have reverted\u0022);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a \u0060using SafeERC20 for ERC20;\u0060 statement to your contract,\r\n * which allows you to call the safe operations as \u0060token.safeTransfer(...)\u0060, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \u0022SafeERC20: approve from non-zero to non-zero allowance\u0022\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \u0022SafeERC20: decreased allowance below zero\u0022);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \u0022SafeERC20: call to non-contract\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \u0022SafeERC20: low-level call failed\u0022);\r\n\r\n        if (returndata.length \u003E 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \u0022SafeERC20: ERC20 operation did not succeed\u0022);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\upgrades\\contracts\\Initializable.sol\r\n\r\npragma solidity \u003E=0.4.24 \u003C0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the \u0060initializer\u0060 modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \u0022Contract instance has already been initialized\u0022);\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts-ethereum-package\\contracts\\GSN\\Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Initializable, Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003E uint256) private _balances;\r\n\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - the caller must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     * - the caller must have allowance for \u0060sender\u0060\u0027s tokens of at least\r\n     * \u0060amount\u0060.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \u0022ERC20: transfer amount exceeds allowance\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 must have allowance for the caller of at least\r\n     * \u0060subtractedValue\u0060.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \u0022ERC20: decreased allowance below zero\u0022));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060sender\u0060 cannot be the zero address.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \u0022ERC20: transfer from the zero address\u0022);\r\n        require(recipient != address(0), \u0022ERC20: transfer to the zero address\u0022);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \u0022ERC20: transfer amount exceeds balance\u0022);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060to\u0060 cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \u0022ERC20: mint to the zero address\u0022);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \u0022ERC20: burn from the zero address\u0022);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \u0022ERC20: burn amount exceeds balance\u0022);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\r\n     *\r\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060owner\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \u0022ERC20: approve from the zero address\u0022);\r\n        require(spender != address(0), \u0022ERC20: approve to the zero address\u0022);\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \u0022ERC20: burn amount exceeds allowance\u0022));\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for \u0060name\u0060, \u0060symbol\u0060, and \u0060decimals\u0060. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if \u0060decimals\u0060 equals \u00602\u0060, a balance of \u0060505\u0060 tokens should\r\n     * be displayed to a user as \u00605,05\u0060 (\u0060505 / 10 ** 2\u0060).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\DecentralizedAutonomousTrust.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Decentralized Autonomous Trust\r\n * This contract is the reference implementation provided by Fairmint for a\r\n * Decentralized Autonomous Trust as described in the continuous\r\n * organization whitepaper (https://github.com/c-org/whitepaper) and\r\n * specified here: https://github.com/fairmint/c-org/wiki. Use at your own\r\n * risk. If you have question or if you\u0027re looking for a ready-to-use\r\n * solution using this contract, you might be interested in Fairmint\u0027s\r\n * offering. Do not hesitate to get in touch with us: https://fairmint.co\r\n */\r\ncontract DecentralizedAutonomousTrust\r\n  is ERC20, ERC20Detailed\r\n{\r\n  using SafeMath for uint;\r\n  using Sqrt for uint;\r\n  using SafeERC20 for IERC20;\r\n\r\n  /**\r\n   * Events\r\n   */\r\n\r\n  event Buy(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Sell(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Burn(\r\n    address indexed _from,\r\n    uint _fairValue\r\n  );\r\n  event Pay(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Close(\r\n    uint _exitFee\r\n  );\r\n  event StateChange(\r\n    uint _previousState,\r\n    uint _newState\r\n  );\r\n  event UpdateConfig(\r\n    address _whitelistAddress,\r\n    address indexed _beneficiary,\r\n    address indexed _control,\r\n    address indexed _feeCollector,\r\n    bool _autoBurn,\r\n    uint _revenueCommitmentBasisPoints,\r\n    uint _feeBasisPoints,\r\n    uint _minInvestment,\r\n    uint _openUntilAtLeast\r\n  );\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  /// @notice The default state\r\n  uint private constant STATE_INIT = 0;\r\n\r\n  /// @notice The state after initGoal has been reached\r\n  uint private constant STATE_RUN = 1;\r\n\r\n  /// @notice The state after closed by the \u0060beneficiary\u0060 account from STATE_RUN\r\n  uint private constant STATE_CLOSE = 2;\r\n\r\n  /// @notice The state after closed by the \u0060beneficiary\u0060 account from STATE_INIT\r\n  uint private constant STATE_CANCEL = 3;\r\n\r\n  /// @notice When multiplying 2 terms, the max value is 2^128-1\r\n  uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The denominator component for values specified in basis points.\r\n  uint private constant BASIS_POINTS_DEN = 10000;\r\n\r\n  /// @notice The max \u0060totalSupply() \u002B burnedSupply\u0060\r\n  /// @dev This limit ensures that the DAT\u0027s formulas do not overflow (\u003CMAX_BEFORE_SQUARE/2)\r\n  uint private constant MAX_SUPPLY = 10 ** 38;\r\n\r\n  /**\r\n   * Data specific to our token business logic\r\n   */\r\n\r\n  /// @notice The contract for transfer authorizations, if any.\r\n  IWhitelist public whitelist;\r\n\r\n  /// @notice The total number of burned FAIR tokens, excluding tokens burned from a \u0060Sell\u0060 action in the DAT.\r\n  uint public burnedSupply;\r\n\r\n  /**\r\n   * Data for DAT business logic\r\n   */\r\n\r\n  /// @notice Set if the FAIRs minted by the organization when it commits its revenues are\r\n  /// automatically burnt (\u0060true\u0060) or not (\u0060false\u0060). Defaults to \u0060false\u0060 meaning that there\r\n  /// is no automatic burn.\r\n  bool public autoBurn;\r\n\r\n  /// @notice The address of the beneficiary organization which receives the investments.\r\n  /// Points to the wallet of the organization.\r\n  address payable public beneficiary;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the numerator component of the fractional value.\r\n  uint public buySlopeNum;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the denominator component of the fractional value.\r\n  uint public buySlopeDen;\r\n\r\n  /// @notice The address from which the updatable variables can be updated\r\n  address public control;\r\n\r\n  /// @notice The address of the token used as reserve in the bonding curve\r\n  /// (e.g. the DAI contract). Use ETH if 0.\r\n  IERC20 public currency;\r\n\r\n  /// @notice The address where fees are sent.\r\n  address payable public feeCollector;\r\n\r\n  /// @notice The percent fee collected each time new FAIR are issued expressed in basis points.\r\n  uint public feeBasisPoints;\r\n\r\n  /// @notice The initial fundraising goal (expressed in FAIR) to start the c-org.\r\n  /// \u00600\u0060 means that there is no initial fundraising and the c-org immediately moves to run state.\r\n  uint public initGoal;\r\n\r\n  /// @notice A map with all investors in init state using address as a key and amount as value.\r\n  /// @dev This structure\u0027s purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\r\n  mapping(address =\u003E uint) public initInvestors;\r\n\r\n  /// @notice The initial number of FAIR created at initialization for the beneficiary.\r\n  /// Technically however, this variable is not a constant as we must always have\r\n  ///\u0060init_reserve\u003E=total_supply\u002Bburnt_supply\u0060 which means that \u0060init_reserve\u0060 will be automatically\r\n  /// decreased to equal \u0060total_supply\u002Bburnt_supply\u0060 in case \u0060init_reserve\u003Etotal_supply\u002Bburnt_supply\u0060\r\n  /// after an investor sells his FAIRs.\r\n  /// @dev Organizations may move these tokens into vesting contract(s)\r\n  uint public initReserve;\r\n\r\n  /// @notice The investment reserve of the c-org. Defines the percentage of the value invested that is\r\n  /// automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  uint public investmentReserveBasisPoints;\r\n\r\n  /// @notice The earliest date/time (in seconds) that the DAT may enter the \u0060CLOSE\u0060 state, ensuring\r\n  /// that if the DAT reaches the \u0060RUN\u0060 state it will remain running for at least this period of time.\r\n  /// @dev This value may be increased anytime by the control account\r\n  uint public openUntilAtLeast;\r\n\r\n  /// @notice The minimum amount of \u0060currency\u0060 investment accepted.\r\n  uint public minInvestment;\r\n\r\n  /// @notice The revenue commitment of the organization. Defines the percentage of the value paid through the contract\r\n  /// that is automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  uint public revenueCommitmentBasisPoints;\r\n\r\n  /// @notice The current state of the contract.\r\n  /// @dev See the constants above for possible state values.\r\n  uint public state;\r\n\r\n  string public constant version = \u00222\u0022;\r\n  // --- EIP712 niceties ---\r\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n  mapping (address =\u003E uint) public nonces;\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n  // bytes32 public constant PERMIT_TYPEHASH = keccak256(\u0022Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\u0022);\r\n  bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n  modifier authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  )\r\n  {\r\n    if(address(whitelist) != address(0))\r\n    {\r\n      // This is not set for the minting of initialReserve\r\n      whitelist.authorizeTransfer(_from, _to, _value, _isSell);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Buyback reserve\r\n   */\r\n\r\n  /// @notice The total amount of currency value currently locked in the contract and available to sellers.\r\n  function buybackReserve() public view returns (uint)\r\n  {\r\n    uint reserve = address(this).balance;\r\n    if(address(currency) != address(0))\r\n    {\r\n      reserve = currency.balanceOf(address(this));\r\n    }\r\n\r\n    if(reserve \u003E MAX_BEFORE_SQUARE)\r\n    {\r\n      /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\r\n      return MAX_BEFORE_SQUARE;\r\n    }\r\n\r\n    return reserve;\r\n  }\r\n\r\n  /**\r\n   * Functions required for the whitelist\r\n   */\r\n\r\n  function _detectTransferRestriction(\r\n    address _from,\r\n    address _to,\r\n    uint _value\r\n  ) private view\r\n    returns (uint)\r\n  {\r\n    if(address(whitelist) != address(0))\r\n    {\r\n      // This is not set for the minting of initialReserve\r\n      return whitelist.detectTransferRestriction(_from, _to, _value);\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Functions required by the ERC-20 token standard\r\n   */\r\n\r\n  /// @dev Moves tokens from one account to another if authorized.\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint _amount\r\n  ) internal\r\n    authorizeTransfer(_from, _to, _amount, false)\r\n  {\r\n    require(state != STATE_INIT || _from == beneficiary, \u0022ONLY_BENEFICIARY_DURING_INIT\u0022);\r\n    super._transfer(_from, _to, _amount);\r\n  }\r\n\r\n  /// @dev Removes tokens from the circulating supply.\r\n  function _burn(\r\n    address _from,\r\n    uint _amount,\r\n    bool _isSell\r\n  ) internal\r\n    authorizeTransfer(_from, address(0), _amount, _isSell)\r\n  {\r\n    super._burn(_from, _amount);\r\n\r\n    if(!_isSell)\r\n    {\r\n      // This is a burn\r\n      require(state == STATE_RUN, \u0022ONLY_DURING_RUN\u0022);\r\n      // SafeMath not required as we cap how high this value may get during mint\r\n      burnedSupply \u002B= _amount;\r\n      emit Burn(_from, _amount);\r\n    }\r\n  }\r\n\r\n  /// @notice Called to mint tokens on \u0060buy\u0060.\r\n  function _mint(\r\n    address _to,\r\n    uint _quantity\r\n  ) internal\r\n    authorizeTransfer(address(0), _to, _quantity, false)\r\n  {\r\n    super._mint(_to, _quantity);\r\n\r\n    // Math: If this value got too large, the DAT may overflow on sell\r\n    require(totalSupply().add(burnedSupply) \u003C= MAX_SUPPLY, \u0022EXCESSIVE_SUPPLY\u0022);\r\n  }\r\n\r\n  /**\r\n   * Transaction Helpers\r\n   */\r\n\r\n  /// @notice Confirms the transfer of \u0060_quantityToInvest\u0060 currency to the contract.\r\n  function _collectInvestment(\r\n    uint _quantityToInvest,\r\n    uint _msgValue,\r\n    bool _refundRemainder\r\n  ) private\r\n  {\r\n    if(address(currency) == address(0))\r\n    {\r\n      // currency is ETH\r\n      if(_refundRemainder)\r\n      {\r\n        // Math: if _msgValue was not sufficient then revert\r\n        uint refund = _msgValue.sub(_quantityToInvest);\r\n        if(refund \u003E 0)\r\n        {\r\n          Address.sendValue(msg.sender, refund);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        require(_quantityToInvest == _msgValue, \u0022INCORRECT_MSG_VALUE\u0022);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // currency is ERC20\r\n      require(_msgValue == 0, \u0022DO_NOT_SEND_ETH\u0022);\r\n\r\n      currency.safeTransferFrom(msg.sender, address(this), _quantityToInvest);\r\n    }\r\n  }\r\n\r\n  /// @dev Send \u0060_amount\u0060 currency from the contract to the \u0060_to\u0060 account.\r\n  function _transferCurrency(\r\n    address payable _to,\r\n    uint _amount\r\n  ) private\r\n  {\r\n    if(_amount \u003E 0)\r\n    {\r\n      if(address(currency) == address(0))\r\n      {\r\n        Address.sendValue(_to, _amount);\r\n      }\r\n      else\r\n      {\r\n        currency.safeTransfer(_to, _amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Config / Control\r\n   */\r\n\r\n  /// @notice Called once after deploy to set the initial configuration.\r\n  /// None of the values provided here may change once initially set.\r\n  /// @dev using the init pattern in order to support zos upgrades\r\n  function initialize(\r\n    uint _initReserve,\r\n    address _currencyAddress,\r\n    uint _initGoal,\r\n    uint _buySlopeNum,\r\n    uint _buySlopeDen,\r\n    uint _investmentReserveBasisPoints,\r\n    string memory _name,\r\n    string memory _symbol\r\n  ) public\r\n  {\r\n    require(control == address(0), \u0022ALREADY_INITIALIZED\u0022);\r\n\r\n    ERC20Detailed.initialize(_name, _symbol, 18);\r\n\r\n    // Set initGoal, which in turn defines the initial state\r\n    if(_initGoal == 0)\r\n    {\r\n      emit StateChange(state, STATE_RUN);\r\n      state = STATE_RUN;\r\n    }\r\n    else\r\n    {\r\n      // Math: If this value got too large, the DAT would overflow on sell\r\n      require(_initGoal \u003C MAX_SUPPLY, \u0022EXCESSIVE_GOAL\u0022);\r\n      initGoal = _initGoal;\r\n    }\r\n\r\n    require(_buySlopeNum \u003E 0, \u0022INVALID_SLOPE_NUM\u0022);\r\n    require(_buySlopeDen \u003E 0, \u0022INVALID_SLOPE_DEN\u0022);\r\n    require(_buySlopeNum \u003C MAX_BEFORE_SQUARE, \u0022EXCESSIVE_SLOPE_NUM\u0022);\r\n    require(_buySlopeDen \u003C MAX_BEFORE_SQUARE, \u0022EXCESSIVE_SLOPE_DEN\u0022);\r\n    buySlopeNum = _buySlopeNum;\r\n    buySlopeDen = _buySlopeDen;\r\n    // 100% or less\r\n    require(_investmentReserveBasisPoints \u003C= BASIS_POINTS_DEN, \u0022INVALID_RESERVE\u0022);\r\n    investmentReserveBasisPoints = _investmentReserveBasisPoints;\r\n\r\n    // Set default values (which may be updated using \u0060updateConfig\u0060)\r\n    minInvestment = 100 ether;\r\n    beneficiary = msg.sender;\r\n    control = msg.sender;\r\n    feeCollector = msg.sender;\r\n\r\n    // Save currency\r\n    currency = IERC20(_currencyAddress);\r\n\r\n    // Mint the initial reserve\r\n    if(_initReserve \u003E 0)\r\n    {\r\n      initReserve = _initReserve;\r\n      _mint(beneficiary, initReserve);\r\n    }\r\n  }\r\n  function getChainId(\r\n  ) private pure\r\n    returns (uint id)\r\n  {\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      id := chainid()\r\n    }\r\n  }\r\n\r\n  function initializePermit(\r\n  ) public\r\n  {\r\n    DOMAIN_SEPARATOR = keccak256(\r\n      abi.encode(\r\n        keccak256(\u0022EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\u0022),\r\n        keccak256(bytes(name())),\r\n        keccak256(bytes(version)),\r\n        getChainId(),\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  function updateConfig(\r\n    address _whitelistAddress,\r\n    address payable _beneficiary,\r\n    address _control,\r\n    address payable _feeCollector,\r\n    uint _feeBasisPoints,\r\n    bool _autoBurn,\r\n    uint _revenueCommitmentBasisPoints,\r\n    uint _minInvestment,\r\n    uint _openUntilAtLeast\r\n  ) public\r\n  {\r\n    // This require(also confirms that initialize has been called.\r\n    require(msg.sender == control, \u0022CONTROL_ONLY\u0022);\r\n\r\n    // address(0) is okay\r\n    whitelist = IWhitelist(_whitelistAddress);\r\n\r\n    require(_control != address(0), \u0022INVALID_ADDRESS\u0022);\r\n    control = _control;\r\n\r\n    require(_feeCollector != address(0), \u0022INVALID_ADDRESS\u0022);\r\n    feeCollector = _feeCollector;\r\n\r\n    autoBurn = _autoBurn;\r\n\r\n    require(_revenueCommitmentBasisPoints \u003C= BASIS_POINTS_DEN, \u0022INVALID_COMMITMENT\u0022);\r\n    require(_revenueCommitmentBasisPoints \u003E= revenueCommitmentBasisPoints, \u0022COMMITMENT_MAY_NOT_BE_REDUCED\u0022);\r\n    revenueCommitmentBasisPoints = _revenueCommitmentBasisPoints;\r\n\r\n    require(_feeBasisPoints \u003C= BASIS_POINTS_DEN, \u0022INVALID_FEE\u0022);\r\n    feeBasisPoints = _feeBasisPoints;\r\n\r\n    require(_minInvestment \u003E 0, \u0022INVALID_MIN_INVESTMENT\u0022);\r\n    minInvestment = _minInvestment;\r\n\r\n    require(_openUntilAtLeast \u003E= openUntilAtLeast, \u0022OPEN_UNTIL_MAY_NOT_BE_REDUCED\u0022);\r\n    openUntilAtLeast = _openUntilAtLeast;\r\n\r\n    if(beneficiary != _beneficiary)\r\n    {\r\n      require(_beneficiary != address(0), \u0022INVALID_ADDRESS\u0022);\r\n      uint tokens = balanceOf(beneficiary);\r\n      initInvestors[_beneficiary] = initInvestors[_beneficiary].add(initInvestors[beneficiary]);\r\n      initInvestors[beneficiary] = 0;\r\n      if(tokens \u003E 0)\r\n      {\r\n        _transfer(beneficiary, _beneficiary, tokens);\r\n      }\r\n      beneficiary = _beneficiary;\r\n    }\r\n\r\n    emit UpdateConfig(\r\n      _whitelistAddress,\r\n      _beneficiary,\r\n      _control,\r\n      _feeCollector,\r\n      _autoBurn,\r\n      _revenueCommitmentBasisPoints,\r\n      _feeBasisPoints,\r\n      _minInvestment,\r\n      _openUntilAtLeast\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Functions for our business logic\r\n   */\r\n\r\n  /// @notice Burn the amount of tokens from the address msg.sender if authorized.\r\n  /// @dev Note that this is not the same as a \u0060sell\u0060 via the DAT.\r\n  function burn(\r\n    uint _amount\r\n  ) public\r\n  {\r\n    _burn(msg.sender, _amount, false);\r\n  }\r\n\r\n  // Buy\r\n\r\n  /// @dev Distributes _value currency between the buybackReserve, beneficiary, and feeCollector.\r\n  function _distributeInvestment(\r\n    uint _value\r\n  ) private\r\n  {\r\n    // Rounding favors buybackReserve, then beneficiary, and feeCollector is last priority.\r\n\r\n    // Math: if investment value is \u003C (2^256 - 1) / 10000 this will never overflow.\r\n    // Except maybe with a huge single investment, but they can try again with multiple smaller investments.\r\n    uint reserve = investmentReserveBasisPoints.mul(_value);\r\n    reserve /= BASIS_POINTS_DEN;\r\n    reserve = _value.sub(reserve);\r\n    uint fee = reserve.mul(feeBasisPoints);\r\n    fee /= BASIS_POINTS_DEN;\r\n\r\n    // Math: since feeBasisPoints is \u003C= BASIS_POINTS_DEN, this will never underflow.\r\n    _transferCurrency(beneficiary, reserve - fee);\r\n    _transferCurrency(feeCollector, fee);\r\n  }\r\n\r\n  /// @notice Calculate how many FAIR tokens you would buy with the given amount of currency if \u0060buy\u0060 was called now.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  function estimateBuyValue(\r\n    uint _currencyValue\r\n  ) public view\r\n    returns (uint)\r\n  {\r\n    if(_currencyValue \u003C minInvestment)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    /// Calculate the tokenValue for this investment\r\n    uint tokenValue;\r\n    if(state == STATE_INIT)\r\n    {\r\n      uint currencyValue = _currencyValue;\r\n      uint _totalSupply = totalSupply();\r\n      // (buy_slope*init_goal)*(init_goal\u002Binit_reserve-total_supply)/2\r\n      // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\r\n      // g: init_goal (MAX_BEFORE_SQUARE/2)\r\n      // t: total_supply (MAX_BEFORE_SQUARE/2)\r\n      // r: init_reserve (MAX_BEFORE_SQUARE/2)\r\n      // source: ((n/d)*g)*(g\u002Br-t)/2\r\n      // impl: (g n (g \u002B r - t))/(2 d)\r\n      uint max = BigDiv.bigDiv2x1(\r\n        initGoal * buySlopeNum,\r\n        initGoal \u002B initReserve - _totalSupply,\r\n        2 * buySlopeDen\r\n      );\r\n      if(currencyValue \u003E max)\r\n      {\r\n        currencyValue = max;\r\n      }\r\n      // Math: worst case\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\r\n      tokenValue = BigDiv.bigDiv2x1(\r\n        currencyValue,\r\n        2 * buySlopeDen,\r\n        initGoal * buySlopeNum\r\n      );\r\n\r\n      if(currencyValue != _currencyValue)\r\n      {\r\n        currencyValue = _currencyValue - max;\r\n        // ((2*next_amount/buy_slope)\u002Binit_goal^2)^(1/2)-init_goal\r\n        // a: next_amount | currencyValue\r\n        // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\r\n        // g: init_goal (MAX_BEFORE_SQUARE/2)\r\n        // r: init_reserve (MAX_BEFORE_SQUARE/2)\r\n        // sqrt(((2*a/(n/d))\u002Bg^2)-g\r\n        // sqrt((2 d a \u002B n g^2)/n) - g\r\n\r\n        // currencyValue == 2 d a\r\n        uint temp = 2 * buySlopeDen;\r\n        currencyValue = temp.mul(currencyValue);\r\n\r\n        // temp == g^2\r\n        temp = initGoal;\r\n        temp *= temp;\r\n\r\n        // temp == n g^2\r\n        temp = temp.mul(buySlopeNum);\r\n\r\n        // temp == (2 d a) \u002B n g^2\r\n        temp = currencyValue.add(temp);\r\n\r\n        // temp == (2 d a \u002B n g^2)/n\r\n        temp /= buySlopeNum;\r\n\r\n        // temp == sqrt((2 d a \u002B n g^2)/n)\r\n        temp = temp.sqrt();\r\n\r\n        // temp == sqrt((2 d a \u002B n g^2)/n) - g\r\n        temp -= initGoal;\r\n\r\n        tokenValue = tokenValue.add(temp);\r\n      }\r\n    }\r\n    else if(state == STATE_RUN)\r\n    {\r\n      // initReserve is reduced on sell as necessary to ensure that this line will not overflow\r\n      uint supply = totalSupply() \u002B burnedSupply - initReserve;\r\n      // Math: worst case\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE\r\n      tokenValue = BigDiv.bigDiv2x1(\r\n        _currencyValue,\r\n        2 * buySlopeDen,\r\n        buySlopeNum\r\n      );\r\n\r\n      // Math: worst case MAX \u002B (MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE)\r\n      tokenValue = tokenValue.add(supply * supply);\r\n      tokenValue = tokenValue.sqrt();\r\n\r\n      // Math: small chance of underflow due to possible rounding in sqrt\r\n      tokenValue = tokenValue.sub(supply);\r\n    }\r\n    else\r\n    {\r\n      // invalid state\r\n      return 0;\r\n    }\r\n\r\n    return tokenValue;\r\n  }\r\n\r\n  /// @notice Purchase FAIR tokens with the given amount of currency.\r\n  /// @param _to The account to receive the FAIR tokens from this purchase.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  /// @param _minTokensBought Buy at least this many FAIR tokens or the transaction reverts.\r\n  /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function buy(\r\n    address _to,\r\n    uint _currencyValue,\r\n    uint _minTokensBought\r\n  ) public payable\r\n  {\r\n    require(_to != address(0), \u0022INVALID_ADDRESS\u0022);\r\n    require(_minTokensBought \u003E 0, \u0022MUST_BUY_AT_LEAST_1\u0022);\r\n\r\n    // Calculate the tokenValue for this investment\r\n    uint tokenValue = estimateBuyValue(_currencyValue);\r\n    require(tokenValue \u003E= _minTokensBought, \u0022PRICE_SLIPPAGE\u0022);\r\n\r\n    emit Buy(msg.sender, _to, _currencyValue, tokenValue);\r\n\r\n    _collectInvestment(_currencyValue, msg.value, false);\r\n\r\n    // Update state, initInvestors, and distribute the investment when appropriate\r\n    if(state == STATE_INIT)\r\n    {\r\n      // Math worst case: MAX_BEFORE_SQUARE\r\n      initInvestors[_to] \u002B= tokenValue;\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE \u002B MAX_BEFORE_SQUARE\r\n      if(totalSupply() \u002B tokenValue - initReserve \u003E= initGoal)\r\n      {\r\n        emit StateChange(state, STATE_RUN);\r\n        state = STATE_RUN;\r\n        // Math worst case:\r\n        // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2\r\n        // / MAX_BEFORE_SQUARE * 2\r\n        uint beneficiaryContribution = BigDiv.bigDiv2x1(\r\n          initInvestors[beneficiary],\r\n          buySlopeNum * initGoal,\r\n          buySlopeDen * 2\r\n        );\r\n        _distributeInvestment(buybackReserve().sub(beneficiaryContribution));\r\n      }\r\n    }\r\n    else // implied: if(state == STATE_RUN)\r\n    {\r\n      if(_to != beneficiary)\r\n      {\r\n        _distributeInvestment(_currencyValue);\r\n      }\r\n    }\r\n\r\n    _mint(_to, tokenValue);\r\n\r\n    if(state == STATE_RUN \u0026\u0026 msg.sender == beneficiary \u0026\u0026 _to == beneficiary \u0026\u0026 autoBurn)\r\n    {\r\n      // must mint before this call\r\n      _burn(beneficiary, tokenValue, false);\r\n    }\r\n  }\r\n\r\n  /// Sell\r\n\r\n  function estimateSellValue(\r\n    uint _quantityToSell\r\n  ) public view\r\n    returns(uint)\r\n  {\r\n    uint reserve = buybackReserve();\r\n\r\n    // Calculate currencyValue for this sale\r\n    uint currencyValue;\r\n    if(state == STATE_RUN)\r\n    {\r\n      uint supply = totalSupply() \u002B burnedSupply;\r\n\r\n      // buyback_reserve = r\r\n      // total_supply = t\r\n      // burnt_supply = b\r\n      // amount = a\r\n      // source: (t\u002Bb)*a*(2*r)/((t\u002Bb)^2)-(((2*r)/((t\u002Bb)^2)*a^2)/2)\u002B((2*r)/((t\u002Bb)^2)*a*b^2)/(2*(t))\r\n      // imp: (a b^2 r)/(t (b \u002B t)^2) \u002B (2 a r)/(b \u002B t) - (a^2 r)/(b \u002B t)^2\r\n\r\n      // Math: burnedSupply is capped in FAIR such that the square will never overflow\r\n      // Math worst case:\r\n      // MAX * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      currencyValue = BigDiv.bigDiv2x2(\r\n        _quantityToSell.mul(reserve),\r\n        burnedSupply * burnedSupply,\r\n        totalSupply(), supply * supply\r\n      );\r\n      // Math: worst case currencyValue is MAX_BEFORE_SQUARE (max reserve, 1 supply)\r\n\r\n      // Math worst case:\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      uint temp = _quantityToSell.mul(2 * reserve);\r\n      temp /= supply;\r\n      // Math: worst-case temp is MAX_BEFORE_SQUARE (max reserve, 1 supply)\r\n\r\n      // Math: considering the worst-case for currencyValue and temp, this can never overflow\r\n      currencyValue \u002B= temp;\r\n\r\n      // Math: worst case\r\n      // MAX * MAX * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\r\n      currencyValue -= BigDiv.bigDiv2x1RoundUp(\r\n        _quantityToSell.mul(_quantityToSell),\r\n        reserve,\r\n        supply * supply\r\n      );\r\n    }\r\n    else if(state == STATE_CLOSE)\r\n    {\r\n      // Math worst case\r\n      // MAX * MAX_BEFORE_SQUARE\r\n      currencyValue = _quantityToSell.mul(reserve);\r\n      currencyValue /= totalSupply();\r\n    }\r\n    else\r\n    {\r\n      // STATE_INIT or STATE_CANCEL\r\n      // Math worst case:\r\n      // MAX * MAX_BEFORE_SQUARE\r\n      currencyValue = _quantityToSell.mul(reserve);\r\n      // Math: FAIR blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\r\n      currencyValue /= totalSupply() - initReserve;\r\n    }\r\n\r\n    return currencyValue;\r\n  }\r\n\r\n  /// @notice Sell FAIR tokens for at least the given amount of currency.\r\n  /// @param _to The account to receive the currency from this sale.\r\n  /// @param _quantityToSell How many FAIR tokens to sell for currency value.\r\n  /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\r\n  /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function sell(\r\n    address payable _to,\r\n    uint _quantityToSell,\r\n    uint _minCurrencyReturned\r\n  ) public\r\n  {\r\n    require(msg.sender != beneficiary || state \u003E= STATE_CLOSE, \u0022BENEFICIARY_ONLY_SELL_IN_CLOSE_OR_CANCEL\u0022);\r\n    require(_minCurrencyReturned \u003E 0, \u0022MUST_SELL_AT_LEAST_1\u0022);\r\n\r\n    uint currencyValue = estimateSellValue(_quantityToSell);\r\n    require(currencyValue \u003E= _minCurrencyReturned, \u0022PRICE_SLIPPAGE\u0022);\r\n\r\n    if(state == STATE_INIT || state == STATE_CANCEL)\r\n    {\r\n      initInvestors[msg.sender] = initInvestors[msg.sender].sub(_quantityToSell);\r\n    }\r\n\r\n    _burn(msg.sender, _quantityToSell, true);\r\n    uint supply = totalSupply() \u002B burnedSupply;\r\n    if(supply \u003C initReserve)\r\n    {\r\n      initReserve = supply;\r\n    }\r\n\r\n    _transferCurrency(_to, currencyValue);\r\n    emit Sell(msg.sender, _to, currencyValue, _quantityToSell);\r\n  }\r\n\r\n  /// Pay\r\n\r\n  function estimatePayValue(\r\n    uint _currencyValue\r\n  ) public view\r\n    returns (uint)\r\n  {\r\n    // buy_slope = n/d\r\n    // revenue_commitment = c/g\r\n    // sqrt(\r\n    //  (2 a c d)\r\n    //  /\r\n    //  (g n)\r\n    //  \u002B s^2\r\n    // ) - s\r\n\r\n    uint supply = totalSupply() \u002B burnedSupply;\r\n\r\n    // Math: worst case\r\n    // MAX * 2 * 10000 * MAX_BEFORE_SQUARE\r\n    // / 10000 * MAX_BEFORE_SQUARE\r\n    uint tokenValue = BigDiv.bigDiv2x1(\r\n      _currencyValue.mul(2 * revenueCommitmentBasisPoints),\r\n      buySlopeDen,\r\n      BASIS_POINTS_DEN * buySlopeNum\r\n    );\r\n\r\n    tokenValue = tokenValue.add(supply * supply);\r\n    tokenValue = tokenValue.sqrt();\r\n\r\n    if(tokenValue \u003E supply)\r\n    {\r\n      tokenValue -= supply;\r\n    }\r\n    else\r\n    {\r\n      tokenValue = 0;\r\n    }\r\n\r\n    return tokenValue;\r\n  }\r\n\r\n  /// @dev Pay the organization on-chain.\r\n  /// @param _to The account which receives tokens for the contribution.\r\n  /// @param _currencyValue How much currency which was paid.\r\n  function _pay(\r\n    address _to,\r\n    uint _currencyValue\r\n  ) private\r\n  {\r\n    require(_currencyValue \u003E 0, \u0022MISSING_CURRENCY\u0022);\r\n    require(state == STATE_RUN, \u0022INVALID_STATE\u0022);\r\n\r\n    // Send a portion of the funds to the beneficiary, the rest is added to the buybackReserve\r\n    // Math: if _currencyValue is \u003C (2^256 - 1) / 10000 this will not overflow\r\n    uint reserve = _currencyValue.mul(investmentReserveBasisPoints);\r\n    reserve /= BASIS_POINTS_DEN;\r\n\r\n    uint tokenValue = estimatePayValue(_currencyValue);\r\n\r\n    // Update the to address to the beneficiary if the currency value would fail\r\n    address to = _to;\r\n    if(to == address(0))\r\n    {\r\n      to = beneficiary;\r\n    }\r\n    else if(_detectTransferRestriction(address(0), _to, tokenValue) != 0)\r\n    {\r\n      to = beneficiary;\r\n    }\r\n\r\n    // Math: this will never underflow since investmentReserveBasisPoints is capped to BASIS_POINTS_DEN\r\n    _transferCurrency(beneficiary, _currencyValue - reserve);\r\n\r\n    // Distribute tokens\r\n    if(tokenValue \u003E 0)\r\n    {\r\n      _mint(to, tokenValue);\r\n      if(to == beneficiary \u0026\u0026 autoBurn)\r\n      {\r\n        // must mint before this call\r\n        _burn(beneficiary, tokenValue, false);\r\n      }\r\n    }\r\n\r\n    emit Pay(msg.sender, _to, _currencyValue, tokenValue);\r\n  }\r\n\r\n  /// @dev Pay the organization on-chain.\r\n  /// @param _to The account which receives tokens for the contribution. If this address\r\n  /// is not authorized to receive tokens then they will be sent to the beneficiary account instead.\r\n  /// @param _currencyValue How much currency which was paid.\r\n  function pay(\r\n    address _to,\r\n    uint _currencyValue\r\n  ) public payable\r\n  {\r\n    _collectInvestment(_currencyValue, msg.value, false);\r\n    _pay(_to, _currencyValue);\r\n  }\r\n\r\n  /// Close\r\n\r\n  function estimateExitFee(\r\n    uint _msgValue\r\n  ) public view\r\n    returns(uint)\r\n  {\r\n    uint exitFee;\r\n\r\n    if(state == STATE_RUN)\r\n    {\r\n      uint reserve = buybackReserve();\r\n      reserve = reserve.sub(_msgValue);\r\n\r\n      // Source: t*(t\u002Bb)*(n/d)-r\r\n      // Implementation: (b n t)/d \u002B (n t^2)/d - r\r\n\r\n      uint _totalSupply = totalSupply();\r\n\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE\r\n      exitFee = BigDiv.bigDiv2x1(\r\n        _totalSupply,\r\n        burnedSupply * buySlopeNum,\r\n        buySlopeDen\r\n      );\r\n      // Math worst case:\r\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\r\n      exitFee \u002B= BigDiv.bigDiv2x1(\r\n        _totalSupply,\r\n        buySlopeNum * _totalSupply,\r\n        buySlopeDen\r\n      );\r\n      // Math: this if condition avoids a potential overflow\r\n      if(exitFee \u003C= reserve)\r\n      {\r\n        exitFee = 0;\r\n      }\r\n      else\r\n      {\r\n        exitFee -= reserve;\r\n      }\r\n    }\r\n\r\n    return exitFee;\r\n  }\r\n\r\n  /// @notice Called by the beneficiary account to STATE_CLOSE or STATE_CANCEL the c-org,\r\n  /// preventing any more tokens from being minted.\r\n  /// @dev Requires an \u0060exitFee\u0060 to be paid.  If the currency is ETH, include a little more than\r\n  /// what appears to be required and any remainder will be returned to your account.  This is\r\n  /// because another user may have a transaction mined which changes the exitFee required.\r\n  /// For other \u0060currency\u0060 types, the beneficiary account will be billed the exact amount required.\r\n  function close() public payable\r\n  {\r\n    require(msg.sender == beneficiary, \u0022BENEFICIARY_ONLY\u0022);\r\n\r\n    uint exitFee = 0;\r\n\r\n    if(state == STATE_INIT)\r\n    {\r\n      // Allow the org to cancel anytime if the initGoal was not reached.\r\n      emit StateChange(state, STATE_CANCEL);\r\n      state = STATE_CANCEL;\r\n    }\r\n    else if(state == STATE_RUN)\r\n    {\r\n      // Collect the exitFee and close the c-org.\r\n      require(openUntilAtLeast \u003C= block.timestamp, \u0022TOO_EARLY\u0022);\r\n\r\n      exitFee = estimateExitFee(msg.value);\r\n\r\n      emit StateChange(state, STATE_CLOSE);\r\n      state = STATE_CLOSE;\r\n\r\n      _collectInvestment(exitFee, msg.value, true);\r\n    }\r\n    else\r\n    {\r\n      revert(\u0022INVALID_STATE\u0022);\r\n    }\r\n\r\n    emit Close(exitFee);\r\n  }\r\n\r\n  // --- Approve by signature ---\r\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n  function permit(\r\n    address holder,\r\n    address spender,\r\n    uint256 nonce,\r\n    uint256 expiry,\r\n    bool allowed,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external\r\n  {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        \u0022\\x19\\x01\u0022,\r\n        DOMAIN_SEPARATOR,\r\n        keccak256(\r\n          abi.encode(PERMIT_TYPEHASH,\r\n                    holder,\r\n                    spender,\r\n                    nonce,\r\n                    expiry,\r\n                    allowed\r\n          )\r\n        )\r\n      )\r\n    );\r\n\r\n    require(holder != address(0), \u0022DAT/invalid-address-0\u0022);\r\n    require(holder == ecrecover(digest, v, r, s), \u0022DAT/invalid-permit\u0022);\r\n    require(expiry == 0 || now \u003C= expiry, \u0022DAT/permit-expired\u0022);\r\n    require(nonce == nonces[holder]\u002B\u002B, \u0022DAT/invalid-nonce\u0022);\r\n    uint wad = allowed ? uint(-1) : 0;\r\n    _approve(holder, spender, wad);\r\n  }\r\n}","ABI":"[{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_fairValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Burn\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_fairValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Buy\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_exitFee\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Close\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_fairValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Pay\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_fairValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Sell\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_previousState\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_newState\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022StateChange\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_whitelistAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_control\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_feeCollector\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_autoBurn\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_revenueCommitmentBasisPoints\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_feeBasisPoints\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_minInvestment\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_openUntilAtLeast\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022UpdateConfig\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022DOMAIN_SEPARATOR\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022PERMIT_TYPEHASH\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022autoBurn\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022beneficiary\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022burn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022burnedSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_minTokensBought\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022buySlopeDen\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022buySlopeNum\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022buybackReserve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022close\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022control\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022currency\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022subtractedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022estimateBuyValue\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_msgValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022estimateExitFee\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022estimatePayValue\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_quantityToSell\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022estimateSellValue\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022feeBasisPoints\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022feeCollector\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022addedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initGoal\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022initInvestors\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initReserve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022symbol\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022decimals\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022initialize\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_initReserve\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_currencyAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_initGoal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_buySlopeNum\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_buySlopeDen\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_investmentReserveBasisPoints\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022_symbol\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022initialize\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initializePermit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022investmentReserveBasisPoints\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minInvestment\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022nonces\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022openUntilAtLeast\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_currencyValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022pay\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022holder\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expiry\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022allowed\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022v\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022r\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022s\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022permit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022revenueCommitmentBasisPoints\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_quantityToSell\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_minCurrencyReturned\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022sell\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022state\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_whitelistAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_control\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_feeCollector\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_feeBasisPoints\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_autoBurn\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_revenueCommitmentBasisPoints\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_minInvestment\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_openUntilAtLeast\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updateConfig\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022version\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022whitelist\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IWhitelist\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"DecentralizedAutonomousTrust","CompilerVersion":"v0.5.16\u002Bcommit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://96e89ad6c10af7ea5f9258c0313e02c26c67d2bd7a5af1d613ce0d0d9ab5b5a3"}]