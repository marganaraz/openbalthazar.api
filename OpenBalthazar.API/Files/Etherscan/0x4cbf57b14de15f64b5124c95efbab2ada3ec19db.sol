[{"SourceCode":"// File: contracts/evmscript/ScriptHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary ScriptHelpers {\r\n    function getSpecId(bytes _script) internal pure returns (uint32) {\r\n        return uint32At(_script, 0);\r\n    }\r\n\r\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mload(add(_data, add(0x20, _location)))\r\n        }\r\n    }\r\n\r\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\r\n            0x1000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\r\n            0x100000000000000000000000000000000000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := add(_data, add(0x20, _location))\r\n        }\r\n    }\r\n\r\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\r\n        bytes memory payload = new bytes(4);\r\n        assembly { mstore(add(payload, 0x20), _sig) }\r\n        return payload;\r\n    }\r\n}\r\n\r\n// File: contracts/common/Uint256Helpers.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_NUMBER_TOO_BIG = \u0022UINT64_NUMBER_TOO_BIG\u0022;\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a \u003C= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: contracts/common/TimeHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than \u0060block.number\u0060 allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than \u0060block.number\u0060 allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than \u0060block.timestamp\u0060 allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than \u0060block.timestamp\u0060 allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: contracts/common/UnstructuredStorage.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary UnstructuredStorage {\r\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function setStorageBool(bytes32 position, bool data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageAddress(bytes32 position, address data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageUint256(bytes32 position, uint256 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n}\r\n\r\n// File: contracts/common/Initializable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract Initializable is TimeHelpers {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\u0022aragonOS.initializable.initializationBlock\u0022)\r\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\r\n\r\n    string private constant ERROR_ALREADY_INITIALIZED = \u0022INIT_ALREADY_INITIALIZED\u0022;\r\n    string private constant ERROR_NOT_INITIALIZED = \u0022INIT_NOT_INITIALIZED\u0022;\r\n\r\n    modifier onlyInit {\r\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    modifier isInitialized {\r\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return Block number in which the contract was initialized\r\n    */\r\n    function getInitializationBlock() public view returns (uint256) {\r\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n    * @return Whether the contract has been initialized by the time of the current block\r\n    */\r\n    function hasInitialized() public view returns (bool) {\r\n        uint256 initializationBlock = getInitializationBlock();\r\n        return initializationBlock != 0 \u0026\u0026 getBlockNumber() \u003E= initializationBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization has finished.\r\n    */\r\n    function initialized() internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization to enable the contract\r\n    *      at a future block number rather than immediately.\r\n    */\r\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Petrifiable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Petrifiable is Initializable {\r\n    // Use block UINT256_MAX (which should be never) as the initializable date\r\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\r\n\r\n    function isPetrified() public view returns (bool) {\r\n        return getInitializationBlock() == PETRIFIED_BLOCK;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract to prevent being initialized.\r\n    *      Useful for freezing base contracts when they\u0027re used behind proxies.\r\n    */\r\n    function petrify() internal onlyInit {\r\n        initializedAt(PETRIFIED_BLOCK);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Autopetrified.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Autopetrified is Petrifiable {\r\n    constructor() public {\r\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\r\n        // This renders them uninitializable (and unusable without a proxy).\r\n        petrify();\r\n    }\r\n}\r\n\r\n// File: contracts/evmscript/IEVMScriptExecutor.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IEVMScriptExecutor {\r\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\r\n    function executorType() external pure returns (bytes32);\r\n}\r\n\r\n// File: contracts/evmscript/executors/BaseEVMScriptExecutor.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract BaseEVMScriptExecutor is IEVMScriptExecutor, Autopetrified {\r\n    uint256 internal constant SCRIPT_START_LOCATION = 4;\r\n}\r\n\r\n// File: contracts/evmscript/executors/CallsScript.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n// Inspired by https://github.com/reverendus/tx-manager\r\n\r\n\r\n\r\n\r\ncontract CallsScript is BaseEVMScriptExecutor {\r\n    using ScriptHelpers for bytes;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\u0022CALLS_SCRIPT\u0022);\r\n    */\r\n    bytes32 internal constant EXECUTOR_TYPE = 0x2dc858a00f3e417be1394b87c07158e989ec681ce8cc68a9093680ac1a870302;\r\n\r\n    string private constant ERROR_BLACKLISTED_CALL = \u0022EVMCALLS_BLACKLISTED_CALL\u0022;\r\n    string private constant ERROR_INVALID_LENGTH = \u0022EVMCALLS_INVALID_LENGTH\u0022;\r\n\r\n    /* This is manually crafted in assembly\r\n    string private constant ERROR_CALL_REVERTED = \u0022EVMCALLS_CALL_REVERTED\u0022;\r\n    */\r\n\r\n    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\r\n\r\n    /**\r\n    * @notice Executes a number of call scripts\r\n    * @param _script [ specId (uint32) ] many calls with this structure -\u003E\r\n    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\r\n    * @param _blacklist Addresses the script cannot call to, or will revert.\r\n    * @return Always returns empty byte array\r\n    */\r\n    function execScript(bytes _script, bytes, address[] _blacklist) external isInitialized returns (bytes) {\r\n        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\r\n        while (location \u003C _script.length) {\r\n            // Check there\u0027s at least address \u002B calldataLength available\r\n            require(_script.length - location \u003E= 0x18, ERROR_INVALID_LENGTH);\r\n\r\n            address contractAddress = _script.addressAt(location);\r\n            // Check address being called is not blacklist\r\n            for (uint256 i = 0; i \u003C _blacklist.length; i\u002B\u002B) {\r\n                require(contractAddress != _blacklist[i], ERROR_BLACKLISTED_CALL);\r\n            }\r\n\r\n            // logged before execution to ensure event ordering in receipt\r\n            // if failed entire execution is reverted regardless\r\n            emit LogScriptCall(msg.sender, address(this), contractAddress);\r\n\r\n            uint256 calldataLength = uint256(_script.uint32At(location \u002B 0x14));\r\n            uint256 startOffset = location \u002B 0x14 \u002B 0x04;\r\n            uint256 calldataStart = _script.locationOf(startOffset);\r\n\r\n            // compute end of script / next location\r\n            location = startOffset \u002B calldataLength;\r\n            require(location \u003C= _script.length, ERROR_INVALID_LENGTH);\r\n\r\n            bool success;\r\n            assembly {\r\n                success := call(\r\n                    sub(gas, 5000),       // forward gas left - 5000\r\n                    contractAddress,      // address\r\n                    0,                    // no value\r\n                    calldataStart,        // calldata start\r\n                    calldataLength,       // calldata length\r\n                    0,                    // don\u0027t write output\r\n                    0                     // don\u0027t write output\r\n                )\r\n\r\n                switch success\r\n                case 0 {\r\n                    let ptr := mload(0x40)\r\n\r\n                    switch returndatasize\r\n                    case 0 {\r\n                        // No error data was returned, revert with \u0022EVMCALLS_CALL_REVERTED\u0022\r\n                        // See remix: doing a \u0060revert(\u0022EVMCALLS_CALL_REVERTED\u0022)\u0060 always results in\r\n                        // this memory layout\r\n                        mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\r\n                        mstore(add(ptr, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\r\n                        mstore(add(ptr, 0x24), 0x0000000000000000000000000000000000000000000000000000000000000016) // reason length\r\n                        mstore(add(ptr, 0x44), 0x45564d43414c4c535f43414c4c5f524556455254454400000000000000000000) // reason\r\n\r\n                        revert(ptr, 100) // 100 = 4 \u002B 3 * 32 (error identifier \u002B 3 words for the ABI encoded error)\r\n                    }\r\n                    default {\r\n                        // Forward the full error data\r\n                        returndatacopy(ptr, 0, returndatasize)\r\n                        revert(ptr, returndatasize)\r\n                    }\r\n                }\r\n                default { }\r\n            }\r\n        }\r\n        // No need to allocate empty bytes for the return as this can only be called via an delegatecall\r\n        // (due to the isInitialized modifier)\r\n    }\r\n\r\n    function executorType() external pure returns (bytes32) {\r\n        return EXECUTOR_TYPE;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022hasInitialized\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_script\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022_blacklist\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022execScript\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022executorType\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getInitializationBlock\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isPetrified\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022src\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogScriptCall\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"CallsScript","CompilerVersion":"v0.4.24\u002Bcommit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc0a5ce5a7ff53f8983234421cf2c20eec46c02dc8d5f5adc34835f9f5100c22"}]