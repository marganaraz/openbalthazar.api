[{"SourceCode":"pragma solidity \u003E= 0.5.11;\r\n\r\n/**\r\n * @title  ChainValidator interface\r\n * @author Jakub Fornadel\r\n * @notice External chain validator contract, can be used for more sophisticated validation of new validators and transactors, e.g. custom min. required conditions,\r\n *         concrete users whitelisting, etc...\r\n **/\r\ninterface ChainValidator {\r\n    /**\r\n     * @notice Validation function for new validators\r\n     * \r\n     * @param vesting               How many tokens new validator wants to vest\r\n     * @param acc                   Account address of the validator\r\n     * @param mining                Flag if validator is going to mine. \r\n     *                               mining == false in case validateNewValidator is called during vestInChain method\r\n     *                               mining == true in case validateNewValidator is called during startMining method\r\n     * @param actNumOfValidators    How many active validators is currently in chain\r\n     **/\r\n    function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool);\r\n    \r\n    /**\r\n     * @notice Validation function for new transactors\r\n     * \r\n     * @param deposit               How many tokens new transactor wants to deposit\r\n     * @param acc                   Account address of the transactor\r\n     * @param actNumOfTransactors   How many whitelisted transactors (their deposit balance \u003E= min. required balance) is currently in chain\r\n     **/\r\n    function validateNewTransactor(uint256 deposit, address acc, uint256 actNumOfTransactors) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title  EnergyChainValidator for Lition energy chain\r\n * @author Jakub Fornadel\r\n * @notice External chain validator contract with specific conditions tailored for Lition Energy chain\r\n **/\r\ncontract EnergyChainValidator is ChainValidator {\r\n    \r\n    /**************************************************************************************************************************/\r\n    /************************************************** Constants *************************************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Token precision. 1 LIT token = 1*10^18\r\n    uint256 constant LIT_PRECISION               = 10**18;\r\n    \r\n    // Min deposit value\r\n    uint256 constant MIN_DEPOSIT                 = 5000*LIT_PRECISION;\r\n    \r\n    // Min vesting value\r\n    uint256 constant MIN_VESTING                 = 1000*LIT_PRECISION;\r\n    \r\n    // Min vesting value\r\n    uint256 constant MAX_VESTING                 = 500000*LIT_PRECISION;\r\n    \r\n    \r\n    /**************************************************************************************************************************/\r\n    /*********************************** Structs and functions related to the list of users ***********************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    \r\n    // Iterable map that is used only together with the Users mapping as data holder\r\n    struct IterableMap {\r\n        // map of indexes to the list array\r\n        // indexes are shifted \u002B1 compared to the real indexes of this list, because 0 means non-existing element\r\n        mapping(address =\u003E uint256) listIndex;\r\n        // list of addresses \r\n        address[]                   list;        \r\n    }    \r\n    \r\n    // Adds acc from the map\r\n    function insertAcc(IterableMap storage map, address acc) internal {\r\n        map.list.push(acc);\r\n        // indexes are stored \u002B 1   \r\n        map.listIndex[acc] = map.list.length;\r\n    }\r\n    \r\n    // Removes acc from the map\r\n    function removeAcc(IterableMap storage map, address acc) internal {\r\n        uint256 index = map.listIndex[acc];\r\n        require(index \u003E 0 \u0026\u0026 index \u003C= map.list.length, \u0022RemoveAcc invalid index\u0022);\r\n        \r\n        // Move an last element of array into the vacated key slot.\r\n        uint256 foundIndex = index - 1;\r\n        uint256 lastIndex  = map.list.length - 1;\r\n    \r\n        map.listIndex[map.list[lastIndex]] = foundIndex \u002B 1;\r\n        map.list[foundIndex] = map.list[lastIndex];\r\n        map.list.length--;\r\n    \r\n        // Deletes element\r\n        map.listIndex[acc] = 0;\r\n    }\r\n    \r\n    // Returns true, if acc exists in the iterable map, otherwise false\r\n    function existAcc(IterableMap storage map, address acc) internal view returns (bool) {\r\n        return map.listIndex[acc] != 0;\r\n    }\r\n    \r\n    \r\n    /**************************************************************************************************************************/\r\n    /******************************************** Other structs and functions *************************************************/\r\n    /**************************************************************************************************************************/\r\n\r\n\r\n    // List of admins - they can add/remove whitelisted validators and users\r\n    IterableMap private admins;\r\n    \r\n    // List of whitelisted users who can deposit\r\n    IterableMap private whitelistedUsers;\r\n    \r\n    constructor() public {\r\n        insertAcc(admins, msg.sender);\r\n    }\r\n\r\n\r\n    /**************************************************************************************************************************/\r\n    /*********************************************** Contract Interface *******************************************************/\r\n    /**************************************************************************************************************************/\r\n\r\n    \r\n    /**\r\n     * @notice Validation function for new validators. All validators with vesting in range \u003C1000, 50000\u003E LIT tokens are allowed \r\n     * \r\n     * @param vesting               How many tokens new validator wants to vest\r\n     * @param acc                   Account address of the validator\r\n     * @param mining                Flag if validator is going to mine. \r\n     *                               mining == false in case validateNewValidator is called during vestInChain method\r\n     *                               mining == true in case validateNewValidator is called during startMining method\r\n     * @param actNumOfValidators    How many active validators is currently in chain\r\n     **/\r\n    function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {\r\n        if (vesting \u003C MIN_VESTING || vesting \u003E MAX_VESTING) {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Validation function for new transactors. Only whitelisted accounts are allowed\r\n     * \r\n     * @param deposit               How many tokens new transactor wants to deposit\r\n     * @param acc                   Account address of the transactor\r\n     * @param actNumOfTransactors   How many whitelisted transactors (their deposit balance \u003E= min. required balance) is currently in chain\r\n     **/\r\n    function validateNewTransactor(uint256 deposit, address acc, uint256 actNumOfTransactors) external returns (bool) {\r\n        if (existAcc(whitelistedUsers, acc) == true \u0026\u0026 deposit \u003E= MIN_DEPOSIT) {\r\n            return  true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * @notice Adds new whitelisted accounts that are allowed to transact on Lition energy chain\r\n     *         Provided existing accounts are ignored\r\n     * \r\n     * @param accounts List of accounts\r\n     **/\r\n    function addWhitelistedUsers(address[] calldata accounts) external {\r\n        addUsers(whitelistedUsers, accounts);\r\n    }\r\n    \r\n    /**\r\n     * @notice Removes existing whitelisted accounts that are allowed to transact on Lition energy chain.\r\n     *         Provided non-existing accounts are ignored\r\n     * \r\n     * @param accounts List of accounts\r\n     **/\r\n    function removeWhitelistedUsers(address[] calldata accounts) external {\r\n        require(whitelistedUsers.list.length \u003E 0, \u0022There are no whitelisted users to be removed\u0022);\r\n        \r\n        removeUsers(whitelistedUsers, accounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds new admins that are allowed to add/remove whitelisted users\r\n     *         Provided existing accounts are ignored*\r\n     * @param accounts List of accounts\r\n     **/\r\n    function addAdmins(address[] calldata accounts) external {\r\n        addUsers(admins, accounts);\r\n    }\r\n    \r\n    /**\r\n     * @notice Removes existing admin that is allowed to add/remove whitelisted users. \r\n     *         Provided account must exist as registered admin\r\n     * \r\n     * @param account List of accounts\r\n     **/\r\n    function removeAdmin(address account) external {\r\n        require(admins.list.length \u003E 1, \u0022Cannot remove all admins, at least one must be always present\u0022);\r\n        require(existAcc(admins, account) == true, \u0022Trying to remove non-existing admin\u0022);\r\n        \r\n        removeAcc(admins, account);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of admins (their accounts)\r\n     *\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all admins in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return accounts    List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getAdmins(uint256 batch) external view returns (address[100] memory accounts, uint256 count, bool end) {\r\n        return getUsers(admins, batch);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of whitelisted users (their accounts)\r\n     *\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all admins in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return accounts    List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getWhitelistedUsers(uint256 batch) external view returns (address[100] memory accounts, uint256 count, bool end) {\r\n        return getUsers(whitelistedUsers, batch);\r\n    }\r\n    \r\n    \r\n    /*************************************************************************************************************************/\r\n    /******************************************** Contract internal functions ************************************************/\r\n    /*************************************************************************************************************************/\r\n\r\n    \r\n    // Returns list of suers users\r\n    function getUsers(IterableMap storage internalUsersGroup, uint256 batch) internal view returns (address[100] memory users, uint256 count, bool end) {\r\n        count = 0;\r\n        uint256 usersTotalCount = internalUsersGroup.list.length;\r\n        \r\n        uint256 i;\r\n        for(i = batch * 100; i \u003C (batch \u002B 1)*100 \u0026\u0026 i \u003C usersTotalCount; i\u002B\u002B) {\r\n            users[count] = internalUsersGroup.list[i];\r\n            count\u002B\u002B;\r\n        }\r\n        \r\n        if (i \u003E= usersTotalCount) {\r\n            end = true;\r\n        }\r\n        else {\r\n            end = false;\r\n        }\r\n    }\r\n    \r\n    function addUsers(IterableMap storage internalUsersGroup, address[] memory users) internal {\r\n        require(existAcc(admins, msg.sender) == true, \u0022Only admins can do internal changes\u0022);\r\n        require(users.length \u003C= 100, \u0022Max number of processed users is 100\u0022);\r\n        \r\n        for (uint256 i = 0; i \u003C users.length; i\u002B\u002B) {\r\n            if (existAcc(internalUsersGroup, users[i]) == false) {\r\n                insertAcc(internalUsersGroup, users[i]);\r\n            }    \r\n        }\r\n    }\r\n    \r\n    function removeUsers(IterableMap storage internalUsersGroup, address[] memory users) internal {\r\n        require(existAcc(admins, msg.sender) == true, \u0022Only admins can remove whitelisted users\u0022);\r\n        require(users.length \u003C= 100, \u0022Max number of processed users is 100\u0022);\r\n        \r\n        for (uint256 i = 0; i \u003C users.length; i\u002B\u002B) {\r\n            if (existAcc(internalUsersGroup, users[i]) == true) {\r\n                removeAcc(internalUsersGroup, users[i]);\r\n            }    \r\n        }\r\n    }\r\n}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022accounts\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022addAdmins\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022accounts\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022addWhitelistedUsers\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022batch\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getAdmins\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[100]\u0022,\u0022name\u0022:\u0022accounts\u0022,\u0022type\u0022:\u0022address[100]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022count\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022end\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022batch\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getWhitelistedUsers\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[100]\u0022,\u0022name\u0022:\u0022accounts\u0022,\u0022type\u0022:\u0022address[100]\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022count\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022end\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022accounts\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022removeWhitelistedUsers\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022deposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022acc\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022actNumOfTransactors\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022validateNewTransactor\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022vesting\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022acc\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022mining\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022actNumOfValidators\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022validateNewValidator\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"EnergyChainValidator","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://352bf42a9a6e8a16186f1e734d742f8c90297d3c234838f3a105356fcd11d45e"}]