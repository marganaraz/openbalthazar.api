[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * \u003E Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from \u0060ReentrancyGuard\u0060 will make the \u0060nonReentrant\u0060 modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single \u0060nonReentrant\u0060 guard, functions marked as\r\n * \u0060nonReentrant\u0060 may not call one another. This can be worked around by making\r\n * those functions \u0060private\u0060, and then adding \u0060external\u0060 \u0060nonReentrant\u0060 entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter \u002B= 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \u0022ReentrancyGuard: reentrant call\u0022);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IAllocationStrategy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n * @notice Allocation strategy for assets.\r\n *         - It invests the underlying assets into some yield generating contracts,\r\n *           usually lending contracts, in return it gets new assets aka. saving assets.\r\n *         - Sainv assets can be redeemed back to the underlying assets plus interest any time.\r\n */\r\ninterface IAllocationStrategy {\r\n\r\n    /**\r\n     * @notice Underlying asset for the strategy\r\n     * @return address Underlying asset address\r\n     */\r\n    function underlying() external view returns (address);\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the saving assets\r\n     * @return uint256 Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Applies accrued interest to all savings\r\n      * @dev This should calculates interest accrued from the last checkpointed\r\n      *      block up to the current block and writes new checkpoint to storage.\r\n      * @return bool success(true) or failure(false)\r\n      */\r\n    function accrueInterest() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies underlying assets into the market and receives saving assets in exchange\r\n     * @dev Interst shall be accrued\r\n     * @param investAmount The amount of the underlying asset to supply\r\n     * @return uint256 Amount of saving assets created\r\n     */\r\n    function investUnderlying(uint256 investAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Sender redeems saving assets in exchange for a specified amount of underlying asset\r\n     * @dev Interst shall be accrued\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint256 Amount of saving assets burned\r\n     */\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/IRToken.sol\r\n\r\npragma solidity ^0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n * @notice RToken interface a ERC20 interface and one can mint new tokens by\r\n *      trasfering underlying token into the contract, configure _hats_ for\r\n *      addresses and pay earned interest in new _rTokens_.\r\n */\r\ncontract IRToken is IERC20 {\r\n\r\n\r\n    /**\r\n     * @notice Global stats\r\n     */\r\n    struct GlobalStats {\r\n        /// @notice Total redeemable tokens supply\r\n        uint256 totalSupply;\r\n        /// @notice Total saving assets in redeemable amount\r\n        uint256 totalSavingsAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Stats for accounts\r\n     */\r\n    struct AccountStats {\r\n        /// @notice Cumulative interests paid\r\n        uint256 cumulativeInterest;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // For external transactions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mint(uint256 mintAmount) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a selected hat for the account.\r\n     * @param hatID The id of the selected Hat\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a new hat for the account.\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mintWithNewHat(uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeem(uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @param doChangeHat Should the hat of the \u0060msg.sender\u0060 be switched to the new one\r\n     */\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat) external returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Change the hat for \u0060msg.sender\u0060\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHat(uint256 hatID) external;\r\n\r\n    /**\r\n     * @notice pay interest to the owner\r\n     * @param owner Account owner address\r\n     *\r\n     * Anyone can trigger the interest distribution on behalf of the recipient,\r\n     * due to the fact that the recipient can be a contract code that has not\r\n     * implemented the interaction with the rToken contract internally\u0060.\r\n     *\r\n     * A interest lock-up period may apply, in order to mitigate the \u0022hat\r\n     * inheritance scam\u0022.\r\n     */\r\n    function payInterest(address owner) external returns (bool);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Essential info views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the maximum hatID in the system\r\n     */\r\n    function getMaximumHatID() external view returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Get the hatID of the owner and the hat structure\r\n     * @param owner Account owner address\r\n     * @return hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient\u0027s relative proportions\r\n     */\r\n    function getHatByAddress(address owner) external view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Get the hat structure\r\n     * @param hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient\u0027s relative proportions\r\n     */\r\n    function getHatByID(uint256 hatID) external view\r\n        returns (\r\n            address[] memory recipients,\r\n            uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Amount of saving assets given to the recipient along with the\r\n     *         loans.\r\n     * @param owner Account owner address\r\n     */\r\n    function receivedSavingsOf(address owner) external view returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Amount of token loaned to the recipient along with the savings\r\n     *         assets.\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function receivedLoanOf(address owner) external view returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Get the current interest balance of the owner.\r\n               It is equivalent of: receivedSavings - receivedLoan - freeBalance\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function interestPayableOf(address owner) external view returns (uint256 amount);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // statistics views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the current saving strategy contract\r\n     * @return Saving strategy address\r\n     */\r\n    function getCurrentSavingStrategy() external view returns (address);\r\n\r\n    /**\r\n    * @notice Get saving asset balance for specific saving strategy\r\n    * @return rAmount Balance in redeemable amount\r\n    * @return sAmount Balance in native amount of the strategy\r\n    */\r\n    function getSavingAssetBalance() external view returns (uint256 nAmount, uint256 sAmount);\r\n\r\n    /**\r\n    * @notice Get global stats\r\n    * @return global stats\r\n    */\r\n    function getGlobalStats() external view returns (GlobalStats memory);\r\n\r\n    /**\r\n    * @notice Get account stats\r\n    * @param owner Account owner address\r\n    * @return account stats\r\n    */\r\n    function getAccountStats(address owner) external view returns (AccountStats memory);\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // admin functions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n    * @notice Change allocation strategy for the contract instance\r\n    * @param allocationStrategy Allocation strategy instance\r\n    */\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy) external;\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Events\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address indexed minter, uint256 mintAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address indexed redeemer, address indexed redeemTo, uint256 redeemAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when interest paid\r\n     */\r\n    event InterestPaid(address indexed recipient, uint256 interestAmount);\r\n\r\n    /**\r\n     * @notice A new hat is created\r\n     */\r\n    event HatCreated(uint256 indexed hatID);\r\n\r\n    /**\r\n     * @notice Hat is changed for the account\r\n     */\r\n    event HatChanged(address indexed account, uint256 indexed hatID);\r\n}\r\n\r\n// File: contracts/RToken.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice RToken an ERC20 token that is 1:1 redeemable to its underlying ERC20 token.\r\n */\r\ncontract RToken is IRToken, Ownable, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SELF_HAT_ID = uint256(int256(-1));\r\n\r\n    uint32 constant PROPORTION_BASE = 0xFFFFFFFF;\r\n\r\n    //\r\n    // public structures\r\n    //\r\n\r\n    /**\r\n     * @notice Hat structure describes who are the recipients of the interest\r\n     *\r\n     * To be a valid hat structure:\r\n     *   - at least one recipient\r\n     *   - recipients.length == proportions.length\r\n     *   - each value in proportions should be greater than 0\r\n     */\r\n    struct Hat {\r\n        address[] recipients;\r\n        uint32[] proportions;\r\n    }\r\n\r\n    /**\r\n     * @notice Create rToken linked with cToken at \u0060cToken_\u0060\r\n     */\r\n    constructor(IAllocationStrategy allocationStrategy) public {\r\n        ias = allocationStrategy;\r\n        token = IERC20(ias.underlying());\r\n        // special hat aka. zero hat : hatID = 0\r\n        hats.push(Hat(new address[](0), new uint32[](0)));\r\n    }\r\n\r\n    //\r\n    // ERC20 Interface\r\n    //\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name = \u0022Redeemable DAI (rDAI ethberlin)\u0022;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol = \u0022rDAItest\u0022;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint256 public decimals = 18;\r\n\r\n     /**\r\n      * @notice Total number of tokens in circulation\r\n      */\r\n     uint256 public totalSupply;\r\n\r\n    /**\r\n     * @notice Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accounts[owner].rAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferInternal(msg.sender, msg.sender, dst, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferInternal(msg.sender, src, dst, amount);\r\n    }\r\n\r\n    //\r\n    // rToken interface\r\n    //\r\n\r\n    /// @dev IRToken.mint implementation\r\n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.mintWithSelectedHat implementation\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID) external returns (bool) {\r\n        require(hatID == SELF_HAT_ID || hatID \u003C hats.length, \u0022Invalid hat ID\u0022);\r\n        changeHatInternal(msg.sender, hatID);\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.mintWithNewHat implementation\r\n     */\r\n    function mintWithNewHat(uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions) external nonReentrant returns (bool) {\r\n        uint256 hatID = createHatInternal(recipients, proportions);\r\n        changeHatInternal(msg.sender, hatID);\r\n\r\n        mintInternal(mintAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.redeem implementation\r\n     *      It withdraws equal amount of initially supplied underlying assets\r\n     */\r\n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\r\n        redeemInternal(msg.sender, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens) external returns (bool) {\r\n        redeemInternal(redeemTo, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n     /// @dev IRToken.createHat implementation\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat) external nonReentrant returns (uint256 hatID) {\r\n        hatID = createHatInternal(recipients, proportions);\r\n        if (doChangeHat) {\r\n            changeHatInternal(msg.sender, hatID);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.changeHat implementation\r\n    function changeHat(uint256 hatID) external nonReentrant {\r\n        changeHatInternal(msg.sender, hatID);\r\n    }\r\n\r\n    /// @dev IRToken.getMaximumHatID implementation\r\n    function getMaximumHatID() external view returns (uint256 hatID) {\r\n        return hats.length - 1;\r\n    }\r\n\r\n    /// @dev IRToken.getHatByAddress implementation\r\n    function getHatByAddress(address owner) external view returns (\r\n        uint256 hatID,\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) {\r\n        hatID = accounts[owner].hatID;\r\n        if (hatID != 0 \u0026\u0026 hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.getHatByID implementation\r\n    function getHatByID(uint256 hatID) external view returns (\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) {\r\n        if (hatID != 0 \u0026\u0026 hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.receivedSavingsOf implementation\r\n    function receivedSavingsOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        uint256 rGross =\r\n            account.sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        return rGross;\r\n    }\r\n\r\n    /// @dev IRToken.receivedLoanOf implementation\r\n    function receivedLoanOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        return account.lDebt;\r\n    }\r\n\r\n    /// @dev IRToken.interestPayableOf implementation\r\n    function interestPayableOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        return getInterestPayableOf(account);\r\n    }\r\n\r\n    /// @dev IRToken.payInterest implementation\r\n    function payInterest(address owner) external nonReentrant returns (bool) {\r\n        Account storage account = accounts[owner];\r\n\r\n        ias.accrueInterest();\r\n        uint256 interestAmount = getInterestPayableOf(account);\r\n\r\n        if (interestAmount \u003E 0) {\r\n            account.stats.cumulativeInterest = account.stats.cumulativeInterest.add(interestAmount);\r\n            account.rInterest = account.rInterest.add(interestAmount);\r\n            account.rAmount = account.rAmount.add(interestAmount);\r\n            totalSupply = totalSupply.add(interestAmount);\r\n            emit InterestPaid(owner, interestAmount);\r\n            emit Transfer(address(this), owner, interestAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation!1\r\n    function getGlobalStats() external view returns (GlobalStats memory) {\r\n        uint256 totalSavingsAmount;\r\n        totalSavingsAmount \u002B=\r\n            savingAssetOrignalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(10 ** 18);\r\n        return GlobalStats({\r\n            totalSupply: totalSupply,\r\n            totalSavingsAmount: totalSavingsAmount\r\n        });\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation\r\n    function getAccountStats(address owner) external view returns (AccountStats memory) {\r\n        Account storage account = accounts[owner];\r\n        return account.stats;\r\n    }\r\n\r\n    /// @dev IRToken.getCurrentSavingStrategy implementation\r\n    function getCurrentSavingStrategy() external view returns (address) {\r\n        return address(ias);\r\n    }\r\n\r\n    /// @dev IRToken.getSavingAssetBalance implementation\r\n    function getSavingAssetBalance() external view\r\n        returns (uint256 nAmount, uint256 sAmount) {\r\n        sAmount = savingAssetOrignalAmount;\r\n        nAmount = sAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(10 ** 18);\r\n    }\r\n\r\n    /// @dev IRToken.changeAllocationStrategy implementation\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy) external {\r\n        require(allocationStrategy.underlying() == address(token), \u0022New strategy should have the same underlying asset\u0022);\r\n        IAllocationStrategy oldIas = ias;\r\n        ias = allocationStrategy;\r\n        // redeem everything from the old strategy\r\n        uint256 sOriginalBurned = oldIas.redeemUnderlying(totalSupply);\r\n        // invest everything into the new strategy\r\n        token.transferFrom(msg.sender, address(this), totalSupply);\r\n        token.approve(address(ias), totalSupply);\r\n        uint256 sOriginalCreated = ias.investUnderlying(totalSupply);\r\n        // calculate new saving asset conversion rate\r\n        // if new original saving asset is 2x in amount\r\n        // then the conversion of internal amount should be also 2x\r\n        savingAssetConversionRate =\r\n            sOriginalCreated\r\n            .mul(10 ** 18)\r\n            .div(sOriginalBurned);\r\n    }\r\n\r\n    //\r\n    // internal\r\n    //\r\n\r\n    /// @dev Current saving strategy\r\n    IAllocationStrategy ias;\r\n\r\n    /// @dev Underlying token\r\n    IERC20 token;\r\n\r\n    /// @dev Saving assets original amount\r\n    uint256 savingAssetOrignalAmount;\r\n\r\n    /// @dev Saving asset original to internal amount conversion rate.\r\n    ///      - It has 18 decimals\r\n    ///      - It starts with value 1.\r\n    ///      - Each strategy switching results a new conversion rate\r\n    uint256 savingAssetConversionRate = 10 ** 18;\r\n\r\n    /// @dev Saving assets exchange rate with\r\n\r\n    /// @dev Approved token transfer amounts on behalf of others\r\n    mapping(address =\u003E mapping(address =\u003E uint256)) transferAllowances;\r\n\r\n    /// @dev Hat list\r\n    Hat[] hats;\r\n\r\n    /// @dev Account structure\r\n    struct Account {\r\n        //\r\n        // Essential info\r\n        //\r\n        /// @dev ID of the hat selected for the account\r\n        uint256 hatID;\r\n        /// @dev Redeemable token balance for the account\r\n        uint256 rAmount;\r\n        /// @dev Redeemable token balance portion that is from interest payment\r\n        uint256 rInterest;\r\n        /// @dev Loan recipients and their amount of debt\r\n        mapping (address =\u003E uint256) lRecipients;\r\n        /// @dev Loan debt amount for the account\r\n        uint256 lDebt;\r\n        /// @dev Saving asset amount internal\r\n        uint256 sInternalAmount;\r\n\r\n        /// @dev Stats\r\n        AccountStats stats;\r\n    }\r\n\r\n    /// @dev Account mapping\r\n    mapping (address =\u003E Account) accounts;\r\n\r\n    /**\r\n     * @dev Transfer \u0060tokens\u0060 tokens from \u0060src\u0060 to \u0060dst\u0060 by \u0060spender\u0060\r\n            Called by both \u0060transfer\u0060 and \u0060transferFrom\u0060 internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferInternal(address spender, address src, address dst, uint256 tokens) internal returns (bool) {\r\n        require(src != dst, \u0022src should not equal dst\u0022);\r\n        require(accounts[src].rAmount \u003E= tokens, \u0022Not enough balance to transfer\u0022);\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint256 startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint256(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n        require(startingAllowance \u003E= tokens, \u0022Not enough allowance for transfer\u0022);\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        uint256 allowanceNew = startingAllowance.sub(tokens);\r\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\r\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\r\n\r\n        /////////////////////////\r\n        // EFFECTS \u0026 INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // apply hat inheritance rule\r\n        if (accounts[src].hatID != 0 \u0026\u0026 accounts[dst].hatID == 0) {\r\n            changeHatInternal(dst, accounts[src].hatID);\r\n        }\r\n\r\n        accounts[src].rAmount = srcTokensNew;\r\n        accounts[dst].rAmount = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint256(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        // lRecipients adjustments\r\n        uint256 sInternalAmountCollected = estimateAndRecollectLoans(src, tokens);\r\n        distributeLoans(dst, tokens, sInternalAmountCollected);\r\n\r\n        // rInterest adjustment for src\r\n        if (accounts[src].rInterest \u003E accounts[src].rAmount) {\r\n            accounts[src].rInterest = accounts[src].rAmount;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sender supplies assets into the market and receives rTokens in exchange\r\n     * @dev Invest into underlying assets immediately\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     */\r\n    function mintInternal(uint256 mintAmount) internal {\r\n        require(token.allowance(msg.sender, address(this)) \u003E= mintAmount, \u0022Not enough allowance\u0022);\r\n\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        // create saving assets\r\n        token.transferFrom(msg.sender, address(this), mintAmount);\r\n        token.approve(address(ias), mintAmount);\r\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\r\n\r\n        // update global and account r balances\r\n        totalSupply = totalSupply.add(mintAmount);\r\n        account.rAmount = account.rAmount.add(mintAmount);\r\n\r\n        // update global stats\r\n        savingAssetOrignalAmount \u002B= sOriginalCreated;\r\n\r\n        // distribute saving assets as loans to recipients\r\n        uint256 sInternalCreated =\r\n            sOriginalCreated\r\n            .mul(savingAssetConversionRate)\r\n            .div(10 ** 18);\r\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\r\n\r\n        emit Mint(msg.sender, mintAmount);\r\n        emit Transfer(address(this), msg.sender, mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @dev Withdraw equal amount of initially supplied underlying assets\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemAmount The number of rTokens to redeem into underlying\r\n     */\r\n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\r\n        Account storage account = accounts[msg.sender];\r\n        require(redeemAmount \u003E 0, \u0022Redeem amount cannot be zero\u0022);\r\n        require(redeemAmount \u003C= account.rAmount, \u0022Not enough balance to redeem\u0022);\r\n\r\n        uint256 sOriginalBurned = redeemAndRecollectLoans(msg.sender, redeemAmount);\r\n\r\n        // update Account r balances and global statistics\r\n        account.rAmount = account.rAmount.sub(redeemAmount);\r\n        if (account.rInterest \u003E account.rAmount) {\r\n            account.rInterest = account.rAmount;\r\n        }\r\n        totalSupply = totalSupply.sub(redeemAmount);\r\n\r\n        // update global stats\r\n        savingAssetOrignalAmount -= sOriginalBurned;\r\n\r\n        // transfer the token back\r\n        token.transfer(redeemTo, redeemAmount);\r\n\r\n        emit Transfer(msg.sender, address(this), redeemAmount);\r\n        emit Redeem(msg.sender, redeemTo, redeemAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     */\r\n    function createHatInternal(\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) internal returns (uint256 hatID) {\r\n        uint i;\r\n\r\n        require(recipients.length \u003E 0, \u0022Invalid hat: at least one recipient\u0022);\r\n        require(recipients.length == proportions.length, \u0022Invalid hat: length not matching\u0022);\r\n\r\n        // normalize the proportions\r\n        uint256 totalProportions = 0;\r\n        for (i = 0; i \u003C recipients.length; \u002B\u002Bi) {\r\n            require(proportions[i] \u003E 0, \u0022Invalid hat: proportion should be larger than 0\u0022);\r\n            totalProportions \u002B= uint256(proportions[i]);\r\n        }\r\n        for (i = 0; i \u003C proportions.length; \u002B\u002Bi) {\r\n            proportions[i] = uint32(\r\n                uint256(proportions[i])\r\n                * uint256(PROPORTION_BASE)\r\n                / totalProportions);\r\n        }\r\n\r\n        hatID = hats.push(Hat(\r\n            recipients,\r\n            proportions\r\n        )) - 1;\r\n        emit HatCreated(hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the hat for \u0060owner\u0060\r\n     * @param owner Account owner\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHatInternal(address owner, uint256 hatID) internal {\r\n        Account storage account = accounts[owner];\r\n        if (account.rAmount \u003E 0) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(owner, account.rAmount);\r\n            account.hatID = hatID;\r\n            distributeLoans(owner, account.rAmount, sInternalAmountCollected);\r\n        } else {\r\n            account.hatID = hatID;\r\n        }\r\n        emit HatChanged(owner, hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Get interest payable of the account\r\n     */\r\n    function getInterestPayableOf(Account storage account) internal view returns (uint256) {\r\n        uint256 rGross =\r\n            account.sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        if (rGross \u003E (account.lDebt \u002B account.rInterest)) {\r\n            return rGross - account.lDebt - account.rInterest;\r\n        } else {\r\n            // no interest accumulated yet or even negative interest rate!?\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the incoming tokens to the recipients as loans.\r\n     *      The tokens are immediately invested into the saving strategy and\r\n     *      add to the sAmount of the recipient account.\r\n     *      Recipient also inherits the owner\u0027s hat if it does already have one.\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount being loaned to the recipients\r\n     * @param sInternalAmount Amount of saving assets (internal amount) being given to the recipients\r\n     */\r\n    function distributeLoans(\r\n            address owner,\r\n            uint256 rAmount,\r\n            uint256 sInternalAmount) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        bool[] memory recipientsNeedsNewHat = new bool[](hat.recipients.length);\r\n        uint i;\r\n        if (hat.recipients.length \u003E 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i \u003C hat.proportions.length; \u002B\u002Bi) {\r\n                Account storage recipient = accounts[hat.recipients[i]];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // inherit the hat if needed\r\n                if (recipient.hatID == 0) {\r\n                    recipientsNeedsNewHat[i] = true;\r\n                }\r\n\r\n                uint256 lDebtRecipient = isLastRecipient ? rLeft :\r\n                    rAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                account.lRecipients[hat.recipients[i]] = account.lRecipients[hat.recipients[i]].add(lDebtRecipient);\r\n                recipient.lDebt = recipient.lDebt.add(lDebtRecipient);\r\n                // leftover adjustments\r\n                if (rLeft \u003E lDebtRecipient) {\r\n                    rLeft -= lDebtRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n\r\n                uint256 sInternalAmountRecipient = isLastRecipient ? sInternalLeft:\r\n                    sInternalAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                recipient.sInternalAmount = recipient.sInternalAmount.add(sInternalAmountRecipient);\r\n                // leftover adjustments\r\n                if (sInternalLeft \u003E= sInternalAmountRecipient) {\r\n                    sInternalLeft -= sInternalAmountRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, give all interest to the owner\r\n            account.lDebt = account.lDebt.add(rAmount);\r\n            account.sInternalAmount = account.sInternalAmount.add(sInternalAmount);\r\n        }\r\n\r\n        // apply to new hat owners\r\n        for (i = 0; i \u003C hat.proportions.length; \u002B\u002Bi) {\r\n            if (recipientsNeedsNewHat[i]) {\r\n                changeHatInternal(hat.recipients[i], account.hatID);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      without actually redeeming the saving assets\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by giving back estimated amount of saving assets\r\n     * @return Estimated amount of saving assets (internal) needs to recollected\r\n     */\r\n    function estimateAndRecollectLoans(\r\n        address owner,\r\n        uint256 rAmount) internal returns (uint256 sInternalAmount) {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        // accrue interest so estimate is up to date\r\n        ias.accrueInterest();\r\n        sInternalAmount = rAmount\r\n            .mul(savingAssetConversionRate)\r\n            .div(ias.exchangeRateStored()); // the 1e18 decimals should be cancelled out\r\n        recollectLoans(account, hat, rAmount, sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      by redeeming the saving assets in \u0060rAmount\u0060\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by redeeming equivalent value of the saving assets\r\n     * @return Amount of saving assets redeemed for rAmount of tokens.\r\n     */\r\n    function redeemAndRecollectLoans(\r\n        address owner,\r\n        uint256 rAmount) internal returns (uint256 sOriginalBurned) {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        sOriginalBurned = ias.redeemUnderlying(rAmount);\r\n        uint256 sInternalBurned =\r\n            sOriginalBurned\r\n            .mul(savingAssetConversionRate)\r\n            .div(10 ** 18);\r\n        recollectLoans(account, hat, rAmount, sInternalBurned);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loan from the recipients\r\n     * @param account Owner account\r\n     * @param hat     Owner\u0027s hat\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     * @param sInternalAmount Amount of sasving assets (internal amount) recollected from the recipients\r\n     */\r\n    function recollectLoans(\r\n        Account storage account,\r\n        Hat storage hat,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount) internal {\r\n        uint i;\r\n        if (hat.recipients.length \u003E 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i \u003C hat.proportions.length; \u002B\u002Bi) {\r\n                Account storage recipient = accounts[hat.recipients[i]];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                uint256 lDebtRecipient = isLastRecipient ? rLeft: rAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                if (recipient.lDebt \u003E lDebtRecipient) {\r\n                    recipient.lDebt -= lDebtRecipient;\r\n                } else {\r\n                    recipient.lDebt = 0;\r\n                }\r\n                if (account.lRecipients[hat.recipients[i]] \u003E lDebtRecipient) {\r\n                    account.lRecipients[hat.recipients[i]] -= lDebtRecipient;\r\n                } else {\r\n                    account.lRecipients[hat.recipients[i]] = 0;\r\n                }\r\n                // leftover adjustments\r\n                if (rLeft \u003E lDebtRecipient) {\r\n                    rLeft -= lDebtRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n\r\n                uint256 sInternalAmountRecipient = isLastRecipient ? sInternalLeft:\r\n                    sInternalAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                if (recipient.sInternalAmount \u003E sInternalAmountRecipient) {\r\n                    recipient.sInternalAmount -= sInternalAmountRecipient;\r\n                } else {\r\n                    recipient.sInternalAmount = 0;\r\n                }\r\n                // leftover adjustments\r\n                if (sInternalLeft \u003E= sInternalAmountRecipient) {\r\n                    sInternalLeft -= sInternalAmountRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, recollect interests from the owner\r\n            if (account.lDebt \u003E rAmount) {\r\n                account.lDebt -= rAmount;\r\n            } else {\r\n                account.lDebt = 0;\r\n            }\r\n            if (account.sInternalAmount \u003E sInternalAmount) {\r\n                account.sInternalAmount -= sInternalAmount;\r\n            } else {\r\n                account.sInternalAmount = 0;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getHatByAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022receivedLoanOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getHatByID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022src\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getAccountStats\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022cumulativeInterest\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022changeHat\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mintWithSelectedHat\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMaximumHatID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022},{\u0022name\u0022:\u0022doChangeHat\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022createHat\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getGlobalStats\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022totalSupply\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalSavingsAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022interestPayableOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022name\u0022:\u0022mintWithNewHat\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022SELF_HAT_ID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentSavingStrategy\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022payInterest\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022redeemTo\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022redeemTokens\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022redeemAndTransfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022allocationStrategy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeAllocationStrategy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getSavingAssetBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022nAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022sAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022redeemTokens\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022redeem\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022receivedSavingsOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022allocationStrategy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022minter\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Mint\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022redeemTo\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022redeemAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Redeem\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022interestAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022InterestPaid\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022HatCreated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022HatChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"RToken","CompilerVersion":"v0.5.8\u002Bcommit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009d3c2943cc0f92bf8b7c11714e560515ec1fa9d5","Library":"","SwarmSource":"bzzr://f021839fe8854d479946478c8fef03e73822b1e7b1cee1fe13465f32a39a63dc"}]