[{"SourceCode":"pragma solidity \u003E=0.5.0 \u003C0.7.0;\r\n\r\n\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract Executor {\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else\r\n            success = false;\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \u0022Method can only be called from this contract\u0022);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n///         This contract is tightly coupled to our proxy contract (see \u0060proxies/Proxy.sol\u0060)\r\n/// @author Richard Meissner - \u003Crichard@gnosis.io\u003E\r\ncontract MasterCopy is SelfAuthorized {\r\n\r\n    event ChangedMasterCopy(address masterCopy);\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address private masterCopy;\r\n\r\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n    /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \u0022Invalid master copy address provided\u0022);\r\n        masterCopy = _masterCopy;\r\n        emit ChangedMasterCopy(_masterCopy);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - \u003Cstefan@gnosis.pm\u003E\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address =\u003E address) internal modules;\r\n\r\n    function setupModules(address to, bytes memory data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \u0022Modules have already been initialized\u0022);\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \u0022Could not finish initialization\u0022);\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) \u0026\u0026 address(module) != SENTINEL_MODULES, \u0022Invalid module address provided\u0022);\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \u0022Module has already been added\u0022);\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) \u0026\u0026 address(module) != SENTINEL_MODULES, \u0022Invalid module address provided\u0022);\r\n        require(modules[address(prevModule)] == address(module), \u0022Invalid prevModule, module pair provided\u0022);\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES \u0026\u0026 modules[msg.sender] != address(0), \u0022Method can only be called from an enabled module\u0022);\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        success = execTransactionFromModule(to, value, data, operation);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Load free memory location\r\n            let ptr := mload(0x40)\r\n            // We allocate memory for the return data by setting the free memory location to\r\n            // current free memory location \u002B data size \u002B 32 bytes for data size value\r\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n            // Store the size\r\n            mstore(ptr, returndatasize())\r\n            // Store the data\r\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n            // Point the return data to the correct memory location\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    /// @dev Returns array of first 10 modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\r\n        return array;\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return Array of modules.\r\n    function getModulesPaginated(address start, uint256 pageSize)\r\n        public\r\n        view\r\n        returns (address[] memory array, address next)\r\n    {\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[start];\r\n        while(currentModule != address(0x0) \u0026\u0026 currentModule != SENTINEL_MODULES \u0026\u0026 moduleCount \u003C pageSize) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount\u002B\u002B;\r\n        }\r\n        next = currentModule;\r\n        // Set correct size of returned array\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - \u003Cstefan@gnosis.pm\u003E\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \u0022Method can only be called from manager\u0022);\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \u0022Manager has already been set\u0022);\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Create and Add Modules - Allows to create and add multiple module in one transaction.\r\n/// @author Stefan George - \u003Cstefan@gnosis.pm\u003E\r\n/// @author Richard Meissner - \u003Crichard@gnosis.pm\u003E\r\ncontract CreateAndAddModules {\r\n\r\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\r\n    /// @param module Not used.\r\n    function enableModule(Module module)\r\n        public\r\n    {\r\n        revert();\r\n    }\r\n\r\n    /// @dev Allows to create and add multiple module in one transaction.\r\n    /// @param proxyFactory Module proxy factory contract.\r\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. \u003Cbyte_array_len_1\u003E\u003Cbyte_array_data_1\u003E\u003Cbyte_array_len_2\u003E\u003Cbyte_array_data_2\u003E)\r\n    function createAndAddModules(address proxyFactory, bytes memory data)\r\n        public\r\n    {\r\n        uint256 length = data.length;\r\n        Module module;\r\n        uint256 i = 0;\r\n        while (i \u003C length) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                let createBytesLength := mload(add(0x20, add(data, i)))\r\n                let createBytes := add(0x40, add(data, i))\r\n\r\n                let output := mload(0x40)\r\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\r\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\r\n\r\n                // Data is always padded to 32 bytes\r\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\r\n            }\r\n            this.enableModule(module);\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022proxyFactory\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022createAndAddModules\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract Module\u0022,\u0022name\u0022:\u0022module\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022enableModule\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"CreateAndAddModules","CompilerVersion":"v0.5.14\u002Bcommit.1f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://876f5acbfed500662dcd5771114bd9401ed05cd814a37ca449fecc86d58b35ca"}]