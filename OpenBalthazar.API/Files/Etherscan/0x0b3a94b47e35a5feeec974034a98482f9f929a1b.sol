[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ninterface KyberReserveIf {\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n\r\ncontract KyberNetworkIf { \r\n    mapping(address=\u003Eaddress[]) public reservesPerTokenSrc; //reserves supporting token to eth\r\n    mapping(address=\u003Eaddress[]) public reservesPerTokenDest;//reserves support eth to token\r\n}\r\n\r\n\r\ncontract KyberProxy {\r\n    address public kyberNetworkContract;\r\n}\r\n\r\n\r\ncontract CheckReserveSplit {\r\n    \r\n    ERC20 constant ETH = ERC20(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));\r\n    KyberNetworkIf public constant kyber = KyberNetworkIf(0x9ae49C0d7F8F9EF4B864e004FE86Ac8294E20950);\r\n    ERC20 public constant dai = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    ERC20 public constant usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    uint constant minSplitValueEthDAI = 30;\r\n    uint constant maxSplitValueEthDAI = 140;\r\n    uint constant minSplitValueEthUsdc = 10;\r\n    uint constant maxSplitValueEthUsdc = 70;\r\n    \r\n    uint numSplitRateCalls = 4;\r\n    \r\n    mapping(address=\u003Eaddress[]) public reservesPerTokenDest;//reserves supporting eth to token\r\n    mapping(address=\u003Eaddress[]) public reservesPerTokenDestBest;//reserves supporting eth to token\r\n\r\n    constructor () public {\r\n    }\r\n    \r\n    function setNumSplitRateCalls (uint num) public {\r\n        \r\n        numSplitRateCalls = num;\r\n    }\r\n    \r\n    function copyReserves(ERC20 token) public {\r\n    \r\n        KyberReserveIf reserve;\r\n        uint index = 0;\r\n        \r\n        // fetch resereves find reserve with best rate and with 2nd best.\r\n        while (true) {   \r\n            \r\n            reserve = KyberReserveIf(getReserveTokenDest(address(token), index\u002B\u002B));\r\n            if (reserve == KyberReserveIf(address(0x0))) break;\r\n            reservesPerTokenDest[address(token)].push(address(reserve));\r\n        }\r\n    }\r\n    \r\n    function copyBestReserves(ERC20 token, uint[] memory reserveIds) public {\r\n        \r\n        for (uint i = 0; i \u003C reserveIds.length; i\u002B\u002B) {\r\n            reservesPerTokenDestBest[address(token)].push(reservesPerTokenDest[address(token)][reserveIds[i]]);\r\n        }        \r\n    }\r\n\r\n    function getBestReservesEthToToken(ERC20 token) public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        \r\n        KyberReserveIf reserve;\r\n        uint rate;\r\n        index = 0;\r\n        \r\n        // fetch resereves find reserve with best rate and with 2nd best.\r\n        for(uint i = 0; i \u003C reservesPerTokenDestBest[address(token)].length; i\u002B\u002B) {\r\n        \r\n            reserve = KyberReserveIf(reservesPerTokenDestBest[address(token)][i]);\r\n            if (reserve == KyberReserveIf(address(0x0))) break;\r\n            rate = reserve.getConversionRate(ETH, token, 1 ether, block.number);\r\n            \r\n            if(rate \u003E bestRate) {\r\n                \r\n                if (bestRate \u003E secondRate) {\r\n                    secondRate = bestRate;\r\n                    second = best;\r\n                }\r\n                \r\n                bestRate = rate;\r\n                best = reserve;\r\n            } else if (rate \u003E secondRate) {\r\n                secondRate = rate;\r\n                second = reserve;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getReserveTokenDest (address token, uint index) internal view returns (address reserve) {\r\n\r\n        (bool success, bytes memory returnData) = \r\n            address(kyber).staticcall(\r\n                abi.encodePacked( // This encodes the function to call and the parameters to pass to that function\r\n                        kyber.reservesPerTokenDest.selector, \r\n                        abi.encode(token, index) \r\n                    )\r\n                );\r\n        \r\n        if (success) {\r\n            reserve = abi.decode(returnData, (address));\r\n        } else { // transferFrom reverted. However, the complete tx did not revert and we can handle the case here.\r\n            reserve = address(0x0);\r\n        }\r\n    }\r\n\r\n    function getBestEthToDaiReserves() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(dai);\r\n    }\r\n    \r\n    function getBestEthToUsdcReserves() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(usdc);\r\n    }\r\n    \r\n    // which eth trade value 2nd best reserve has better rate then best reserve\r\n    function getSplitThreshold(ERC20 token) public view \r\n        returns(uint splitThresholdEth, KyberReserveIf best, KyberReserveIf second) \r\n    {\r\n        uint[] memory rates = new uint[](3);\r\n        \r\n        (best, second, rates[0], rates[1], )  = getBestReservesEthToToken(token);\r\n        \r\n        (uint stepSizeWei, uint splitValueEthWei) = getBasicStepSizes(token);\r\n        \r\n        uint numSplitCalls = numSplitRateCalls;\r\n\r\n        while (numSplitCalls-- \u003E 0) {\r\n            rates[2] = best.getConversionRate(ETH, token, splitValueEthWei, block.number);\r\n            \r\n            stepSizeWei /= 2;\r\n            splitValueEthWei \u002B= rates[2] \u003C rates[1] ? (- stepSizeWei) : stepSizeWei;\r\n        }\r\n        \r\n        if(rates[2] == 0) {\r\n            splitValueEthWei -= (stepSizeWei * 2);\r\n\r\n            rates[2] = best.getConversionRate(ETH, token, splitValueEthWei, block.number);\r\n        }\r\n        \r\n        splitThresholdEth = splitValueEthWei / 10 ** 18;\r\n    }\r\n    \r\n    function getBasicStepSizes (ERC20 token) internal pure returns(uint stepSizeWei, uint splitValueEthWei) {\r\n        if(token == usdc) {\r\n            stepSizeWei = (maxSplitValueEthUsdc - minSplitValueEthUsdc) * 10 ** 18 / 2;\r\n            splitValueEthWei = minSplitValueEthUsdc * 10 ** 18 \u002B stepSizeWei;\r\n        } else {\r\n            stepSizeWei = (maxSplitValueEthDAI - minSplitValueEthDAI) * 10 ** 18 / 2;\r\n            splitValueEthWei = minSplitValueEthDAI * 10 ** 18 \u002B stepSizeWei;            \r\n        }\r\n    }\r\n\r\n    function getDaiSplitThreshold() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , ) = getSplitThreshold(dai);\r\n    }\r\n   \r\n    function getDaiSplitValues() public view \r\n        returns (KyberReserveIf bestReserve, uint bestRate, KyberReserveIf secondBest, uint secondRate, uint splitThresholdEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitThresholdEth, bestReserve, secondBest) = getSplitThreshold(dai);\r\n        bestRate = bestReserve.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        secondRate = secondBest.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, dai, (splitThresholdEth \u002B 1) * 10 ** 18, block.number);\r\n    }\r\n    \r\n    function getUsdcSplitThreshold() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , ) = getSplitThreshold(usdc);\r\n    }\r\n    \r\n    function getUsdcSplitValues() public view \r\n        returns (KyberReserveIf bestReserve, uint rate1, KyberReserveIf secondBest, uint rate2, uint splitThresholdEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitThresholdEth, bestReserve, secondBest) = getSplitThreshold(usdc);\r\n        rate1 = bestReserve.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rate2 = secondBest.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, usdc, (splitThresholdEth \u002B 1) *10 ** 18, block.number);\r\n    }\r\n    \r\n    function compareSplitTrade(ERC20 token, uint tradeValueEth) public view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint daiAmountSingleReserve, uint daiAmountTwoRes) \r\n    {\r\n        KyberReserveIf reserveBest;\r\n        KyberReserveIf reseve2nd;\r\n        uint splitThresholdEth;\r\n        uint[] memory rates = new uint[](2);\r\n        \r\n        (splitThresholdEth, reserveBest, reseve2nd) = getSplitThreshold(token);\r\n        if (splitThresholdEth \u003E tradeValueEth) return (0, 0, splitThresholdEth, 0);\r\n        if (splitThresholdEth \u003C tradeValueEth * 2 / 3) {\r\n            splitThresholdEth = tradeValueEth * 2 / 3;\r\n        }\r\n        \r\n        rateSingleReserve = reserveBest.getConversionRate(ETH, token, tradeValueEth * 10 ** 18, block.number);\r\n        rates[0] = reserveBest.getConversionRate(ETH, token, splitThresholdEth * 10 ** 18, block.number);\r\n        rates[1] = reseve2nd.getConversionRate(ETH, token, (tradeValueEth - splitThresholdEth) * 10 ** 18, block.number);\r\n        rateTwoReserves = (rates[0] * splitThresholdEth \u002B rates[1] * (tradeValueEth - splitThresholdEth)) / tradeValueEth;\r\n        \r\n        daiAmountSingleReserve = (rateSingleReserve / 10 ** 18) * tradeValueEth;\r\n        daiAmountTwoRes = (rateTwoReserves / 10 ** 18) * tradeValueEth;\r\n    }\r\n    \r\n    function getDaiSplitThresholdGas() public returns (uint splitThresholdEth) {\r\n        return getDaiSplitThreshold();\r\n    }\r\n    \r\n    function viewSplitTradeEthToDai(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleRes, uint rateTwoReserves, uint daiReceivedSingle, uint daiReceivedTwo) \r\n    {\r\n        return compareSplitTrade(dai, tradeValueEth);\r\n    }\r\n    \r\n    function viewSplitTradeEthToUsdc(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleRes, uint rateTwoReserves, uint daiReceivedSingle, uint daiReceivedTwo) \r\n    {\r\n        return compareSplitTrade(usdc, tradeValueEth);\r\n    }\r\n    \r\n    function getAllReserves (ERC20 token) public view returns (KyberReserveIf [] memory reserves, uint [] memory rates) {\r\n        \r\n        reserves = new KyberReserveIf[](reservesPerTokenDest[address(token)].length);\r\n        rates = new uint[](reservesPerTokenDest[address(token)].length);\r\n        \r\n        // fetch resereves find reserve with best rate and with 2nd best.\r\n        for(uint i = 0; i \u003C reservesPerTokenDest[address(token)].length; i\u002B\u002B) {\r\n        \r\n            reserves[i] = KyberReserveIf(reservesPerTokenDest[address(token)][i]);\r\n            rates[i] = reserves[i].getConversionRate(ETH, token, 1 ether, block.number);\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getDaiSplitThreshold\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tradeValueEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022viewSplitTradeEthToDai\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateSingleRes\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateTwoReserves\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiReceivedSingle\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiReceivedTwo\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tradeValueEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022compareSplitTrade\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateSingleReserve\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateTwoReserves\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiAmountSingleReserve\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiAmountTwoRes\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022num\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setNumSplitRateCalls\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tradeValueEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022viewSplitTradeEthToUsdc\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateSingleRes\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateTwoReserves\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiReceivedSingle\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022daiReceivedTwo\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022usdc\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getAllReserves\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf[]\u0022,\u0022name\u0022:\u0022reserves\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022rates\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022reserveIds\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022copyBestReserves\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getBestEthToDaiReserves\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022best\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022second\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022bestRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022secondRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022reservesPerTokenDest\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getSplitThreshold\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022best\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022second\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022kyber\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberNetworkIf\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022reservesPerTokenDestBest\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getDaiSplitValues\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022bestReserve\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022bestRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022secondBest\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022secondRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateBestAfterSplitValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getDaiSplitThresholdGas\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getBestEthToUsdcReserves\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022best\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022second\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022bestRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022secondRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022copyReserves\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getUsdcSplitValues\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022bestReserve\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rate1\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022secondBest\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rate2\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rateBestAfterSplitValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dai\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getUsdcSplitThreshold\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022splitThresholdEth\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ERC20\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getBestReservesEthToToken\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022best\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022contract KyberReserveIf\u0022,\u0022name\u0022:\u0022second\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022bestRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022secondRate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"CheckReserveSplit","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://df294a82cbf7b71fb7d0c2c7b350ad007054a87b07ca4ac5b1b5b84e8faeffc6"}]