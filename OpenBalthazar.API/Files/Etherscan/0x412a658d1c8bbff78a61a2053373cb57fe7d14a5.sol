[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-06-18\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-06-06\r\n*/\r\n\r\n/**\r\n * Source Code first verified at https://etherscan.io on Wednesday, April 24, 2019\r\n (UTC) */\r\n\r\npragma solidity ^0.4.25;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title math operations that returns specific size reults (32, 64 and 256\r\n *        bits)\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint64\r\n     */\r\n    function mul64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        require(c \u003C 2**64);\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint64\r\n     */\r\n    function div64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        uint256 c = a / b;\r\n        require(c \u003C 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint64\r\n     */\r\n    function sub64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        require(b \u003C= a);\r\n        uint256 c = a - b;\r\n        require(c \u003C 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a \u002B b as a uint64\r\n     */\r\n    function add64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a \u0026\u0026 c \u003C 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint32\r\n     */\r\n    function mul32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        require(c \u003C 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint32\r\n     */\r\n    function div32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        uint256 c = a / b;\r\n        require(c \u003C 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint32\r\n     */\r\n    function sub32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        require(b \u003C= a);\r\n        uint256 c = a - b;\r\n        require(c \u003C 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a \u002B b as a uint32\r\n     */\r\n    function add32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a \u0026\u0026 c \u003C 2**32);\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint256\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        /* solcov ignore next */\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint256\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        /* solcov ignore next */\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint256\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a \u002B b as a uint256\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Merkle Tree\u0027s proof helper contract\r\n */\r\nlibrary Merkle {\r\n\r\n    /**\r\n     * @dev calculates the hash of two child nodes on the merkle tree.\r\n     * @param a Hash of the left child node.\r\n     * @param b Hash of the right child node.\r\n     * @return sha3 hash of the resulting node.\r\n     */\r\n    function combinedHash(bytes32 a, bytes32 b) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(a, b));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates a root hash associated with a Merkle proof\r\n     * @param proof array of proof hashes\r\n     * @param key index of the leaf element list.\r\n     *        this key indicates the specific position of the leaf\r\n     *        in the merkle tree. It will be used to know if the\r\n     *        node that will be hashed along with the proof node\r\n     *        is placed on the right or the left of the current\r\n     *        tree level. That is achieved by doing the modulo of\r\n     *        the current key/position. A new level of nodes will\r\n     *        be evaluated after that, and the new left or right\r\n     *        position is obtained by doing the same operation, \r\n     *        after dividing the key/position by two.\r\n     * @param leaf the leaf element to verify on the set.\r\n     * @return the hash of the Merkle proof. Should match the Merkle root\r\n     *         if the proof is valid\r\n     */\r\n    function getProofRootHash(bytes32[] memory proof, uint256 key, bytes32 leaf) public pure returns(bytes32) {\r\n        bytes32 hash = keccak256(abi.encodePacked(leaf));\r\n        uint256 k = key;\r\n        for(uint i = 0; i\u003Cproof.length; i\u002B\u002B) {\r\n            uint256 bit = k % 2;\r\n            k = k / 2;\r\n\r\n            if (bit == 0)\r\n                hash = combinedHash(hash, proof[i]);\r\n            else\r\n                hash = combinedHash(proof[i], hash);\r\n        }\r\n        return hash;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Data Structures for BatPay: Accounts, Payments \u0026 Challenge\r\n */\r\ncontract Data {\r\n    struct Account {\r\n        address owner;\r\n        uint64  balance;\r\n        uint32  lastCollectedPaymentId;\r\n    }\r\n\r\n    struct BulkRegistration {\r\n        bytes32 rootHash;\r\n        uint32  recordCount;\r\n        uint32  smallestRecordId;\r\n    }\r\n\r\n    struct Payment {\r\n        uint32  fromAccountId;\r\n        uint64  amount;\r\n        uint64  fee;\r\n        uint32  smallestAccountId;\r\n        uint32  greatestAccountId;\r\n        uint32  totalNumberOfPayees;\r\n        uint64  lockTimeoutBlockNumber;\r\n        bytes32 paymentDataHash;\r\n        bytes32 lockingKeyHash;\r\n        bytes32 metadata;\r\n    }\r\n\r\n    struct CollectSlot {\r\n        uint32  minPayIndex;\r\n        uint32  maxPayIndex;\r\n        uint64  amount;\r\n        uint64  delegateAmount;\r\n        uint32  to;\r\n        uint64  block;\r\n        uint32  delegate;\r\n        uint32  challenger;\r\n        uint32  index;\r\n        uint64  challengeAmount;\r\n        uint8   status;\r\n        address addr;\r\n        bytes32 data;\r\n    }\r\n\r\n    struct Config {\r\n        uint32 maxBulk;\r\n        uint32 maxTransfer;\r\n        uint32 challengeBlocks;\r\n        uint32 challengeStepBlocks;\r\n        uint64 collectStake;\r\n        uint64 challengeStake;\r\n        uint32 unlockBlocks;\r\n        uint32 massExitIdBlocks;\r\n        uint32 massExitIdStepBlocks;\r\n        uint32 massExitBalanceBlocks;\r\n        uint32 massExitBalanceStepBlocks;\r\n        uint64 massExitStake;\r\n        uint64 massExitChallengeStake;\r\n        uint64 maxCollectAmount;\r\n    }\r\n\r\n    Config public params;\r\n    address public owner;\r\n\r\n    uint public constant MAX_ACCOUNT_ID = 2**32-1;    // Maximum account id (32-bits)\r\n    uint public constant NEW_ACCOUNT_FLAG = 2**256-1; // Request registration of new account\r\n    uint public constant INSTANT_SLOT = 32768;\r\n\r\n}\r\n\r\n\r\n/**\r\n  * @title Accounts, methods to manage accounts and balances\r\n  */\r\n\r\ncontract Accounts is Data {\r\n    event BulkRegister(uint bulkSize, uint smallestAccountId, uint bulkId );\r\n    event AccountRegistered(uint accountId, address accountAddress);\r\n\r\n    IERC20 public token;\r\n    Account[] public accounts;\r\n    BulkRegistration[] public bulkRegistrations;\r\n\r\n    /**\r\n      * @dev determines whether accountId is valid\r\n      * @param accountId an account id\r\n      * @return boolean\r\n      */\r\n    function isValidId(uint accountId) public view returns (bool) {\r\n        return (accountId \u003C accounts.length);\r\n    }\r\n\r\n    /**\r\n      * @dev determines whether accountId is the owner of the account\r\n      * @param accountId an account id\r\n      * @return boolean\r\n      */\r\n    function isAccountOwner(uint accountId) public view returns (bool) {\r\n        return isValidId(accountId) \u0026\u0026 msg.sender == accounts[accountId].owner;\r\n    }\r\n\r\n    /**\r\n      * @dev modifier to restrict that accountId is valid\r\n      * @param accountId an account id\r\n      */\r\n    modifier validId(uint accountId) {\r\n        require(isValidId(accountId), \u0022accountId is not valid\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev modifier to restrict that accountId is owner\r\n      * @param accountId an account ID\r\n      */\r\n    modifier onlyAccountOwner(uint accountId) {\r\n        require(isAccountOwner(accountId), \u0022Only account owner can invoke this method\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev Reserve accounts but delay assigning addresses.\r\n      *      Accounts will be claimed later using MerkleTree\u0027s rootHash.\r\n      * @param bulkSize Number of accounts to reserve.\r\n      * @param rootHash Hash of the root node of the Merkle Tree referencing the list of addresses.\r\n      */\r\n    function bulkRegister(uint256 bulkSize, bytes32 rootHash) public {\r\n        require(bulkSize \u003E 0, \u0022Bulk size can\u0027t be zero\u0022);\r\n        require(bulkSize \u003C params.maxBulk, \u0022Cannot register this number of ids simultaneously\u0022);\r\n        require(SafeMath.add(accounts.length, bulkSize) \u003C= MAX_ACCOUNT_ID, \u0022Cannot register: ran out of ids\u0022);\r\n        require(rootHash \u003E 0, \u0022Root hash can\u0027t be zero\u0022);\r\n\r\n        emit BulkRegister(bulkSize, accounts.length, bulkRegistrations.length);\r\n        bulkRegistrations.push(BulkRegistration(rootHash, uint32(bulkSize), uint32(accounts.length)));\r\n        accounts.length = SafeMath.add(accounts.length, bulkSize);\r\n    }\r\n\r\n    /** @dev Complete registration for a reserved account by showing the\r\n      *     bulkRegistration-id and Merkle proof associated with this address\r\n      * @param addr Address claiming this account\r\n      * @param proof Merkle proof for address and id\r\n      * @param accountId Id of the account to be registered.\r\n      * @param bulkId BulkRegistration id for the transaction reserving this account\r\n      */\r\n    function claimBulkRegistrationId(address addr, bytes32[] memory proof, uint accountId, uint bulkId) public {\r\n        require(bulkId \u003C bulkRegistrations.length, \u0022the bulkId referenced is invalid\u0022);\r\n        uint smallestAccountId = bulkRegistrations[bulkId].smallestRecordId;\r\n        uint n = bulkRegistrations[bulkId].recordCount;\r\n        bytes32 rootHash = bulkRegistrations[bulkId].rootHash;\r\n        bytes32 hash = Merkle.getProofRootHash(proof, SafeMath.sub(accountId, smallestAccountId), bytes32(addr));\r\n\r\n        require(accountId \u003E= smallestAccountId \u0026\u0026 accountId \u003C smallestAccountId \u002B n,\r\n            \u0022the accountId specified is not part of that bulk registration slot\u0022);\r\n        require(hash == rootHash, \u0022invalid Merkle proof\u0022);\r\n        emit AccountRegistered(accountId, addr);\r\n\r\n        accounts[accountId].owner = addr;\r\n    }\r\n\r\n    /**\r\n      * @dev Register a new account\r\n      * @return the id of the new account\r\n      */\r\n    function register() public returns (uint32 ret) {\r\n        require(accounts.length \u003C MAX_ACCOUNT_ID, \u0022no more accounts left\u0022);\r\n        ret = (uint32)(accounts.length);\r\n        accounts.push(Account(msg.sender, 0, 0));\r\n        emit AccountRegistered(ret, msg.sender);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw tokens from the BatchPayment contract into the original address.\r\n     * @param amount Amount of tokens to withdraw.\r\n     * @param accountId Id of the user requesting the withdraw.\r\n     */\r\n    function withdraw(uint64 amount, uint256 accountId)\r\n        external\r\n        onlyAccountOwner(accountId)\r\n    {\r\n        uint64 balance = accounts[accountId].balance;\r\n\r\n        require(balance \u003E= amount, \u0022insufficient funds\u0022);\r\n        require(amount \u003E 0, \u0022amount should be nonzero\u0022);\r\n\r\n        balanceSub(accountId, amount);\r\n\r\n        require(token.transfer(msg.sender, amount), \u0022transfer failed\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit tokens into the BatchPayment contract to enable scalable payments\r\n     * @param amount Amount of tokens to deposit on \u0060accountId\u0060. User should have\r\n     *        enough balance and issue an \u0060approve()\u0060 method prior to calling this.\r\n     * @param accountId The id of the user account. In case \u0060NEW_ACCOUNT_FLAG\u0060 is used,\r\n     *        a new account will be registered and the requested amount will be\r\n     *        deposited in a single operation.\r\n     */\r\n    function deposit(uint64 amount, uint256 accountId) external {\r\n        require(accountId \u003C accounts.length || accountId == NEW_ACCOUNT_FLAG, \u0022invalid accountId\u0022);\r\n        require(amount \u003E 0, \u0022amount should be positive\u0022);\r\n\r\n        if (accountId == NEW_ACCOUNT_FLAG) {\r\n            // new account\r\n            uint newId = register();\r\n            accounts[newId].balance = amount;\r\n        } else {\r\n            // existing account\r\n            balanceAdd(accountId, amount);\r\n        }\r\n\r\n        require(token.transferFrom(msg.sender, address(this), amount), \u0022transfer failed\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the specified account balance by \u0060amount\u0060 tokens.\r\n     * @param accountId An account id\r\n     * @param amount number of tokens\r\n     */\r\n    function balanceAdd(uint accountId, uint64 amount)\r\n    internal\r\n    validId(accountId)\r\n    {\r\n        accounts[accountId].balance = SafeMath.add64(accounts[accountId].balance, amount);\r\n    }\r\n\r\n    /**\r\n     *  @dev Substract \u0060amount\u0060 tokens from the specified account\u0027s balance\r\n     *  @param accountId An account id\r\n     *  @param amount number of tokens\r\n     */\r\n    function balanceSub(uint accountId, uint64 amount)\r\n    internal\r\n    validId(accountId)\r\n    {\r\n        uint64 balance = accounts[accountId].balance;\r\n        require(balance \u003E= amount, \u0022not enough funds\u0022);\r\n        accounts[accountId].balance = SafeMath.sub64(balance, amount);\r\n    }\r\n\r\n    /**\r\n     *  @dev returns the balance associated with the account in tokens\r\n     *  @param accountId account requested.\r\n     */\r\n    function balanceOf(uint accountId)\r\n        external\r\n        view\r\n        validId(accountId)\r\n        returns (uint64)\r\n    {\r\n        return accounts[accountId].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev gets number of accounts registered and reserved.\r\n      * @return returns the size of the accounts array.\r\n      */\r\n    function getAccountsLength() external view returns (uint) {\r\n        return accounts.length;\r\n    }\r\n\r\n    /**\r\n      * @dev gets the number of bulk registrations performed\r\n      * @return the size of the bulkRegistrations array.\r\n      */\r\n    function getBulkLength() external view returns (uint) {\r\n        return bulkRegistrations.length;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Challenge helper library\r\n */\r\nlibrary Challenge {\r\n\r\n    uint8 public constant PAY_DATA_HEADER_MARKER = 0xff; // marker in payData header\r\n\r\n    /**\r\n     * @dev Reverts if challenge period has expired or Collect Slot status is\r\n     *      not a valid one.\r\n     */\r\n    modifier onlyValidCollectSlot(Data.CollectSlot storage collectSlot, uint8 validStatus) {\r\n        require(!challengeHasExpired(collectSlot), \u0022Challenge has expired\u0022);\r\n        require(isSlotStatusValid(collectSlot, validStatus), \u0022Wrong Collect Slot status\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if the current block number is greater or equal than the\r\n     *         allowed block for this challenge.\r\n     */\r\n    function challengeHasExpired(Data.CollectSlot storage collectSlot) public view returns (bool) {\r\n        return collectSlot.block \u003C= block.number;\r\n    }\r\n\r\n    /**\r\n     * @return true if the Slot status is valid.\r\n     */\r\n    function isSlotStatusValid(Data.CollectSlot storage collectSlot, uint8 validStatus) public view returns (bool) {\r\n        return collectSlot.status == validStatus;\r\n    }\r\n\r\n    /** @dev calculates new block numbers based on the current block and a\r\n     *      delta constant specified by the protocol policy.\r\n     * @param delta number of blocks into the future to calculate.\r\n     * @return future block number.\r\n     */\r\n    function getFutureBlock(uint delta) public view returns(uint64) {\r\n        return SafeMath.add64(block.number, delta);\r\n    }\r\n\r\n    /**\r\n     * @dev Inspects the compact payment list provided and calculates the sum\r\n     *      of the amounts referenced\r\n     * @param data binary array, with 12 bytes per item. 8-bytes amount,\r\n     *        4-bytes payment index.\r\n     * @return the sum of the amounts referenced on the array.\r\n     */\r\n    function getDataSum(bytes memory data) public pure returns (uint sum) {\r\n        require(data.length \u003E 0, \u0022no data provided\u0022);\r\n        require(data.length % 12 == 0, \u0022wrong data format, data length should be multiple of 12\u0022);\r\n\r\n        uint n = SafeMath.div(data.length, 12);\r\n        uint maxSafeAmount = 2**64;\r\n        uint maxSafePayIndex = 2**32;\r\n        int previousPayIndex = -1;\r\n        int currentPayIndex = 0;\r\n\r\n        // Get the sum of the stated amounts in data\r\n        // Each entry in data is [8-bytes amount][4-bytes payIndex]\r\n        sum = 0;\r\n        for (uint i = 0; i \u003C n; i\u002B\u002B) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n              sum := add(sum, mod(mload(add(data, add(8, mul(i, 12)))), maxSafeAmount))\r\n              currentPayIndex := mod(mload(add(data, mul(add(i, 1), 12))), maxSafePayIndex)\r\n            }\r\n            require(sum \u003C maxSafeAmount, \u0022max cashout exceeded\u0022);\r\n            require(previousPayIndex \u003C currentPayIndex, \u0022wrong data format, data should be ordered by payIndex\u0022);\r\n            previousPayIndex = currentPayIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that obtains the amount/payIndex pair located at\r\n     *      position \u0060index\u0060.\r\n     * @param data binary array, with 12 bytes per item. 8-bytes amount,\r\n     *        4-bytes payment index.\r\n     * @param index Array item requested.\r\n     * @return amount and payIndex requested.\r\n     */\r\n    function getDataAtIndex(bytes memory data, uint index) public pure returns (uint64 amount, uint32 payIndex) {\r\n        require(data.length \u003E 0, \u0022no data provided\u0022);\r\n        require(data.length % 12 == 0, \u0022wrong data format, data length should be multiple of 12\u0022);\r\n\r\n        uint mod1 = 2**64;\r\n        uint mod2 = 2**32;\r\n        uint i = SafeMath.mul(index, 12);\r\n\r\n        require(i \u003C= SafeMath.sub(data.length, 12), \u0022index * 12 must be less or equal than (data.length - 12)\u0022);\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            amount := mod( mload(add(data, add(8, i))), mod1 )\r\n\r\n            payIndex := mod( mload(add(data, add(12, i))), mod2 )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev obtains the number of bytes per id in \u0060payData\u0060\r\n     * @param payData efficient binary representation of a list of accountIds\r\n     * @return bytes per id in \u0060payData\u0060\r\n     */\r\n    function getBytesPerId(bytes payData) internal pure returns (uint) {\r\n        // payData includes a 2 byte header and a list of ids\r\n        // [0xff][bytesPerId]\r\n\r\n        uint len = payData.length;\r\n        require(len \u003E= 2, \u0022payData length should be \u003E= 2\u0022);\r\n        require(uint8(payData[0]) == PAY_DATA_HEADER_MARKER, \u0022payData header missing\u0022);\r\n        uint bytesPerId = uint(payData[1]);\r\n        require(bytesPerId \u003E 0 \u0026\u0026 bytesPerId \u003C 32, \u0022second byte of payData should be positive and less than 32\u0022);\r\n\r\n        // remaining bytes should be a multiple of bytesPerId\r\n        require((len - 2) % bytesPerId == 0,\r\n        \u0022payData length is invalid, all payees must have same amount of bytes (payData[1])\u0022);\r\n\r\n        return bytesPerId;\r\n    }\r\n\r\n    /**\r\n     * @dev Process payData, inspecting the list of ids, accumulating the amount for\r\n     *    each entry of \u0060id\u0060.\r\n     *   \u0060payData\u0060 includes 2 header bytes, followed by n bytesPerId-bytes entries.\r\n     *   \u0060payData\u0060 format: [byte 0xff][byte bytesPerId][delta 0][delta 1]..[delta n-1]\r\n     * @param payData List of payees of a specific Payment, with the above format.\r\n     * @param id ID to look for in \u0060payData\u0060\r\n     * @param amount amount per occurrence of \u0060id\u0060 in \u0060payData\u0060\r\n     * @return the amount sum for all occurrences of \u0060id\u0060 in \u0060payData\u0060\r\n     */\r\n    function getPayDataSum(bytes memory payData, uint id, uint amount) public pure returns (uint sum) {\r\n        uint bytesPerId = getBytesPerId(payData);\r\n        uint modulus = 1 \u003C\u003C SafeMath.mul(bytesPerId, 8);\r\n        uint currentId = 0;\r\n\r\n        sum = 0;\r\n\r\n        for (uint i = 2; i \u003C payData.length; i \u002B= bytesPerId) {\r\n            // Get next id delta from paydata\r\n            // currentId \u002B= payData[2\u002Bi*bytesPerId]\r\n\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                currentId := add(\r\n                    currentId,\r\n                    mod(\r\n                        mload(add(payData, add(i, bytesPerId))),\r\n                        modulus))\r\n\r\n                switch eq(currentId, id)\r\n                case 1 { sum := add(sum, amount) }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculates the number of accounts included in payData\r\n     * @param payData efficient binary representation of a list of accountIds\r\n     * @return number of accounts present\r\n     */\r\n    function getPayDataCount(bytes payData) public pure returns (uint) {\r\n        uint bytesPerId = getBytesPerId(payData);\r\n\r\n        // calculate number of records\r\n        return SafeMath.div(payData.length - 2, bytesPerId);\r\n    }\r\n\r\n    /**\r\n     * @dev function. Phase I of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     * @param challenger id of the challenger user\r\n     */\r\n    function challenge_1(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts,\r\n        uint32 challenger\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 1)\r\n    {\r\n        require(accounts[challenger].balance \u003E= config.challengeStake, \u0022not enough balance\u0022);\r\n\r\n        collectSlot.status = 2;\r\n        collectSlot.challenger = challenger;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n\r\n        accounts[challenger].balance -= config.challengeStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase II of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param data Binary array listing the payments in which the user was referenced.\r\n     */\r\n    function challenge_2(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 2)\r\n    {\r\n        require(getDataSum(data) == collectSlot.amount, \u0022data doesn\u0027t represent collected amount\u0022);\r\n\r\n        collectSlot.data = keccak256(data);\r\n        collectSlot.status = 3;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase III of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param data Binary array listing the payments in which the user was referenced.\r\n     * @param disputedPaymentIndex index selecting the disputed payment\r\n     */\r\n    function challenge_3(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        bytes memory data,\r\n        uint32 disputedPaymentIndex\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 3)\r\n    {\r\n        require(collectSlot.data == keccak256(data),\r\n        \u0022data mismatch, collected data hash doesn\u0027t match provided data hash\u0022);\r\n        (collectSlot.challengeAmount, collectSlot.index) = getDataAtIndex(data, disputedPaymentIndex);\r\n        collectSlot.status = 4;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase IV of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param payments a reference to the BatPay payments array\r\n     * @param payData binary data describing the list of account receiving\r\n     *        tokens on the selected transfer\r\n     */\r\n    function challenge_4(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Payment[] storage payments,\r\n        bytes memory payData\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 4)\r\n    {\r\n        require(collectSlot.index \u003E= collectSlot.minPayIndex \u0026\u0026 collectSlot.index \u003C collectSlot.maxPayIndex,\r\n            \u0022payment referenced is out of range\u0022);\r\n        Data.Payment memory p = payments[collectSlot.index];\r\n        require(keccak256(payData) == p.paymentDataHash,\r\n        \u0022payData mismatch, payment\u0027s data hash doesn\u0027t match provided payData hash\u0022);\r\n        require(p.lockingKeyHash == 0, \u0022payment is locked\u0022);\r\n\r\n        uint collected = getPayDataSum(payData, collectSlot.to, p.amount);\r\n\r\n        // Check if id is included in bulkRegistration within payment\r\n        if (collectSlot.to \u003E= p.smallestAccountId \u0026\u0026 collectSlot.to \u003C p.greatestAccountId) {\r\n            collected = SafeMath.add(collected, p.amount);\r\n        }\r\n\r\n        require(collected == collectSlot.challengeAmount,\r\n        \u0022amount mismatch, provided payData sum doesn\u0027t match collected challenge amount\u0022);\r\n\r\n        collectSlot.status = 5;\r\n    }\r\n\r\n    /**\r\n     * @dev the challenge was completed successfully, or the delegate failed to respond on time.\r\n     *      The challenger will collect the stake.\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     */\r\n    function challenge_success(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts\r\n    )\r\n        public\r\n    {\r\n        require((collectSlot.status == 2 || collectSlot.status == 4),\r\n            \u0022Wrong Collect Slot status\u0022);\r\n        require(challengeHasExpired(collectSlot),\r\n            \u0022Challenge not yet finished\u0022);\r\n\r\n        accounts[collectSlot.challenger].balance = SafeMath.add64(\r\n            accounts[collectSlot.challenger].balance,\r\n            SafeMath.add64(config.collectStake, config.challengeStake));\r\n\r\n        collectSlot.status = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. The delegate proved the challenger wrong, or\r\n     *      the challenger failed to respond on time. The delegae collects the stake.\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     */\r\n    function challenge_failed(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts\r\n    )\r\n        public\r\n    {\r\n        require(collectSlot.status == 5 || (collectSlot.status == 3 \u0026\u0026 block.number \u003E= collectSlot.block),\r\n            \u0022challenge not completed\u0022);\r\n\r\n        // Challenge failed\r\n        // delegate wins Stake\r\n        accounts[collectSlot.delegate].balance = SafeMath.add64(\r\n            accounts[collectSlot.delegate].balance,\r\n            config.challengeStake);\r\n\r\n        // reset slot to status=1, waiting for challenges\r\n        collectSlot.challenger = 0;\r\n        collectSlot.status = 1;\r\n        collectSlot.block = getFutureBlock(config.challengeBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Helps verify a ECDSA signature, while recovering the signing address.\r\n     * @param hash Hash of the signed message\r\n     * @param sig binary representation of the r, s \u0026 v parameters.\r\n     * @return address of the signer if data provided is valid, zero otherwise.\r\n     */\r\n    function recoverHelper(bytes32 hash, bytes sig) public pure returns (address) {\r\n        bytes memory prefix = \u0022\\x19Ethereum Signed Message:\\n32\u0022;\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v \u003C 27) {\r\n            v \u002B= 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        return ecrecover(prefixedHash, v, r, s);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Payments and Challenge game - Performs the operations associated with\r\n *        transfer and the different steps of the collect challenge game.\r\n */\r\ncontract Payments is Accounts {\r\n    event PaymentRegistered(\r\n        uint32 indexed payIndex,\r\n        uint indexed from,\r\n        uint totalNumberOfPayees,\r\n        uint amount\r\n    );\r\n\r\n    event PaymentUnlocked(uint32 indexed payIndex, bytes key);\r\n    event PaymentRefunded(uint32 beneficiaryAccountId, uint64 amountRefunded);\r\n\r\n    /**\r\n     * Event for collection logging. Off-chain monitoring services may listen\r\n     * to this event to trigger challenges.\r\n     */\r\n    event Collect(\r\n        uint indexed delegate,\r\n        uint indexed slot,\r\n        uint indexed to,\r\n        uint32 fromPayindex,\r\n        uint32 toPayIndex,\r\n        uint amount\r\n    );\r\n\r\n    event Challenge1(uint indexed delegate, uint indexed slot, uint challenger);\r\n    event Challenge2(uint indexed delegate, uint indexed slot);\r\n    event Challenge3(uint indexed delegate, uint indexed slot, uint index);\r\n    event Challenge4(uint indexed delegate, uint indexed slot);\r\n    event ChallengeSuccess(uint indexed delegate, uint indexed slot);\r\n    event ChallengeFailed(uint indexed delegate, uint indexed slot);\r\n\r\n    Payment[] public payments;\r\n    mapping (uint32 =\u003E mapping (uint32 =\u003E CollectSlot)) public collects;\r\n\r\n    /**\r\n     * @dev Register token payment to multiple recipients\r\n     * @param fromId Account id for the originator of the transaction\r\n     * @param amount Amount of tokens to pay each destination.\r\n     * @param fee Fee in tokens to be payed to the party providing the unlocking service\r\n     * @param payData Efficient representation of the destination account list\r\n     * @param newCount Number of new destination accounts that will be reserved during the registerPayment transaction\r\n     * @param rootHash Hash of the root hash of the Merkle tree listing the addresses reserved.\r\n     * @param lockingKeyHash hash resulting of calculating the keccak256 of\r\n     *        of the key locking this payment to help in atomic data swaps.\r\n     *        This hash will later be used by the \u0060unlock\u0060 function to unlock the payment we are registering.\r\n     *         The \u0060lockingKeyHash\u0060 must be equal to the keccak256 of the packed\r\n     *         encoding of the unlockerAccountId and the key used by the unlocker to encrypt the traded data:\r\n     *             \u0060keccak256(abi.encodePacked(unlockerAccountId, key))\u0060\r\n     *         DO NOT use previously used locking keys, since an attacker could realize that by comparing key hashes\r\n     * @param metadata Application specific data to be stored associated with the payment\r\n     */\r\n    function registerPayment(\r\n        uint32 fromId,\r\n        uint64 amount,\r\n        uint64 fee,\r\n        bytes payData,\r\n        uint newCount,\r\n        bytes32 rootHash,\r\n        bytes32 lockingKeyHash,\r\n        bytes32 metadata\r\n    )\r\n        external\r\n    {\r\n        require(payments.length \u003C 2**32, \u0022Cannot add more payments\u0022);\r\n        require(isAccountOwner(fromId), \u0022Invalid fromId\u0022);\r\n        require(amount \u003E 0, \u0022Invalid amount\u0022);\r\n        require(newCount == 0 || rootHash \u003E 0, \u0022Invalid root hash\u0022); // although bulkRegister checks this, we anticipate\r\n        require(fee == 0 || lockingKeyHash \u003E 0, \u0022Invalid lock hash\u0022);\r\n\r\n        Payment memory p;\r\n\r\n        // Prepare a Payment struct\r\n        p.totalNumberOfPayees = SafeMath.add32(Challenge.getPayDataCount(payData), newCount);\r\n        require(p.totalNumberOfPayees \u003E 0, \u0022Invalid number of payees, should at least be 1 payee\u0022);\r\n        require(p.totalNumberOfPayees \u003C params.maxTransfer,\r\n        \u0022Too many payees, it should be less than config maxTransfer\u0022);\r\n\r\n        p.fromAccountId = fromId;\r\n        p.amount = amount;\r\n        p.fee = fee;\r\n        p.lockingKeyHash = lockingKeyHash;\r\n        p.metadata = metadata;\r\n        p.smallestAccountId = uint32(accounts.length);\r\n        p.greatestAccountId = SafeMath.add32(p.smallestAccountId, newCount);\r\n        p.lockTimeoutBlockNumber = SafeMath.add64(block.number, params.unlockBlocks);\r\n        p.paymentDataHash = keccak256(abi.encodePacked(payData));\r\n\r\n        // calculate total cost of payment\r\n        uint64 totalCost = SafeMath.mul64(amount, p.totalNumberOfPayees);\r\n        totalCost = SafeMath.add64(totalCost, fee);\r\n\r\n        // Check that fromId has enough balance and substract totalCost\r\n        balanceSub(fromId, totalCost);\r\n\r\n        // If this operation includes new accounts, do a bulkRegister\r\n        if (newCount \u003E 0) {\r\n            bulkRegister(newCount, rootHash);\r\n        }\r\n\r\n        // Save the new Payment\r\n        payments.push(p);\r\n\r\n        emit PaymentRegistered(SafeMath.sub32(payments.length, 1), p.fromAccountId, p.totalNumberOfPayees, p.amount);\r\n    }\r\n\r\n    /**\r\n     * @dev provide the required key, releasing the payment and enabling the buyer decryption the digital content.\r\n     * @param payIndex payment Index associated with the registerPayment operation.\r\n     * @param unlockerAccountId id of the party providing the unlocking service. Fees wil be payed to this id.\r\n     * @param key Cryptographic key used to encrypt traded data.\r\n     */\r\n    function unlock(uint32 payIndex, uint32 unlockerAccountId, bytes memory key) public returns(bool) {\r\n        require(payIndex \u003C payments.length, \u0022invalid payIndex, payments is not that long yet\u0022);\r\n        require(isValidId(unlockerAccountId), \u0022Invalid unlockerAccountId\u0022);\r\n        require(block.number \u003C payments[payIndex].lockTimeoutBlockNumber, \u0022Hash lock expired\u0022);\r\n        bytes32 h = keccak256(abi.encodePacked(unlockerAccountId, key));\r\n        require(h == payments[payIndex].lockingKeyHash, \u0022Invalid key\u0022);\r\n\r\n        payments[payIndex].lockingKeyHash = bytes32(0);\r\n        balanceAdd(unlockerAccountId, payments[payIndex].fee);\r\n\r\n        emit PaymentUnlocked(payIndex, key);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Enables the buyer to recover funds associated with a \u0060registerPayment()\u0060\r\n     *      operation for which decryption keys were not provided.\r\n     * @param payIndex Index of the payment transaction associated with this request.\r\n     * @return true if the operation succeded.\r\n     */\r\n    function refundLockedPayment(uint32 payIndex) external returns (bool) {\r\n        require(payIndex \u003C payments.length, \u0022invalid payIndex, payments is not that long yet\u0022);\r\n        require(payments[payIndex].lockingKeyHash != 0, \u0022payment is already unlocked\u0022);\r\n        require(block.number \u003E= payments[payIndex].lockTimeoutBlockNumber, \u0022Hash lock has not expired yet\u0022);\r\n        Payment memory payment = payments[payIndex];\r\n        require(payment.totalNumberOfPayees \u003E 0, \u0022payment already refunded\u0022);\r\n\r\n        uint64 total = SafeMath.add64(\r\n            SafeMath.mul64(payment.totalNumberOfPayees, payment.amount),\r\n            payment.fee\r\n        );\r\n\r\n        payment.totalNumberOfPayees = 0;\r\n        payment.fee = 0;\r\n        payment.amount = 0;\r\n        payments[payIndex] = payment;\r\n\r\n        // Complete refund\r\n        balanceAdd(payment.fromAccountId, total);\r\n        emit PaymentRefunded(payment.fromAccountId, total);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev let users claim pending balance associated with prior transactions\r\n            Users ask a delegate to complete the transaction on their behalf,\r\n            the delegate calculates the apropiate amount (declaredAmount) and\r\n            waits for a possible challenger.\r\n            If this is an instant collect, tokens are transfered immediatly.\r\n     * @param delegate id of the delegate account performing the operation on the name of the user.\r\n     * @param slotId Individual slot used for the challenge game.\r\n     * @param toAccountId Destination of the collect operation.\r\n     * @param maxPayIndex payIndex of the first payment index not covered by this application.\r\n     * @param declaredAmount amount of tokens owed to this user account\r\n     * @param fee fee in tokens to be paid for the end user help.\r\n     * @param destination Address to withdraw the full account balance.\r\n     * @param signature An R,S,V ECDS signature provided by a user.\r\n     */\r\n    function collect(\r\n        uint32 delegate,\r\n        uint32 slotId,\r\n        uint32 toAccountId,\r\n        uint32 maxPayIndex,\r\n        uint64 declaredAmount,\r\n        uint64 fee,\r\n        address destination,\r\n        bytes memory signature\r\n    )\r\n    public\r\n    {\r\n        // Check delegate and toAccountId are valid\r\n        require(isAccountOwner(delegate), \u0022invalid delegate\u0022);\r\n        require(isValidId(toAccountId), \u0022toAccountId must be a valid account id\u0022);\r\n\r\n        // make sure the game slot is empty (release it if necessary)\r\n        freeSlot(delegate, slotId);\r\n\r\n        Account memory tacc = accounts[toAccountId];\r\n        require(tacc.owner != 0, \u0022account registration has to be completed\u0022);\r\n\r\n        if (delegate != toAccountId) {\r\n            // If \u0022toAccountId\u0022 != delegate, check who signed this transaction\r\n            bytes32 hash =\r\n            keccak256(\r\n            abi.encodePacked(\r\n                address(this), delegate, toAccountId, tacc.lastCollectedPaymentId,\r\n                maxPayIndex, declaredAmount, fee, destination\r\n            ));\r\n            require(Challenge.recoverHelper(hash, signature) == tacc.owner, \u0022Bad user signature\u0022);\r\n        }\r\n\r\n        // Check maxPayIndex is valid\r\n        require(maxPayIndex \u003E 0 \u0026\u0026 maxPayIndex \u003C= payments.length,\r\n        \u0022invalid maxPayIndex, payments is not that long yet\u0022);\r\n        require(maxPayIndex \u003E tacc.lastCollectedPaymentId, \u0022account already collected payments up to maxPayIndex\u0022);\r\n        require(payments[maxPayIndex - 1].lockTimeoutBlockNumber \u003C block.number,\r\n            \u0022cannot collect payments that can be unlocked\u0022);\r\n\r\n        // Check if declaredAmount and fee are valid\r\n        require(declaredAmount \u003C= params.maxCollectAmount, \u0022declaredAmount is too big\u0022);\r\n        require(fee \u003C= declaredAmount, \u0022fee is too big, should be smaller than declaredAmount\u0022);\r\n\r\n        // Prepare the challenge slot\r\n        CollectSlot storage sl = collects[delegate][slotId];\r\n        sl.delegate = delegate;\r\n        sl.minPayIndex = tacc.lastCollectedPaymentId;\r\n        sl.maxPayIndex = maxPayIndex;\r\n        sl.amount = declaredAmount;\r\n        sl.to = toAccountId;\r\n        sl.block = Challenge.getFutureBlock(params.challengeBlocks);\r\n        sl.status = 1;\r\n\r\n        // Calculate how many tokens needs the delegate, and setup delegateAmount and addr\r\n        uint64 needed = params.collectStake;\r\n\r\n        // check if this is an instant collect\r\n        if (slotId \u003E= INSTANT_SLOT) {\r\n            uint64 declaredAmountLessFee = SafeMath.sub64(declaredAmount, fee);\r\n            sl.delegateAmount = declaredAmount;\r\n            needed = SafeMath.add64(needed, declaredAmountLessFee);\r\n            sl.addr = address(0);\r\n\r\n            // Instant-collect, toAccount gets the declaredAmount now\r\n            balanceAdd(toAccountId, declaredAmountLessFee);\r\n        } else\r\n        {   // not instant-collect\r\n            sl.delegateAmount = fee;\r\n            sl.addr = destination;\r\n        }\r\n\r\n        // Check delegate has enough funds\r\n        require(accounts[delegate].balance \u003E= needed, \u0022not enough funds\u0022);\r\n\r\n        // Update the lastCollectPaymentId for the toAccount\r\n        accounts[toAccountId].lastCollectedPaymentId = uint32(maxPayIndex);\r\n\r\n        // Now the delegate Pays\r\n        balanceSub(delegate, needed);\r\n\r\n        // Proceed if the user is withdrawing its balance\r\n        if (destination != address(0) \u0026\u0026 slotId \u003E= INSTANT_SLOT) {\r\n            uint64 toWithdraw = accounts[toAccountId].balance;\r\n            accounts[toAccountId].balance = 0;\r\n            require(token.transfer(destination, toWithdraw), \u0022transfer failed\u0022);\r\n        }\r\n\r\n        emit Collect(delegate, slotId, toAccountId, tacc.lastCollectedPaymentId, maxPayIndex, declaredAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev gets the number of payments issued\r\n     * @return returns the size of the payments array.\r\n     */\r\n    function getPaymentsLength() external view returns (uint) {\r\n        return payments.length;\r\n    }\r\n\r\n    /**\r\n     * @dev initiate a challenge game\r\n     * @param delegate id of the delegate that performed the collect operation\r\n     *        in the name of the end-user.\r\n     * @param slot slot used for the challenge game. Every user has a sperate\r\n     *        set of slots\r\n     * @param challenger id of the user account challenging the delegate.\r\n     */\r\n    function challenge_1(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        uint32 challenger\r\n    )\r\n        public\r\n        validId(delegate)\r\n        onlyAccountOwner(challenger)\r\n    {\r\n        Challenge.challenge_1(collects[delegate][slot], params, accounts, challenger);\r\n        emit Challenge1(delegate, slot, challenger);\r\n    }\r\n\r\n    /**\r\n     * @dev The delegate provides the list of payments that mentions the enduser\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     * @param data binary list of payment indexes associated with this collect operation.\r\n     */\r\n    function challenge_2(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_2(collects[delegate][slot], params, data);\r\n        emit Challenge2(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev the Challenger chooses a single index into the delegate provided data list\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     * @param data binary list of payment indexes associated with this collect operation.\r\n     * @param index index into the data array for the payment id selected by the challenger\r\n     */\r\n    function challenge_3(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory data,\r\n        uint32 index\r\n    )\r\n        public\r\n        validId(delegate)\r\n    {\r\n        require(isAccountOwner(collects[delegate][slot].challenger), \u0022only challenger can call challenge_2\u0022);\r\n\r\n        Challenge.challenge_3(collects[delegate][slot], params, data, index);\r\n        emit Challenge3(delegate, slot, index);\r\n    }\r\n\r\n    /**\r\n     * @dev the delegate provides proof that the destination account was\r\n     *      included on that payment, winning the game\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_4(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory payData\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_4(\r\n            collects[delegate][slot],\r\n            payments,\r\n            payData\r\n            );\r\n        emit Challenge4(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev the challenge was completed successfully. The delegate stake is slashed.\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_success(\r\n        uint32 delegate,\r\n        uint32 slot\r\n    )\r\n        public\r\n        validId(delegate)\r\n    {\r\n        Challenge.challenge_success(collects[delegate][slot], params, accounts);\r\n        emit ChallengeSuccess(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev The delegate won the challenge game. He gets the challenge stake.\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_failed(\r\n        uint32 delegate,\r\n        uint32 slot\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_failed(collects[delegate][slot], params, accounts);\r\n        emit ChallengeFailed(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev Releases a slot used by the collect channel game, only when the game is finished.\r\n     *      This does three things:\r\n     *        1. Empty the slot\r\n     *        2. Pay the delegate\r\n     *        3. Pay the destinationAccount\r\n     *      Also, if a token.transfer was requested, transfer the outstanding balance to the specified address.\r\n     * @param delegate id of the account requesting the release operation\r\n     * @param slot id of the slot requested for the duration of the challenge game\r\n     */\r\n    function freeSlot(uint32 delegate, uint32 slot) public {\r\n        CollectSlot memory s = collects[delegate][slot];\r\n\r\n        // If this is slot is empty, nothing else to do here.\r\n        if (s.status == 0) return;\r\n\r\n        // Make sure this slot is ready to be freed.\r\n        // It should be in the waiting state(1) and with challenge time ran-out\r\n        require(s.status == 1, \u0022slot not available\u0022);\r\n        require(block.number \u003E= s.block, \u0022slot not available\u0022);\r\n\r\n        // 1. Put the slot in the empty state\r\n        collects[delegate][slot].status = 0;\r\n\r\n        // 2. Pay the delegate\r\n        // This includes the stake as well as fees and other tokens reserved during collect()\r\n        // [delegateAmount \u002B stake] =\u003E delegate\r\n        balanceAdd(delegate, SafeMath.add64(s.delegateAmount, params.collectStake));\r\n\r\n        // 3. Pay the destination account\r\n        // [amount - delegateAmount] =\u003E to\r\n        uint64 balance = SafeMath.sub64(s.amount, s.delegateAmount);\r\n\r\n        // was a transfer requested?\r\n        if (s.addr != address(0))\r\n        {\r\n            // empty the account balance\r\n            balance = SafeMath.add64(balance, accounts[s.to].balance);\r\n            accounts[s.to].balance = 0;\r\n            if (balance != 0)\r\n                require(token.transfer(s.addr, balance), \u0022transfer failed\u0022);\r\n        } else\r\n        {\r\n            balanceAdd(s.to, balance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BatchPayment processing\r\n * @notice This contract allows to scale ERC-20 token transfer for fees or\r\n *         micropayments on the few-buyers / many-sellers setting.\r\n */\r\ncontract BatPay is Payments {\r\n\r\n    /**\r\n     * @dev Contract constructor, sets ERC20 token this contract will use for payments\r\n     * @param token_ ERC20 contract address\r\n     * @param maxBulk Maximum number of users to register in a single bulkRegister\r\n     * @param maxTransfer Maximum number of destinations on a single payment\r\n     * @param challengeBlocks number of blocks to wait for a challenge\r\n     * @param challengeStepBlocks number of blocks to wait for a single step on\r\n     *        the challenge game\r\n     * @param collectStake stake in tokens for a collect operation\r\n     * @param challengeStake stake in tokens for the challenger of a collect operation\r\n     * @param unlockBlocks number of blocks to wait after registering payment\r\n     *        for an unlock operation\r\n     * @param maxCollectAmount Maximum amount of tokens to be collected in a\r\n     *        single transaction\r\n     */\r\n    constructor(\r\n        IERC20 token_,\r\n        uint32 maxBulk,\r\n        uint32 maxTransfer,\r\n        uint32 challengeBlocks,\r\n        uint32 challengeStepBlocks,\r\n        uint64 collectStake,\r\n        uint64 challengeStake,\r\n        uint32 unlockBlocks,\r\n        uint64 maxCollectAmount\r\n    )\r\n        public\r\n    {\r\n        require(token_ != address(0), \u0022Token address can\u0027t be zero\u0022);\r\n        require(maxBulk \u003E 0, \u0022Parameter maxBulk can\u0027t be zero\u0022);\r\n        require(maxTransfer \u003E 0, \u0022Parameter maxTransfer can\u0027t be zero\u0022);\r\n        require(challengeBlocks \u003E 0, \u0022Parameter challengeBlocks can\u0027t be zero\u0022);\r\n        require(challengeStepBlocks \u003E 0, \u0022Parameter challengeStepBlocks can\u0027t be zero\u0022);\r\n        require(collectStake \u003E 0, \u0022Parameter collectStake can\u0027t be zero\u0022);\r\n        require(challengeStake \u003E 0, \u0022Parameter challengeStake can\u0027t be zero\u0022);\r\n        require(unlockBlocks \u003E 0, \u0022Parameter unlockBlocks can\u0027t be zero\u0022);\r\n        require(maxCollectAmount \u003E 0, \u0022Parameter maxCollectAmount can\u0027t be zero\u0022);\r\n\r\n        owner = msg.sender;\r\n        token = IERC20(token_);\r\n        params.maxBulk = maxBulk;\r\n        params.maxTransfer = maxTransfer;\r\n        params.challengeBlocks = challengeBlocks;\r\n        params.challengeStepBlocks = challengeStepBlocks;\r\n        params.collectStake = collectStake;\r\n        params.challengeStake = challengeStake;\r\n        params.unlockBlocks = unlockBlocks;\r\n        params.maxCollectAmount = maxCollectAmount;\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022fromId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022fee\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022payData\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022newCount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rootHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022lockingKeyHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022metadata\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022registerPayment\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slotId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022toAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022maxPayIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022declaredAmount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022fee\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022destination\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022collect\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAccountsLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022bulkRegistrations\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022rootHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022recordCount\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022smallestRecordId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isValidId\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022register\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022ret\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022INSTANT_SLOT\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022proof\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022bulkId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022claimBulkRegistrationId\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022NEW_ACCOUNT_FLAG\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022payIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022unlockerAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022key\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022unlock\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022challenge_2\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022challenge_success\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isAccountOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022deposit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022payData\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022challenge_4\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022collects\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022minPayIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022maxPayIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022delegateAmount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022block\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challenger\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challengeAmount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_ACCOUNT_ID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022payments\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022fromAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022fee\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022smallestAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022greatestAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022totalNumberOfPayees\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022lockTimeoutBlockNumber\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022paymentDataHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022lockingKeyHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022metadata\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022challenge_failed\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challenger\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022challenge_1\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint64\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getPaymentsLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getBulkLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022freeSlot\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022params\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022maxBulk\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022maxTransfer\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challengeBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challengeStepBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022collectStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022challengeStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022unlockBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022massExitIdBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022massExitIdStepBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022massExitBalanceBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022massExitBalanceStepBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022massExitStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022massExitChallengeStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022maxCollectAmount\u0022,\u0022type\u0022:\u0022uint64\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022payIndex\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022refundLockedPayment\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022bulkSize\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rootHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022bulkRegister\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022accounts\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022lastCollectedPaymentId\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022token\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022name\u0022:\u0022challenge_3\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022token_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022maxBulk\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022maxTransfer\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challengeBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022challengeStepBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022collectStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022challengeStake\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022name\u0022:\u0022unlockBlocks\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022name\u0022:\u0022maxCollectAmount\u0022,\u0022type\u0022:\u0022uint64\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022payIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022totalNumberOfPayees\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PaymentRegistered\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022payIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022key\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022PaymentUnlocked\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022beneficiaryAccountId\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amountRefunded\u0022,\u0022type\u0022:\u0022uint64\u0022}],\u0022name\u0022:\u0022PaymentRefunded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022fromPayindex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022toPayIndex\u0022,\u0022type\u0022:\u0022uint32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Collect\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022challenger\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Challenge1\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Challenge2\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Challenge3\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Challenge4\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ChallengeSuccess\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022delegate\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022slot\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ChallengeFailed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022bulkSize\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022smallestAccountId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022bulkId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022BulkRegister\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022accountId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022accountAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AccountRegistered\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"BatPay","CompilerVersion":"v0.4.25\u002Bcommit.59dbf8f1","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"0000000000000000000000003f17dd476faf0a4855572f0b6ed5115d9bba22ad000000000000000000000000000000000000000000000000000000000000c351000000000000000000000000000000000000000000000000000000000000c3510000000000000000000000000000000000000000000000000000000000000330000000000000000000000000000000000000000000000000000000000000008800000000000000000000000000000000000000000000000000000bd2cc61d000000000000000000000000000000000000000000000000000000009bb49b2f800000000000000000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000002d79883d2000","Library":"Merkle:01c1116b515830d420bc51881d4e23149ffb0608;Challenge:1909578a895ef88249f08cd5662af9b3181367b1","SwarmSource":"bzzr://d4f6dff6e8c0c568032fecb87f854613786cf03f4a824fcb7e50fc38d868b620"}]