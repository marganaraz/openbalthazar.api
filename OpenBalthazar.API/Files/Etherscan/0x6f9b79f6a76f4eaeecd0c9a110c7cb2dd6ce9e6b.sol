[{"SourceCode":"{\u0022AccessControl.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n/// @title A facet of KittyCore that manages special access privileges.\\n/// @author Axiom Zen (https://www.axiomzen.co)\\n/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.\\n\\ncontract AccessControl {\\n    // This facet controls access control for CryptoKitties. There are four roles managed here:\\n    //\\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\\n    //         set to the address that created the smart contract in the KittyCore constructor.\\n    //\\n    //     - The CFO: The CFO can withdraw funds from KittyCore and its auction contracts.\\n    //\\n    //     - The COO: The COO can release gen0 kitties to auction, and mint promo cats.\\n    //\\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\\n    // address to any role, the CEO address itself doesn\\u0027t have the ability to act in those roles. This\\n    // restriction is intentional so that we aren\\u0027t tempted to use the CEO address frequently out of\\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\\n    // account.\\n\\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\\n    event ContractUpgrade(address newContract);\\n\\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\\n    address public ceoAddress;\\n    address public cfoAddress;\\n    address public cooAddress;\\n\\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\\n    bool public paused = false;\\n\\n    /// @dev Access modifier for CEO-only functionality\\n    modifier onlyCEO() {\\n        require(msg.sender == ceoAddress, \\\u0022only CEO\\\u0022);\\n        _;\\n    }\\n\\n    /// @dev Access modifier for CFO-only functionality\\n    modifier onlyCFO() {\\n        require(msg.sender == cfoAddress, \\\u0022only CFO\\\u0022);\\n        _;\\n    }\\n\\n    /// @dev Access modifier for COO-only functionality\\n    modifier onlyCOO() {\\n        require(msg.sender == cooAddress, \\\u0022only COO\\\u0022);\\n        _;\\n    }\\n\\n    modifier onlyCLevel() {\\n        require(\\n            msg.sender == cooAddress ||\\n            msg.sender == ceoAddress ||\\n            msg.sender == cfoAddress, \\\u0022only CLevel\\\u0022\\n        );\\n        _;\\n    }\\n\\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\\n    /// @param _newCEO The address of the new CEO\\n    function setCEO(address _newCEO) external onlyCEO {\\n        require(_newCEO != address(0), \\\u0022newCEO looks like no changes\\\u0022);\\n\\n        ceoAddress = _newCEO;\\n    }\\n\\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\\n    /// @param _newCFO The address of the new CFO\\n    function setCFO(address _newCFO) external onlyCEO {\\n        require(_newCFO != address(0), \\\u0022newCFO looks like no changes\\\u0022);\\n\\n        cfoAddress = _newCFO;\\n    }\\n\\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\\n    /// @param _newCOO The address of the new COO\\n    function setCOO(address _newCOO) external onlyCEO {\\n        require(_newCOO != address(0), \\\u0022newCOO looks like no changes\\\u0022);\\n\\n        cooAddress = _newCOO;\\n    }\\n\\n    /*** Pausable functionality adapted from OpenZeppelin ***/\\n\\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\\n    modifier whenNotPaused() {\\n        require(!paused, \\\u0022current contract is paused\\\u0022);\\n        _;\\n    }\\n\\n    /// @dev Modifier to allow actions only when the contract IS paused\\n    modifier whenPaused {\\n        require(paused, \\\u0022current contract is not paused\\\u0022);\\n        _;\\n    }\\n\\n    /// @dev Called by any \\\u0022C-level\\\u0022 role to pause the contract. Used only when\\n    ///  a bug or exploit is detected and we need to limit damage.\\n    function pause() external onlyCLevel whenNotPaused {\\n        paused = true;\\n    }\\n\\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\\n    ///  one reason we may pause the contract is when CFO or COO accounts are\\n    ///  compromised.\\n    /// @notice This is public rather than external so it can be called by\\n    ///  derived contracts.\\n    function unpause() public onlyCEO whenPaused {\\n        // can\\u0027t unpause if contract was upgraded\\n        paused = false;\\n    }\\n}\\n\u0022},\u0022ERC721.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.11;\\r\\n\\r\\ncontract ERC721 {\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\\r\\n\\r\\n    function balanceOf(address _owner) public view returns (uint256 _balance);\\r\\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\\r\\n    function transfer(address payable _to, uint256 _tokenId) external;\\r\\n    function approve(address payable _to, uint256 _tokenId) external;\\r\\n    function takeOwnership(uint256 _tokenId) public;\\r\\n}\\r\\n\u0022},\u0022GridBase.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.11;\\r\\n\\r\\nimport \\\u0022./ownable.sol\\\u0022;\\r\\nimport \\\u0022./AccessControl.sol\\\u0022;\\r\\n//import \\\u0022./GridOwnership.sol\\\u0022;\\r\\n//import \\\u0022./safemath.sol\\\u0022;\\r\\n//import \\\u0022./console.sol\\\u0022;\\r\\n\\r\\ncontract GridBase is Ownable, AccessControl {\\r\\n\\r\\n    //using SafeMath for uint256;\\r\\n\\r\\n    uint public levelUpFee = 0.01 ether;\\r\\n    uint public limitGridsEachtime = 100;\\r\\n    uint public discountGridsCount = 0;\\r\\n\\r\\n    //uint fee;\\r\\n\\r\\n    struct structGird {\\r\\n        uint16 x;\\r\\n        uint16 y;\\r\\n        uint level;\\r\\n        address payable owner;\\r\\n        address payable inviter;\\r\\n    }\\r\\n\\r\\n    structGird[] public arr_struct_grid;\\r\\n\\r\\n    mapping (address =\\u003e uint) public mappingOwnerGridCount;\\r\\n    mapping (uint16 =\\u003e uint) public mappingPositionToGirdId;\\r\\n\\r\\n    // Set in case the core contract is broken and an upgrade is required\\r\\n    address public newContractAddress;\\r\\n\\r\\n    address payable public authorAddress;\\r\\n    address payable public foundationAddress;\\r\\n\\r\\n    /// @notice Creates the main CryptoKitties smart contract instance.\\r\\n    constructor () public {\\r\\n        // Starts paused.\\r\\n        paused = true;\\r\\n\\r\\n        // the creator of the contract is the initial CEO\\r\\n        ceoAddress = msg.sender;\\r\\n        // the creator of the contract is also the initial COO\\r\\n        cooAddress = msg.sender;\\r\\n        cfoAddress = msg.sender;\\r\\n    }\\r\\n\\r\\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\\r\\n    ///  breaking bug. This method does nothing but keep track of the new contract and\\r\\n    ///  emit a message indicating that the new address is set. It\\u0027s up to clients of this\\r\\n    ///  contract to update to the new contract address in that case. (This contract will\\r\\n    ///  be paused indefinitely if such an upgrade takes place.)\\r\\n    /// @param _v2Address new address\\r\\n    function setNewContractAddress(address _v2Address) external onlyCEO whenPaused {\\r\\n        // See README.md for updgrade plan\\r\\n        newContractAddress = _v2Address;\\r\\n        emit ContractUpgrade(_v2Address);\\r\\n    }\\r\\n\\r\\n    function setAuthorAddress(address payable _address) external onlyCEO whenPaused {\\r\\n        require(_address != address(0), \\\u0022authorAddress can not be empty\\\u0022);\\r\\n        authorAddress = _address;\\r\\n    }\\r\\n\\r\\n    function setFoundationAddress(address payable _address) external onlyCEO whenPaused {\\r\\n        require(_address != address(0), \\\u0022foundationAddress can not be empty\\\u0022);\\r\\n        foundationAddress = _address;\\r\\n    }\\r\\n\\r\\n    /*/// @notice Returns all the relevant information about a specific kitty.\\r\\n    /// @param _id The ID of the kitty of interest.\\r\\n    function getGrid(uint256 _id)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n        uint16 x,\\r\\n        uint16 y,\\r\\n        uint256 level\\r\\n    ) {\\r\\n        structGird memory _grid = arr_struct_grid[_id];\\r\\n\\r\\n        x = uint16(_grid.x);\\r\\n        y = uint16(_grid.y);\\r\\n        level = uint256(_grid.level);\\r\\n    }*/\\r\\n\\r\\n    /// @dev Override unpause so it requires all external contract addresses\\r\\n    ///  to be set before contract can be unpaused. Also, we can\\u0027t have\\r\\n    ///  newContractAddress set either, because then the contract was upgraded.\\r\\n    /// @notice This is public rather than external so we can call super.unpause\\r\\n    ///  without using an expensive CALL.\\r\\n    function unpause() public onlyCEO whenPaused {\\r\\n        require(newContractAddress == address(0), \\\u0022set newContractAddress first\\\u0022);\\r\\n        require(authorAddress != address(0), \\\u0022set authorAddress first\\\u0022);\\r\\n        require(foundationAddress != address(0), \\\u0022set foundationAddress first\\\u0022);\\r\\n\\r\\n        // Actually unpause the contract.\\r\\n        super.unpause();\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner whenPaused {\\r\\n        owner.transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function setLevelUpFee(uint _fee) external onlyCLevel whenPaused {\\r\\n        levelUpFee = _fee;\\r\\n    }\\r\\n\\r\\n    function setlimitGridsEachtime(uint _limit) external onlyCLevel whenPaused {\\r\\n        limitGridsEachtime = _limit;\\r\\n    }\\r\\n\\r\\n\\r\\n  function getContractStatus() external view onlyCLevel returns(uint, uint, uint) {\\r\\n    return (levelUpFee, limitGridsEachtime, address(this).balance);\\r\\n  }\\r\\n\\r\\n  function getLevelUpFee() external view whenNotPaused returns(uint) {\\r\\n    return levelUpFee;\\r\\n  }\\r\\n\\r\\n  function getLimitGridsEachtime() external view whenNotPaused returns(uint) {\\r\\n    return limitGridsEachtime;\\r\\n  }\\r\\n\\r\\n  function getContractBalance() external view onlyCLevel returns(uint) {\\r\\n    return address(this).balance;\\r\\n  }\\r\\n}\\r\\n\u0022},\u0022GridMain.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.11;\\r\\n\\r\\nimport \\\u0022./GridOwnership.sol\\\u0022;\\r\\nimport \\\u0022./safemath.sol\\\u0022;\\r\\n//import \\\u0022./console.sol\\\u0022;\\r\\n\\r\\ncontract GridMain is GridOwnership {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath32 for uint32;\\r\\n    using SafeMath16 for uint16;\\r\\n\\r\\n    //uint16 public version = 101;\\r\\n\\r\\n    function buyGird(uint16 _i, uint16 _j, uint16 _k, uint16 _l, address payable _inviter) external payable whenNotPaused {\\r\\n        require(_i \\u003e= 1 \\u0026\\u0026 _i \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_j \\u003e= 1 \\u0026\\u0026 _j \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_k \\u003e= _i \\u0026\\u0026 _k \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_l \\u003e= _j \\u0026\\u0026 _l \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        //require(_k \\u003e= _i \\u0026\\u0026 _l \\u003e= _j, \\\u0022value invalid\\\u0022);\\r\\n        require((_k-_i\u002B1)*(_l-_j\u002B1) \\u003c= limitGridsEachtime, \\\u0022too many grids you selected, that may cause problems.\\\u0022);\\r\\n        uint16 _x;\\r\\n        uint16 _y;\\r\\n        //string memory position;\\r\\n        uint16 position;\\r\\n        uint256 currentPrice = 0;\\r\\n        uint256 gridId = 0;\\r\\n        uint256 tempLevelUpFee = 0;\\r\\n        address payable inviter;\\r\\n\\r\\n        if(_inviter == address(0)){\\r\\n            inviter = owner;\\r\\n        }else{\\r\\n            inviter = _inviter;\\r\\n        }\\r\\n\\r\\n        //log(\\\u0022mappingPositionToGirdId[position]: \\\u0022, mappingPositionToGirdId[position]);\\r\\n        //log(\\\u0022arr_struct_grid[1].level: \\\u0022, arr_struct_grid[1].level);\\r\\n        //log(\\\u0022msg.value: \\\u0022, msg.value);\\r\\n        //uint fee = msg.value;\\r\\n        //address acc = msg.sender;\\r\\n\\r\\n        for(_x = _i; _x\\u003c=_k; _x\u002B\u002B){\\r\\n            for(_y = _j; _y\\u003c=_l; _y\u002B\u002B){\\r\\n                //position = strConcat(uint2str(_x),uint2str(_y));\\r\\n                //log(\\\u0022position: \\\u0022, position);\\r\\n                position = (_x-1)*100\u002B_y;\\r\\n                gridId = mappingPositionToGirdId[position];\\r\\n                if(gridId \\u003e 0){\\r\\n                    structGird storage _grid = arr_struct_grid[gridId-1];\\r\\n                    //if(_grid.level \\u003e 0){\\r\\n                        //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\\r\\n                        //mappingPositionToOwner[position] = msg.sender;\\r\\n                        currentPrice \u002B= _grid.level * levelUpFee \u002B levelUpFee;\\r\\n                        _grid.owner.transfer(_grid.level * levelUpFee \u002B levelUpFee / 5);\\r\\n                    _grid.inviter.transfer(levelUpFee / 10);\\r\\n                    authorAddress.transfer(levelUpFee / 10);\\r\\n                    foundationAddress.transfer(levelUpFee / 10);\\r\\n                    owner.transfer(levelUpFee/50);\\r\\n                    mappingOwnerGridCount[_grid.owner] = mappingOwnerGridCount[_grid.owner].sub(1);\\r\\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\\r\\n                    _grid.level = _grid.level.add(1);\\r\\n                    _grid.owner = msg.sender;\\r\\n                    if(_grid.inviter != inviter){\\r\\n                        _grid.inviter = inviter;\\r\\n                    }\\r\\n                    //}\\r\\n                }else{\\r\\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\\r\\n                    //mappingGirdPositionToOwner[position] = msg.sender;\\r\\n                    //tempLevelUpFee = levelUpFee;\\r\\n                    if(discountGridsCount \\u003c 1000){\\r\\n                        //currentPrice \u002B= levelUpFee;\\r\\n                    }else if(discountGridsCount \\u003c 3000){\\r\\n                        tempLevelUpFee = levelUpFee*1/10;\\r\\n                    }else if(discountGridsCount \\u003c 6000){\\r\\n                        tempLevelUpFee = levelUpFee*3/10;\\r\\n                    }else if(discountGridsCount \\u003c 10000){\\r\\n                        tempLevelUpFee = levelUpFee*6/10;\\r\\n                    }else{\\r\\n                        tempLevelUpFee = levelUpFee;\\r\\n                    }\\r\\n                    discountGridsCount = discountGridsCount.add(1);\\r\\n                    currentPrice \u002B= tempLevelUpFee;\\r\\n                    uint id = arr_struct_grid.push(structGird(_x, _y, 1, msg.sender, inviter));\\r\\n                    mappingPositionToGirdId[position] = id;\\r\\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\\r\\n                    owner.transfer(tempLevelUpFee);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        require(msg.value \\u003e= currentPrice, \\\u0022out of your balance\\\u0022);\\r\\n        //require(address(this).balance \\u003e= currentPrice, \\\u0022out of contract balance, please buy level0 grids\\\u0022);\\r\\n        /*for(_x = _i; _x\\u003c=_k; _x\u002B\u002B){\\r\\n            for(_y = _j; _y\\u003c=_l; _y\u002B\u002B){\\r\\n                //position = strConcat(uint2str(_x),uint2str(_y));\\r\\n                position = (_x-1)*100\u002B_y;\\r\\n                gridId = mappingPositionToGirdId[position];\\r\\n                if(gridId \\u003e 0){\\r\\n                    structGird memory _grid = arr_struct_grid[gridId-1];\\r\\n                 //\\u0026\\u0026 _grid.level \\u003e 0){\\r\\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\\r\\n                    //mappingPositionToOwner[position] = msg.sender;\\r\\n                    //mappingPositionToGird[position].level = mappingPositionToGird[position].level.add(1);\\r\\n                    //mappingPositionToGird[position].owner = msg.sender;\\r\\n                    _grid.owner.transfer(_grid.level * levelUpFee \u002B levelUpFee / 5);\\r\\n                    _grid.inviter.transfer(levelUpFee / 10);\\r\\n                    authorAddress.transfer(levelUpFee / 10);\\r\\n                    foundationAddress.transfer(levelUpFee / 10);\\r\\n                    owner.transfer(levelUpFee/50);\\r\\n\\r\\n                    mappingOwnerGridCount[_grid.owner] = mappingOwnerGridCount[_grid.owner].sub(1);\\r\\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\\r\\n                    _grid.level = _grid.level.add(1);\\r\\n                    _grid.owner = msg.sender;\\r\\n                    _grid.inviter = inviter;\\r\\n                }else{\\r\\n                    uint id = arr_struct_grid.push(structGird(_x, _y, 1, msg.sender, inviter));\\r\\n                    mappingPositionToGirdId[position] = id;\\r\\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\\r\\n                    owner.transfer(levelUpFee);\\r\\n                    //mappingGirdPositionToOwner[position] = msg.sender;\\r\\n                    //mappingPositionToGird[position] = structGird(_x, _y, 1, msg.sender);\\r\\n                }\\r\\n            }\\r\\n        }*/\\r\\n        msg.sender.transfer(msg.value.sub(currentPrice));\\r\\n    }\\r\\n\\r\\n    function getGridPrice(uint16 _i, uint16 _j, uint16 _k, uint16 _l) external view whenNotPaused returns(uint256){\\r\\n        require(_i \\u003e= 1 \\u0026\\u0026 _i \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_j \\u003e= 1 \\u0026\\u0026 _j \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_k \\u003e= _i \\u0026\\u0026 _k \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        require(_l \\u003e= _j \\u0026\\u0026 _l \\u003c= 100, \\\u0022value invalid\\\u0022);\\r\\n        //require(_k \\u003e= _i \\u0026\\u0026 _l \\u003e= _j, \\\u0022value invalid\\\u0022);\\r\\n        require((_k-_i\u002B1)*(_l-_j\u002B1) \\u003c= limitGridsEachtime, \\\u0022too many grids you selected, that may cause problems.\\\u0022);\\r\\n        uint16 _x;\\r\\n        uint16 _y;\\r\\n        //string memory position;\\r\\n        uint16 position;\\r\\n\\r\\n        //log(\\\u0022mappingPositionToGirdId[position]: \\\u0022, mappingPositionToGirdId[position]);\\r\\n        //log(\\\u0022arr_struct_grid[1].level: \\\u0022, arr_struct_grid[1].level);\\r\\n        //log(\\\u0022msg.value: \\\u0022, msg.value);\\r\\n        //uint fee = msg.value;\\r\\n        //address acc = msg.sender;\\r\\n\\r\\n        uint256 currentPrice = 0;\\r\\n        uint256 gridId = 0;\\r\\n        uint256 tempLevelUpFee = 0;\\r\\n        for(_x = _i; _x\\u003c=_k; _x\u002B\u002B){\\r\\n            for(_y = _j; _y\\u003c=_l; _y\u002B\u002B){\\r\\n                //position = strConcat(uint2str(_x),uint2str(_y));\\r\\n                //log(\\\u0022position: \\\u0022, position);\\r\\n                position = (_x-1)*100\u002B_y;\\r\\n                gridId = mappingPositionToGirdId[position];\\r\\n                if(gridId \\u003e 0){\\r\\n                    structGird memory _grid = arr_struct_grid[gridId-1];\\r\\n                    //if(_grid.level \\u003e 0){\\r\\n                        //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\\r\\n                        //mappingPositionToOwner[position] = msg.sender;\\r\\n                        currentPrice \u002B= _grid.level * levelUpFee \u002B levelUpFee;\\r\\n                    //}\\r\\n                }else{\\r\\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\\r\\n                    //mappingGirdPositionToOwner[position] = msg.sender;\\r\\n                    if(discountGridsCount \\u003c 1000){\\r\\n                        //currentPrice \u002B= levelUpFee;\\r\\n                    }else if(discountGridsCount \\u003c 3000){\\r\\n                        tempLevelUpFee = levelUpFee*1/10;\\r\\n                    }else if(discountGridsCount \\u003c 6000){\\r\\n                        tempLevelUpFee = levelUpFee*3/10;\\r\\n                    }else if(discountGridsCount \\u003c 10000){\\r\\n                        tempLevelUpFee = levelUpFee*6/10;\\r\\n                    }else{\\r\\n                        tempLevelUpFee = levelUpFee;\\r\\n                    }\\r\\n                    //discountGridsCount = discountGridsCount.add(1);\\r\\n                    currentPrice \u002B= tempLevelUpFee;\\r\\n                    //currentPrice \u002B= levelUpFee;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return currentPrice;\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022GridOwnership.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\u0022./GridBase.sol\\\u0022;\\r\\nimport \\\u0022./ERC721.sol\\\u0022;\\r\\nimport \\\u0022./safemath.sol\\\u0022;\\r\\n\\r\\ncontract GridOwnership is ERC721, GridBase {\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  mapping (uint =\\u003e address) gridApprovals;\\r\\n\\r\\n  modifier onlyOwnerOf(uint _gridId) {\\r\\n    require(msg.sender == arr_struct_grid[_gridId].owner, \\\u0022you are not owner of this grid\\\u0022);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function balanceOf(address _owner) public view returns (uint256 _balance) {\\r\\n    return mappingOwnerGridCount[_owner];\\r\\n  }\\r\\n\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner) {\\r\\n    _owner = arr_struct_grid[_tokenId].owner;\\r\\n    require(_owner != address(0), \\\u0022address invalid\\\u0022);\\r\\n  }\\r\\n\\r\\n  function _transfer(address _from, address payable _to, uint256 _tokenId) private {\\r\\n    mappingOwnerGridCount[_to] = mappingOwnerGridCount[_to].add(1);\\r\\n    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].sub(1);\\r\\n    arr_struct_grid[_tokenId].owner = _to;\\r\\n    emit Transfer(_from, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  function transfer(address payable _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) whenNotPaused {\\r\\n    // Safety check to prevent against an unexpected 0x0 default.\\r\\n    require(_to != address(0), \\\u0022address invalid\\\u0022);\\r\\n    // Disallow transfers to this contract to prevent accidental misuse.\\r\\n    // The contract should never own any kitties (except very briefly\\r\\n    // after a gen0 cat is created and before it goes on auction).\\r\\n    require(_to != address(this), \\\u0022address invalid\\\u0022);\\r\\n    // Disallow transfers to the auction contracts to prevent accidental\\r\\n    // misuse. Auction contracts should only take ownership of kitties\\r\\n    // through the allow \u002B transferFrom flow.\\r\\n    //require(_to != address(saleAuction));\\r\\n    //require(_to != address(siringAuction));\\r\\n    _transfer(msg.sender, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  function approve(address payable _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) whenNotPaused {\\r\\n    gridApprovals[_tokenId] = _to;\\r\\n    emit Approval(msg.sender, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  function takeOwnership(uint256 _tokenId) public {\\r\\n    require(gridApprovals[_tokenId] == msg.sender, \\\u0022you are not that guy\\\u0022);\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    _transfer(owner, msg.sender, _tokenId);\\r\\n  }\\r\\n}\u0022},\u0022ownable.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.11;\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\u0022user permissions\\\u0022.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address payable public owner;\\r\\n\\r\\n    event ContractOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\\r\\n   * account.\\r\\n   */\\r\\n    constructor () public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\u0022only owner\\\u0022);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param newOwner The address to transfer ownership to.\\r\\n   */\\r\\n    function transferContractOwnership(address payable newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\u0022new owner can not be empty\\\u0022);\\r\\n        emit ContractOwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n}\\r\\n\u0022},\u0022safemath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeMath32\\r\\n * @dev SafeMath library implemented for uint32\\r\\n */\\r\\nlibrary SafeMath32 {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        uint32 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return sub(a, b, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint32 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint32 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return div(a, b, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function div(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint32 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return mod(a, b, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function mod(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeMath16\\r\\n * @dev SafeMath library implemented for uint16\\r\\n */\\r\\nlibrary SafeMath16 {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n        uint16 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n        return sub(a, b, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function sub(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint16 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint16 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n        return div(a, b, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function div(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint16 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n        return mod(a, b, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n     * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n     */\\r\\n    function mod(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n\u0022}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022authorAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cfoAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ceoAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_i\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_j\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_k\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_l\u0022,\u0022type\u0022:\u0022uint16\u0022}],\u0022name\u0022:\u0022getGridPrice\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_newCEO\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCEO\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_newCOO\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCOO\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022unpause\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_i\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_j\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_k\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022_l\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_inviter\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022buyGird\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_limit\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setlimitGridsEachtime\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_newCFO\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCFO\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022paused\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ownerOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022newContractAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLevelUpFee\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getContractBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022discountGridsCount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getLimitGridsEachtime\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pause\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022mappingOwnerGridCount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022limitGridsEachtime\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferContractOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cooAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022takeOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint16\u0022}],\u0022name\u0022:\u0022mappingPositionToGirdId\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getContractStatus\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022levelUpFee\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_fee\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setLevelUpFee\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAuthorAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022arr_struct_grid\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022x\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint16\u0022,\u0022name\u0022:\u0022y\u0022,\u0022type\u0022:\u0022uint16\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022inviter\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_v2Address\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setNewContractAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setFoundationAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022foundationAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newContract\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ContractUpgrade\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ContractOwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_approved\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"GridMain","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://67c360e1549af4fa494644ad5ef357e8a48870015a06b8eb67522393a6a81e9a"}]