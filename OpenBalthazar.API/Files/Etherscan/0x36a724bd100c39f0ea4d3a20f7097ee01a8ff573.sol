[{"SourceCode":"// hevm: flattened sources of /nix/store/jyvwn5yyqxwkfxc45k04h2dk209dn6sh-dss-cdp-manager-8976239/src/GetCdps.sol\r\npragma solidity =0.5.12;\r\n\r\n////// /nix/store/4vip6nyqfd0yhs15md21rzxsk5jgx6sv-dss/dapp/dss/src/lib.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see \u003Chttp://www.gnu.org/licenses/\u003E.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an \u0027anonymous\u0027 event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\n////// /nix/store/jyvwn5yyqxwkfxc45k04h2dk209dn6sh-dss-cdp-manager-8976239/src/DssCdpManager.sol\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import { LibNote } from \u0022dss/lib.sol\u0022; */\r\n\r\ncontract VatLike {\r\n    function urns(bytes32, address) public view returns (uint, uint);\r\n    function hope(address) public;\r\n    function flux(bytes32, address, address, uint) public;\r\n    function move(address, address, uint) public;\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n    function fork(bytes32, address, address, int, int) public;\r\n}\r\n\r\ncontract UrnHandler {\r\n    constructor(address vat) public {\r\n        VatLike(vat).hope(msg.sender);\r\n    }\r\n}\r\n\r\ncontract DssCdpManager is LibNote {\r\n    address                   public vat;\r\n    uint                      public cdpi;      // Auto incremental\r\n    mapping (uint =\u003E address) public urns;      // CDPId =\u003E UrnHandler\r\n    mapping (uint =\u003E List)    public list;      // CDPId =\u003E Prev \u0026 Next CDPIds (double linked list)\r\n    mapping (uint =\u003E address) public owns;      // CDPId =\u003E Owner\r\n    mapping (uint =\u003E bytes32) public ilks;      // CDPId =\u003E Ilk\r\n\r\n    mapping (address =\u003E uint) public first;     // Owner =\u003E First CDPId\r\n    mapping (address =\u003E uint) public last;      // Owner =\u003E Last CDPId\r\n    mapping (address =\u003E uint) public count;     // Owner =\u003E Amount of CDPs\r\n\r\n    mapping (\r\n        address =\u003E mapping (\r\n            uint =\u003E mapping (\r\n                address =\u003E uint\r\n            )\r\n        )\r\n    ) public cdpCan;                            // Owner =\u003E CDPId =\u003E Allowed Addr =\u003E True/False\r\n\r\n    mapping (\r\n        address =\u003E mapping (\r\n            address =\u003E uint\r\n        )\r\n    ) public urnCan;                            // Urn =\u003E Allowed Addr =\u003E True/False\r\n\r\n    struct List {\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\r\n\r\n    modifier cdpAllowed(\r\n        uint cdp\r\n    ) {\r\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \u0022cdp-not-allowed\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier urnAllowed(\r\n        address urn\r\n    ) {\r\n        require(msg.sender == urn || urnCan[urn][msg.sender] == 1, \u0022urn-not-allowed\u0022);\r\n        _;\r\n    }\r\n\r\n    constructor(address vat_) public {\r\n        vat = vat_;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x \u002B y) \u003E= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003C= x);\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y \u003E= 0);\r\n    }\r\n\r\n    // Allow/disallow a usr address to manage the cdp.\r\n    function cdpAllow(\r\n        uint cdp,\r\n        address usr,\r\n        uint ok\r\n    ) public cdpAllowed(cdp) {\r\n        cdpCan[owns[cdp]][cdp][usr] = ok;\r\n    }\r\n\r\n    // Allow/disallow a usr address to quit to the the sender urn.\r\n    function urnAllow(\r\n        address usr,\r\n        uint ok\r\n    ) public {\r\n        urnCan[msg.sender][usr] = ok;\r\n    }\r\n\r\n    // Open a new cdp for a given usr address.\r\n    function open(\r\n        bytes32 ilk,\r\n        address usr\r\n    ) public note returns (uint) {\r\n        require(usr != address(0), \u0022usr-address-0\u0022);\r\n\r\n        cdpi = add(cdpi, 1);\r\n        urns[cdpi] = address(new UrnHandler(vat));\r\n        owns[cdpi] = usr;\r\n        ilks[cdpi] = ilk;\r\n\r\n        // Add new CDP to double linked list and pointers\r\n        if (first[usr] == 0) {\r\n            first[usr] = cdpi;\r\n        }\r\n        if (last[usr] != 0) {\r\n            list[cdpi].prev = last[usr];\r\n            list[last[usr]].next = cdpi;\r\n        }\r\n        last[usr] = cdpi;\r\n        count[usr] = add(count[usr], 1);\r\n\r\n        emit NewCdp(msg.sender, usr, cdpi);\r\n        return cdpi;\r\n    }\r\n\r\n    // Give the cdp ownership to a dst address.\r\n    function give(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) {\r\n        require(dst != address(0), \u0022dst-address-0\u0022);\r\n        require(dst != owns[cdp], \u0022dst-already-owner\u0022);\r\n\r\n        // Remove transferred CDP from double linked list of origin user and pointers\r\n        if (list[cdp].prev != 0) {\r\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\r\n        }\r\n        if (list[cdp].next != 0) {                              // If wasn\u0027t the last one\r\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\r\n        } else {                                                // If was the last one\r\n            last[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\r\n        }\r\n        if (first[owns[cdp]] == cdp) {                          // If was the first one\r\n            first[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\r\n        }\r\n        count[owns[cdp]] = sub(count[owns[cdp]], 1);\r\n\r\n        // Transfer ownership\r\n        owns[cdp] = dst;\r\n\r\n        // Add transferred CDP to double linked list of destiny user and pointers\r\n        list[cdp].prev = last[dst];\r\n        list[cdp].next = 0;\r\n        if (last[dst] != 0) {\r\n            list[last[dst]].next = cdp;\r\n        }\r\n        if (first[dst] == 0) {\r\n            first[dst] = cdp;\r\n        }\r\n        last[dst] = cdp;\r\n        count[dst] = add(count[dst], 1);\r\n    }\r\n\r\n    // Frob the cdp keeping the generated DAI or collateral freed in the cdp urn address.\r\n    function frob(\r\n        uint cdp,\r\n        int dink,\r\n        int dart\r\n    ) public note cdpAllowed(cdp) {\r\n        address urn = urns[cdp];\r\n        VatLike(vat).frob(\r\n            ilks[cdp],\r\n            urn,\r\n            urn,\r\n            urn,\r\n            dink,\r\n            dart\r\n        );\r\n    }\r\n\r\n    // Transfer wad amount of cdp collateral from the cdp address to a dst address.\r\n    function flux(\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilks[cdp], urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\r\n    // This function has the purpose to take away collateral from the system that doesn\u0027t correspond to the cdp but was sent there wrongly.\r\n    function flux(\r\n        bytes32 ilk,\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilk, urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of DAI from the cdp address to a dst address.\r\n    function move(\r\n        uint cdp,\r\n        address dst,\r\n        uint rad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).move(urns[cdp], dst, rad);\r\n    }\r\n\r\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\r\n    function quit(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) urnAllowed(dst) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], urns[cdp]);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            urns[cdp],\r\n            dst,\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Import a position from src urn to the urn owned by cdp\r\n    function enter(\r\n        address src,\r\n        uint cdp\r\n    ) public note urnAllowed(src) cdpAllowed(cdp) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], src);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            src,\r\n            urns[cdp],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Move a position from cdpSrc urn to the cdpDst urn\r\n    function shift(\r\n        uint cdpSrc,\r\n        uint cdpDst\r\n    ) public note cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\r\n        require(ilks[cdpSrc] == ilks[cdpDst], \u0022non-matching-cdps\u0022);\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdpSrc], urns[cdpSrc]);\r\n        VatLike(vat).fork(\r\n            ilks[cdpSrc],\r\n            urns[cdpSrc],\r\n            urns[cdpDst],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n}\r\n\r\n////// /nix/store/jyvwn5yyqxwkfxc45k04h2dk209dn6sh-dss-cdp-manager-8976239/src/GetCdps.sol\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import \u0022./DssCdpManager.sol\u0022; */\r\n\r\ncontract GetCdps {\r\n    function getCdpsAsc(address manager, address guy) external view returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks) {\r\n        uint count = DssCdpManager(manager).count(guy);\r\n        ids = new uint[](count);\r\n        urns = new address[](count);\r\n        ilks = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = DssCdpManager(manager).first(guy);\r\n\r\n        while (id \u003E 0) {\r\n            ids[i] = id;\r\n            urns[i] = DssCdpManager(manager).urns(id);\r\n            ilks[i] = DssCdpManager(manager).ilks(id);\r\n            (,id) = DssCdpManager(manager).list(id);\r\n            i\u002B\u002B;\r\n        }\r\n    }\r\n\r\n    function getCdpsDesc(address manager, address guy) external view returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks) {\r\n        uint count = DssCdpManager(manager).count(guy);\r\n        ids = new uint[](count);\r\n        urns = new address[](count);\r\n        ilks = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = DssCdpManager(manager).last(guy);\r\n\r\n        while (id \u003E 0) {\r\n            ids[i] = id;\r\n            urns[i] = DssCdpManager(manager).urns(id);\r\n            ilks[i] = DssCdpManager(manager).ilks(id);\r\n            (id,) = DssCdpManager(manager).list(id);\r\n            i\u002B\u002B;\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022manager\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022guy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getCdpsAsc\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ids\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022urns\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022ilks\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022manager\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022guy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getCdpsDesc\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022ids\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022urns\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022bytes32[]\u0022,\u0022name\u0022:\u0022ilks\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"GetCdps","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1f524da9652dec1dc77c86f663a6bf6b9d63e66b6320b6defed05258f24172ff"}]