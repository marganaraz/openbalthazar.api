[{"SourceCode":"/**\r\n* Absolutus smart contract by BioHazzardt\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \u0027Invalid values\u0027);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0027Substraction result smaller than zero\u0027);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0027Invalid values\u0027);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public manager;\r\n    address public ownerWallet;\r\n    address public adminWallet;\r\n    uint adminPersent;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        manager = msg.sender;\r\n        adminWallet = 0xcFebf7C3Ec7B407DFf17aa20a2631c95c8ff508c;\r\n        ownerWallet = 0xcFebf7C3Ec7B407DFf17aa20a2631c95c8ff508c;\r\n        adminPersent = 10;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \u0022only for owner\u0022);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager() {\r\n        require((msg.sender == owner)||(msg.sender == manager), \u0022only for owner or manager\u0022);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwnerOrManager {\r\n        manager = _manager;\r\n    }\r\n\r\n    function setAdminWallet(address _admin) public onlyOwner {\r\n        adminWallet = _admin;\r\n    }\r\n}\r\n\r\n\r\ncontract WalletOnly {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. \u0060keccak256(\u0027\u0027)\u0060\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n}\r\n\r\n\r\ncontract Absolutus is Ownable, WalletOnly {\r\n    // Events\r\n    event RegLevelEvent(address indexed _user, address indexed _referrer, uint _id, uint _time);\r\n    event BuyLevelEvent(address indexed _user, uint _level, uint _time);\r\n    event ProlongateLevelEvent(address indexed _user, uint _level, uint _time);\r\n    event GetMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _price, bool _prevLost);\r\n    event LostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _price, bool _prevLost);\r\n\r\n    // New events\r\n    event PaymentForHolder(address indexed _addr, uint _index, uint _value);\r\n    event PaymentForHolderLost(address indexed _addr, uint _index, uint _value);\r\n\r\n    // Common values\r\n    mapping (uint =\u003E uint) public LEVEL_PRICE;\r\n    address canSetLevelPrice;\r\n    uint REFERRER_1_LEVEL_LIMIT = 3;\r\n    uint PERIOD_LENGTH = 365 days; // uncomment before production\r\n    uint MAX_AUTOPAY_COUNT = 5;     // Automatic level buying limit per one transaction (to prevent gas limit reaching)\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerID;\r\n        uint fund;          // Fund for the automatic level pushcase\r\n        uint currentLvl;    // Current user\u0027s level\r\n        address[] referral;\r\n        mapping (uint =\u003E uint) levelExpired;\r\n        mapping (uint =\u003E uint) paymentsCount;\r\n    }\r\n\r\n    mapping (address =\u003E UserStruct) public users;\r\n    mapping (uint =\u003E address) public userList;\r\n    mapping (address =\u003E uint) public allowUsers;\r\n\r\n    uint public currUserID = 0;\r\n    bool nostarted = false;\r\n\r\n    AbsDAO _dao; // DAO contract\r\n    bool daoSet = false; // if true payment processed for DAO holders\r\n\r\n    using SafeMath for uint; // \u003C== do not forget about this\r\n\r\n    constructor() public {\r\n        // Prices in ETH: production\r\n        LEVEL_PRICE[1] = 0.5 ether;\r\n        LEVEL_PRICE[2] = 1.0 ether;\r\n        LEVEL_PRICE[3] = 2.0 ether;\r\n        LEVEL_PRICE[4] = 4.0 ether;\r\n        LEVEL_PRICE[5] = 16.0 ether;\r\n        LEVEL_PRICE[6] = 32.0 ether;\r\n        LEVEL_PRICE[7] = 64.0 ether;\r\n        LEVEL_PRICE[8] = 128.0 ether;\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID\u002B\u002B;\r\n\r\n        canSetLevelPrice = owner;\r\n\r\n        // Create root user\r\n        userStruct = UserStruct({\r\n            isExist : true,\r\n            id : currUserID,\r\n            referrerID : 0,\r\n            fund: 0,\r\n            currentLvl: 1,\r\n            referral : new address[](0)\r\n        });\r\n\r\n        users[ownerWallet] = userStruct;\r\n        userList[currUserID] = ownerWallet;\r\n\r\n        users[ownerWallet].levelExpired[1] = 77777777777;\r\n        users[ownerWallet].levelExpired[2] = 77777777777;\r\n        users[ownerWallet].levelExpired[3] = 77777777777;\r\n        users[ownerWallet].levelExpired[4] = 77777777777;\r\n        users[ownerWallet].levelExpired[5] = 77777777777;\r\n        users[ownerWallet].levelExpired[6] = 77777777777;\r\n        users[ownerWallet].levelExpired[7] = 77777777777;\r\n        users[ownerWallet].levelExpired[8] = 77777777777;\r\n\r\n        // Set inviting registration only\r\n        nostarted = true;\r\n    }\r\n\r\n    function () external payable {\r\n        require(!isContract(msg.sender), \u0027This contract cannot support payments from other contracts\u0027);\r\n\r\n        uint level;\r\n\r\n        // Check for payment with level price\r\n        if (msg.value == LEVEL_PRICE[1]) {\r\n            level = 1;\r\n        } else if (msg.value == LEVEL_PRICE[2]) {\r\n            level = 2;\r\n        } else if (msg.value == LEVEL_PRICE[3]) {\r\n            level = 3;\r\n        } else if (msg.value == LEVEL_PRICE[4]) {\r\n            level = 4;\r\n        } else if (msg.value == LEVEL_PRICE[5]) {\r\n            level = 5;\r\n        } else if (msg.value == LEVEL_PRICE[6]) {\r\n            level = 6;\r\n        } else if (msg.value == LEVEL_PRICE[7]) {\r\n            level = 7;\r\n        } else if (msg.value == LEVEL_PRICE[8]) {\r\n            level = 8;\r\n        } else {\r\n            // Pay to user\u0027s fund\r\n            if (!users[msg.sender].isExist || users[msg.sender].currentLvl \u003E= 8)\r\n                revert(\u0027Incorrect Value send\u0027);\r\n\r\n            users[msg.sender].fund \u002B= msg.value;\r\n            updateCurrentLevel(msg.sender);\r\n            // if the referer is have funds for autobuy next level\r\n            if (LEVEL_PRICE[users[msg.sender].currentLvl\u002B1] \u003C= users[msg.sender].fund) {\r\n                buyLevelByFund(msg.sender, 0);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Buy level or register user\r\n        if (users[msg.sender].isExist) {\r\n            buyLevel(level);\r\n        } else if (level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if (users[referrer].isExist) {\r\n                refId = users[referrer].id;\r\n            } else {\r\n                revert(\u0027Incorrect referrer\u0027);\r\n                // refId = 1;\r\n            }\r\n\r\n            regUser(refId);\r\n        } else {\r\n            revert(\u0022Please buy first level for 0.1 ETH\u0022);\r\n        }\r\n    }\r\n\r\n    // allow user in invite mode\r\n    function allowUser(address _user) public onlyOwner {\r\n        require(nostarted, \u0027You cant allow user in battle mode\u0027);\r\n        allowUsers[_user] = 1;\r\n    }\r\n\r\n    // disable inviting\r\n    function battleMode() public onlyOwner {\r\n        require(nostarted, \u0027Battle mode activated\u0027);\r\n        nostarted = false;\r\n    }\r\n\r\n    // this function sets the DAO contract address\r\n    function setDAOAddress(address payable _dao_addr) public onlyOwner {\r\n        require(!daoSet, \u0027DAO address already set\u0027);\r\n        _dao = AbsDAO(_dao_addr);\r\n        daoSet = true;\r\n    }\r\n\r\n    // process payment to administrator wallet\r\n    // or DAO holders\r\n    function payToAdmin(uint _amount) internal {\r\n        if (daoSet) {\r\n            // Pay for DAO\r\n            uint holderCount = _dao.getHolderCount();       // get the DAO holders count\r\n            for (uint i = 1; i \u003C= holderCount; i\u002B\u002B) {\r\n                uint val = _dao.getHolderPieAt(i);          // get pie of holder with index == i\r\n                address payable holder = _dao.getHolder(i); // get the holder address\r\n\r\n                if (val \u003E 0) {                              // check of the holder pie value\r\n                    uint payValue = _amount.div(100).mul(val); // calculate amount for pay to the holder\r\n                    holder.transfer(payValue);\r\n                    emit PaymentForHolder(holder, i, payValue); // payment ok\r\n                } else {\r\n                    emit PaymentForHolderLost(holder, i, val); // holder\u0027s pie value is zero\r\n                }\r\n            }\r\n        } else {\r\n            // pay to admin wallet\r\n            address(uint160(adminWallet)).transfer(_amount);\r\n        }\r\n    }\r\n\r\n    // user registration\r\n    function regUser(uint referrerID) public payable {\r\n        require(!isContract(msg.sender), \u0027This contract cannot support payments from other contracts\u0027);\r\n\r\n        if (nostarted) {\r\n            require(allowUsers[msg.sender] \u003E 0, \u0027You cannot use this contract on start\u0027);\r\n        }\r\n\r\n        require(!users[msg.sender].isExist, \u0027User exist\u0027);\r\n        require(referrerID \u003E 0 \u0026\u0026 referrerID \u003C= currUserID, \u0027Incorrect referrer Id\u0027);\r\n        require(msg.value==LEVEL_PRICE[1], \u0027Incorrect Value\u0027);\r\n\r\n        // NOTE: use one more variable to prevent \u0027Security/No-assign-param\u0027 error (for vscode-solidity extension).\r\n        // Need to check the gas consumtion with it\r\n        uint _referrerID = referrerID;\r\n\r\n        if (users[userList[referrerID]].referral.length \u003E= REFERRER_1_LEVEL_LIMIT) {\r\n            _referrerID = users[findFreeReferrer(userList[referrerID])].id;\r\n        }\r\n\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID\u002B\u002B;\r\n\r\n        // add user to list\r\n        userStruct = UserStruct({\r\n            isExist : true,\r\n            id : currUserID,\r\n            referrerID : _referrerID,\r\n            fund: 0,\r\n            currentLvl: 1,\r\n            referral : new address[](0)\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currUserID] = msg.sender;\r\n\r\n        users[msg.sender].levelExpired[1] = now \u002B PERIOD_LENGTH;\r\n        users[msg.sender].levelExpired[2] = 0;\r\n        users[msg.sender].levelExpired[3] = 0;\r\n        users[msg.sender].levelExpired[4] = 0;\r\n        users[msg.sender].levelExpired[5] = 0;\r\n        users[msg.sender].levelExpired[6] = 0;\r\n        users[msg.sender].levelExpired[7] = 0;\r\n        users[msg.sender].levelExpired[8] = 0;\r\n\r\n        users[userList[_referrerID]].referral.push(msg.sender);\r\n\r\n        // pay for referer\r\n        payForLevel(\r\n            1,\r\n            msg.sender,\r\n            msg.sender,\r\n            0,\r\n            false\r\n        );\r\n\r\n        emit RegLevelEvent(\r\n            msg.sender,\r\n            userList[_referrerID],\r\n            currUserID,\r\n            now\r\n        );\r\n    }\r\n\r\n    // buy level function\r\n    function buyLevel(uint _level) public payable {\r\n        require(!isContract(msg.sender), \u0027This contract cannot support payments from other contracts\u0027);\r\n\r\n        require(users[msg.sender].isExist, \u0027User not exist\u0027);\r\n        require(_level\u003E0 \u0026\u0026 _level\u003C=8, \u0027Incorrect level\u0027);\r\n        require(msg.value==LEVEL_PRICE[_level], \u0027Incorrect Value\u0027);\r\n\r\n        if (_level \u003E 1) { // Replace for condition (_level == 1) on top (done)\r\n            for (uint i = _level-1; i\u003E0; i--) {\r\n                require(users[msg.sender].levelExpired[i] \u003E= now, \u0027Buy the previous level\u0027);\r\n            }\r\n        }\r\n\r\n        // if(users[msg.sender].levelExpired[_level] == 0){ \u003C-- BUG\r\n        // if the level expired in the future, need add PERIOD_LENGTH to the level expiration time,\r\n        // or set the level expiration time to \u0027now \u002B PERIOD_LENGTH\u0027 in other cases.\r\n        if (users[msg.sender].levelExpired[_level] \u003E now) {\r\n            users[msg.sender].levelExpired[_level] \u002B= PERIOD_LENGTH;\r\n        } else {\r\n            users[msg.sender].levelExpired[_level] = now \u002B PERIOD_LENGTH;\r\n        }\r\n\r\n        // Set user\u0027s current level\r\n        if (users[msg.sender].currentLvl \u003C _level)\r\n            users[msg.sender].currentLvl = _level;\r\n\r\n        // provide payment for the user\u0027s referer\r\n        payForLevel(\r\n            _level,\r\n            msg.sender,\r\n            msg.sender,\r\n            0,\r\n            false\r\n        );\r\n\r\n        emit BuyLevelEvent(msg.sender, _level, now);\r\n    }\r\n\r\n    function setLevelPrice(uint _level, uint _price) public {\r\n        require(_level \u003E= 0 \u0026\u0026 _level \u003C= 8, \u0027Invalid level\u0027);\r\n        require(msg.sender == canSetLevelPrice, \u0027Invalid caller\u0027);\r\n        require(_price \u003E 0, \u0027Price cannot be zero or negative\u0027);\r\n\r\n        LEVEL_PRICE[_level] = _price * 1.0 finney;\r\n    }\r\n\r\n    function setCanUpdateLevelPrice(address addr) public onlyOwner {\r\n        canSetLevelPrice = addr;\r\n    }\r\n\r\n    // for interactive correction of the limitations\r\n    function setMaxAutopayForLevelCount(uint _count) public onlyOwnerOrManager {\r\n        MAX_AUTOPAY_COUNT = _count;\r\n    }\r\n\r\n    // buyLevelByFund provides automatic payment for next level for user\r\n    function buyLevelByFund(address referer, uint _counter) internal {\r\n        require(users[referer].isExist, \u0027User not exists\u0027);\r\n\r\n        uint _level = users[referer].currentLvl \u002B 1; // calculate a next level\r\n        require(users[referer].fund \u003E= LEVEL_PRICE[_level], \u0027Not have funds to autobuy level\u0027);\r\n\r\n        uint remaining = users[referer].fund - LEVEL_PRICE[_level]; // Amount for pay to the referer\r\n\r\n        // extend the level\u0027s expiration time\r\n        if (users[referer].levelExpired[_level] \u003E= now) {\r\n            users[referer].levelExpired[_level] \u002B= PERIOD_LENGTH;\r\n        } else {\r\n            users[referer].levelExpired[_level] = now \u002B PERIOD_LENGTH;\r\n        }\r\n\r\n        users[referer].currentLvl = _level; // set current level for referer\r\n        users[referer].fund = 0;            // clear the referer\u0027s fund\r\n\r\n        // process payment for next referer with increment autopay counter\r\n        payForLevel(\r\n            _level,\r\n            referer,\r\n            referer,\r\n            _counter\u002B1,\r\n            false\r\n        );\r\n        address(uint160(referer)).transfer(remaining); // send the remaining amount to referer\r\n\r\n        emit BuyLevelEvent(referer, _level, now); // emit the buy level event for referer\r\n    }\r\n\r\n    // updateCurrentLevel calculate \u0027currentLvl\u0027 value for given user\r\n    function updateCurrentLevel(address _user) internal {\r\n        users[_user].currentLvl = actualLevel(_user);\r\n    }\r\n\r\n    // helper function\r\n    function actualLevel(address _user) public view returns(uint) {\r\n        require(users[_user].isExist, \u0027User not found\u0027);\r\n\r\n        for (uint i = 1; i \u003C= 8; i\u002B\u002B) {\r\n            if (users[_user].levelExpired[i] \u003C= now) {\r\n                return i-1;\r\n            }\r\n        }\r\n\r\n        return 8;\r\n    }\r\n\r\n    // payForLevel provides payment processing for user\u0027s referer and automatic buying referer\u0027s next\r\n    // level.\r\n    function payForLevel(uint _level, address _user, address _sender, uint _autoPayCtr, bool prevLost) internal {\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n\r\n        if (_level == 1 || _level == 5) {\r\n            referer = userList[users[_user].referrerID];\r\n        } else if (_level == 2 || _level == 6) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer = userList[users[referer1].referrerID];\r\n        } else if (_level == 3 || _level == 7) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer2 = userList[users[referer1].referrerID];\r\n            referer = userList[users[referer2].referrerID];\r\n        } else if (_level == 4 || _level == 8) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer2 = userList[users[referer1].referrerID];\r\n            referer3 = userList[users[referer2].referrerID];\r\n            referer = userList[users[referer3].referrerID];\r\n        }\r\n\r\n        if (!users[referer].isExist) {\r\n            referer = userList[1];\r\n        }\r\n\r\n        uint amountToUser;\r\n        uint amountToAdmin;\r\n\r\n        amountToAdmin = LEVEL_PRICE[_level] / 100 * adminPersent;\r\n        amountToUser = LEVEL_PRICE[_level] - amountToAdmin;\r\n\r\n        if (users[referer].id \u003C= 4) {\r\n            payToAdmin(LEVEL_PRICE[_level]);\r\n\r\n            emit GetMoneyForLevelEvent(\r\n                referer,\r\n                _sender,\r\n                _level,\r\n                now,\r\n                amountToUser,\r\n                prevLost\r\n            );\r\n\r\n            return;\r\n        }\r\n\r\n        if (users[referer].levelExpired[_level] \u003E= now) {\r\n            payToAdmin(amountToAdmin);\r\n\r\n            // update current referer\u0027s level\r\n            updateCurrentLevel(referer);\r\n\r\n\r\n            // check for the user has right level and automatic payment counter\r\n            // smaller than the \u0027MAX_AUTOPAY_COUNT\u0027 value\r\n            if (_level == users[referer].currentLvl \u0026\u0026 _autoPayCtr \u003C MAX_AUTOPAY_COUNT \u0026\u0026 users[referer].currentLvl \u003C 8) {\r\n                users[referer].fund \u002B= amountToUser;\r\n\r\n                emit GetMoneyForLevelEvent(\r\n                    referer,\r\n                    _sender,\r\n                    _level,\r\n                    now,\r\n                    amountToUser,\r\n                    prevLost\r\n                );\r\n\r\n                // if the referer is have funds for autobuy next level\r\n                if (LEVEL_PRICE[users[referer].currentLvl\u002B1] \u003C= users[referer].fund) {\r\n                    buyLevelByFund(referer, _autoPayCtr);\r\n                }\r\n            } else {\r\n                // send the ethers to referer\r\n                address(uint160(referer)).transfer(amountToUser);\r\n\r\n                emit GetMoneyForLevelEvent(\r\n                    referer,\r\n                    _sender,\r\n                    _level,\r\n                    now,\r\n                    amountToUser,\r\n                    prevLost\r\n                );\r\n            }\r\n        } else {\r\n            // pay for the referer\u0027s referer\r\n            emit LostMoneyForLevelEvent(\r\n                referer,\r\n                _sender,\r\n                _level,\r\n                now,\r\n                amountToUser,\r\n                prevLost\r\n            );\r\n\r\n            payForLevel(\r\n                _level,\r\n                referer,\r\n                _sender,\r\n                _autoPayCtr,\r\n                true\r\n            );\r\n        }\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if (users[_user].referral.length \u003C REFERRER_1_LEVEL_LIMIT) {\r\n            return _user;\r\n        }\r\n\r\n        address[] memory referrals = new address[](363);\r\n        referrals[0] = users[_user].referral[0];\r\n        referrals[1] = users[_user].referral[1];\r\n        referrals[2] = users[_user].referral[2];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for (uint i = 0; i\u003C363; i\u002B\u002B) {\r\n            if (users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT) {\r\n                if (i\u003C120) {\r\n                    referrals[(i\u002B1)*3] = users[referrals[i]].referral[0];\r\n                    referrals[(i\u002B1)*3\u002B1] = users[referrals[i]].referral[1];\r\n                    referrals[(i\u002B1)*3\u002B2] = users[referrals[i]].referral[2];\r\n                }\r\n            } else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(!noFreeReferrer, \u0027No Free Referrer\u0027);\r\n        return freeReferrer;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return users[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return users[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address  addr ) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AbsDAO is Ownable, WalletOnly {\r\n    // events\r\n    event TransferPie(address indexed _from, address indexed _to, uint _value);\r\n    event NewHolder(address indexed _addr, uint _index);\r\n    event HolderChanged(address indexed _from, address indexed _to, uint _index);\r\n    event PaymentReceived(address indexed _from, uint _value);\r\n    event PaymentForHolder(address indexed _addr, uint _index, uint _value);\r\n    event PaymentForHolderLost(address indexed _addr, uint _index, uint _value);\r\n\r\n    struct Holder {\r\n        bool isExist;\r\n        uint id;\r\n        uint value;\r\n        address payable addr;\r\n    }\r\n\r\n    mapping(address =\u003E Holder) public holders;\r\n    mapping(uint=\u003Eaddress payable) holderAddrs;\r\n\r\n    uint holderCount;\r\n    uint _initialPie = 100;\r\n\r\n    using SafeMath for uint;\r\n\r\n    constructor() public {\r\n        // creating root hoder\r\n        holderCount = 1;\r\n        holders[msg.sender] = Holder({\r\n            isExist: true,\r\n            id: 1,\r\n            value: _initialPie,\r\n            addr: msg.sender\r\n        });\r\n\r\n        holderAddrs[1] = msg.sender;\r\n    }\r\n\r\n    function () external payable {\r\n        require(!isContract(msg.sender), \u0027This contract cannot support payments from other contracts\u0027);\r\n\r\n        emit PaymentReceived(msg.sender, msg.value);\r\n\r\n        for (uint i = 1; i \u003C= holderCount; i\u002B\u002B) {\r\n            if (holders[holderAddrs[i]].value \u003E 0) {\r\n                uint payValue = msg.value.div(100).mul(holders[holderAddrs[i]].value);\r\n                holderAddrs[i].transfer(payValue);\r\n                emit PaymentForHolder(holderAddrs[i], i, payValue);\r\n            } else {\r\n                emit PaymentForHolderLost(holderAddrs[i], i, holders[holderAddrs[i]].value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getHolderPieAt(uint i) public view returns(uint) {\r\n        return holders[holderAddrs[i]].value;\r\n    }\r\n\r\n    function getHolder(uint i) public view returns(address payable) {\r\n        return holderAddrs[i];\r\n    }\r\n\r\n    function getHolderCount() public view returns(uint) {\r\n        return holderCount;\r\n    }\r\n\r\n    function transferPie(uint _amount, address payable _to) public {\r\n        require(holders[msg.sender].isExist, \u0027Holder not found\u0027);\r\n        require(_amount \u003E 0 \u0026\u0026 _amount \u003C= holders[msg.sender].value, \u0027Invalid amount\u0027);\r\n\r\n        if (_amount == holders[msg.sender].value) {\r\n            uint id = holders[msg.sender].id;\r\n            delete holders[msg.sender];\r\n\r\n            holders[_to] = Holder({\r\n                isExist: true,\r\n                id: id,\r\n                value: _amount,\r\n                addr: _to\r\n            });\r\n\r\n            holderAddrs[id] = _to;\r\n\r\n            emit HolderChanged(msg.sender, _to, id);\r\n        } else {\r\n            if (holders[_to].isExist) {\r\n                holders[msg.sender].value -= _amount;\r\n                holders[_to].value \u002B= _amount;\r\n            } else if (holderCount \u003C 20) {\r\n                holderCount \u002B= 1;\r\n                holders[msg.sender].value -= _amount;\r\n                holders[_to] = Holder({\r\n                    isExist: true,\r\n                    id: holderCount,\r\n                    value: _amount,\r\n                    addr: _to\r\n                });\r\n\r\n                holderAddrs[holderCount] = _to;\r\n\r\n                emit NewHolder(_to, holderCount);\r\n            } else {\r\n                revert(\u0027Holder limit excised\u0027);\r\n            }\r\n        }\r\n\r\n        emit TransferPie(msg.sender, _to, _amount);\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_count\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMaxAutopayForLevelCount\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022actualLevel\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022findFreeReferrer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_admin\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAdminWallet\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022adminWallet\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022manager\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022viewUserReferral\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCanUpdateLevelPrice\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowUser\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LEVEL_PRICE\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022referrerID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022regUser\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ownerWallet\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_dao_addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setDAOAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022userList\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022currUserID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022users\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isExist\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022referrerID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022fund\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022currentLvl\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_manager\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setManager\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022viewUserLevelExpired\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022battleMode\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_price\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setLevelPrice\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022buyLevel\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowUsers\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_referrer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RegLevelEvent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022BuyLevelEvent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_time\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ProlongateLevelEvent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_referral\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_time\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_price\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_prevLost\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022GetMoneyForLevelEvent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_referral\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_time\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_price\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_prevLost\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022LostMoneyForLevelEvent\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_index\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PaymentForHolder\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_index\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PaymentForHolderLost\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Absolutus","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://18e2dfe8ebf7cefa713c3c410c3ee6e5b2a8151cd8310b4c152a6bbe075d75d3"}]