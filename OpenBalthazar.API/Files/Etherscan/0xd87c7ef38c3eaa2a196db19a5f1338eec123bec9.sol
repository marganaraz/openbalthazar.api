[{"SourceCode":"{\u0022Earnings.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\n\\r\\ncontract Earnings {\\r\\n    using SafeMath for *;\\r\\n\\r\\n    // -------------------- mapping ------------------------ //\\r\\n    mapping(address =\\u003e UserWithdraw) public userWithdraw; // record user withdraw reward information\\r\\n\\r\\n    // -------------------- variate ------------------------ //\\r\\n    uint8 constant internal percent = 100;\\r\\n    uint8 constant internal remain = 20;       // Static and dynamic rewards returns remain at 20 percent\\r\\n\\r\\n    address public resonanceAddress;\\r\\n    address public owner;\\r\\n\\r\\n    // -------------------- struct ------------------------ //\\r\\n    struct UserWithdraw {\\r\\n        uint256 withdrawStraight; // withdraw straight eth amount\\r\\n        uint256 withdrawTeam;  // withdraw team eth amount\\r\\n        uint256 withdrawStatic; // withdraw static eth amount\\r\\n        uint256 withdrawTerminator;//withdraw terminator amount\\r\\n        uint256 withdrawNode;  // withdraw node amount\\r\\n        uint256 lockEth;      // user lock eth\\r\\n        uint256 activateEth;  // record user activate eth\\r\\n    }\\r\\n\\r\\n    constructor()\\r\\n    public{\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    // -------------------- modifier ------------------------ //\\r\\n    modifier onlyOwner(){\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyResonance (){\\r\\n        require(msg.sender == resonanceAddress);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // -------------------- owner api ------------------------ //\\r\\n    function allowResonance(address _addr) public onlyOwner() {\\r\\n        resonanceAddress = _addr;\\r\\n    }\\r\\n\\r\\n    // -------------------- Resonance api ------------------------ //\\r\\n    // calculate actual reinvest amount, include amount \u002B lockEth\\r\\n    function calculateReinvestAmount(\\r\\n        address reinvestAddress,\\r\\n        uint256 amount,\\r\\n        uint256 userAmount,\\r\\n        uint8 requireType)//type: 1 =\\u003e straightEth, 2 =\\u003e teamEth, 3 =\\u003e withdrawStatic, 4 =\\u003e withdrawNode\\r\\n    public\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        if (requireType == 1) {\\r\\n            require(amount.add((userWithdraw[reinvestAddress].withdrawStatic).mul(100).div(80)) \\u003c= userAmount);\\r\\n        } else if (requireType == 2) {\\r\\n            require(amount.add((userWithdraw[reinvestAddress].withdrawStraight).mul(100).div(80)) \\u003c= userAmount.add(amount));\\r\\n        } else if (requireType == 3) {\\r\\n            require(amount.add((userWithdraw[reinvestAddress].withdrawTeam).mul(100).div(80)) \\u003c= userAmount.add(amount));\\r\\n        } else if (requireType == 5) {\\r\\n            require(amount.add((userWithdraw[reinvestAddress].withdrawNode).mul(100).div(80)) \\u003c= userAmount);\\r\\n        }\\r\\n\\r\\n        //      userWithdraw[reinvestAddress].lockEth = userWithdraw[reinvestAddress].lockEth.add(amount.mul(remain).div(100));\\\\\\r\\n        uint256 _active = userWithdraw[reinvestAddress].lockEth - userWithdraw[reinvestAddress].activateEth;\\r\\n        if (amount \\u003e _active) {\\r\\n            userWithdraw[reinvestAddress].activateEth \u002B= _active;\\r\\n            amount = amount.add(_active);\\r\\n        } else {\\r\\n            userWithdraw[reinvestAddress].activateEth = userWithdraw[reinvestAddress].activateEth.add(amount);\\r\\n            amount = amount.mul(2);\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function routeAddLockEth(\\r\\n        address withdrawAddress,\\r\\n        uint256 amount,\\r\\n        uint256 lockProfits,\\r\\n        uint256 userRouteEth,\\r\\n        uint256 routeType)\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        if (routeType == 1) {\\r\\n            addLockEthStatic(withdrawAddress, amount, lockProfits, userRouteEth);\\r\\n        } else if (routeType == 2) {\\r\\n            addLockEthStraight(withdrawAddress, amount, userRouteEth);\\r\\n        } else if (routeType == 3) {\\r\\n            addLockEthTeam(withdrawAddress, amount, userRouteEth);\\r\\n        } else if (routeType == 4) {\\r\\n            addLockEthTerminator(withdrawAddress, amount, userRouteEth);\\r\\n        } else if (routeType == 5) {\\r\\n            addLockEthNode(withdrawAddress, amount, userRouteEth);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLockEthStatic(address withdrawAddress, uint256 amount, uint256 lockProfits, uint256 userStatic)\\r\\n    internal\\r\\n    {\\r\\n        require(amount.add(userWithdraw[withdrawAddress].withdrawStatic.mul(100).div(percent - remain)) \\u003c= userStatic);\\r\\n        userWithdraw[withdrawAddress].lockEth \u002B= lockProfits;\\r\\n        userWithdraw[withdrawAddress].withdrawStatic \u002B= amount.sub(lockProfits);\\r\\n    }\\r\\n\\r\\n    function addLockEthStraight(address withdrawAddress, uint256 amount, uint256 userStraightEth)\\r\\n    internal\\r\\n    {\\r\\n        require(amount.add(userWithdraw[withdrawAddress].withdrawStraight.mul(100).div(percent - remain)) \\u003c= userStraightEth);\\r\\n        userWithdraw[withdrawAddress].lockEth \u002B= amount.mul(remain).div(100);\\r\\n        userWithdraw[withdrawAddress].withdrawStraight \u002B= amount.mul(percent - remain).div(100);\\r\\n    }\\r\\n\\r\\n    function addLockEthTeam(address withdrawAddress, uint256 amount, uint256 userTeamEth)\\r\\n    internal\\r\\n    {\\r\\n        require(amount.add(userWithdraw[withdrawAddress].withdrawTeam.mul(100).div(percent - remain)) \\u003c= userTeamEth);\\r\\n        userWithdraw[withdrawAddress].lockEth \u002B= amount.mul(remain).div(100);\\r\\n        userWithdraw[withdrawAddress].withdrawTeam \u002B= amount.mul(percent - remain).div(100);\\r\\n    }\\r\\n\\r\\n    function addLockEthTerminator(address withdrawAddress, uint256 amount, uint256 withdrawAmount)\\r\\n    internal\\r\\n    {\\r\\n        userWithdraw[withdrawAddress].lockEth \u002B= amount.mul(remain).div(100);\\r\\n        userWithdraw[withdrawAddress].withdrawTerminator \u002B= withdrawAmount;\\r\\n    }\\r\\n\\r\\n    function addLockEthNode(address withdrawAddress, uint256 amount, uint256 userNodeEth)\\r\\n    internal\\r\\n    {\\r\\n        require(amount.add(userWithdraw[withdrawAddress].withdrawNode.mul(100).div(percent - remain)) \\u003c= userNodeEth);\\r\\n        userWithdraw[withdrawAddress].lockEth \u002B= amount.mul(remain).div(100);\\r\\n        userWithdraw[withdrawAddress].withdrawNode \u002B= amount.mul(percent - remain).div(100);\\r\\n    }\\r\\n\\r\\n\\r\\n    function addActivateEth(address userAddress, uint256 amount)\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        uint256 _afterFounds = getAfterFounds(userAddress);\\r\\n        if (amount \\u003e _afterFounds) {\\r\\n            userWithdraw[userAddress].activateEth = userWithdraw[userAddress].lockEth;\\r\\n        }\\r\\n        else {\\r\\n            userWithdraw[userAddress].activateEth \u002B= amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function changeWithdrawTeamZero(address userAddress)\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        userWithdraw[userAddress].withdrawTeam = 0;\\r\\n    }\\r\\n\\r\\n    function getWithdrawStraight(address reinvestAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return userWithdraw[reinvestAddress].withdrawStraight;\\r\\n    }\\r\\n\\r\\n    function getWithdrawStatic(address reinvestAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return userWithdraw[reinvestAddress].withdrawStatic;\\r\\n    }\\r\\n\\r\\n    function getWithdrawTeam(address reinvestAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return userWithdraw[reinvestAddress].withdrawTeam;\\r\\n    }\\r\\n\\r\\n    function getWithdrawNode(address reinvestAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return userWithdraw[reinvestAddress].withdrawNode;\\r\\n    }\\r\\n\\r\\n    function getAfterFounds(address userAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return userWithdraw[userAddress].lockEth - userWithdraw[userAddress].activateEth;\\r\\n    }\\r\\n\\r\\n    function getStaticAfterFounds(address reinvestAddress) public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256, uint256)\\r\\n    {\\r\\n        return (userWithdraw[reinvestAddress].withdrawStatic, userWithdraw[reinvestAddress].lockEth - userWithdraw[reinvestAddress].activateEth);\\r\\n    }\\r\\n\\r\\n    function getStaticAfterFoundsTeam(address userAddress) public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (uint256, uint256, uint256)\\r\\n    {\\r\\n        return (userWithdraw[userAddress].withdrawStatic, userWithdraw[userAddress].lockEth - userWithdraw[userAddress].activateEth, userWithdraw[userAddress].withdrawTeam);\\r\\n    }\\r\\n\\r\\n    function getUserWithdrawInfo(address reinvestAddress) public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (\\r\\n        uint256 withdrawStraight,\\r\\n        uint256 withdrawTeam,\\r\\n        uint256 withdrawStatic,\\r\\n        uint256 withdrawNode\\r\\n    )\\r\\n    {\\r\\n        withdrawStraight = userWithdraw[reinvestAddress].withdrawStraight;\\r\\n        withdrawTeam = userWithdraw[reinvestAddress].withdrawTeam;\\r\\n        withdrawStatic = userWithdraw[reinvestAddress].withdrawStatic;\\r\\n        withdrawNode = userWithdraw[reinvestAddress].withdrawNode;\\r\\n    }\\r\\n\\r\\n}\\r\\n\u0022},\u0022ERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./IERC20.sol\\\u0022;\\nimport \\\u0022./SafeMath.sol\\\u0022;\\n\\n/**\\n * @dev Implementation of the \u0060IERC20\u0060 interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using \u0060_mint\u0060.\\n * For a generic mechanism see \u0060ERC20Mintable\u0060.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an \u0060Approval\u0060 event is emitted on calls to \u0060transferFrom\u0060.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard \u0060decreaseAllowance\u0060 and \u0060increaseAllowance\u0060\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See \u0060IERC20.approve\u0060.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See \u0060IERC20.totalSupply\u0060.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See \u0060IERC20.balanceOf\u0060.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See \u0060IERC20.transfer\u0060.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060recipient\u0060 cannot be the zero address.\\n     * - the caller must have a balance of at least \u0060amount\u0060.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See \u0060IERC20.allowance\u0060.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See \u0060IERC20.approve\u0060.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060spender\u0060 cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See \u0060IERC20.transferFrom\u0060.\\n     *\\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of \u0060ERC20\u0060;\\n     *\\n     * Requirements:\\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\\n     * - \u0060sender\u0060 must have a balance of at least \u0060value\u0060.\\n     * - the caller must have allowance for \u0060sender\u0060\\u0027s tokens of at least\\n     * \u0060amount\u0060.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\\n     *\\n     * This is an alternative to \u0060approve\u0060 that can be used as a mitigation for\\n     * problems described in \u0060IERC20.approve\u0060.\\n     *\\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060spender\u0060 cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\\n     *\\n     * This is an alternative to \u0060approve\u0060 that can be used as a mitigation for\\n     * problems described in \u0060IERC20.approve\u0060.\\n     *\\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060spender\u0060 cannot be the zero address.\\n     * - \u0060spender\u0060 must have allowance for the caller of at least\\n     * \u0060subtractedValue\u0060.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\\n     *\\n     * This is internal function is equivalent to \u0060transfer\u0060, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a \u0060Transfer\u0060 event.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060sender\u0060 cannot be the zero address.\\n     * - \u0060recipient\u0060 cannot be the zero address.\\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\u0022ERC20: transfer from the zero address\\\u0022);\\n        require(recipient != address(0), \\\u0022ERC20: transfer to the zero address\\\u0022);\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\\n     * the total supply.\\n     *\\n     * Emits a \u0060Transfer\u0060 event with \u0060from\u0060 set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - \u0060to\u0060 cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\u0022ERC20: mint to the zero address\\\u0022);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destoys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\\n     * total supply.\\n     *\\n     * Emits a \u0060Transfer\u0060 event with \u0060to\u0060 set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - \u0060account\u0060 cannot be the zero address.\\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\u0022ERC20: burn from the zero address\\\u0022);\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\\n     *\\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an \u0060Approval\u0060 event.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060owner\u0060 cannot be the zero address.\\n     * - \u0060spender\u0060 cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\u0022ERC20: approve from the zero address\\\u0022);\\n        require(spender != address(0), \\\u0022ERC20: approve to the zero address\\\u0022);\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See \u0060_burn\u0060 and \u0060_approve\u0060.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\\n\u0022},\u0022ERC20Burnable.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./ERC20.sol\\\u0022;\\n\\n/**\\n * @dev Extension of \u0060ERC20\u0060 that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\ncontract ERC20Burnable is ERC20 {\\n    /**\\n     * @dev Destoys \u0060amount\u0060 tokens from the caller.\\n     *\\n     * See \u0060ERC20._burn\u0060.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev See \u0060ERC20._burnFrom\u0060.\\n     */\\n    function burnFrom(address account, uint256 amount) public {\\n        _burnFrom(account, amount);\\n    }\\n}\\n\u0022},\u0022ERC20Capped.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./ERC20Mintable.sol\\\u0022;\\n\\n/**\\n * @dev Extension of \u0060ERC20Mintable\u0060 that adds a cap to the supply of tokens.\\n */\\ncontract ERC20Capped is ERC20Mintable {\\n    uint256 private _cap;\\n\\n    /**\\n     * @dev Sets the value of the \u0060cap\u0060. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    constructor (uint256 cap) public {\\n        require(cap \\u003e 0, \\\u0022ERC20Capped: cap is 0\\\u0022);\\n        _cap = cap;\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token\\u0027s total supply.\\n     */\\n    function cap() public view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See \u0060ERC20Mintable.mint\u0060.\\n     *\\n     * Requirements:\\n     *\\n     * - \u0060value\u0060 must not cause the total supply to go over the cap.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(totalSupply().add(value) \\u003c= _cap, \\\u0022ERC20Capped: cap exceeded\\\u0022);\\n        super._mint(account, value);\\n    }\\n}\\n\u0022},\u0022ERC20Detailed.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./IERC20.sol\\\u0022;\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for \u0060name\u0060, \u0060symbol\u0060, and \u0060decimals\u0060. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if \u0060decimals\u0060 equals \u00602\u0060, a balance of \u0060505\u0060 tokens should\\n     * be displayed to a user as \u00605,05\u0060 (\u0060505 / 10 ** 2\u0060).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * \\u003e Note that this information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * \u0060IERC20.balanceOf\u0060 and \u0060IERC20.transfer\u0060.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\u0022},\u0022ERC20Mintable.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./ERC20.sol\\\u0022;\\nimport \\\u0022./MinterRole.sol\\\u0022;\\n\\n/**\\n * @dev Extension of \u0060ERC20\u0060 that adds a set of accounts with the \u0060MinterRole\u0060,\\n * which have permission to mint (create) new tokens as they see fit.\\n *\\n * At construction, the deployer of the contract is the only minter.\\n */\\ncontract ERC20Mintable is ERC20, MinterRole {\\n    /**\\n     * @dev See \u0060ERC20._mint\u0060.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the \u0060MinterRole\u0060.\\n     */\\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\u0022},\u0022IERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves \u0060amount\u0060 tokens from the caller\\u0027s account to \u0060recipient\u0060.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a \u0060Transfer\u0060 event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\\n     * zero by default.\\n     *\\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an \u0060Approval\u0060 event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a \u0060Transfer\u0060 event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\\n     * another (\u0060to\u0060).\\n     *\\n     * Note that \u0060value\u0060 may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\u0022},\u0022KOCToken.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\nimport \\\u0022./ERC20.sol\\\u0022;\\r\\nimport \\\u0022./ERC20Detailed.sol\\\u0022;\\r\\nimport \\\u0022./ERC20Capped.sol\\\u0022;\\r\\nimport \\\u0022./ERC20Burnable.sol\\\u0022;\\r\\n\\r\\n// \u6D4B\u8BD5\u7528\u7684Token\\r\\ncontract KOCToken is ERC20, ERC20Detailed, ERC20Burnable {\\r\\n\\r\\n    event CreateTokenSuccess(address owner, uint256 balance);\\r\\n\\r\\n    uint256 amount = 2100000000;\\r\\n    constructor(\\r\\n\\r\\n    )\\r\\n    ERC20Burnable()\\r\\n    ERC20Detailed(\\\u0022KOC\\\u0022, \\\u0022KOC\\\u0022, 18)\\r\\n    ERC20()\\r\\n    public\\r\\n    {\\r\\n        _mint(msg.sender, amount * (10 ** 18));\\r\\n        emit CreateTokenSuccess(msg.sender, balanceOf(msg.sender));\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022MinterRole.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\nimport \\\u0022./Roles.sol\\\u0022;\\n\\ncontract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\u0022MinterRole: caller does not have the Minter role\\\u0022);\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\u0022},\u0022Recommend.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\ncontract Recommend {\\r\\n    // -------------------- mapping ------------------------ //\\r\\n    mapping(address =\\u003e RecommendRecord) internal recommendRecord;  // record straight reward information\\r\\n\\r\\n\\r\\n    // -------------------- struct ------------------------ //\\r\\n    struct RecommendRecord {\\r\\n        uint256[] straightTime;  // this record start time, 3 days timeout\\r\\n        address[] refeAddress; // referral address\\r\\n        uint256[] ethAmount; // this record buy eth amount\\r\\n        bool[] supported; // false means unsupported\\r\\n    }\\r\\n\\r\\n    // -------------------- variate ------------------------ //\\r\\n    address public resonanceAddress;\\r\\n    address public owner;\\r\\n\\r\\n    constructor()\\r\\n    public{\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    // -------------------- modifier ------------------------ //\\r\\n    modifier onlyOwner(){\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyResonance (){\\r\\n        require(msg.sender == resonanceAddress);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // -------------------- owner api ------------------------ //\\r\\n    function allowResonance(address _addr) public onlyOwner() {\\r\\n        resonanceAddress = _addr;\\r\\n    }\\r\\n\\r\\n    // -------------------- Resonance api ----------------//\\r\\n    function getRecommendByIndex(uint256 index, address userAddress)\\r\\n    public\\r\\n    view\\r\\n//    onlyResonance() TODO\\r\\n    returns (\\r\\n        uint256 straightTime,\\r\\n        address refeAddress,\\r\\n        uint256 ethAmount,\\r\\n        bool supported\\r\\n    )\\r\\n    {\\r\\n        straightTime = recommendRecord[userAddress].straightTime[index];\\r\\n        refeAddress = recommendRecord[userAddress].refeAddress[index];\\r\\n        ethAmount = recommendRecord[userAddress].ethAmount[index];\\r\\n        supported = recommendRecord[userAddress].supported[index];\\r\\n    }\\r\\n\\r\\n    function pushRecommend(\\r\\n        address userAddress,\\r\\n        address refeAddress,\\r\\n        uint256 ethAmount\\r\\n    )\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        RecommendRecord storage _recommendRecord = recommendRecord[userAddress];\\r\\n        _recommendRecord.straightTime.push(block.timestamp);\\r\\n        _recommendRecord.refeAddress.push(refeAddress);\\r\\n        _recommendRecord.ethAmount.push(ethAmount);\\r\\n        _recommendRecord.supported.push(false);\\r\\n    }\\r\\n\\r\\n    function setSupported(uint256 index, address userAddress, bool supported)\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        recommendRecord[userAddress].supported[index] = supported;\\r\\n    }\\r\\n\\r\\n    // -------------------- user api ------------------------ //\\r\\n    // get current address\\u0027s recommend record\\r\\n    function getRecommendRecord()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        uint256[] memory straightTime,\\r\\n        address[] memory refeAddress,\\r\\n        uint256[] memory ethAmount,\\r\\n        bool[]    memory supported\\r\\n    )\\r\\n    {\\r\\n        RecommendRecord memory records = recommendRecord[msg.sender];\\r\\n        straightTime = records.straightTime;\\r\\n        refeAddress = records.refeAddress;\\r\\n        ethAmount = records.ethAmount;\\r\\n        supported = records.supported;\\r\\n    }\\r\\n\\r\\n}\\r\\n\u0022},\u0022Resonance.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\nimport \\\u0022./Earnings.sol\\\u0022;\\r\\nimport \\\u0022./TeamRewards.sol\\\u0022;\\r\\nimport \\\u0022./Terminator.sol\\\u0022;\\r\\nimport \\\u0022./Recommend.sol\\\u0022;\\r\\n\\r\\nimport \\\u0022./ResonanceF.sol\\\u0022;\\r\\n\\r\\ncontract Resonance is ResonanceF {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256     public totalSupply = 0;\\r\\n    uint256     constant internal bonusPrice = 0.0000001 ether; // init price\\r\\n    uint256     constant internal priceIncremental = 0.00000001 ether; // increase price\\r\\n    uint256     constant internal magnitude = 2 ** 64;\\r\\n    uint256     public perBonusDivide = 0; //per Profit divide\\r\\n    uint256     public  systemRetain = 0;\\r\\n    uint256     public terminatorPoolAmount; //terminator award Pool Amount\\r\\n    uint256     public activateSystem = 20;\\r\\n    uint256     public activateGlobal = 20;\\r\\n\\r\\n    mapping(address =\\u003e User) public userInfo; // user define all user\\u0027s information\\r\\n    mapping(address =\\u003e address[]) public straightInviteAddress; // user  effective straight invite address, sort reward\\r\\n    mapping(address =\\u003e int256) internal payoutsTo; // record\\r\\n    mapping(address =\\u003e uint256[11]) public userSubordinateCount;\\r\\n    mapping(address =\\u003e uint256) public whitelistPerformance;\\r\\n    mapping(address =\\u003e UserReinvest) public userReinvest;\\r\\n    mapping(address =\\u003e uint256) public lastStraightLength;\\r\\n\\r\\n    uint8   constant internal remain = 20;       // Static and dynamic rewards returns remain at 20 percent\\r\\n    uint32  constant internal ratio = 1000;      // eth to erc20 token ratio\\r\\n    uint32  constant internal blockNumber = 40000; // straight sort reward block number\\r\\n    uint256 public   currentBlockNumber;\\r\\n    uint256 public   straightSortRewards = 0;\\r\\n    uint256  public initAddressAmount = 0;   // The first 100 addresses and enough to 1 eth, 100 -500 enough to 5 eth, 500 addresses later cancel limit\\r\\n    uint256 public totalEthAmount = 0; // all user total buy eth amount\\r\\n    uint8 constant public percent = 100;\\r\\n\\r\\n    address  public eggAddress = address(0x12d4fEcccc3cbD5F7A2C9b88D709317e0E616691);   // total eth 1 percent to  egg address\\r\\n    address  public systemAddress = address(0x6074510054e37D921882B05Ab40537Ce3887F3AD);\\r\\n    address  public nodeAddressReward = address(0xB351d5030603E8e89e1925f6d6F50CDa4D6754A6);\\r\\n    address  public globalAddressReward = address(0x49eec1928b457d1f26a2466c8bd9eC1318EcB68f);\\r\\n    address [10] public straightSort; // straight reward\\r\\n\\r\\n    Earnings internal earningsInstance;\\r\\n    TeamRewards internal teamRewardInstance;\\r\\n    Terminator internal terminatorInstance;\\r\\n    Recommend internal recommendInstance;\\r\\n\\r\\n    struct User {\\r\\n        address userAddress;  // user address\\r\\n        uint256 ethAmount;    // user buy eth amount\\r\\n        uint256 profitAmount; // user profit amount\\r\\n        uint256 tokenAmount;  // user get token amount\\r\\n        uint256 tokenProfit;  // profit by profitAmount\\r\\n        uint256 straightEth;  // user straight eth\\r\\n        uint256 lockStraight;\\r\\n        uint256 teamEth;      // team eth reward\\r\\n        bool staticTimeout;      // static timeout, 3 days\\r\\n        uint256 staticTime;     // record static out time\\r\\n        uint8 level;        // user team level\\r\\n        address straightAddress;\\r\\n        uint256 refeTopAmount; // subordinate address topmost eth amount\\r\\n        address refeTopAddress; // subordinate address topmost eth address\\r\\n    }\\r\\n\\r\\n    struct UserReinvest {\\r\\n//        uint256 nodeReinvest;\\r\\n        uint256 staticReinvest;\\r\\n        bool    isPush;\\r\\n    }\\r\\n\\r\\n    uint8[7] internal rewardRatio;  // [0] means market support rewards         10%\\r\\n    // [1] means static rewards                 30%\\r\\n    // [2] means straight rewards               30%\\r\\n    // [3] means team rewards                   29%\\r\\n    // [4] means terminator rewards             5%\\r\\n    // [5] means straight sort rewards          5%\\r\\n    // [6] means egg rewards                    1%\\r\\n\\r\\n    uint8[11] internal teamRatio; // team reward ratio\\r\\n\\r\\n    modifier mustAdmin (address adminAddress){\\r\\n        require(adminAddress != address(0));\\r\\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier mustReferralAddress (address referralAddress) {\\r\\n        require(msg.sender != admin[0] || msg.sender != admin[1] || msg.sender != admin[2] || msg.sender != admin[3] || msg.sender != admin[4]);\\r\\n        if (teamRewardInstance.isWhitelistAddress(msg.sender)) {\\r\\n            require(referralAddress == admin[0] || referralAddress == admin[1] || referralAddress == admin[2] || referralAddress == admin[3] || referralAddress == admin[4]);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier limitInvestmentCondition(uint256 ethAmount){\\r\\n         if (initAddressAmount \\u003c= 50) {\\r\\n            require(ethAmount \\u003c= 5 ether);\\r\\n            _;\\r\\n        } else {\\r\\n            _;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier limitAddressReinvest() {\\r\\n        if (initAddressAmount \\u003c= 50 \\u0026\\u0026 userInfo[msg.sender].ethAmount \\u003e 0) {\\r\\n            require(msg.value \\u003c= userInfo[msg.sender].ethAmount.mul(3));\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n    // -------------------- modifier ------------------------ //\\r\\n\\r\\n    // --------------------- event -------------------------- //\\r\\n    event WithdrawStaticProfits(address indexed user, uint256 ethAmount);\\r\\n    event Buy(address indexed user, uint256 ethAmount, uint256 buyTime);\\r\\n    event Withdraw(address indexed user, uint256 ethAmount, uint8 indexed value, uint256 buyTime);\\r\\n    event Reinvest(address indexed user, uint256 indexed ethAmount, uint8 indexed value, uint256 buyTime);\\r\\n    event SupportSubordinateAddress(uint256 indexed index, address indexed subordinate, address indexed refeAddress, bool supported);\\r\\n    // --------------------- event -------------------------- //\\r\\n\\r\\n    constructor(\\r\\n        address _erc20Address,\\r\\n        address _earningsAddress,\\r\\n        address _teamRewardsAddress,\\r\\n        address _terminatorAddress,\\r\\n        address _recommendAddress\\r\\n    )\\r\\n    public\\r\\n    {\\r\\n        earningsInstance = Earnings(_earningsAddress);\\r\\n        teamRewardInstance = TeamRewards(_teamRewardsAddress);\\r\\n        terminatorInstance = Terminator(_terminatorAddress);\\r\\n        kocInstance = KOCToken(_erc20Address);\\r\\n        recommendInstance = Recommend(_recommendAddress);\\r\\n        rewardRatio = [10, 30, 30, 29, 5, 5, 1];\\r\\n        teamRatio = [6, 5, 4, 3, 3, 2, 2, 1, 1, 1, 1];\\r\\n        currentBlockNumber = block.number;\\r\\n    }\\r\\n\\r\\n    // -------------------- user api ----------------//\\r\\n    function buy(address referralAddress)\\r\\n    public\\r\\n    mustReferralAddress(referralAddress)\\r\\n    limitInvestmentCondition(msg.value)\\r\\n    payable\\r\\n    {\\r\\n        require(!teamRewardInstance.getWhitelistTime());\\r\\n        uint256 ethAmount = msg.value;\\r\\n        address userAddress = msg.sender;\\r\\n        User storage _user = userInfo[userAddress];\\r\\n\\r\\n        _user.userAddress = userAddress;\\r\\n\\r\\n        if (_user.ethAmount == 0 \\u0026\\u0026 !teamRewardInstance.isWhitelistAddress(userAddress)) {\\r\\n            teamRewardInstance.referralPeople(userAddress, referralAddress);\\r\\n            _user.straightAddress = referralAddress;\\r\\n        } else {\\r\\n            referralAddress == teamRewardInstance.getUserreferralAddress(userAddress);\\r\\n        }\\r\\n\\r\\n        address straightAddress;\\r\\n        address whiteAddress;\\r\\n        address adminAddress;\\r\\n        bool whitelist;\\r\\n        (straightAddress, whiteAddress, adminAddress, whitelist) = teamRewardInstance.getUserSystemInfo(userAddress);\\r\\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\\r\\n\\r\\n        if (userInfo[referralAddress].userAddress == address(0)) {\\r\\n            userInfo[referralAddress].userAddress = referralAddress;\\r\\n        }\\r\\n\\r\\n        if (userInfo[userAddress].straightAddress == address(0)) {\\r\\n            userInfo[userAddress].straightAddress = straightAddress;\\r\\n        }\\r\\n\\r\\n        // uint256 _withdrawStatic;\\r\\n        uint256 _lockEth;\\r\\n        uint256 _withdrawTeam;\\r\\n        (, _lockEth, _withdrawTeam) = earningsInstance.getStaticAfterFoundsTeam(userAddress);\\r\\n\\r\\n        if (ethAmount \\u003e= _lockEth) {\\r\\n            ethAmount = ethAmount.add(_lockEth);\\r\\n            if (userInfo[userAddress].staticTimeout \\u0026\\u0026 userInfo[userAddress].staticTime \u002B 3 days \\u003c block.timestamp) {\\r\\n                address(uint160(systemAddress)).transfer(userInfo[userAddress].teamEth.sub(_withdrawTeam.mul(100).div(80)));\\r\\n                userInfo[userAddress].teamEth = 0;\\r\\n                earningsInstance.changeWithdrawTeamZero(userAddress);\\r\\n            }\\r\\n            userInfo[userAddress].staticTimeout = false;\\r\\n            userInfo[userAddress].staticTime = block.timestamp;\\r\\n        } else {\\r\\n            _lockEth = ethAmount;\\r\\n            ethAmount = ethAmount.mul(2);\\r\\n        }\\r\\n\\r\\n        earningsInstance.addActivateEth(userAddress, _lockEth);\\r\\n        if (initAddressAmount \\u003c= 50 \\u0026\\u0026 userInfo[userAddress].ethAmount \\u003e 0) {\\r\\n            require(userInfo[userAddress].profitAmount == 0);\\r\\n        }\\r\\n\\r\\n        if (ethAmount \\u003e= 1 ether \\u0026\\u0026 _user.ethAmount == 0) {// when initAddressAmount \\u003c= 500, address can only invest once before out of static\\r\\n            initAddressAmount\u002B\u002B;\\r\\n        }\\r\\n\\r\\n        calculateBuy(_user, ethAmount, straightAddress, whiteAddress, adminAddress, userAddress);\\r\\n\\r\\n        straightReferralReward(_user, ethAmount);\\r\\n        // calculate straight referral reward\\r\\n\\r\\n        uint256 topProfits = whetherTheCap();\\r\\n        require(earningsInstance.getWithdrawStatic(msg.sender).mul(100).div(80) \\u003c= topProfits);\\r\\n\\r\\n        emit Buy(userAddress, ethAmount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // contains some methods for buy or reinvest\\r\\n    function calculateBuy(\\r\\n        User storage user,\\r\\n        uint256 ethAmount,\\r\\n        address straightAddress,\\r\\n        address whiteAddress,\\r\\n        address adminAddress,\\r\\n        address users\\r\\n    )\\r\\n    internal\\r\\n    {\\r\\n        require(ethAmount \\u003e 0);\\r\\n        user.ethAmount = teamRewardInstance.isWhitelistAddress(user.userAddress) ? (ethAmount.mul(110).div(100)).add(user.ethAmount) : ethAmount.add(user.ethAmount);\\r\\n\\r\\n        if (user.ethAmount \\u003e user.refeTopAmount.mul(60).div(100)) {\\r\\n            user.straightEth \u002B= user.lockStraight;\\r\\n            user.lockStraight = 0;\\r\\n        }\\r\\n        if (user.ethAmount \\u003e= 1 ether \\u0026\\u0026 !userReinvest[user.userAddress].isPush \\u0026\\u0026 !teamRewardInstance.isWhitelistAddress(user.userAddress)) {\\r\\n                straightInviteAddress[straightAddress].push(user.userAddress);\\r\\n                userReinvest[user.userAddress].isPush = true;\\r\\n                // record straight address\\r\\n            if (straightInviteAddress[straightAddress].length.sub(lastStraightLength[straightAddress]) \\u003e straightInviteAddress[straightSort[9]].length.sub(lastStraightLength[straightSort[9]])) {\\r\\n                    bool has = false;\\r\\n                    //search this address\\r\\n                    for (uint i = 0; i \\u003c 10; i\u002B\u002B) {\\r\\n                        if (straightSort[i] == straightAddress) {\\r\\n                            has = true;\\r\\n                        }\\r\\n                    }\\r\\n                    if (!has) {\\r\\n                        //search this address if not in this array,go sort after cover last\\r\\n                        straightSort[9] = straightAddress;\\r\\n                    }\\r\\n                    // sort referral address\\r\\n                    quickSort(straightSort, int(0), int(9));\\r\\n                    // straightSortAddress(straightAddress);\\r\\n                }\\r\\n//            }\\r\\n\\r\\n        }\\r\\n\\r\\n        address(uint160(eggAddress)).transfer(ethAmount.mul(rewardRatio[6]).div(100));\\r\\n        // transfer to eggAddress 1% eth\\r\\n\\r\\n        straightSortRewards \u002B= ethAmount.mul(rewardRatio[5]).div(100);\\r\\n        // straight sort rewards, 5% eth\\r\\n\\r\\n        teamReferralReward(ethAmount, straightAddress);\\r\\n        // issue team reward\\r\\n\\r\\n        terminatorPoolAmount \u002B= ethAmount.mul(rewardRatio[4]).div(100);\\r\\n        // issue terminator reward\\r\\n\\r\\n        calculateToken(user, ethAmount);\\r\\n        // calculate and transfer KOC token\\r\\n\\r\\n        calculateProfit(user, ethAmount, users);\\r\\n        // calculate user earn profit\\r\\n\\r\\n        updateTeamLevel(straightAddress);\\r\\n        // update team level\\r\\n\\r\\n        totalEthAmount \u002B= ethAmount;\\r\\n\\r\\n        whitelistPerformance[whiteAddress] \u002B= ethAmount;\\r\\n        whitelistPerformance[adminAddress] \u002B= ethAmount;\\r\\n\\r\\n        addTerminator(user.userAddress);\\r\\n    }\\r\\n\\r\\n    // contains five kinds of reinvest, 1 means reinvest static rewards, 2 means recommend rewards\\r\\n    //                                  3 means team rewards,  4 means terminators rewards, 5 means node rewards\\r\\n    function reinvest(uint256 amount, uint8 value)\\r\\n    public\\r\\n    payable\\r\\n    {\\r\\n        address reinvestAddress = msg.sender;\\r\\n\\r\\n        address straightAddress;\\r\\n        address whiteAddress;\\r\\n        address adminAddress;\\r\\n        (straightAddress, whiteAddress, adminAddress,) = teamRewardInstance.getUserSystemInfo(msg.sender);\\r\\n\\r\\n        require(value == 1 || value == 2 || value == 3 || value == 4, \\\u0022resonance 303\\\u0022);\\r\\n\\r\\n        uint256 earningsProfits = 0;\\r\\n\\r\\n        if (value == 1) {\\r\\n            earningsProfits = whetherTheCap();\\r\\n            uint256 _withdrawStatic;\\r\\n            uint256 _afterFounds;\\r\\n            uint256 _withdrawTeam;\\r\\n            (_withdrawStatic, _afterFounds, _withdrawTeam) = earningsInstance.getStaticAfterFoundsTeam(reinvestAddress);\\r\\n\\r\\n            _withdrawStatic = _withdrawStatic.mul(100).div(80);\\r\\n            require(_withdrawStatic.add(userReinvest[reinvestAddress].staticReinvest).add(amount) \\u003c= earningsProfits);\\r\\n\\r\\n            if (amount \\u003e= _afterFounds) {\\r\\n                if (userInfo[reinvestAddress].staticTimeout \\u0026\\u0026 userInfo[reinvestAddress].staticTime \u002B 3 days \\u003c block.timestamp) {\\r\\n                    address(uint160(systemAddress)).transfer(userInfo[reinvestAddress].teamEth.sub(_withdrawTeam.mul(100).div(80)));\\r\\n                    userInfo[reinvestAddress].teamEth = 0;\\r\\n                    earningsInstance.changeWithdrawTeamZero(reinvestAddress);\\r\\n                }\\r\\n                userInfo[reinvestAddress].staticTimeout = false;\\r\\n                userInfo[reinvestAddress].staticTime = block.timestamp;\\r\\n            }\\r\\n            userReinvest[reinvestAddress].staticReinvest \u002B= amount;\\r\\n        } else if (value == 2) {\\r\\n            //\u590D\u6295\u76F4\u63A8\\r\\n            require(userInfo[reinvestAddress].straightEth \\u003e= amount);\\r\\n            userInfo[reinvestAddress].straightEth = userInfo[reinvestAddress].straightEth.sub(amount);\\r\\n\\r\\n            earningsProfits = userInfo[reinvestAddress].straightEth;\\r\\n        } else if (value == 3) {\\r\\n            require(userInfo[reinvestAddress].teamEth \\u003e= amount);\\r\\n            userInfo[reinvestAddress].teamEth = userInfo[reinvestAddress].teamEth.sub(amount);\\r\\n\\r\\n            earningsProfits = userInfo[reinvestAddress].teamEth;\\r\\n        } else if (value == 4) {\\r\\n            terminatorInstance.reInvestTerminatorReward(reinvestAddress, amount);\\r\\n        }\\r\\n\\r\\n        amount = earningsInstance.calculateReinvestAmount(msg.sender, amount, earningsProfits, value);\\r\\n\\r\\n        calculateBuy(userInfo[reinvestAddress], amount, straightAddress, whiteAddress, adminAddress, reinvestAddress);\\r\\n\\r\\n        straightReferralReward(userInfo[reinvestAddress], amount);\\r\\n\\r\\n        emit Reinvest(reinvestAddress, amount, value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // contains five kinds of withdraw, 1 means withdraw static rewards, 2 means recommend rewards\\r\\n    //                                  3 means team rewards,  4 means terminators rewards, 5 means node rewards\\r\\n    function withdraw(uint256 amount, uint8 value)\\r\\n    public\\r\\n    {\\r\\n        address withdrawAddress = msg.sender;\\r\\n        require(value == 1 || value == 2 || value == 3 || value == 4);\\r\\n\\r\\n        uint256 _lockProfits = 0;\\r\\n        uint256 _userRouteEth = 0;\\r\\n        uint256 transValue = amount.mul(80).div(100);\\r\\n\\r\\n        if (value == 1) {\\r\\n            _userRouteEth = whetherTheCap();\\r\\n            _lockProfits = SafeMath.mul(amount, remain).div(100);\\r\\n        } else if (value == 2) {\\r\\n            _userRouteEth = userInfo[withdrawAddress].straightEth;\\r\\n        } else if (value == 3) {\\r\\n            if (userInfo[withdrawAddress].staticTimeout) {\\r\\n                require(userInfo[withdrawAddress].staticTime \u002B 3 days \\u003e= block.timestamp);\\r\\n            }\\r\\n            _userRouteEth = userInfo[withdrawAddress].teamEth;\\r\\n        } else if (value == 4) {\\r\\n            _userRouteEth = amount.mul(80).div(100);\\r\\n            terminatorInstance.modifyTerminatorReward(withdrawAddress, _userRouteEth);\\r\\n        }\\r\\n\\r\\n        earningsInstance.routeAddLockEth(withdrawAddress, amount, _lockProfits, _userRouteEth, value);\\r\\n\\r\\n        address(uint160(withdrawAddress)).transfer(transValue);\\r\\n\\r\\n        emit Withdraw(withdrawAddress, amount, value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // referral address support subordinate, 10%\\r\\n    function supportSubordinateAddress(uint256 index, address subordinate)\\r\\n    public\\r\\n    payable\\r\\n    {\\r\\n        User storage _user = userInfo[msg.sender];\\r\\n\\r\\n        require(_user.ethAmount.sub(_user.tokenProfit.mul(100).div(120)) \\u003e= _user.refeTopAmount.mul(60).div(100));\\r\\n\\r\\n        uint256 straightTime;\\r\\n        address refeAddress;\\r\\n        uint256 ethAmount;\\r\\n        bool supported;\\r\\n        (straightTime, refeAddress, ethAmount, supported) = recommendInstance.getRecommendByIndex(index, _user.userAddress);\\r\\n        require(!supported);\\r\\n\\r\\n        require(straightTime.add(3 days) \\u003e= block.timestamp \\u0026\\u0026 refeAddress == subordinate \\u0026\\u0026 msg.value \\u003e= ethAmount.div(10));\\r\\n\\r\\n        if (_user.ethAmount.add(msg.value) \\u003e= _user.refeTopAmount.mul(60).div(100)) {\\r\\n            _user.straightEth \u002B= ethAmount.mul(rewardRatio[2]).div(100);\\r\\n        } else {\\r\\n            _user.lockStraight \u002B= ethAmount.mul(rewardRatio[2]).div(100);\\r\\n        }\\r\\n\\r\\n        address straightAddress;\\r\\n        address whiteAddress;\\r\\n        address adminAddress;\\r\\n        (straightAddress, whiteAddress, adminAddress,) = teamRewardInstance.getUserSystemInfo(subordinate);\\r\\n        calculateBuy(userInfo[subordinate], msg.value, straightAddress, whiteAddress, adminAddress, subordinate);\\r\\n\\r\\n        recommendInstance.setSupported(index, _user.userAddress, true);\\r\\n\\r\\n        emit SupportSubordinateAddress(index, subordinate, refeAddress, supported);\\r\\n    }\\r\\n\\r\\n    // -------------------- internal function ----------------//\\r\\n    // calculate team reward and issue reward\\r\\n    //teamRatio = [6, 5, 4, 3, 3, 2, 2, 1, 1, 1, 1];\\r\\n    function teamReferralReward(uint256 ethAmount, address referralStraightAddress)\\r\\n    internal\\r\\n    {\\r\\n        if (teamRewardInstance.isWhitelistAddress(msg.sender)) {\\r\\n            uint256 _systemRetain = ethAmount.mul(rewardRatio[3]).div(100);\\r\\n            uint256 _nodeReward = _systemRetain.mul(activateSystem).div(100);\\r\\n            systemRetain \u002B= _nodeReward;\\r\\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\\r\\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\\r\\n            address(uint160(systemAddress)).transfer(_systemRetain.mul(100 - activateSystem).div(100));\\r\\n        } else {\\r\\n            uint256 _refeReward = ethAmount.mul(rewardRatio[3]).div(100);\\r\\n\\r\\n            //system residue eth\\r\\n            uint256 residueAmount = _refeReward;\\r\\n\\r\\n            //user straight address\\r\\n            User memory currentUser = userInfo[referralStraightAddress];\\r\\n\\r\\n            //issue team reward\\r\\n            for (uint8 i = 2; i \\u003c= 12; i\u002B\u002B) {//i start at 2, end at 12\\r\\n                //get straight user\\r\\n                address straightAddress = currentUser.straightAddress;\\r\\n\\r\\n                User storage currentUserStraight = userInfo[straightAddress];\\r\\n                //if straight user meet requirements\\r\\n                if (currentUserStraight.level \\u003e= i) {\\r\\n                    uint256 currentReward = _refeReward.mul(teamRatio[i - 2]).div(29);\\r\\n                    currentUserStraight.teamEth = currentUserStraight.teamEth.add(currentReward);\\r\\n                    //sub reward amount\\r\\n                    residueAmount = residueAmount.sub(currentReward);\\r\\n                }\\r\\n\\r\\n                currentUser = userInfo[straightAddress];\\r\\n            }\\r\\n\\r\\n            uint256 _nodeReward = residueAmount.mul(activateSystem).div(100);\\r\\n            systemRetain = systemRetain.add(_nodeReward);\\r\\n            address(uint160(systemAddress)).transfer(residueAmount.mul(100 - activateSystem).div(100));\\r\\n\\r\\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\\r\\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateTeamLevel(address refferAddress)\\r\\n    internal\\r\\n    {\\r\\n        User memory currentUserStraight = userInfo[refferAddress];\\r\\n\\r\\n        uint8 levelUpCount = 0;\\r\\n\\r\\n        uint256 currentInviteCount = straightInviteAddress[refferAddress].length;\\r\\n        if (currentInviteCount \\u003e= 2) {\\r\\n            levelUpCount = 2;\\r\\n        }\\r\\n\\r\\n        if (currentInviteCount \\u003e 12) {\\r\\n            currentInviteCount = 12;\\r\\n        }\\r\\n\\r\\n        uint256 lackCount = 0;\\r\\n        for (uint8 j = 2; j \\u003c currentInviteCount; j\u002B\u002B) {\\r\\n            if (userSubordinateCount[refferAddress][j - 1] \\u003e= 1 \u002B lackCount) {\\r\\n                levelUpCount = j \u002B 1;\\r\\n                lackCount = 0;\\r\\n            } else {\\r\\n                lackCount\u002B\u002B;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (levelUpCount \\u003e currentUserStraight.level) {\\r\\n            uint8 oldLevel = userInfo[refferAddress].level;\\r\\n            userInfo[refferAddress].level = levelUpCount;\\r\\n\\r\\n            if (currentUserStraight.straightAddress != address(0)) {\\r\\n                if (oldLevel \\u003e 0) {\\r\\n                    if (userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] \\u003e 0) {\\r\\n                        userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] = userSubordinateCount[currentUserStraight.straightAddress][oldLevel - 1] - 1;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                userSubordinateCount[currentUserStraight.straightAddress][levelUpCount - 1] = userSubordinateCount[currentUserStraight.straightAddress][levelUpCount - 1] \u002B 1;\\r\\n                updateTeamLevel(currentUserStraight.straightAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // calculate bonus profit\\r\\n    function calculateProfit(User storage user, uint256 ethAmount, address users)\\r\\n    internal\\r\\n    {\\r\\n        if (teamRewardInstance.isWhitelistAddress(user.userAddress)) {\\r\\n            ethAmount = ethAmount.mul(110).div(100);\\r\\n        }\\r\\n\\r\\n        uint256 userBonus = ethToBonus(ethAmount);\\r\\n        require(userBonus \\u003e= 0 \\u0026\\u0026 SafeMath.add(userBonus, totalSupply) \\u003e= totalSupply);\\r\\n        totalSupply \u002B= userBonus;\\r\\n        uint256 tokenDivided = SafeMath.mul(ethAmount, rewardRatio[1]).div(100);\\r\\n        getPerBonusDivide(tokenDivided, userBonus, users);\\r\\n        user.profitAmount \u002B= userBonus;\\r\\n    }\\r\\n\\r\\n    // get user bonus information for calculate static rewards\\r\\n    function getPerBonusDivide(uint256 tokenDivided, uint256 userBonus, address users)\\r\\n    public\\r\\n    {\\r\\n        uint256 fee = tokenDivided * magnitude;\\r\\n        perBonusDivide \u002B= SafeMath.div(SafeMath.mul(tokenDivided, magnitude), totalSupply);\\r\\n        //calculate every bonus earnings eth\\r\\n        fee = fee - (fee - (userBonus * (tokenDivided * magnitude / (totalSupply))));\\r\\n\\r\\n        int256 updatedPayouts = (int256) ((perBonusDivide * userBonus) - fee);\\r\\n\\r\\n        payoutsTo[users] \u002B= updatedPayouts;\\r\\n    }\\r\\n\\r\\n    // calculate and transfer KOC token\\r\\n    function calculateToken(User storage user, uint256 ethAmount)\\r\\n    internal\\r\\n    {\\r\\n        kocInstance.transfer(user.userAddress, ethAmount.mul(ratio));\\r\\n        user.tokenAmount \u002B= ethAmount.mul(ratio);\\r\\n    }\\r\\n\\r\\n    // calculate straight reward and record referral address recommendRecord\\r\\n    function straightReferralReward(User memory user, uint256 ethAmount)\\r\\n    internal\\r\\n    {\\r\\n        address _referralAddresses = user.straightAddress;\\r\\n        userInfo[_referralAddresses].refeTopAmount = (userInfo[_referralAddresses].refeTopAmount \\u003e user.ethAmount) ? userInfo[_referralAddresses].refeTopAmount : user.ethAmount;\\r\\n        userInfo[_referralAddresses].refeTopAddress = (userInfo[_referralAddresses].refeTopAmount \\u003e user.ethAmount) ? userInfo[_referralAddresses].refeTopAddress : user.userAddress;\\r\\n\\r\\n        recommendInstance.pushRecommend(_referralAddresses, user.userAddress, ethAmount);\\r\\n\\r\\n        if (teamRewardInstance.isWhitelistAddress(user.userAddress)) {\\r\\n            uint256 _systemRetain = ethAmount.mul(rewardRatio[2]).div(100);\\r\\n\\r\\n            uint256 _nodeReward = _systemRetain.mul(activateSystem).div(100);\\r\\n            systemRetain \u002B= _nodeReward;\\r\\n            address(uint160(systemAddress)).transfer(_systemRetain.mul(100 - activateSystem).div(100));\\r\\n\\r\\n            address(uint160(globalAddressReward)).transfer(_nodeReward.mul(activateGlobal).div(100));\\r\\n            address(uint160(nodeAddressReward)).transfer(_nodeReward.mul(100 - activateGlobal).div(100));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // sort straight address, 10\\r\\n    function straightSortAddress(address referralAddress)\\r\\n    internal\\r\\n    {\\r\\n        for (uint8 i = 0; i \\u003c 10; i\u002B\u002B) {\\r\\n            if (straightInviteAddress[straightSort[i]].length.sub(lastStraightLength[straightSort[i]]) \\u003c straightInviteAddress[referralAddress].length.sub(lastStraightLength[referralAddress])) {\\r\\n                address  [] memory temp;\\r\\n                for (uint j = i; j \\u003c 10; j\u002B\u002B) {\\r\\n                    temp[j] = straightSort[j];\\r\\n                }\\r\\n                straightSort[i] = referralAddress;\\r\\n                for (uint k = i; k \\u003c 9; k\u002B\u002B) {\\r\\n                    straightSort[k \u002B 1] = temp[k];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //sort straight address, 10\\r\\n    function quickSort(address  [10] storage arr, int left, int right) internal {\\r\\n        int i = left;\\r\\n        int j = right;\\r\\n        if (i == j) return;\\r\\n        uint pivot = straightInviteAddress[arr[uint(left \u002B (right - left) / 2)]].length.sub(lastStraightLength[arr[uint(left \u002B (right - left) / 2)]]);\\r\\n        while (i \\u003c= j) {\\r\\n            while (straightInviteAddress[arr[uint(i)]].length.sub(lastStraightLength[arr[uint(i)]]) \\u003e pivot) i\u002B\u002B;\\r\\n            while (pivot \\u003e straightInviteAddress[arr[uint(j)]].length.sub(lastStraightLength[arr[uint(j)]])) j--;\\r\\n            if (i \\u003c= j) {\\r\\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\\r\\n                i\u002B\u002B;\\r\\n                j--;\\r\\n            }\\r\\n        }\\r\\n        if (left \\u003c j)\\r\\n            quickSort(arr, left, j);\\r\\n        if (i \\u003c right)\\r\\n            quickSort(arr, i, right);\\r\\n    }\\r\\n\\r\\n    // settle straight rewards\\r\\n    function settleStraightRewards()\\r\\n    internal\\r\\n    {\\r\\n        uint256 addressAmount;\\r\\n        for (uint8 i = 0; i \\u003c 10; i\u002B\u002B) {\\r\\n            addressAmount \u002B= straightInviteAddress[straightSort[i]].length - lastStraightLength[straightSort[i]];\\r\\n        }\\r\\n\\r\\n        uint256 _straightSortRewards = SafeMath.div(straightSortRewards, 2);\\r\\n        uint256 perAddressReward = SafeMath.div(_straightSortRewards, addressAmount);\\r\\n        for (uint8 j = 0; j \\u003c 10; j\u002B\u002B) {\\r\\n            address(uint160(straightSort[j])).transfer(SafeMath.mul(straightInviteAddress[straightSort[j]].length.sub(lastStraightLength[straightSort[j]]), perAddressReward));\\r\\n            straightSortRewards = SafeMath.sub(straightSortRewards, SafeMath.mul(straightInviteAddress[straightSort[j]].length.sub(lastStraightLength[straightSort[j]]), perAddressReward));\\r\\n            lastStraightLength[straightSort[j]] = straightInviteAddress[straightSort[j]].length;\\r\\n        }\\r\\n        delete (straightSort);\\r\\n        currentBlockNumber = block.number;\\r\\n    }\\r\\n\\r\\n    // calculate bonus\\r\\n    function ethToBonus(uint256 ethereum)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        uint256 _price = bonusPrice * 1e18;\\r\\n        // calculate by wei\\r\\n        uint256 _tokensReceived =\\r\\n        (\\r\\n        (\\r\\n        SafeMath.sub(\\r\\n            (sqrt\\r\\n        (\\r\\n            (_price ** 2)\\r\\n            \u002B\\r\\n            (2 * (priceIncremental * 1e18) * (ethereum * 1e18))\\r\\n            \u002B\\r\\n            (((priceIncremental) ** 2) * (totalSupply ** 2))\\r\\n            \u002B\\r\\n            (2 * (priceIncremental) * _price * totalSupply)\\r\\n        )\\r\\n            ), _price\\r\\n        )\\r\\n        ) / (priceIncremental)\\r\\n        ) - (totalSupply);\\r\\n\\r\\n        return _tokensReceived;\\r\\n    }\\r\\n\\r\\n    // utils for calculate bonus\\r\\n    function sqrt(uint x) internal pure returns (uint y) {\\r\\n        uint z = (x \u002B 1) / 2;\\r\\n        y = x;\\r\\n        while (z \\u003c y) {\\r\\n            y = z;\\r\\n            z = (x / z \u002B z) / 2;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // get user bonus profits\\r\\n    function myBonusProfits(address user)\\r\\n    view\\r\\n    public\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return (uint256) ((int256)(perBonusDivide.mul(userInfo[user].profitAmount)) - payoutsTo[user]).div(magnitude);\\r\\n    }\\r\\n\\r\\n    function whetherTheCap()\\r\\n    internal\\r\\n    returns (uint256)\\r\\n    {\\r\\n        require(userInfo[msg.sender].ethAmount.mul(120).div(100) \\u003e= userInfo[msg.sender].tokenProfit);\\r\\n        uint256 _currentAmount = userInfo[msg.sender].ethAmount.sub(userInfo[msg.sender].tokenProfit.mul(100).div(120));\\r\\n        uint256 topProfits = _currentAmount.mul(remain \u002B 100).div(100);\\r\\n        uint256 userProfits = myBonusProfits(msg.sender);\\r\\n\\r\\n        if (userProfits \\u003e topProfits) {\\r\\n            userInfo[msg.sender].profitAmount = 0;\\r\\n            payoutsTo[msg.sender] = 0;\\r\\n            userInfo[msg.sender].tokenProfit \u002B= topProfits;\\r\\n            userInfo[msg.sender].staticTime = block.timestamp;\\r\\n            userInfo[msg.sender].staticTimeout = true;\\r\\n        }\\r\\n\\r\\n        if (topProfits == 0) {\\r\\n            topProfits = userInfo[msg.sender].tokenProfit;\\r\\n        } else {\\r\\n            topProfits = (userProfits \\u003e= topProfits) ? topProfits : userProfits.add(userInfo[msg.sender].tokenProfit); // not add again\\r\\n        }\\r\\n\\r\\n        return topProfits;\\r\\n    }\\r\\n\\r\\n    // -------------------- set api ---------------- //\\r\\n    function setStraightSortRewards()\\r\\n    public\\r\\n    onlyAdmin()\\r\\n    returns (bool)\\r\\n    {\\r\\n        require(currentBlockNumber \u002B blockNumber \\u003c block.number);\\r\\n        settleStraightRewards();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // -------------------- get api ---------------- //\\r\\n    // get straight sort list, 10 addresses\\r\\n    function getStraightSortList()\\r\\n    public\\r\\n    view\\r\\n    returns (address[10] memory)\\r\\n    {\\r\\n        return straightSort;\\r\\n    }\\r\\n\\r\\n    // get effective straight addresses current step\\r\\n    function getStraightInviteAddress()\\r\\n    public\\r\\n    view\\r\\n    returns (address[] memory)\\r\\n    {\\r\\n        return straightInviteAddress[msg.sender];\\r\\n    }\\r\\n\\r\\n    // get currentBlockNumber\\r\\n    function getcurrentBlockNumber()\\r\\n    public\\r\\n    view\\r\\n    returns (uint256){\\r\\n        return currentBlockNumber;\\r\\n    }\\r\\n\\r\\n    function getPurchaseTasksInfo()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        uint256 ethAmount,\\r\\n        uint256 refeTopAmount,\\r\\n        address refeTopAddress,\\r\\n        uint256 lockStraight\\r\\n    )\\r\\n    {\\r\\n        User memory getUser = userInfo[msg.sender];\\r\\n        ethAmount = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\\r\\n        refeTopAmount = getUser.refeTopAmount;\\r\\n        refeTopAddress = getUser.refeTopAddress;\\r\\n        lockStraight = getUser.lockStraight;\\r\\n    }\\r\\n\\r\\n    function getPersonalStatistics()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        uint256 holdings,\\r\\n        uint256 dividends,\\r\\n        uint256 invites,\\r\\n        uint8 level,\\r\\n        uint256 afterFounds,\\r\\n        uint256 referralRewards,\\r\\n        uint256 teamRewards,\\r\\n        uint256 nodeRewards\\r\\n    )\\r\\n    {\\r\\n        User memory getUser = userInfo[msg.sender];\\r\\n\\r\\n        uint256 _withdrawStatic;\\r\\n        (_withdrawStatic, afterFounds) = earningsInstance.getStaticAfterFounds(getUser.userAddress);\\r\\n\\r\\n        holdings = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\\r\\n        dividends = (myBonusProfits(msg.sender) \\u003e= holdings.mul(120).div(100)) ? holdings.mul(120).div(100) : myBonusProfits(msg.sender);\\r\\n        invites = straightInviteAddress[msg.sender].length;\\r\\n        level = getUser.level;\\r\\n        referralRewards = getUser.straightEth;\\r\\n        teamRewards = getUser.teamEth;\\r\\n        uint256 _nodeRewards = (totalEthAmount == 0) ? 0 : whitelistPerformance[msg.sender].mul(systemRetain).div(totalEthAmount);\\r\\n        nodeRewards = (whitelistPerformance[msg.sender] \\u003c 500 ether) ? 0 : _nodeRewards;\\r\\n    }\\r\\n\\r\\n    function getUserBalance()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        uint256 staticBalance,\\r\\n        uint256 recommendBalance,\\r\\n        uint256 teamBalance,\\r\\n        uint256 terminatorBalance,\\r\\n        uint256 nodeBalance,\\r\\n        uint256 totalInvest,\\r\\n        uint256 totalDivided,\\r\\n        uint256 withdrawDivided\\r\\n    )\\r\\n    {\\r\\n        User memory getUser = userInfo[msg.sender];\\r\\n        uint256 _currentEth = getUser.ethAmount.sub(getUser.tokenProfit.mul(100).div(120));\\r\\n\\r\\n        uint256 withdrawStraight;\\r\\n        uint256 withdrawTeam;\\r\\n        uint256 withdrawStatic;\\r\\n        uint256 withdrawNode;\\r\\n        (withdrawStraight, withdrawTeam, withdrawStatic, withdrawNode) = earningsInstance.getUserWithdrawInfo(getUser.userAddress);\\r\\n\\r\\n//        uint256 _staticReward = getUser.ethAmount.mul(120).div(100).sub(withdrawStatic.mul(100).div(80));\\r\\n        uint256 _staticReward = (getUser.ethAmount.mul(120).div(100) \\u003e withdrawStatic.mul(100).div(80)) ? getUser.ethAmount.mul(120).div(100).sub(withdrawStatic.mul(100).div(80)) : 0;\\r\\n\\r\\n        uint256 _staticBonus = (withdrawStatic.mul(100).div(80) \\u003c myBonusProfits(msg.sender).add(getUser.tokenProfit)) ? myBonusProfits(msg.sender).add(getUser.tokenProfit).sub(withdrawStatic.mul(100).div(80)) : 0;\\r\\n\\r\\n        staticBalance = (myBonusProfits(getUser.userAddress) \\u003e= _currentEth.mul(remain \u002B 100).div(100)) ? _staticReward.sub(userReinvest[getUser.userAddress].staticReinvest) : _staticBonus.sub(userReinvest[getUser.userAddress].staticReinvest);\\r\\n\\r\\n        recommendBalance = getUser.straightEth.sub(withdrawStraight.mul(100).div(80));\\r\\n        teamBalance = getUser.teamEth.sub(withdrawTeam.mul(100).div(80));\\r\\n        terminatorBalance = terminatorInstance.getTerminatorRewardAmount(getUser.userAddress);\\r\\n        nodeBalance = 0;\\r\\n        totalInvest = getUser.ethAmount;\\r\\n        totalDivided = getUser.tokenProfit.add(myBonusProfits(getUser.userAddress));\\r\\n        withdrawDivided = earningsInstance.getWithdrawStatic(getUser.userAddress).mul(100).div(80);\\r\\n    }\\r\\n\\r\\n    // returns contract statistics\\r\\n    function contractStatistics()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        uint256 recommendRankPool,\\r\\n        uint256 terminatorPool\\r\\n    )\\r\\n    {\\r\\n        recommendRankPool = straightSortRewards;\\r\\n        terminatorPool = getCurrentTerminatorAmountPool();\\r\\n    }\\r\\n\\r\\n    function listNodeBonus(address node)\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        address nodeAddress,\\r\\n        uint256 performance\\r\\n    )\\r\\n    {\\r\\n        nodeAddress = node;\\r\\n        performance = whitelistPerformance[node];\\r\\n    }\\r\\n\\r\\n    function listRankOfRecommend()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        address[10] memory _straightSort,\\r\\n        uint256[10] memory _inviteNumber\\r\\n    )\\r\\n    {\\r\\n        for (uint8 i = 0; i \\u003c 10; i\u002B\u002B) {\\r\\n            if (straightSort[i] == address(0)){\\r\\n                break;\\r\\n            }\\r\\n            _inviteNumber[i] = straightInviteAddress[straightSort[i]].length.sub(lastStraightLength[straightSort[i]]);\\r\\n        }\\r\\n        _straightSort = straightSort;\\r\\n    }\\r\\n\\r\\n    // return current effective user for initAddressAmount\\r\\n    function getCurrentEffectiveUser()\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return initAddressAmount;\\r\\n    }\\r\\n    function addTerminator(address addr)\\r\\n    internal\\r\\n    {\\r\\n        uint256 allInvestAmount = userInfo[addr].ethAmount.sub(userInfo[addr].tokenProfit.mul(100).div(120));\\r\\n        uint256 withdrawAmount = terminatorInstance.checkBlockWithdrawAmount(block.number);\\r\\n        terminatorInstance.addTerminator(addr, allInvestAmount, block.number, (terminatorPoolAmount - withdrawAmount).div(2));\\r\\n    }\\r\\n\\r\\n    function isLockWithdraw()\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        bool isLock,\\r\\n        uint256 lockTime\\r\\n    )\\r\\n    {\\r\\n        isLock = userInfo[msg.sender].staticTimeout;\\r\\n        lockTime = userInfo[msg.sender].staticTime;\\r\\n    }\\r\\n\\r\\n    function modifyActivateSystem(uint256 value)\\r\\n    mustAdmin(msg.sender)\\r\\n    public\\r\\n    {\\r\\n        activateSystem = value;\\r\\n    }\\r\\n\\r\\n    function modifyActivateGlobal(uint256 value)\\r\\n    mustAdmin(msg.sender)\\r\\n    public\\r\\n    {\\r\\n        activateGlobal = value;\\r\\n    }\\r\\n\\r\\n    //return Current Terminator reward pool amount\\r\\n    function getCurrentTerminatorAmountPool()\\r\\n    view public\\r\\n    returns(uint256 amount)\\r\\n    {\\r\\n        return terminatorPoolAmount-terminatorInstance.checkBlockWithdrawAmount(block.number);\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022ResonanceF.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\nimport \\\u0022./KOCToken.sol\\\u0022;\\r\\n\\r\\ncontract ResonanceF {\\r\\n    address[5] internal admin = [address(0x8434750c01D702c9cfabb3b7C5AA2774Ee67C90D), address(0xD8e79f0D2592311E740Ff097FFb0a7eaa8cb506a), address(0x740beb9fa9CCC6e971f90c25C5D5CC77063a722D), address(0x1b5bbac599f1313dB3E8061A0A65608f62897B0C), address(0x6Fd6dF175B97d2E6D651b536761e0d36b33A9495)];\\r\\n\\r\\n    address internal boosAddress = address(0x541f5417187981b28Ef9e7Df814b160Ae2Bcb72C);\\r\\n\\r\\n    KOCToken  internal kocInstance;\\r\\n\\r\\n    modifier onlyAdmin () {\\r\\n        address adminAddress = msg.sender;\\r\\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3]|| adminAddress == admin[4]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function withdrawAll()\\r\\n    public\\r\\n    payable\\r\\n    onlyAdmin()\\r\\n    {\\r\\n       address(uint160(boosAddress)).transfer(address(this).balance);\\r\\n       kocInstance.transfer(address(uint160(boosAddress)), kocInstance.balanceOf(address(this)));\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022Roles.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\u0022Roles: account already has role\\\u0022);\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\u0022Roles: account does not have role\\\u0022);\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\u0022Roles: account is the zero address\\\u0022);\\n        return role.bearer[account];\\n    }\\n}\\n\u0022},\u0022SafeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a \u002B b;\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\u0022SafeMath: subtraction overflow\\\u0022);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\u0022SafeMath: division by zero\\\u0022);\\n        uint256 c = a / b;\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\u0022SafeMath: modulo by zero\\\u0022);\\n        return a % b;\\n    }\\n}\\n\u0022},\u0022TeamRewards.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\ncontract TeamRewards {\\r\\n\\r\\n    // -------------------- mapping ------------------------ //\\r\\n    mapping(address =\\u003e UserSystemInfo) public userSystemInfo;// user system information mapping\\r\\n    mapping(address =\\u003e address[])      public whitelistAddress;   // Whitelist addresses defined at the beginning of the project\\r\\n\\r\\n    // -------------------- array ------------------------ //\\r\\n    address[5] internal admin = [address(0x8434750c01D702c9cfabb3b7C5AA2774Ee67C90D), address(0xD8e79f0D2592311E740Ff097FFb0a7eaa8cb506a), address(0x740beb9fa9CCC6e971f90c25C5D5CC77063a722D), address(0x1b5bbac599f1313dB3E8061A0A65608f62897B0C), address(0x6Fd6dF175B97d2E6D651b536761e0d36b33A9495)];\\r\\n\\r\\n    // -------------------- variate ------------------------ //\\r\\n    address public resonanceAddress;\\r\\n    address public owner;\\r\\n    bool    public whitelistTime;\\r\\n\\r\\n    // -------------------- event ------------------------ //\\r\\n    event TobeWhitelistAddress(address indexed user, address adminAddress);\\r\\n\\r\\n    // -------------------- structure ------------------------ //\\r\\n    // user system information\\r\\n    struct UserSystemInfo {\\r\\n        address userAddress;     // user address\\r\\n        address straightAddress; // straight Address\\r\\n        address whiteAddress;    // whiteList Address\\r\\n        address adminAddress;    // admin Address\\r\\n        bool whitelist;  // if whitelist\\r\\n    }\\r\\n\\r\\n    constructor()\\r\\n    public{\\r\\n        whitelistTime = true;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    // -------------------- modifier ------------------------ //\\r\\n    modifier onlyOwner(){\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin () {\\r\\n        address adminAddress = msg.sender;\\r\\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier mustAdmin (address adminAddress){\\r\\n        require(adminAddress != address(0));\\r\\n        require(adminAddress == admin[0] || adminAddress == admin[1] || adminAddress == admin[2] || adminAddress == admin[3] || adminAddress == admin[4]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyResonance (){\\r\\n        require(msg.sender == resonanceAddress);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // -------------------- user api ----------------//\\r\\n    function toBeWhitelistAddress(address adminAddress, address whitelist)\\r\\n    public\\r\\n    mustAdmin(adminAddress)\\r\\n    onlyAdmin()\\r\\n    payable\\r\\n    {\\r\\n        require(whitelistTime);\\r\\n        require(!userSystemInfo[whitelist].whitelist);\\r\\n        whitelistAddress[adminAddress].push(whitelist);\\r\\n        UserSystemInfo storage _userSystemInfo = userSystemInfo[whitelist];\\r\\n        _userSystemInfo.straightAddress = adminAddress;\\r\\n        _userSystemInfo.whiteAddress = whitelist;\\r\\n        _userSystemInfo.adminAddress = adminAddress;\\r\\n        _userSystemInfo.whitelist = true;\\r\\n        emit TobeWhitelistAddress(whitelist, adminAddress);\\r\\n    }\\r\\n\\r\\n    // -------------------- Resonance api ----------------//\\r\\n    function referralPeople(address userAddress,address referralAddress)\\r\\n    public\\r\\n    onlyResonance()\\r\\n    {\\r\\n        UserSystemInfo storage _userSystemInfo = userSystemInfo[userAddress];\\r\\n        _userSystemInfo.straightAddress = referralAddress;\\r\\n        _userSystemInfo.whiteAddress = userSystemInfo[referralAddress].whiteAddress;\\r\\n        _userSystemInfo.adminAddress = userSystemInfo[referralAddress].adminAddress;\\r\\n    }\\r\\n\\r\\n    function getUserSystemInfo(address userAddress)\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        address  straightAddress,\\r\\n        address whiteAddress,\\r\\n        address adminAddress,\\r\\n        bool whitelist)\\r\\n    {\\r\\n        straightAddress = userSystemInfo[userAddress].straightAddress;\\r\\n        whiteAddress = userSystemInfo[userAddress].whiteAddress;\\r\\n        adminAddress = userSystemInfo[userAddress].adminAddress;\\r\\n        whitelist    = userSystemInfo[userAddress].whitelist;\\r\\n    }\\r\\n\\r\\n    function getUserreferralAddress(address userAddress)\\r\\n    public\\r\\n    view\\r\\n    onlyResonance()\\r\\n    returns (address )\\r\\n    {\\r\\n        return userSystemInfo[userAddress].straightAddress;\\r\\n    }\\r\\n\\r\\n    // -------------------- Owner api ----------------//\\r\\n    function allowResonance(address _addr) public onlyOwner() {\\r\\n        resonanceAddress = _addr;\\r\\n    }\\r\\n\\r\\n    // -------------------- Admin api ---------------- //\\r\\n    // set whitelist close\\r\\n    function setWhitelistTime(bool off)\\r\\n    public\\r\\n    onlyAdmin()\\r\\n    {\\r\\n        whitelistTime = off;\\r\\n    }\\r\\n\\r\\n    function getWhitelistTime()\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n    {\\r\\n        return whitelistTime;\\r\\n    }\\r\\n\\r\\n    // get all whitelist by admin address\\r\\n    function getAdminWhitelistAddress(address adminx)\\r\\n    public\\r\\n    view\\r\\n    returns (address[] memory)\\r\\n    {\\r\\n        return whitelistAddress[adminx];\\r\\n    }\\r\\n\\r\\n    // check if the user is whitelist\\r\\n    function isWhitelistAddress(address user)\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n    {\\r\\n        return userSystemInfo[user].whitelist;\\r\\n    }\\r\\n\\r\\n    function getStraightAddress (address userAddress)\\r\\n    public\\r\\n    view\\r\\n    returns (address  straightAddress)\\r\\n    {\\r\\n        straightAddress = userSystemInfo[userAddress].straightAddress;\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022Terminator.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\r\\n\\r\\ncontract Terminator {\\r\\n\\r\\n    address terminatorOwner;     //\u5408\u7EA6\u62E5\u6709\u8005\\r\\n    address callOwner;           //\u90E8\u5206\u65B9\u6CD5\u5141\u8BB8\u8C03\u7528\u8005\uFF08\u4E3B\u5408\u7EA6\uFF09\\r\\n\\r\\n    struct recodeTerminator {\\r\\n        address userAddress;     //\u7528\u6237\u5730\u5740\\r\\n        uint256 amountInvest;    //\u7528\u6237\u7559\u5B58\u5728\u5408\u7EA6\u5F53\u4E2D\u7684\u91D1\u989D\\r\\n    }\\r\\n\\r\\n    uint256 public BlockNumber;                                                           //\u533A\u5757\u9AD8\u5EA6\\r\\n    uint256 public AllTerminatorInvestAmount;                                             //\u7EC8\u7ED3\u8005\u6240\u6709\u7528\u6237\u603B\u6295\u5165\u91D1\u989D\\r\\n    uint256 public TerminatorRewardPool;                                                  //\u5F53\u524D\u7EC8\u7ED3\u8005\u5956\u6C60\u91D1\u989D\\r\\n    uint256 public TerminatorRewardWithdrawPool;                                          //\u7EC8\u7ED3\u8005\u53EF\u63D0\u73B0\u5956\u6C60\u91D1\u989D\\r\\n    uint256 public signRecodeTerminator;                                                  //\u6807\u8BB0\u63D2\u5165\u4F4D\u7F6E\\r\\n\\r\\n    recodeTerminator[50] public recodeTerminatorInfo;                                     //\u7EC8\u7ED3\u8005\u8BB0\u5F55\u6570\u7EC4\\r\\n    mapping(address =\\u003e uint256 [4]) internal terminatorAllReward;                         //\u7528\u6237\u603B\u5956\u52B1\u91D1\u989D\u548C\u5DF2\u63D0\u53D6\u7684\u5956\u52B1\u91D1\u989D\u548C\u590D\u6295\u603B\u91D1\u989D\\r\\n    mapping(uint256 =\\u003e address[50]) internal blockAllTerminatorAddress;                   //\u6BCF\u4E2A\u533A\u5757\u6709\u591A\u5C11\u7EC8\u7ED3\u8005\\r\\n    uint256[] internal signBlockHasTerminator;                                            //\u4EA7\u751F\u7EC8\u7ED3\u8005\u7684\u533A\u5757\u6570\u7EC4\\r\\n\\r\\n    //\u4E8B\u4EF6\\r\\n    event AchieveTerminator(uint256 terminatorBlocknumber);  //\u6210\u4E3A\u7EC8\u7ED3\u8005\\r\\n\\r\\n    //\u521D\u59CB\u5316\u5408\u7EA6\\r\\n    constructor() public{\\r\\n        terminatorOwner = msg.sender;\\r\\n    }\\r\\n\\r\\n    //\u6DFB\u52A0\u7EC8\u7ED3\u8005\uFF08\u4E3B\u5408\u7EA6\u8C03\u7528\uFF09\\r\\n    function addTerminator(address addr, uint256 amount, uint256 blockNumber, uint256 amountPool)\\r\\n    public\\r\\n    checkCallOwner(msg.sender)\\r\\n    {\\r\\n        require(amount \\u003e 0);\\r\\n        require(amountPool \\u003e 0);\\r\\n        if (blockNumber \\u003e= BlockNumber \u002B 240 \\u0026\\u0026 BlockNumber != 0) {\\r\\n            addRecodeToTerminatorArray(BlockNumber);\\r\\n            signBlockHasTerminator.push(BlockNumber);\\r\\n        }\\r\\n        addRecodeTerminator(addr, amount, blockNumber, amountPool);\\r\\n        BlockNumber = blockNumber;\\r\\n    }\\r\\n\\r\\n    //\u7528\u6237\u63D0\u53D6\u5956\u52B1\uFF08\u4E3B\u5408\u7EA6\u8C03\u7528\uFF09\\r\\n    function modifyTerminatorReward(address addr, uint256 amount)\\r\\n    public\\r\\n    checkCallOwner(msg.sender)\\r\\n    {\\r\\n        require(amount \\u003c= terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3]);\\r\\n        terminatorAllReward[addr][1] \u002B= amount;\\r\\n    }\\r\\n    //\u7528\u6237\u590D\u6295(\u4E3B\u5408\u7EA6\u8C03\u7528)\\r\\n    function reInvestTerminatorReward(address addr, uint256 amount)\\r\\n    public\\r\\n    checkCallOwner(msg.sender)\\r\\n    {\\r\\n        require(amount \\u003c= terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3]);\\r\\n        terminatorAllReward[addr][3] \u002B= amount;\\r\\n    }\\r\\n\\r\\n    //\u6DFB\u52A0\u7528\u6237\u4FE1\u606F\u8BB0\u5F55\uFF0C\u7B49\u5F85\u89E6\u53D1\u7EC8\u7ED3\u8005(\u5185\u90E8\u8C03\u7528)\\r\\n    function addRecodeTerminator(address addr, uint256 amount, uint256 blockNumber, uint256 amountPool)\\r\\n    internal\\r\\n    {\\r\\n        recodeTerminator memory t = recodeTerminator(addr, amount);\\r\\n        if (blockNumber == BlockNumber) {\\r\\n            if (signRecodeTerminator \\u003e= 50) {\\r\\n                AllTerminatorInvestAmount -= recodeTerminatorInfo[signRecodeTerminator % 50].amountInvest;\\r\\n            }\\r\\n            recodeTerminatorInfo[signRecodeTerminator % 50] = t;\\r\\n            signRecodeTerminator\u002B\u002B;\\r\\n            AllTerminatorInvestAmount \u002B= amount;\\r\\n        } else {\\r\\n            recodeTerminatorInfo[0] = t;\\r\\n            signRecodeTerminator = 1;\\r\\n            AllTerminatorInvestAmount = amount;\\r\\n        }\\r\\n        TerminatorRewardPool = amountPool;\\r\\n    }\\r\\n    //\u4EA7\u751F\u7EC8\u7ED3\u8005\uFF0C\u5C06\u7EC8\u7ED3\u8005\u4FE1\u606F\u5199\u5165\u5E76\u8BA1\u7B97\u5956\u52B1\uFF08\u5185\u90E8\u8C03\u7528\uFF09\\r\\n    function addRecodeToTerminatorArray(uint256 blockNumber)\\r\\n    internal\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c 50; i\u002B\u002B) {\\r\\n            if (i \\u003e= signRecodeTerminator) {\\r\\n                break;\\r\\n            }\\r\\n            address userAddress = recodeTerminatorInfo[i].userAddress;\\r\\n            uint256 reward = (recodeTerminatorInfo[i].amountInvest) * (TerminatorRewardPool) / (AllTerminatorInvestAmount);\\r\\n\\r\\n            blockAllTerminatorAddress[blockNumber][i] = userAddress;\\r\\n            terminatorAllReward[userAddress][0] \u002B= reward;\\r\\n            terminatorAllReward[userAddress][2] = reward;\\r\\n        }\\r\\n        TerminatorRewardWithdrawPool \u002B= TerminatorRewardPool;\\r\\n        emit AchieveTerminator(blockNumber);\\r\\n    }\\r\\n\\r\\n    //\u6DFB\u52A0\u4E3B\u5408\u7EA6\u8C03\u7528\u6743\u9650(\u5408\u7EA6\u62E5\u6709\u8005\u8C03\u7528)\\r\\n    function addCallOwner(address addr)\\r\\n    public\\r\\n    checkTerminatorOwner(msg.sender)\\r\\n    {\\r\\n        callOwner = addr;\\r\\n    }\\r\\n    //\u6839\u636E\u533A\u5757\u9AD8\u5EA6\u83B7\u53D6\u83B7\u53D6\u6240\u6709\u83B7\u5F97\u7EC8\u7ED3\u8005\u5956\u52B1\u5730\u5740\\r\\n    function getAllTerminatorAddress(uint256 blockNumber)\\r\\n    view public\\r\\n    returns (address[50] memory)\\r\\n    {\\r\\n        return blockAllTerminatorAddress[blockNumber];\\r\\n    }\\r\\n    //\u83B7\u53D6\u6700\u8FD1\u4E00\u6B21\u83B7\u5F97\u7EC8\u7ED3\u8005\u533A\u5757\u9AD8\u5EA6\u548C\u5956\u52B1\u7684\u6240\u6709\u7528\u6237\u5730\u5740\u548C\u4E0A\u4E00\u6B21\u83B7\u5956\u6570\u91CF\\r\\n    function getLatestTerminatorInfo()\\r\\n    view public\\r\\n    returns (uint256 blockNumber, address[50] memory addressArray, uint256[50] memory amountArray)\\r\\n    {\\r\\n        uint256 index = signBlockHasTerminator.length;\\r\\n\\r\\n        address[50] memory rewardAddress;\\r\\n        uint256[50] memory rewardAmount;\\r\\n        if (index \\u003c= 0) {\\r\\n            return (0, rewardAddress, rewardAmount);\\r\\n        } else {\\r\\n            uint256 blocks = signBlockHasTerminator[index - 1];\\r\\n            rewardAddress = blockAllTerminatorAddress[blocks];\\r\\n            for (uint256 i = 0; i \\u003c 50; i\u002B\u002B) {\\r\\n                if (rewardAddress[i] == address(0)) {\\r\\n                    break;\\r\\n                }\\r\\n                rewardAmount[i] = terminatorAllReward[rewardAddress[i]][2];\\r\\n            }\\r\\n            return (blocks, rewardAddress, rewardAmount);\\r\\n        }\\r\\n    }\\r\\n    //\u83B7\u53D6\u53EF\u63D0\u73B0\u5956\u52B1\u91D1\u989D\\r\\n    function getTerminatorRewardAmount(address addr)\\r\\n    view public\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return terminatorAllReward[addr][0] - (terminatorAllReward[addr][1] * 100 / 80) - terminatorAllReward[addr][3];\\r\\n    }\\r\\n    //\u83B7\u53D6\u7528\u6237\u6240\u6709\u5956\u52B1\u91D1\u989D\u548C\u5DF2\u63D0\u73B0\u91D1\u989D\u548C\u4E0A\u4E00\u6B21\u83B7\u5956\u91D1\u989D\u548C\u590D\u6295\u91D1\u989D\\r\\n    function getUserTerminatorRewardInfo(address addr)\\r\\n    view public\\r\\n    returns (uint256[4] memory)\\r\\n    {\\r\\n        return terminatorAllReward[addr];\\r\\n    }\\r\\n    //\u83B7\u53D6\u6240\u6709\u4EA7\u751F\u7EC8\u7ED3\u8005\u7684\u533A\u5757\u6570\u7EC4\\r\\n    function getAllTerminatorBlockNumber()\\r\\n    view public\\r\\n    returns (uint256[] memory){\\r\\n        return signBlockHasTerminator;\\r\\n    }\\r\\n    //\u83B7\u53D6\u5F53\u6B21\u5DF2\u63D0\u8D70\u5956\u6C60\u91D1\u989D\uFF08\u4F9B\u4E3B\u5408\u7EA6\u8C03\u7528\uFF09\\r\\n    function checkBlockWithdrawAmount(uint256 blockNumber)\\r\\n    view public\\r\\n    returns (uint256)\\r\\n    {\\r\\n        if (blockNumber \\u003e= BlockNumber \u002B 240 \\u0026\\u0026 BlockNumber != 0) {\\r\\n            return (TerminatorRewardPool \u002B TerminatorRewardWithdrawPool);\\r\\n        } else {\\r\\n            return (TerminatorRewardWithdrawPool);\\r\\n        }\\r\\n    }\\r\\n    //\u68C0\u67E5\u5408\u7EA6\u62E5\u6709\u8005\u6743\u9650\\r\\n    modifier checkTerminatorOwner(address addr)\\r\\n    {\\r\\n        require(addr == terminatorOwner);\\r\\n        _;\\r\\n    }\\r\\n    //\u68C0\u67E5\u5408\u7EA6\u8C03\u7528\u8005\u6743\u9650\uFF08\u68C0\u67E5\u662F\u5426\u662F\u4E3B\u5408\u7EA6\u8C03\u7528\uFF09\\r\\n    modifier checkCallOwner(address addr)\\r\\n    {\\r\\n        require(addr == callOwner || addr == terminatorOwner);\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n//\u5907\u6CE8\uFF1A\\r\\n//\u90E8\u7F72\u5B8C\u4E3B\u5408\u7EA6\u540E\uFF0C\u9700\u8981\u8C03\u7528\u8BE5\u5408\u7EA6\u7684addCallOwner\u65B9\u6CD5\uFF0C\u4F20\u5165\u4E3B\u5408\u7EA6\u5730\u5740\uFF0C\u4E3A\u4E3B\u5408\u7EA6\u8C03\u8BE5\u5408\u7EA6\u65B9\u6CD5\u6DFB\u52A0\u6743\u9650\\r\\n\u0022}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalEthAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022globalAddressReward\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022listRankOfRecommend\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022_straightSort\u0022,\u0022type\u0022:\u0022address[10]\u0022},{\u0022name\u0022:\u0022_inviteNumber\u0022,\u0022type\u0022:\u0022uint256[10]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022userInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022profitAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022tokenProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022straightEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lockStraight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022teamEth\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022staticTimeout\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022staticTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022level\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022straightAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022refeTopAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022refeTopAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022userSubordinateCount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022straightInviteAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022node\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022listNodeBonus\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022nodeAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022performance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022straightSort\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022currentBlockNumber\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022nodeAddressReward\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022activateGlobal\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022systemRetain\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022myBonusProfits\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022subordinate\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022supportSubordinateAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getcurrentBlockNumber\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022percent\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getPersonalStatistics\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022holdings\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022dividends\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022invites\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022level\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022afterFounds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022referralRewards\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022teamRewards\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022nodeRewards\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initAddressAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdrawAll\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022contractStatistics\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022recommendRankPool\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022terminatorPool\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getPurchaseTasksInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022refeTopAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022refeTopAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022lockStraight\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022userReinvest\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staticReinvest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022isPush\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022straightSortRewards\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022activateSystem\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022perBonusDivide\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getStraightSortList\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[10]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022whitelistPerformance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022tokenDivided\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022userBonus\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022users\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getPerBonusDivide\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isLockWithdraw\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022isLock\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022lockTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getStraightInviteAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getUserBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staticBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022recommendBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022teamBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022terminatorBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022nodeBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalInvest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalDivided\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022withdrawDivided\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022modifyActivateGlobal\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022terminatorPoolAmount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022lastStraightLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022modifyActivateSystem\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentTerminatorAmountPool\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentEffectiveUser\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022systemAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022setStraightSortRewards\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022referralAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022buy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022reinvest\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022eggAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_erc20Address\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_earningsAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_teamRewardsAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_terminatorAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_recommendAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022WithdrawStaticProfits\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022buyTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Buy\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022buyTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Withdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022ethAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022buyTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Reinvest\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022subordinate\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022refeAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022supported\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022SupportSubordinateAddress\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Resonance","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000483154ecebc32dee66cabbe9c7b7694c806e78540000000000000000000000001dce411679d9d77e20c1930833253960ea5b580f00000000000000000000000007d52faee5664ed5fa3d1510eb5bd0e28da30f1900000000000000000000000072ccc731052ecde4e73a3a4865312004cc1b152000000000000000000000000057cf415867626742755a5618abde17219bf2aec3","Library":"","SwarmSource":"bzzr://a1533a2259fca30289db2437294a7f22dad9225667799e7f0acc8ada85f96280"}]