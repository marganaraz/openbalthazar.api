[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-09-11\r\n*/\r\n\r\n/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IArbitrableTCR {\r\n    \r\n    enum Party {\r\n        None,      // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\r\n        Requester, // Party that made the request to change an address status.\r\n        Challenger // Party that challenges the request to change an address status.\r\n    }\r\n    \r\n    function governor() external view returns(address);\r\n    function arbitrator() external view returns(address);\r\n    function arbitratorExtraData() external view returns(bytes memory);\r\n    function requesterBaseDeposit() external view returns(uint);\r\n    function challengerBaseDeposit() external view returns(uint);\r\n    function challengePeriodDuration() external view returns(uint);\r\n    function metaEvidenceUpdates() external view returns(uint);\r\n    function winnerStakeMultiplier() external view returns(uint);\r\n    function loserStakeMultiplier() external view returns(uint);\r\n    function sharedStakeMultiplier() external view returns(uint);\r\n    function MULTIPLIER_DIVISOR() external view returns(uint);\r\n    function countByStatus() \r\n        external \r\n        view \r\n        returns(\r\n            uint absent,\r\n            uint registered,\r\n            uint registrationRequest,\r\n            uint clearingRequest,\r\n            uint challengedRegistrationRequest,\r\n            uint challengedClearingRequest\r\n        );\r\n}\r\n\r\ninterface IArbitrableAddressTCR {\r\n    enum AddressStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n    \r\n    function addressCount() external view returns(uint); \r\n    function addressList(uint index) external view returns(address);\r\n    function getAddressInfo(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            AddressStatus status,\r\n            uint numberOfRequests\r\n        );\r\n    \r\n    function getRequestInfo(address _address, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n        \r\n    function getRoundInfo(address _address, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n}\r\n\r\ninterface IArbitrableTokenTCR {\r\n    enum TokenStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n    \r\n    function tokenCount() external view returns(uint); \r\n    function tokensList(uint index) external view returns(bytes32);\r\n    function getTokenInfo(bytes32 _tokenID)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory ticker,\r\n            address addr,\r\n            string memory symbolMultihash,\r\n            TokenStatus status,\r\n            uint numberOfRequests\r\n        );\r\n        \r\n    function getRequestInfo(bytes32 _tokenID, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n        \r\n    function getRoundInfo(bytes32 _tokenID, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n}\r\n\r\ninterface IArbitrator {\r\n    \r\n    enum DisputeStatus {Waiting, Appealable, Solved}\r\n    \r\n    function createDispute(uint _choices, bytes calldata _extraData) external payable returns(uint disputeID);\r\n    function arbitrationCost(bytes calldata _extraData) external view returns(uint cost);\r\n    function appeal(uint _disputeID, bytes calldata _extraData) external payable;\r\n    function appealCost(uint _disputeID, bytes calldata _extraData) external view returns(uint cost);\r\n    function appealPeriod(uint _disputeID) external view returns(uint start, uint end);\r\n    function disputeStatus(uint _disputeID) external view returns(DisputeStatus status);\r\n    function currentRuling(uint _disputeID) external view returns(uint ruling);\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ArbitrableTCRView {\r\n    \r\n    struct CountByStatus {\r\n        uint absent;\r\n        uint registered;\r\n        uint registrationRequest;\r\n        uint clearingRequest;\r\n        uint challengedRegistrationRequest;\r\n        uint challengedClearingRequest;\r\n    }\r\n\r\n    struct ArbitrableTCRData {\r\n        address governor;\r\n        address arbitrator;\r\n        bytes arbitratorExtraData;\r\n        uint requesterBaseDeposit;\r\n        uint challengerBaseDeposit;\r\n        uint challengePeriodDuration;\r\n        uint metaEvidenceUpdates;\r\n        uint winnerStakeMultiplier;\r\n        uint loserStakeMultiplier;\r\n        uint sharedStakeMultiplier;\r\n        uint MULTIPLIER_DIVISOR;\r\n        CountByStatus countByStatus;\r\n        uint arbitrationCost;\r\n    }\r\n\r\n    /** @dev Fetch arbitrable TCR data in a single call.\r\n     *  @param _address The address of the Generalized TCR to query.\r\n     *  @return The latest data on an arbitrable TCR contract.\r\n     */\r\n    function fetchArbitrable(address _address) external view returns (ArbitrableTCRData memory result) {\r\n        IArbitrableTCR tcr = IArbitrableTCR(_address);\r\n        result.governor = tcr.governor();\r\n        result.arbitrator = tcr.arbitrator();\r\n        result.arbitratorExtraData = tcr.arbitratorExtraData();\r\n        result.requesterBaseDeposit = tcr.requesterBaseDeposit();\r\n        result.challengerBaseDeposit = tcr.challengerBaseDeposit();\r\n        result.challengePeriodDuration = tcr.challengePeriodDuration();\r\n        result.metaEvidenceUpdates = tcr.metaEvidenceUpdates();\r\n        result.winnerStakeMultiplier = tcr.winnerStakeMultiplier();\r\n        result.loserStakeMultiplier = tcr.loserStakeMultiplier();\r\n        result.sharedStakeMultiplier = tcr.sharedStakeMultiplier();\r\n        result.MULTIPLIER_DIVISOR = tcr.MULTIPLIER_DIVISOR();\r\n        \r\n        {\r\n            (\r\n                uint absent,\r\n                uint registered,\r\n                uint registrationRequest,\r\n                uint clearingRequest,\r\n                uint challengedRegistrationRequest,\r\n                uint challengedClearingRequest\r\n            ) = tcr.countByStatus();\r\n            result.countByStatus = CountByStatus({\r\n                absent: absent,\r\n                registered: registered,\r\n                registrationRequest: registrationRequest,\r\n                clearingRequest: clearingRequest,\r\n                challengedRegistrationRequest: challengedRegistrationRequest,\r\n                challengedClearingRequest: challengedClearingRequest\r\n            });\r\n        }\r\n        \r\n        IArbitrator arbitrator = IArbitrator(result.arbitrator);\r\n        result.arbitrationCost = arbitrator.arbitrationCost(result.arbitratorExtraData);\r\n    }\r\n    \r\n    struct AppealableToken {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        bytes32 tokenID;\r\n        bool inAppealPeriod;\r\n    }\r\n    \r\n    struct AppealableAddress {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        address addr;\r\n        bool inAppealPeriod;\r\n    }\r\n    \r\n    function fetchAppealableAddresses(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableAddress[] memory results) {\r\n        IArbitrableAddressTCR tcr = IArbitrableAddressTCR(_addressTCR);\r\n        results = new AppealableAddress[]( tcr.addressCount() \u003C _count ?  tcr.addressCount() : _count);\r\n        \r\n        for (uint i = _cursor; i \u003C tcr.addressCount() \u0026\u0026 _count - i \u003E 0; i\u002B\u002B) {\r\n            address itemAddr = tcr.addressList(i);\r\n            (\r\n                IArbitrableAddressTCR.AddressStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getAddressInfo(itemAddr);\r\n            \r\n            if (status == IArbitrableAddressTCR.AddressStatus.Absent || status == IArbitrableAddressTCR.AddressStatus.Registered) continue;\r\n            \r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(itemAddr, numberOfRequests - 1);\r\n            \r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n            \r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] \u003E 0 \u0026\u0026 appealPeriod[1] \u003E 0) {\r\n                results[i] = AppealableAddress({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    addr: itemAddr,\r\n                    inAppealPeriod: now \u003C appealPeriod[1]\r\n                });\r\n                \r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not \r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None \u0026\u0026 \r\n                    now \u003E (appealPeriod[1] - appealPeriod[0]) / 2 \u002B appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester \r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n                        \r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(itemAddr, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n                    \r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function fetchAppealableToken(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableToken[] memory results) {\r\n        IArbitrableTokenTCR tcr = IArbitrableTokenTCR(_addressTCR);\r\n        results = new AppealableToken[](tcr.tokenCount() \u003C _count ? tcr.tokenCount() : _count);\r\n        \r\n        for (uint i = _cursor; i \u003C tcr.tokenCount() \u0026\u0026 _count - i \u003E 0; i\u002B\u002B) {\r\n            bytes32 tokenID = tcr.tokensList(i);\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                IArbitrableTokenTCR.TokenStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getTokenInfo(tokenID);\r\n            \r\n            if (status == IArbitrableTokenTCR.TokenStatus.Absent || status == IArbitrableTokenTCR.TokenStatus.Registered) continue;\r\n            \r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(tokenID, numberOfRequests - 1);\r\n            \r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n            \r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] \u003E 0 \u0026\u0026 appealPeriod[1] \u003E 0) {\r\n                results[i] = AppealableToken({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    tokenID: tokenID,\r\n                    inAppealPeriod: now \u003C appealPeriod[1]\r\n                });\r\n                \r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not \r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None \u0026\u0026 \r\n                    now \u003E (appealPeriod[1] - appealPeriod[0]) / 2 \u002B appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester \r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n                        \r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(tokenID, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n                    \r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n   \r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022fetchArbitrable\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022governor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arbitrator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arbitratorExtraData\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022requesterBaseDeposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022challengerBaseDeposit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022challengePeriodDuration\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022metaEvidenceUpdates\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022winnerStakeMultiplier\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022loserStakeMultiplier\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sharedStakeMultiplier\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022MULTIPLIER_DIVISOR\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022absent\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022registered\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022registrationRequest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022clearingRequest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022challengedRegistrationRequest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022challengedClearingRequest\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct ArbitrableTCRView.CountByStatus\u0022,\u0022name\u0022:\u0022countByStatus\u0022,\u0022type\u0022:\u0022tuple\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022arbitrationCost\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct ArbitrableTCRView.ArbitrableTCRData\u0022,\u0022name\u0022:\u0022result\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_addressTCR\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_cursor\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_count\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022fetchAppealableToken\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022disputeID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arbitrator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022tokenID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022inAppealPeriod\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022internalType\u0022:\u0022struct ArbitrableTCRView.AppealableToken[]\u0022,\u0022name\u0022:\u0022results\u0022,\u0022type\u0022:\u0022tuple[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_addressTCR\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_cursor\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_count\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022fetchAppealableAddresses\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022disputeID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022arbitrator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022inAppealPeriod\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022internalType\u0022:\u0022struct ArbitrableTCRView.AppealableAddress[]\u0022,\u0022name\u0022:\u0022results\u0022,\u0022type\u0022:\u0022tuple[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"ArbitrableTCRView","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bf87e5a665ea604860d8f4bf356274481f14d2c74f86f597604c5eab24f99220"}]