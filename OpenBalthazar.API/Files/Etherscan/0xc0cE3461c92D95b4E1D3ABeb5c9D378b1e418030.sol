[{"SourceCode":"/* ERC1820 Pseudo-introspection Registry Contract\r\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\r\n * register which interface it supports and which smart contract is responsible for its implementation.\r\n *\r\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\r\n *\r\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\r\n * this software to the public domain worldwide. This software is distributed without any warranty.\r\n *\r\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\r\n * \u003Chttp://creativecommons.org/publicdomain/zero/1.0/\u003E.\r\n *\r\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\r\n *    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255A\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\r\n *    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551     \u255A\u2588\u2588\u2551\u255A\u2588\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\r\n *    \u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551      \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u255D \u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\r\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551\u255A\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\r\n *    \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D\r\n *\r\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\r\n *    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255A\u2588\u2588\u2557 \u2588\u2588\u2554\u255D\r\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D \u255A\u2588\u2588\u2588\u2588\u2554\u255D\r\n *    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255A\u2588\u2588\u2554\u255D\r\n *    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\r\n *    \u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D   \u255A\u2550\u255D   \u255A\u2550\u255D  \u255A\u2550\u255D   \u255A\u2550\u255D\r\n *\r\n */\r\npragma solidity 0.5.3;\r\n// IV is value needed to have a vanity address starting with \u00270x1820\u0027.\r\n// IV: 53759\r\n\r\n/// @dev The interface a contract MUST implement if it is the implementer of\r\n/// some (other) interface for any address other than itself.\r\ninterface ERC1820ImplementerInterface {\r\n    /// @notice Indicates whether the contract implements the interface \u0027interfaceHash\u0027 for the address \u0027addr\u0027 or not.\r\n    /// @param interfaceHash keccak256 hash of the name of the interface\r\n    /// @param addr Address for which the contract will implement the interface\r\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements \u0027interfaceHash\u0027 for the address \u0027addr\u0027.\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\r\n}\r\n\r\n\r\n/// @title ERC1820 Pseudo-introspection Registry Contract\r\n/// @author Jordi Baylina and Jacques Dafflon\r\n/// @notice This contract is the official implementation of the ERC1820 Registry.\r\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820\r\ncontract ERC1820Registry {\r\n    /// @notice ERC165 Invalid ID.\r\n    bytes4 constant internal INVALID_ID = 0xffffffff;\r\n    /// @notice Method ID for the ERC165 supportsInterface method (= \u0060bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027))\u0060).\r\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;\r\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\r\n    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\u0022ERC1820_ACCEPT_MAGIC\u0022));\r\n\r\n    /// @notice mapping from addresses and interface hashes to their implementers.\r\n    mapping(address =\u003E mapping(bytes32 =\u003E address)) internal interfaces;\r\n    /// @notice mapping from addresses to their manager.\r\n    mapping(address =\u003E address) internal managers;\r\n    /// @notice flag for each address and erc165 interface to indicate if it is cached.\r\n    mapping(address =\u003E mapping(bytes4 =\u003E bool)) internal erc165Cached;\r\n\r\n    /// @notice Indicates a contract is the \u0027implementer\u0027 of \u0027interfaceHash\u0027 for \u0027addr\u0027.\r\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\r\n    /// @notice Indicates \u0027newManager\u0027 is the address of the new manager for \u0027addr\u0027.\r\n    event ManagerChanged(address indexed addr, address indexed newManager);\r\n\r\n    /// @notice Query if an address implements an interface and through which contract.\r\n    /// @param _addr Address being queried for the implementer of an interface.\r\n    /// (If \u0027_addr\u0027 is the zero address then \u0027msg.sender\u0027 is assumed.)\r\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\r\n    /// E.g., \u0027web3.utils.keccak256(\u0022ERC777TokensRecipient\u0022)\u0027 for the \u0027ERC777TokensRecipient\u0027 interface.\r\n    /// @return The address of the contract which implements the interface \u0027_interfaceHash\u0027 for \u0027_addr\u0027\r\n    /// or \u00270\u0027 if \u0027_addr\u0027 did not register an implementer for this interface.\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\r\n        address addr = _addr == address(0) ? msg.sender : _addr;\r\n        if (isERC165Interface(_interfaceHash)) {\r\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\r\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);\r\n        }\r\n        return interfaces[addr][_interfaceHash];\r\n    }\r\n\r\n    /// @notice Sets the contract which implements a specific interface for an address.\r\n    /// Only the manager defined for that address can set it.\r\n    /// (Each address is the manager for itself until it sets a new manager.)\r\n    /// @param _addr Address for which to set the interface.\r\n    /// (If \u0027_addr\u0027 is the zero address then \u0027msg.sender\u0027 is assumed.)\r\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\r\n    /// E.g., \u0027web3.utils.keccak256(\u0022ERC777TokensRecipient\u0022)\u0027 for the \u0027ERC777TokensRecipient\u0027 interface.\r\n    /// @param _implementer Contract address implementing \u0027_interfaceHash\u0027 for \u0027_addr\u0027.\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\r\n        address addr = _addr == address(0) ? msg.sender : _addr;\r\n        require(getManager(addr) == msg.sender, \u0022Not the manager\u0022);\r\n\r\n        require(!isERC165Interface(_interfaceHash), \u0022Must not be an ERC165 hash\u0022);\r\n        if (_implementer != address(0) \u0026\u0026 _implementer != msg.sender) {\r\n            require(\r\n                ERC1820ImplementerInterface(_implementer)\r\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,\r\n                \u0022Does not implement the interface\u0022\r\n            );\r\n        }\r\n        interfaces[addr][_interfaceHash] = _implementer;\r\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\r\n    }\r\n\r\n    /// @notice Sets \u0027_newManager\u0027 as manager for \u0027_addr\u0027.\r\n    /// The new manager will be able to call \u0027setInterfaceImplementer\u0027 for \u0027_addr\u0027.\r\n    /// @param _addr Address for which to set the new manager.\r\n    /// @param _newManager Address of the new manager for \u0027addr\u0027. (Pass \u00270x0\u0027 to reset the manager to \u0027_addr\u0027.)\r\n    function setManager(address _addr, address _newManager) external {\r\n        require(getManager(_addr) == msg.sender, \u0022Not the manager\u0022);\r\n        managers[_addr] = _newManager == _addr ? address(0) : _newManager;\r\n        emit ManagerChanged(_addr, _newManager);\r\n    }\r\n\r\n    /// @notice Get the manager of an address.\r\n    /// @param _addr Address for which to return the manager.\r\n    /// @return Address of the manager for a given address.\r\n    function getManager(address _addr) public view returns(address) {\r\n        // By default the manager of an address is the same address\r\n        if (managers[_addr] == address(0)) {\r\n            return _addr;\r\n        } else {\r\n            return managers[_addr];\r\n        }\r\n    }\r\n\r\n    /// @notice Compute the keccak256 hash of an interface given its name.\r\n    /// @param _interfaceName Name of the interface.\r\n    /// @return The keccak256 hash of an interface name.\r\n    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_interfaceName));\r\n    }\r\n\r\n    /* --- ERC165 Related Functions --- */\r\n    /* --- Developed in collaboration with William Entriken. --- */\r\n\r\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n    /// @param _contract Address of the contract for which to update the cache.\r\n    /// @param _interfaceId ERC165 interface for which to update the cache.\r\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\r\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(\r\n            _contract, _interfaceId) ? _contract : address(0);\r\n        erc165Cached[_contract][_interfaceId] = true;\r\n    }\r\n\r\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\r\n    //  If the result is not cached a direct lookup on the contract address is performed.\r\n    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n    //  \u0027updateERC165Cache\u0027 with the contract address.\r\n    /// @param _contract Address of the contract to check.\r\n    /// @param _interfaceId ERC165 interface to check.\r\n    /// @return True if \u0027_contract\u0027 implements \u0027_interfaceId\u0027, false otherwise.\r\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\r\n        if (!erc165Cached[_contract][_interfaceId]) {\r\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\r\n        }\r\n        return interfaces[_contract][_interfaceId] == _contract;\r\n    }\r\n\r\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n    /// @param _contract Address of the contract to check.\r\n    /// @param _interfaceId ERC165 interface to check.\r\n    /// @return True if \u0027_contract\u0027 implements \u0027_interfaceId\u0027, false otherwise.\r\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\r\n        uint256 success;\r\n        uint256 result;\r\n\r\n        (success, result) = noThrowCall(_contract, ERC165ID);\r\n        if (success == 0 || result == 0) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, INVALID_ID);\r\n        if (success == 0 || result != 0) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, _interfaceId);\r\n        if (success == 1 \u0026\u0026 result == 1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\r\n    /// @param _interfaceHash The hash to check.\r\n    /// @return True if \u0027_interfaceHash\u0027 is an ERC165 interface (ending with 28 zeroes), false otherwise.\r\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\r\n        return _interfaceHash \u0026 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\r\n    }\r\n\r\n    /// @dev Make a call on a contract without throwing if the function does not exist.\r\n    function noThrowCall(address _contract, bytes4 _interfaceId)\r\n        internal view returns (uint256 success, uint256 result)\r\n    {\r\n        bytes4 erc165ID = ERC165ID;\r\n\r\n        assembly {\r\n            let x := mload(0x40)               // Find empty storage location using \u0022free memory pointer\u0022\r\n            mstore(x, erc165ID)                // Place signature at beginning of empty storage\r\n            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\r\n\r\n            success := staticcall(\r\n                30000,                         // 30k gas\r\n                _contract,                     // To addr\r\n                x,                             // Inputs are stored at location x\r\n                0x24,                          // Inputs are 36 (4 \u002B 32) bytes long\r\n                x,                             // Store output over input (saves space)\r\n                0x20                           // Outputs are 32 bytes long\r\n            )\r\n\r\n            result := mload(x)                 // Load the result\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_interfaceHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_implementer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setInterfaceImplementer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getManager\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_newManager\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setManager\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_interfaceName\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022interfaceHash\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_contract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_interfaceId\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022updateERC165Cache\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_interfaceHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022getInterfaceImplementer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_contract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_interfaceId\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022implementsERC165InterfaceNoCache\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_contract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_interfaceId\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022implementsERC165Interface\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022interfaceHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022implementer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022InterfaceImplementerSet\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newManager\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ManagerChanged\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"ERC1820Registry","CompilerVersion":"v0.5.3\u002Bcommit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5304c07d62891b817f843b53e175e67636a5cbb0fd6757f2407add9790cb7399"}]