[{"SourceCode":"{\u0022HEX.sol\u0022:{\u0022content\u0022:\u0022\\r\\npragma solidity 0.5.13;\\r\\n\\r\\ninterface HEX {\\r\\n   /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves \u0060amount\u0060 tokens from the caller\\u0027s account to \u0060recipient\u0060.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\\r\\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\\r\\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\\r\\n     * another (\u0060to\u0060).\\r\\n     *\\r\\n     * Note that \u0060value\u0060 may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\\r\\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    \\r\\n   function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external;\\r\\n   function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\\r\\n   function stakeCount(address stakerAddr) external view returns (uint256);\\r\\n   function stakeLists(address owner, uint256 stakeIndex) external view returns (uint40, uint72, uint72, uint16, uint16, uint16, bool);\\r\\n   function currentDay() external view returns (uint256);\\r\\n   function dailyDataRange(uint256 beginDay, uint256 endDay) external view returns (uint256[] memory);\\r\\n   function globalInfo() external view returns (uint256[13] memory);\\r\\n\\r\\n}\\r\\n\u0022},\u0022HEXPOOL.sol\u0022:{\u0022content\u0022:\u0022//HEXPOOL.sol\\r\\n//\\r\\n//\\r\\n\\r\\npragma solidity ^0.5.13;\\r\\n\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\nimport \\\u0022./IERC20.sol\\\u0022;\\r\\nimport \\\u0022./HEX.sol\\\u0022;\\r\\n\\r\\n////////////////////////////////////////////////\\r\\n////////////////////EVENTS/////////////////////\\r\\n//////////////////////////////////////////////\\r\\ncontract PoolEvents {\\r\\n\\r\\n//when a user enters a pool\\r\\n    event PoolEntry(\\r\\n        address indexed user,//msg.sender\\r\\n        uint indexed heartValue,\\r\\n        uint indexed entryId,\\r\\n        uint poolId\\r\\n    );\\r\\n    \\r\\n//when a user exits a pool\\r\\n    event PoolExit(\\r\\n        address indexed user,//msg.sender\\r\\n        uint indexed heartValue,\\r\\n        uint indexed entryId,\\r\\n        uint poolId\\r\\n    );\\r\\n\\r\\n//when a pool starts staking\\r\\n    event PoolStartStake(\\r\\n        uint heartValue,//always 150m\\r\\n        uint indexed dayLength,\\r\\n        uint indexed poolId,\\r\\n        uint hexStakeId\\r\\n    );\\r\\n\\r\\n//when a pool ends stake\\r\\n    event PoolEndStake(\\r\\n        uint heartValue,//always 150m\\r\\n        uint indexed stakeProfit,\\r\\n        uint indexed dayLength,\\r\\n        uint indexed poolId,\\r\\n        uint hexStakeId\\r\\n    );\\r\\n\\r\\n//when an ended stakes rewards are withdrawn\\r\\n    event Withdrawal(\\r\\n        address indexed user,\\r\\n        uint indexed heartValue\\r\\n    );\\r\\n}\\r\\n\\r\\ncontract TokenEvents {\\r\\n\\r\\n//when a user freezes tokens\\r\\n    event TokenFreeze(\\r\\n        address indexed user,\\r\\n        uint indexed value\\r\\n    );\\r\\n\\r\\n//when a user unfreezes tokens\\r\\n    event TokenUnfreeze(\\r\\n        address indexed user,\\r\\n        uint indexed value\\r\\n    );\\r\\n}\\r\\n\\r\\n//////////////////////////////////////\\r\\n//////////POOL TOKEN CONTRACT////////\\r\\n////////////////////////////////////\\r\\ncontract POOL is IERC20, TokenEvents{\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    bool internal mintBlock;//stops any more tokens ever being minted once _totalSupply reaches _maxSupply - allows for burn rate to take full effect\\r\\n    uint256 internal _maxSupply = 10000000000000000000;// max supply @ 100B\\r\\n    uint256 internal _totalSupply;\\r\\n    string public constant name = \\\u0022HEXPOOL\\\u0022;\\r\\n    string public constant symbol = \\\u0022POOL\\\u0022;\\r\\n    uint public constant decimals = 8;\\r\\n\\r\\n    //BUDDY SYSTEM\\r\\n    uint public buddyDiv;\\r\\n    //FREEZING\\r\\n    uint public totalFrozen;\\r\\n    mapping (address =\\u003e uint) public tokenFrozenBalances;//balance of POOL frozen mapped by user\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060recipient\u0060 cannot be the zero address.\\r\\n     * - the caller must have a balance of at least \u0060amount\u0060.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060spender\u0060 cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\\r\\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\\r\\n     * - the caller must have allowance for \u0060sender\u0060\\u0027s tokens of at least\\r\\n     * \u0060amount\u0060.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\u0022ERC20: transfer amount exceeds allowance\\\u0022));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060spender\u0060 cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060spender\u0060 cannot be the zero address.\\r\\n     * - \u0060spender\u0060 must have allowance for the caller of at least\\r\\n     * \u0060subtractedValue\u0060.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\u0022ERC20: decreased allowance below zero\\\u0022));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060sender\u0060 cannot be the zero address.\\r\\n     * - \u0060recipient\u0060 cannot be the zero address.\\r\\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\u0022ERC20: transfer from the zero address\\\u0022);\\r\\n        require(recipient != address(0), \\\u0022ERC20: transfer to the zero address\\\u0022);\\r\\n        //1% burn rate\\r\\n        uint burnt = amount.div(100);\\r\\n        uint newAmt = amount.sub(burnt);\\r\\n        _balances[sender] = _balances[sender].sub(newAmt, \\\u0022ERC20: transfer amount exceeds balance\\\u0022);\\r\\n        _balances[recipient] = _balances[recipient].add(newAmt);\\r\\n        _burn(sender, burnt);\\r\\n        emit Transfer(sender, recipient, newAmt);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - \u0060to\u0060 cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        uint256 amt = amount;\\r\\n        require(account != address(0), \\\u0022ERC20: mint to the zero address\\\u0022);\\r\\n        if(!mintBlock){\\r\\n            if(_totalSupply \\u003c _maxSupply){\\r\\n                if(_totalSupply.add(amt) \\u003e _maxSupply){\\r\\n                    amt = _maxSupply.sub(_totalSupply);\\r\\n                    _totalSupply = _maxSupply;\\r\\n                    mintBlock = true;\\r\\n                }\\r\\n                else{\\r\\n                    _totalSupply = _totalSupply.add(amt);\\r\\n                }\\r\\n                _balances[account] = _balances[account].add(amt);\\r\\n                emit Transfer(address(0), account, amt);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - \u0060account\u0060 cannot be the zero address.\\r\\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\u0022ERC20: burn from the zero address\\\u0022);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\u0022ERC20: burn amount exceeds balance\\\u0022);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - \u0060owner\u0060 cannot be the zero address.\\r\\n     * - \u0060spender\u0060 cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\u0022ERC20: approve from the zero address\\\u0022);\\r\\n        require(spender != address(0), \\\u0022ERC20: approve to the zero address\\\u0022);\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\\r\\n     * from the caller\\u0027s allowance.\\r\\n     *\\r\\n     * See {_burn} and {_approve}.\\r\\n     */\\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _burn(account, amount);\\r\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \\\u0022ERC20: burn amount exceeds allowance\\\u0022));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\\r\\n     * another (\u0060to\u0060).\\r\\n     *\\r\\n     * Note that \u0060value\u0060 may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\\r\\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    //mint POOL to msg.sender\\r\\n    function mintPool(uint hearts)\\r\\n        internal\\r\\n        returns(bool)\\r\\n    {\\r\\n        uint amt = hearts.div(100);\\r\\n        address minter = msg.sender;\\r\\n        _mint(minter, amt);//mint POOL - 1% of total heart value before fees @ 10 POOL for 1000 HEX\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////\\r\\n    /////////////////PUBLIC FACING - POOL CONTROL//////////\\r\\n    //////////////////////////////////////////////////////\\r\\n\\r\\n    //freeze POOL to contract\\r\\n    function FreezeTokens(uint amt)\\r\\n        public\\r\\n    {\\r\\n        require(amt \\u003e 0, \\\u0022zero input\\\u0022);\\r\\n        require(tokenBalance() \\u003e= amt, \\\u0022Error: insufficient balance\\\u0022);//ensure user has enough funds\\r\\n        //update balances (allow for 1% burn)\\r\\n        tokenFrozenBalances[msg.sender] = tokenFrozenBalances[msg.sender].add(amt.sub(amt.div(100)));\\r\\n        totalFrozen = totalFrozen.add(amt.sub(amt.div(100)));\\r\\n        _transfer(msg.sender, address(this), amt);//make transfer and burn\\r\\n        emit TokenFreeze(msg.sender, amt);\\r\\n    }\\r\\n\\r\\n    //unfreeze POOL from contract\\r\\n    function UnfreezeTokens(uint amt)\\r\\n        public\\r\\n    {\\r\\n        require(amt \\u003e 0, \\\u0022zero input\\\u0022);\\r\\n        require(tokenFrozenBalances[msg.sender] \\u003e= amt,\\\u0022Error: unsufficient frozen balance\\\u0022);//ensure user has enough frozen funds\\r\\n        tokenFrozenBalances[msg.sender] = tokenFrozenBalances[msg.sender].sub(amt);//update balances\\r\\n        totalFrozen = totalFrozen.sub(amt);\\r\\n        _transfer(address(this), msg.sender, amt);//make transfer and burn\\r\\n        emit TokenUnfreeze(msg.sender, amt);\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////\\r\\n    ////////VIEW ONLY//////////////\\r\\n    ///////////////////////////////\\r\\n\\r\\n    //total POOL frozen in contract\\r\\n    function totalFrozenTokenBalance()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return totalFrozen;\\r\\n    }\\r\\n\\r\\n    //pool balance of caller\\r\\n    function tokenBalance()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return balanceOf(msg.sender);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract HEXPOOL is POOL, PoolEvents {\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////CONTRACT SETUP///////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    HEX hexInterface;\\r\\n\\r\\n    //HEXPOOL\\r\\n    address payable constant hexAddress = 0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39;\\r\\n\\r\\n    address payable devAddress;//set in constructor\\r\\n    address payable constant devAddress2 = 0xD30BC4859A79852157211E6db19dE159673a67E2;\\r\\n\\r\\n    uint constant fee = 100; //1%;\\r\\n    uint constant devFee = 2; // 50% of 1% @ 0.5%;\\r\\n    uint constant devFee2 = 4; // 25% of 1% @ 0.25%;\\r\\n    uint constant refFee = 4; // 25% of 1% @ 0.25%; - 100% goes to buddyDiv if no ref, 50% if ref;\\r\\n\\r\\n    uint public last_pool_entry_id;// pool entry id\\r\\n    uint public last_pool_id;// pool id\\r\\n    uint public last_stake_id;// stake id\\r\\n\\r\\n    uint public minEntryHearts;//minimum entry value\\r\\n\\r\\n    mapping (address =\\u003e UserInfo) public users;\\r\\n    mapping (uint =\\u003e EntryInfo) public entries;\\r\\n    mapping (uint =\\u003e PoolInfo) public pools;\\r\\n\\r\\n    mapping (uint =\\u003e uint) internal poolUserCount;\\r\\n    mapping (uint =\\u003e uint[]) internal poolEntryIds;\\r\\n    mapping (address =\\u003e uint[]) internal userEntryIds;\\r\\n\\r\\n    bool locked;\\r\\n    bool ready;\\r\\n\\r\\n    struct UserInfo {\\r\\n        uint     totalHeartsEntered;\\r\\n        address  userAddress;\\r\\n    }\\r\\n\\r\\n    struct EntryInfo {\\r\\n        uint     heartValue;\\r\\n        uint     poolId;\\r\\n        uint     entryId;\\r\\n        address payable userAddress;\\r\\n        address payable refferer;\\r\\n    }\\r\\n\\r\\n    struct PoolInfo {\\r\\n        uint     poolStakeThreshold;//hearts\\r\\n        uint     poolStakeDayLength;\\r\\n        uint     poolValue;//hearts\\r\\n        uint     poolId;\\r\\n        uint     poolType;\\r\\n        mapping  (address =\\u003e bool) poolParticipant;\\r\\n        mapping  (address =\\u003e uint) userHeartValue;\\r\\n        uint     stakeId;\\r\\n        uint40   hexStakeId;\\r\\n        bool     isStaking;\\r\\n        bool     isActive;\\r\\n        uint256  poolStakeStartTimestamp;\\r\\n        uint     stakeValue;\\r\\n        uint     stakeProfit;\\r\\n        bool     stakeEnded;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == devAddress, \\\u0022notOwner\\\u0022);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier canEnter(uint id, uint hearts) {\\r\\n        require(isPoolActive(id), \\\u0022cannot enter, poolId not active\\\u0022);\\r\\n        require(id \\u003c= last_pool_id, \\\u0022Error: poolId out of range\\\u0022);\\r\\n        require(hearts \\u003e minEntryHearts, \\\u0022Error: value must be greater than minEntryHearts\\\u0022);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isReady {\\r\\n        require(ready, \\\u0022cannot enter, pools not initialized\\\u0022);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier synchronized {\\r\\n        require(!locked, \\\u0022Sync lock\\\u0022);\\r\\n        locked = true;\\r\\n        _;\\r\\n        locked = false;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        devAddress = msg.sender;\\r\\n        hexInterface = HEX(hexAddress);\\r\\n        initializePools();\\r\\n    }\\r\\n\\r\\n    function() external payable {\\r\\n        require(false); //refunds any eth accidently sent to contract;\\r\\n    }\\r\\n\\r\\n    function initializePools()\\r\\n        internal\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(!ready, \\\u0022cannot reinitialize\\\u0022);\\r\\n        //create one of each pool on deployment\\r\\n        for(uint i = 0; i \\u003c 3; i\u002B\u002B){\\r\\n            newPool(i, 0, address(0));\\r\\n        }\\r\\n        setMinEntry(100000000000);//1000 HEX @ contract launch, may change dependant on price.\\r\\n        ready = true;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////HEXPOOL CORE//////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //creates a new pool - called on initializePools and when a poolValue reachs its poolStakeThreshold\\r\\n    function newPool(uint poolType, uint remainderHearts, address payable ref)\\r\\n       internal\\r\\n       returns (bool)\\r\\n    {\\r\\n        uint threshold;\\r\\n        uint dayLength;\\r\\n\\r\\n        if(poolType == 0){\\r\\n            threshold = 15000000000000000;//150M BPB @ 10% - 36 DAYS\\r\\n            dayLength = 36;//~1 month\\r\\n        }\\r\\n        else if(poolType == 1){\\r\\n            threshold = 15000000000000000;//150M BPB @ 10% - 365 DAYS\\r\\n            dayLength = 365;//1 year\\r\\n        }\\r\\n        else if(poolType == 2){\\r\\n            threshold = 15000000000000000;//150M BPB @ 10% - 3650 DAYS\\r\\n            dayLength = 3650;//10 years (max rewards)\\r\\n        }\\r\\n        else{\\r\\n            revert(\\\u0022invalid poolType\\\u0022);\\r\\n        }\\r\\n        uint id = _next_pool_id();\\r\\n        PoolInfo storage pool = pools[id];\\r\\n        pool.poolStakeThreshold = threshold;//hearts\\r\\n        pool.poolStakeDayLength = dayLength;\\r\\n        pool.poolValue = remainderHearts;//hearts\\r\\n        pool.poolId = id;\\r\\n        pool.poolType = poolType;\\r\\n        pool.isActive = true;\\r\\n        if(remainderHearts \\u003e 0){//update pool, user and entry data as the new pool now has 1 participant\\r\\n            poolUserCount[id]\u002B\u002B;\\r\\n            pool.poolParticipant[msg.sender] = true;\\r\\n            pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].add(remainderHearts);\\r\\n            //user info\\r\\n            updateUserData(remainderHearts);\\r\\n            //entry info\\r\\n            updateEntryData(remainderHearts, id, ref);\\r\\n        }\\r\\n        pools[id] = pool;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //enters pool - transfers HEX from user to contract - approval needed\\r\\n    function enterPool(uint hearts, uint poolId, address payable ref)\\r\\n        internal\\r\\n        returns(bool)\\r\\n    {\\r\\n        PoolInfo storage pool = pools[poolId];\\r\\n        require(hearts \\u003c= pool.poolStakeThreshold, \\\u0022amount over threshold - only 1 new pool to be created per tx\\\u0022);\\r\\n        require(!pool.isStaking, \\\u0022pool is staking\\\u0022);\\r\\n        //calc amounts\\r\\n        uint _fee = hearts.div(fee);\\r\\n        uint _devFee = _fee.div(devFee);\\r\\n        uint _devFee2 = _fee.div(devFee2);\\r\\n        uint _refFee = _fee.div(refFee);\\r\\n        uint _hearts = hearts.sub(_fee);\\r\\n        pool.poolValue = pool.poolValue.add(_hearts);//increment pool value with heart value after fees\\r\\n        if(!pool.poolParticipant[msg.sender]){\\r\\n            pool.poolParticipant[msg.sender] = true;\\r\\n            poolUserCount[poolId]\u002B\u002B;\\r\\n        }\\r\\n         //TOTAL amount of hearts this user has input in THIS pool after fees (EntryInfo for individual pool entries)\\r\\n        pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].add(_hearts);\\r\\n        //buddy divs\\r\\n        if(buddyDiv \\u003e 0){\\r\\n            require(hexInterface.transfer(msg.sender, buddyDiv), \\\u0022Transfer failed\\\u0022);//send hex as buddy div to user\\r\\n        }\\r\\n        if(ref == address(0)){//no ref\\r\\n            //hex refFee to buddyDivs\\r\\n            buddyDiv = _refFee;\\r\\n        }\\r\\n        else{//ref\\r\\n            //hex refFee to ref\\r\\n            buddyDiv = _refFee.div(2);\\r\\n            require(hexInterface.transferFrom(msg.sender, ref, _refFee.div(2)), \\\u0022Ref transfer failed\\\u0022);//send hex to refferer\\r\\n        }\\r\\n        //send\\r\\n        require(hexInterface.transferFrom(msg.sender, address(this), _hearts.add(buddyDiv)), \\\u0022Transfer failed\\\u0022);//send hex from user to contract \u002B buddyDivs to remain in contract\\r\\n        require(hexInterface.transferFrom(msg.sender, devAddress, _devFee), \\\u0022Dev1 transfer failed\\\u0022);//send hex to dev\\r\\n        require(hexInterface.transferFrom(msg.sender, devAddress2, _devFee2), \\\u0022Dev2 transfer failed\\\u0022);//send hex to dev2\\r\\n        //check for pool overflow\\r\\n        if(pool.poolValue \\u003e pool.poolStakeThreshold){\\r\\n            uint remainderHearts = pool.poolValue.sub(pool.poolStakeThreshold);//get remainder\\r\\n            //user info\\r\\n            updateUserData(_hearts.sub(remainderHearts));//remainder to be rolled to next pool\\r\\n            //entry info\\r\\n            updateEntryData(_hearts.sub(remainderHearts), pool.poolId, ref);//remainder to be rolled to next pool\\r\\n            pool.poolValue = pool.poolStakeThreshold;//set as max\\r\\n             //Back out the remainder value that is spilling into the next pool\\r\\n            pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].sub(remainderHearts);\\r\\n            require(startStake(poolId, pool), \\\u0022Error: could not start stake\\\u0022);\\r\\n            require(newPool(pool.poolType, remainderHearts, ref), \\\u0022Error: could not create new pool\\\u0022);//create new pool with remainder\\r\\n        }\\r\\n        else if(pool.poolValue == pool.poolStakeThreshold){\\r\\n            //user info\\r\\n            updateUserData(_hearts);\\r\\n            //entry info\\r\\n            updateEntryData(_hearts, pool.poolId, ref);\\r\\n            require(startStake(poolId, pool), \\\u0022Error: could not start stake\\\u0022);\\r\\n            require(newPool(pool.poolType, 0, ref), \\\u0022Error: could not create new pool\\\u0022);//new pool no remainder\\r\\n        }\\r\\n        else{\\r\\n            //user info\\r\\n            updateUserData(_hearts);\\r\\n            //entry info\\r\\n            updateEntryData(_hearts, pool.poolId, ref);\\r\\n        }\\r\\n        //mint bonus POOL tokens relative to HEX amount before fees\\r\\n        require(mintPool(hearts), \\\u0022Error: could not mint tokens\\\u0022);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //starts staking poolStakeThreshold to the HEX contract\\r\\n    function startStake(uint poolId, PoolInfo storage pool)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(pool.poolValue == pool.poolStakeThreshold, \\\u0022Stake amount incorrect\\\u0022);\\r\\n        uint newStakedHearts = pool.poolStakeThreshold;\\r\\n        uint newStakedDays = pool.poolStakeDayLength;\\r\\n        hexInterface.stakeStart(newStakedHearts, newStakedDays);\\r\\n        uint hexStakeIndex = hexInterface.stakeCount(address(this)).sub(1);//get the most recent stakeIndex\\r\\n        SStore memory stake = getStakeByIndex(address(this), hexStakeIndex); //get stake from address and stakeindex\\r\\n        //set pool stake id info\\r\\n        pool.hexStakeId = stake.stakeId;\\r\\n        pool.stakeId = last_stake_id;\\r\\n        pool.poolStakeStartTimestamp = now;\\r\\n        pool.isActive = false;\\r\\n        pool.isStaking = true;\\r\\n        _next_stake_id();\\r\\n        emit PoolStartStake(\\r\\n            newStakedHearts,\\r\\n            newStakedDays,\\r\\n            poolId,\\r\\n            stake.stakeId\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //end a pool stake - cannot emergency unstake - needs testing\\r\\n    function endStake(uint poolId)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(poolId \\u003c= last_pool_id, \\\u0022Error: poolId out of range\\\u0022);\\r\\n        PoolInfo storage pool = pools[poolId];\\r\\n        require(pool.isStaking, \\\u0022Error: pool is not yet staked, or has already ended staking\\\u0022);\\r\\n        require(isPoolStakeFinished(poolId), \\\u0022Error: cannot early unstake\\\u0022);\\r\\n\\r\\n        uint256 oldBalance = getContractBalance();\\r\\n        //find the stake index then\\r\\n        //end stake\\r\\n        hexInterface.stakeEnd(getStakeIndexById(address(this), pool.hexStakeId), pool.hexStakeId);\\r\\n        pool.isStaking = false;\\r\\n        pool.stakeEnded = true;\\r\\n        //calc stakeValue and stakeProfit\\r\\n        uint256 stakeValue = getContractBalance().sub(oldBalance);\\r\\n        pool.stakeValue = stakeValue;\\r\\n        pool.stakeProfit = stakeValue.sub(pool.poolStakeThreshold);\\r\\n        emit PoolEndStake(\\r\\n            pool.stakeProfit,\\r\\n            pool.poolValue,\\r\\n            pool.poolStakeDayLength,\\r\\n            pool.poolId,\\r\\n            pool.hexStakeId\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //withdraws any staking rewards - or ends a stake if finished but not yet unstaked\\r\\n    function withdrawPoolRewards(uint poolId)\\r\\n        internal\\r\\n        returns(bool)\\r\\n    {\\r\\n        PoolInfo storage pool = pools[poolId];\\r\\n        require(pool.poolValue \\u003e 0, \\\u0022pool rewards have been drained\\\u0022);\\r\\n        require(pools[poolId].userHeartValue[msg.sender] \\u003e 0, \\\u0022you have no share in this pool\\\u0022);\\r\\n        if(!pool.stakeEnded){\\r\\n            endStake(poolId);\\r\\n        }\\r\\n        uint rewards = getWithdrawableRewards(poolId);//calculate pool share\\r\\n        pool.poolValue = pool.poolValue.sub(pool.userHeartValue[msg.sender]);//reduce pool value\\r\\n        pool.userHeartValue[msg.sender] = 0;//user has withdrawn rewards from pool\\r\\n        if(pool.poolValue == 0){\\r\\n            delete pools[poolId];//delete pool if empty\\r\\n        }\\r\\n        require(hexInterface.transfer(msg.sender, rewards), \\\u0022Transfer failed\\\u0022);//transfer users share\\r\\n        emit Withdrawal(msg.sender, rewards);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //get any withdrawable staking rewards of caller\\r\\n    function getWithdrawableRewards(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns (uint)\\r\\n    {\\r\\n        PoolInfo storage pool = pools[poolId];\\r\\n        require(pool.stakeEnded, \\\u0022pool stake has not yet finished\\\u0022);\\r\\n        if(pool.userHeartValue[msg.sender] == 0){\\r\\n            return 0;\\r\\n        }\\r\\n        uint stakeWithdrawable = pool.stakeValue.mul(pool.userHeartValue[msg.sender]).div(pool.poolStakeThreshold);//withdrawable rewards\\r\\n        return stakeWithdrawable;\\r\\n    }\\r\\n\\r\\n    //exits pool of entry by entryId\\r\\n    function exitPool(uint entryId)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        EntryInfo memory entry = entries[entryId];\\r\\n        require(msg.sender == entry.userAddress, \\\u0022not entry owner, or already exited\\\u0022);\\r\\n        PoolInfo storage pool = pools[entry.poolId];\\r\\n        require(pool.poolParticipant[msg.sender], \\\u0022you are not a pool participant\\\u0022);\\r\\n        require(!pool.isStaking, \\\u0022pool is staking, cannot exit\\\u0022);\\r\\n        users[msg.sender].totalHeartsEntered = users[msg.sender].totalHeartsEntered.sub(entry.heartValue);\\r\\n        pool.poolValue = pool.poolValue.sub(entry.heartValue); //reduce pool value\\r\\n        pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].sub(entry.heartValue);//reduce users pool share\\r\\n        //remove user from pool data if 0 pool share\\r\\n        if(pool.userHeartValue[msg.sender] == 0){\\r\\n            pool.poolParticipant[msg.sender] = false;\\r\\n            poolUserCount[entry.poolId]--;\\r\\n        }\\r\\n        delete entries[entryId];\\r\\n        //calc fee amount\\r\\n        uint _fee = entry.heartValue.div(fee);\\r\\n        uint _devFee = _fee.div(devFee);\\r\\n        uint _devFee2 = _fee.div(devFee2);\\r\\n        uint _refFee = _fee.div(refFee);\\r\\n        uint _hearts = entry.heartValue.sub(_fee);\\r\\n        \\r\\n        if(buddyDiv \\u003e 0){\\r\\n            require(hexInterface.transfer(devAddress, buddyDiv.div(2)), \\\u0022Transfer failed\\\u0022);//send hex as buddy div to dev1 as penalty for user exiting pool\\r\\n            require(hexInterface.transfer(devAddress2, buddyDiv.div(2)), \\\u0022Transfer failed\\\u0022);//send hex as buddy div to dev2 as penalty for user exiting pool\\r\\n        }\\r\\n        if(entry.refferer == address(0)){//no ref\\r\\n            //set new buddyDivs as hex refFee\\r\\n            buddyDiv = _refFee;\\r\\n        }\\r\\n        else{//ref\\r\\n            //set new buddyDivs as hex refFee / 2\\r\\n            buddyDiv = _refFee.div(2);\\r\\n            require(hexInterface.transfer(entry.refferer, _refFee.div(2)), \\\u0022Ref transfer failed\\\u0022);//send hex to refferer\\r\\n        }\\r\\n        //send\\r\\n        require(hexInterface.transfer(msg.sender, _hearts), \\\u0022Transfer failed\\\u0022);//send hex from contract to user\\r\\n        require(hexInterface.transfer(devAddress, _devFee), \\\u0022Dev1 transfer failed\\\u0022);//send hex to dev\\r\\n        require(hexInterface.transfer(devAddress2, _devFee2), \\\u0022Dev2 transfer failed\\\u0022);//send hex to dev2\\r\\n        //events\\r\\n        emit PoolExit(\\r\\n            entry.userAddress,\\r\\n            entry.heartValue,\\r\\n            entry.entryId,\\r\\n            pool.poolId\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //updates user data\\r\\n    function updateUserData(uint hearts)\\r\\n        internal\\r\\n    {\\r\\n        UserInfo storage user = users[msg.sender];\\r\\n        user.totalHeartsEntered = user.totalHeartsEntered.add(hearts);//total amount of hearts deposited by this user after fees\\r\\n        user.userAddress = msg.sender;\\r\\n    }\\r\\n\\r\\n    //updates entry data\\r\\n    function updateEntryData(uint hearts, uint poolId, address payable ref)\\r\\n        internal\\r\\n    {\\r\\n        uint _entryID = _next_pool_entry_id();\\r\\n        userEntryIds[msg.sender].push(_entryID);//update userEntryIds\\r\\n        poolEntryIds[poolId].push(_entryID);//update poolEntryIds\\r\\n        EntryInfo memory entry;\\r\\n        entry.heartValue = hearts;//amount of hearts deposited in this entry after fees\\r\\n        entry.poolId = poolId;//poolId this entry has deposited to\\r\\n        entry.entryId = _entryID;\\r\\n        entry.userAddress = msg.sender;\\r\\n        entry.refferer = ref;\\r\\n        entries[_entryID] = entry;//update entry data\\r\\n        emit PoolEntry(\\r\\n            entry.userAddress,\\r\\n            entry.heartValue,\\r\\n            entry.entryId,\\r\\n            poolId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //get next entry id\\r\\n    function _next_pool_entry_id()\\r\\n        internal\\r\\n        returns (uint)\\r\\n    {\\r\\n        last_pool_entry_id\u002B\u002B;\\r\\n        return last_pool_entry_id;\\r\\n    }\\r\\n\\r\\n    //get next pool id\\r\\n    function _next_pool_id()\\r\\n        internal\\r\\n        returns (uint)\\r\\n    {\\r\\n        last_pool_id\u002B\u002B;\\r\\n        return last_pool_id;\\r\\n    }\\r\\n\\r\\n    //get next stake id\\r\\n    function _next_stake_id()\\r\\n        internal\\r\\n        returns (uint)\\r\\n    {\\r\\n        last_stake_id\u002B\u002B;\\r\\n        return last_stake_id;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////PUBLIC FACING HEXPOOL////////////////////\\r\\n    ////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //enter any pool that isActive\\r\\n    function EnterPool(uint _hearts, uint _poolId, address payable _ref)\\r\\n        public\\r\\n        canEnter(_poolId, _hearts)\\r\\n        synchronized\\r\\n    {\\r\\n        require(enterPool(_hearts, _poolId, _ref), \\\u0022Error: could not enter pool\\\u0022);\\r\\n    }\\r\\n\\r\\n    //withdraw funds from pool by entryId - pool cannot be already staking\\r\\n    function ExitPool(uint _entryId)\\r\\n        public\\r\\n        synchronized\\r\\n    {\\r\\n        require(exitPool(_entryId), \\\u0022Error: could not exit pool\\\u0022);\\r\\n    }\\r\\n\\r\\n    //ends a staked pool\\r\\n    function EndPoolStake(uint _poolId)\\r\\n        public\\r\\n        synchronized\\r\\n    {\\r\\n        require(endStake(_poolId), \\\u0022Error: could not end stake\\\u0022);\\r\\n    }\\r\\n\\r\\n    //withdraws HEX staking rewards\\r\\n    function WithdrawHEX(uint _poolId)\\r\\n        public\\r\\n        synchronized\\r\\n    {\\r\\n        require(withdrawPoolRewards(_poolId), \\\u0022Error: could not withdraw rewards\\\u0022);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////\\r\\n    ////////////VIEW ONLY/////////////////////\\r\\n    //////////////////////////////////////////\\r\\n\\r\\n    //only an active pool can be entered or exited\\r\\n    function isPoolActive(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        isReady\\r\\n        returns(bool)\\r\\n    {\\r\\n        return pools[poolId].isActive;\\r\\n    }\\r\\n\\r\\n    //\\r\\n    function isPoolStaking(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return pools[poolId].isStaking;\\r\\n    }\\r\\n\\r\\n    //\\r\\n    function isPoolStakeFinished(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        //add 1 to stakeDayLength to account for stake pending time\\r\\n        return pools[poolId].poolStakeStartTimestamp.add((pools[poolId].poolStakeDayLength.add(1)).mul(86400)) \\u003c= now;\\r\\n    }\\r\\n\\r\\n    //\\r\\n    function isPoolStakeEnded(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return pools[poolId].stakeEnded;\\r\\n    }\\r\\n\\r\\n    //general user info\\r\\n    function getUserInfo(address addr)\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n        uint    totalHeartsEntered,\\r\\n        uint[] memory _entryIds,\\r\\n        address userAddress\\r\\n        )\\r\\n    {\\r\\n        return(users[addr].totalHeartsEntered, userEntryIds[addr], users[addr].userAddress);\\r\\n    }\\r\\n\\r\\n    //general entry info\\r\\n    function getEntryInfo(uint entryId)\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n        uint     heartValue,\\r\\n        uint     poolId,\\r\\n        address payable userAddress,\\r\\n        address payable refferer\\r\\n        )\\r\\n    {\\r\\n        return(entries[entryId].heartValue, entries[entryId].poolId, entries[entryId].userAddress, entries[entryId].refferer);\\r\\n    }\\r\\n\\r\\n    //general pool info\\r\\n    function getPoolInfo(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n        uint     poolStakeThreshold,//hearts\\r\\n        uint     poolStakeDayLength,\\r\\n        uint     poolValue,//hearts\\r\\n        uint     poolType,\\r\\n        bool     isStaking,\\r\\n        uint256  poolStakeStartTimestamp,\\r\\n        bool     stakeEnded\\r\\n        )\\r\\n    {\\r\\n        return(\\r\\n            pools[poolId].poolStakeThreshold,\\r\\n            pools[poolId].poolStakeDayLength,\\r\\n            pools[poolId].poolValue,\\r\\n            pools[poolId].poolType,\\r\\n            pools[poolId].isStaking,\\r\\n            pools[poolId].poolStakeStartTimestamp,\\r\\n            pools[poolId].stakeEnded\\r\\n            );\\r\\n    }\\r\\n\\r\\n    //returns all entryIds of a pool\\r\\n    function getPoolEntryIds(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(uint[] memory)\\r\\n    {\\r\\n        return poolEntryIds[poolId];\\r\\n    }\\r\\n\\r\\n    //return vital stake params\\r\\n    function getPoolStakeInfo(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(uint stakeId, uint hexStakeIndex, uint40 hexStakeId)\\r\\n    {\\r\\n        return(pools[poolId].stakeId, getStakeIndexById(address(this), pools[poolId].hexStakeId), pools[poolId].hexStakeId);\\r\\n    }\\r\\n\\r\\n    //returns amount of users by address in a pool\\r\\n    function getPoolUserCount(uint poolId)\\r\\n        public\\r\\n        view\\r\\n        returns(uint)\\r\\n    {\\r\\n        return poolUserCount[poolId];\\r\\n    }\\r\\n\\r\\n    //is address a user of pool\\r\\n    function isPoolParticipant(uint id, address addr)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n       return pools[id].poolParticipant[addr];\\r\\n    }\\r\\n\\r\\n    //returns total hearts a user owns in pool\\r\\n    function getUserHeartValue(uint id, address addr)\\r\\n        public\\r\\n        view\\r\\n        returns(uint)\\r\\n    {\\r\\n       return pools[id].userHeartValue[addr];\\r\\n    }\\r\\n\\r\\n    //returns contract HEX balance\\r\\n    function getContractBalance()\\r\\n        public\\r\\n        view\\r\\n        returns(uint)\\r\\n    {\\r\\n        return hexInterface.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    //////////////////MUTABLE//////////////////////\\r\\n    //////////////////////////////////////////////\\r\\n\\r\\n    function setMinEntry(uint hearts)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        minEntryHearts = hearts;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    ///////////////////HEX UTILS///////////////////\\r\\n    ///////////////////////////////////////////////\\r\\n    //credits to kyle bahr @ https://gist.github.com/kbahr/80e61ab761053849f7fdc6226b85a354\\r\\n\\r\\n    struct SStore {\\r\\n        uint40 stakeId;\\r\\n        uint72 stakedHearts;\\r\\n        uint72 stakeShares;\\r\\n        uint16 lockedDay;\\r\\n        uint16 stakedDays;\\r\\n        uint16 unlockedDay;\\r\\n        bool isAutoStake;\\r\\n    }\\r\\n\\r\\n    struct DailyDataCache {\\r\\n        uint256 dayPayoutTotal;\\r\\n        uint256 dayStakeSharesTotal;\\r\\n        uint256 dayUnclaimedSatoshisTotal;\\r\\n    }\\r\\n    uint256 private constant HEARTS_UINT_SHIFT = 72;\\r\\n    uint256 private constant HEARTS_MASK = (1 \\u003c\\u003c HEARTS_UINT_SHIFT) - 1;\\r\\n    uint256 private constant SATS_UINT_SHIFT = 56;\\r\\n    uint256 private constant SATS_MASK = (1 \\u003c\\u003c SATS_UINT_SHIFT) - 1;\\r\\n\\r\\n    function decodeDailyData(uint256 encDay)\\r\\n    private\\r\\n    pure\\r\\n    returns (DailyDataCache memory)\\r\\n    {\\r\\n        uint256 v = encDay;\\r\\n        uint256 payout = v \\u0026 HEARTS_MASK;\\r\\n        v = v \\u003e\\u003e HEARTS_UINT_SHIFT;\\r\\n        uint256 shares = v \\u0026 HEARTS_MASK;\\r\\n        v = v \\u003e\\u003e HEARTS_UINT_SHIFT;\\r\\n        uint256 sats = v \\u0026 SATS_MASK;\\r\\n        return DailyDataCache(payout, shares, sats);\\r\\n    }\\r\\n\\r\\n    function interestForRange(DailyDataCache[] memory dailyData, uint256 myShares)\\r\\n    private\\r\\n    pure\\r\\n    returns (uint256)\\r\\n    {\\r\\n        uint256 len = dailyData.length;\\r\\n        uint256 total = 0;\\r\\n        for(uint256 i = 0; i \\u003c len; i\u002B\u002B){\\r\\n            total \u002B= interestForDay(dailyData[i], myShares);\\r\\n        }\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    function interestForDay(DailyDataCache memory dayObj, uint256 myShares)\\r\\n    private\\r\\n    pure\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return myShares * dayObj.dayPayoutTotal / dayObj.dayStakeSharesTotal;\\r\\n    }\\r\\n\\r\\n    function getDataRange(uint256 b, uint256 e)\\r\\n    private\\r\\n    view\\r\\n    returns (DailyDataCache[] memory)\\r\\n    {\\r\\n        uint256[] memory dataRange = hexInterface.dailyDataRange(b, e);\\r\\n        uint256 len = dataRange.length;\\r\\n        DailyDataCache[] memory data = new DailyDataCache[](len);\\r\\n        for(uint256 i = 0; i \\u003c len; i\u002B\u002B){\\r\\n            data[i] = decodeDailyData(dataRange[i]);\\r\\n        }\\r\\n        return data;\\r\\n    }\\r\\n\\r\\n    function getLastDataDay()\\r\\n    private\\r\\n    view\\r\\n    returns(uint256)\\r\\n    {\\r\\n        uint256[13] memory globalInfo = hexInterface.globalInfo();\\r\\n        uint256 lastDay = globalInfo[4];\\r\\n        return lastDay;\\r\\n    }\\r\\n\\r\\n    function getInterestByStake(SStore memory s)\\r\\n    private\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        uint256 b = s.lockedDay;\\r\\n        uint256 e = getLastDataDay(); // ostensibly \\\u0022today\\\u0022\\r\\n\\r\\n        if (b \\u003e= e) {\\r\\n            //not started - error\\r\\n            return 0;\\r\\n        } else {\\r\\n            DailyDataCache[] memory data = getDataRange(b, e);\\r\\n            return interestForRange(data, s.stakeShares);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getInterestByStakeId(address addr, uint40 stakeId)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        SStore memory s = getStakeByStakeId(addr, stakeId);\\r\\n\\r\\n        return getInterestByStake(s);\\r\\n    }\\r\\n\\r\\n    function getTotalValueByStakeId(address addr, uint40 stakeId)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        SStore memory stake = getStakeByStakeId(addr, stakeId);\\r\\n\\r\\n        uint256 interest = getInterestByStake(stake);\\r\\n        return stake.stakedHearts \u002B interest;\\r\\n    }\\r\\n\\r\\n    function getStakeByIndex(address addr, uint256 idx)\\r\\n    private\\r\\n    view\\r\\n    returns (SStore memory)\\r\\n    {\\r\\n        uint40 stakeId;\\r\\n        uint72 stakedHearts;\\r\\n        uint72 stakeShares;\\r\\n        uint16 lockedDay;\\r\\n        uint16 stakedDays;\\r\\n        uint16 unlockedDay;\\r\\n        bool isAutoStake;\\r\\n\\r\\n        (stakeId,\\r\\n            stakedHearts,\\r\\n            stakeShares,\\r\\n            lockedDay,\\r\\n            stakedDays,\\r\\n            unlockedDay,\\r\\n            isAutoStake) = hexInterface.stakeLists(addr, idx);\\r\\n\\r\\n        return SStore(stakeId,\\r\\n                        stakedHearts,\\r\\n                        stakeShares,\\r\\n                        lockedDay,\\r\\n                        stakedDays,\\r\\n                        unlockedDay,\\r\\n                        isAutoStake);\\r\\n    }\\r\\n\\r\\n    function getStakeByStakeId(address addr, uint40 sid)\\r\\n    private\\r\\n    view\\r\\n    returns (SStore memory)\\r\\n    {\\r\\n\\r\\n        uint40 stakeId;\\r\\n        uint72 stakedHearts;\\r\\n        uint72 stakeShares;\\r\\n        uint16 lockedDay;\\r\\n        uint16 stakedDays;\\r\\n        uint16 unlockedDay;\\r\\n        bool isAutoStake;\\r\\n\\r\\n        uint256 stakeCount = hexInterface.stakeCount(addr);\\r\\n        for(uint256 i = 0; i \\u003c stakeCount; i\u002B\u002B){\\r\\n            (stakeId,\\r\\n            stakedHearts,\\r\\n            stakeShares,\\r\\n            lockedDay,\\r\\n            stakedDays,\\r\\n            unlockedDay,\\r\\n            isAutoStake) = hexInterface.stakeLists(addr, i);\\r\\n\\r\\n            if(stakeId == sid){\\r\\n                return SStore(stakeId,\\r\\n                                stakedHearts,\\r\\n                                stakeShares,\\r\\n                                lockedDay,\\r\\n                                stakedDays,\\r\\n                                unlockedDay,\\r\\n                                isAutoStake);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getStakeIndexById(address addr, uint40 sid)\\r\\n        private\\r\\n        view\\r\\n        returns (uint)\\r\\n    {\\r\\n        uint40 stakeId;\\r\\n        uint72 stakedHearts;\\r\\n        uint72 stakeShares;\\r\\n        uint16 lockedDay;\\r\\n        uint16 stakedDays;\\r\\n        uint16 unlockedDay;\\r\\n        bool isAutoStake;\\r\\n\\r\\n        uint256 stakeCount = hexInterface.stakeCount(addr);\\r\\n        for(uint256 i = 0; i \\u003c stakeCount; i\u002B\u002B){\\r\\n            (stakeId,\\r\\n            stakedHearts,\\r\\n            stakeShares,\\r\\n            lockedDay,\\r\\n            stakedDays,\\r\\n            unlockedDay,\\r\\n            isAutoStake) = hexInterface.stakeLists(addr, i);\\r\\n\\r\\n            if(stakeId == sid){\\r\\n                return i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022IERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.13;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\n \\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves \u0060amount\u0060 tokens from the caller\\u0027s account to \u0060recipient\u0060.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\\r\\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\\r\\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\\r\\n     * another (\u0060to\u0060).\\r\\n     *\\r\\n     * Note that \u0060value\u0060 may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\\r\\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\u0022},\u0022SafeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.13;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\u0022}}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022stakeProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dayLength\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hexStakeId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PoolEndStake\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022entryId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PoolEntry\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022entryId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PoolExit\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022dayLength\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hexStakeId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PoolStartStake\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TokenFreeze\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TokenUnfreeze\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022user\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Withdrawal\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022EndPoolStake\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_hearts\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022_ref\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022EnterPool\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_entryId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ExitPool\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amt\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022FreezeTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amt\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022UnfreezeTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022WithdrawHEX\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022buddyDiv\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022subtractedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022entries\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022entryId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022refferer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getContractBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022entryId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getEntryInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022heartValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address payable\u0022,\u0022name\u0022:\u0022refferer\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint40\u0022,\u0022name\u0022:\u0022stakeId\u0022,\u0022type\u0022:\u0022uint40\u0022}],\u0022name\u0022:\u0022getInterestByStakeId\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getPoolEntryIds\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getPoolInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeThreshold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeDayLength\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolType\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isStaking\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeStartTimestamp\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022stakeEnded\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getPoolStakeInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022stakeId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hexStakeIndex\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint40\u0022,\u0022name\u0022:\u0022hexStakeId\u0022,\u0022type\u0022:\u0022uint40\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getPoolUserCount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint40\u0022,\u0022name\u0022:\u0022stakeId\u0022,\u0022type\u0022:\u0022uint40\u0022}],\u0022name\u0022:\u0022getTotalValueByStakeId\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getUserHeartValue\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getUserInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalHeartsEntered\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256[]\u0022,\u0022name\u0022:\u0022_entryIds\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getWithdrawableRewards\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022addedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isPoolActive\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isPoolParticipant\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isPoolStakeEnded\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isPoolStakeFinished\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022isPoolStaking\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022last_pool_entry_id\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022last_pool_id\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022last_stake_id\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minEntryHearts\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022pools\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeThreshold\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeDayLength\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolType\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022stakeId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint40\u0022,\u0022name\u0022:\u0022hexStakeId\u0022,\u0022type\u0022:\u0022uint40\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isStaking\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isActive\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022poolStakeStartTimestamp\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022stakeValue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022stakeProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022stakeEnded\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hearts\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMinEntry\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022tokenFrozenBalances\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalFrozen\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalFrozenTokenBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022users\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalHeartsEntered\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022userAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"HEXPOOL","CompilerVersion":"v0.5.13\u002Bcommit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ca62bd23ffec7202a2b3a5f9ecfb53da305133c5723869fed8a369af68340e93"}]