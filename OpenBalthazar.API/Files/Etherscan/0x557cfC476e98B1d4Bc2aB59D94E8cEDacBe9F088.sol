[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \u0022user permissions\u0022.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if \u0060msg.sender\u0060 is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the \u0060onlyOwner\u0060\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen \u003Cremco@2\u03C0.com\u003E, Eenae \u003Calexey@mixbytes.io\u003E\r\n * @dev If you mark a function \u0060nonReentrant\u0060, you should also\r\n * mark it \u0060external\u0060.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter \u002B= 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\ncontract minterests is Ownable, ReentrancyGuard {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n    * @dev Represents the balance of a given user. The \u0027previous\u0027 field is used to store the\r\n    *      balance of the previous month in order to ponderate the bond\u0027s held time when updating\r\n    *      interests.\r\n    */\r\n  struct Balance {\r\n    // Total number of tokens held last month.\r\n    uint256 previousBalance;\r\n    // Total number of tokens held atm.\r\n    uint256 currentBalance;\r\n    // Total number of months these tokens have been held as of last month.\r\n    uint256 previousHolding;\r\n    // Total number of months these tokens have been held atm.\r\n    uint256 currentHolding;\r\n    // How much tokens has been bought through referral.\r\n    uint256 refereeBalance;\r\n  }\r\n\r\n  /**\r\n    * @dev Represents the claiming informations of an investor :\r\n    *      Whether he is claiming and in which currency he whishes to get paid.\r\n    */\r\n  struct Claiming {\r\n    // Tells wether investor is claiming its interests or not.\r\n    bool claiming;\r\n    // The currency type to be delivered, Euro or Ether.\r\n    bytes32 currency;\r\n    // The name of the bond partition to be redeemed.\r\n    bytes32 partitionNameInHex;\r\n  }\r\n\r\n  /**\r\n    * @dev Represents all about an investor.\r\n    */\r\n  struct Info {\r\n    // Calculated according to the balance, the held time, and the token type.\r\n    // It needs to be multiplied by 10 to get the \u20AC value.\r\n    uint256 balanceInterests;\r\n    // User status about his willing to claim its interests.\r\n    Claiming claimingInterests;\r\n    // User status about his willing to redeem its midterm or longterm bonds.\r\n    Claiming claimingBonds;\r\n    // Total of midterm bond tokens.\r\n    Balance mid;\r\n    // Total of longterm bond tokens.\r\n    Balance lng;\r\n    // Total of perpetual bond tokens.\r\n    Balance per;\r\n  }\r\n  // The state of each investor.\r\n  mapping (address =\u003E Info) investors;\r\n\r\n  // A list of \u0022superuser\u0022 that have control over a few methods of this contract,\r\n  // not a controller as in ERC1400. Used to allow third-parties to update an investor\u0027s\r\n  // infos.\r\n  mapping (address =\u003E bool) _isInterestsController;\r\n\r\n  // To what extent an interest unit can be divided (10^18).\r\n  uint256 DECIMALS = 1000000000000000000;\r\n\r\n\r\n  /**************************** MWT_interests events ********************************/\r\n\r\n  // Emitted when an investor invested through a referal link.\r\n  event Refered (\r\n    address indexed referer,\r\n    address indexed referee,\r\n    uint256 midAmount,\r\n    uint256 lngAmount,\r\n    uint256 perAmount\r\n  );\r\n\r\n  // Emitted when the balance of an investor which invested through\r\n  // a referal link is updated.\r\n  event ModifiedReferee (\r\n    address indexed investor,\r\n    uint256 midAmount,\r\n    uint256 lngAmount,\r\n    uint256 perAmount\r\n  );\r\n\r\n  // Emitted when an investor\u0027s interests balance is modified.\r\n  event UpdatedInterests (\r\n    address indexed investor,\r\n    uint256 interests\r\n  );\r\n\r\n  // Special case when a controller directly modified an investor\u0027s\r\n  // interests balance.\r\n  event ModifiedInterests (\r\n    address indexed investor,\r\n    uint256 value\r\n  );\r\n\r\n  // Emitted when an \u0022interest controller\u0022 is addded or removed.\r\n  event ModifiedInterestsController (\r\n    address indexed controller,\r\n    bool value\r\n  );\r\n\r\n  // Emitted when the claiming state of the investor is modified.\r\n  event ModifiedClaimingInterests (\r\n    address indexed investor,\r\n    bool claiming,\r\n    bytes32 currency\r\n  );\r\n\r\n  // Emitted when an user\u0027s interests are to be paid in euros by\r\n  // the third party.\r\n  event WillBePaidInterests (\r\n    address indexed investor,\r\n    uint256 balanceInterests\r\n  );\r\n\r\n  // Emitted when the bonds claiming status of an investor changed.\r\n  event ModifiedClaimingBonds (\r\n    address indexed investor,\r\n    bool claiming,\r\n    bytes32 currency,\r\n    bytes32 partitionNameInHex\r\n  );\r\n\r\n  // Emitted when an user\u0027s bonds are to be paid in euros by\r\n  // the third party.\r\n  event WillBePaidBonds (\r\n    address indexed investor,\r\n    bytes32 partitionNameInHex,\r\n    uint256 claimedAmount\r\n  );\r\n\r\n  // Emitted when the number of months an investor has been holding\r\n  // each bond is modified. It\u0027s modified when a month has passed,\r\n  // when the bonds are redeemed, or when set ad hoc by the contract\r\n  // owner.\r\n  event ModifiedHoldings (\r\n    address indexed investor,\r\n    uint256 midHolding,\r\n    uint256 lngHolding,\r\n    uint256 perHolding\r\n  );\r\n\r\n  // Emitted when an user redeems more bonds that we know he got. This\r\n  // seems sneaky, and actually it is : the bonds balance is on another\r\n  // contract (ERC1400) and we know about the actual balance of the\r\n  // investor when we call \u0060updateInterests\u0060, once each month...\r\n  event ModifiedHoldingsAndBalanceError (\r\n    address indexed investor,\r\n    bytes32 partitionNameInHex,\r\n    uint256 holding,\r\n    uint256 balance\r\n  );\r\n\r\n  // Emitted when an investor\u0027s interests balance is modified. It\u0027s\r\n  // modified when one month has passed, when bonds are redeemed, or\r\n  // when the balance is set ad hoc by the contract owner.\r\n  event ModifiedBalances (\r\n    address indexed investor,\r\n    uint256 midBalance,\r\n    uint256 lngBalance,\r\n    uint256 perBalance\r\n  );\r\n\r\n\r\n  /**************************** MWT_interests getters ********************************/\r\n\r\n  /**\r\n    * @dev Get the interests balance of an investor.\r\n    */\r\n  function interestsOf (address investor) external view returns (uint256) {\r\n    return (investors[investor].balanceInterests);\r\n  }\r\n\r\n  /**\r\n    * @dev Check whether an address is an \u0022interest controller\u0022 (a third-party superuser).\r\n    */\r\n  function isInterestsController (address _address) external view returns (bool) {\r\n    return (_isInterestsController[_address]);\r\n  }\r\n\r\n  /**\r\n    * @dev Check whether an investor is currently claiming its interests, and in which currency.\r\n    */\r\n  function isClaimingInterests (address investor) external view returns (bool, bytes32) {\r\n    return (investors[investor].claimingInterests.claiming, investors[investor].claimingInterests.currency);\r\n  }\r\n\r\n  /**\r\n    * @dev Check whether an investor is currently claiming its bonds, which one(s), and in which currency.\r\n    */\r\n  function isClaimingBonds (address investor) external view returns (bool, bytes32, bytes32) {\r\n    return (\r\n      investors[investor].claimingBonds.claiming,\r\n      investors[investor].claimingBonds.currency,\r\n      investors[investor].claimingBonds.partitionNameInHex\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Get the midterm bond infos of an investor.\r\n    */\r\n  function midtermBondInfosOf (address investor) external view returns (\r\n    uint256,\r\n    uint256,\r\n    uint256\r\n  ) {\r\n    return (\r\n      investors[investor].mid.currentBalance,\r\n      investors[investor].mid.currentHolding,\r\n      investors[investor].mid.refereeBalance\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Get the longterm bond infos of an investor.\r\n    */\r\n  function longtermBondInfosOf (address investor) external view returns (\r\n    uint256,\r\n    uint256,\r\n    uint256\r\n  ) {\r\n    return (\r\n      investors[investor].lng.currentBalance,\r\n      investors[investor].lng.currentHolding,\r\n      investors[investor].lng.refereeBalance\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Get the perpetual bond infos of an investor.\r\n    */\r\n  function perpetualBondInfosOf (address investor) external view returns (\r\n    uint256,\r\n    uint256,\r\n    uint256\r\n  ) {\r\n    return (\r\n      investors[investor].per.currentBalance,\r\n      investors[investor].per.currentHolding,\r\n      investors[investor].per.refereeBalance\r\n    );\r\n  }\r\n\r\n\r\n\r\n  /**************************** MWT_interests external functions ********************************/\r\n\r\n  /**\r\n    * @dev Allows an investor to express his desire to redeem his interests.\r\n    */\r\n  function claimInterests (bool claiming, bytes32 _currency) external {\r\n    bytes32 currency = _currency;\r\n    require (currency == \u0022eur\u0022 || currency == \u0022eth\u0022, \u0022A8\u0022); // Transfer Blocked - Token restriction\r\n    uint256 minimum = currency == \u0022eth\u0022 ? 10 : 100; // ie: 100 euros\r\n\r\n    require (investors[msg.sender].balanceInterests \u003E= minimum.mul(DECIMALS), \u0022A6\u0022); // Transfer Blocked - Receiver not eligible\r\n    if (!claiming) {\r\n      currency = \u0022\u0022;\r\n    }\r\n\r\n    investors[msg.sender].claimingInterests.claiming = claiming;\r\n    investors[msg.sender].claimingInterests.currency = currency;\r\n\r\n    emit ModifiedClaimingInterests (msg.sender, claiming, currency);\r\n  }\r\n\r\n  /**\r\n    * @dev This function updates interests balance for several investors, so that they can be paid by the third party.\r\n    */\r\n  function payInterests (address[] calldata investorsAddresses) external nonReentrant {\r\n    require (_isInterestsController[msg.sender], \u0022A5\u0022); // Your are not allowed to perform this action\r\n\r\n    for (uint i = 0; i \u003C investorsAddresses.length; i\u002B\u002B) {\r\n      require (investors[investorsAddresses[i]].claimingInterests.claiming, \u0022A6\u0022); // This investor is not currently claiming\r\n\r\n      investors[investorsAddresses[i]].claimingInterests.claiming = false;\r\n      investors[investorsAddresses[i]].claimingInterests.currency = \u0022\u0022;\r\n\r\n      emit ModifiedClaimingInterests(investorsAddresses[i], false, \u0022\u0022);\r\n      emit WillBePaidInterests(investorsAddresses[i], investors[investorsAddresses[i]].balanceInterests);\r\n      investors[investorsAddresses[i]].balanceInterests = 0;\r\n      emit UpdatedInterests(investorsAddresses[i], investors[investorsAddresses[i]].balanceInterests);\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @dev Allows an investor to claim one of its bonds.\r\n    */\r\n  function claimBond (bool claiming, bytes32 _currency, bytes32 partition) external {\r\n    uint256 bondYear = 0;\r\n    uint256 bondMonth = 0;\r\n    bytes32 currency = _currency;\r\n\r\n    require (currency == \u0022eur\u0022 || currency == \u0022eth\u0022, \u0022A8\u0022); // Transfer Blocked - Token restriction\r\n    // This function is only for midterm and longterm bonds, which have a restricted period\r\n    // before they can be withdrawn.\r\n    // We use 3 utf8 characters in each partition to identify it (\u0022mid\u0022 for the midterm ones and \u0022lng\u0022 for the longterm\r\n    // ones).\r\n    require ((partition[0] == \u0022m\u0022 \u0026\u0026 partition[1] == \u0022i\u0022 \u0026\u0026 partition[2] == \u0022d\u0022)\r\n              || (partition[0] == \u0022l\u0022 \u0026\u0026 partition[1] == \u0022n\u0022 \u0026\u0026 partition[2] == \u0022g\u0022), \u0022A6\u0022);\r\n\r\n    // Retrieving the bond issuance date (YYYYMM) from an UTF8 encoded string.\r\n    for (uint i = 4; i \u003C 10; i\u002B\u002B) {\r\n      // Is it a valid UTF8 digit ? https://www.utf8-chartable.de/unicode-utf8-table.pl\r\n      require ((uint8(partition[i]) \u003E= 48) \u0026\u0026 (uint8(partition[i]) \u003C= 57), \u0022A6\u0022); // Transfer Blocked - Receiver not eligible\r\n    }\r\n\r\n    // The first digit is the millenium.\r\n    bondYear = bondYear.add(uint256(uint8(partition[4])).sub(48).mul(1000));\r\n    // The second one is the century.\r\n    bondYear = bondYear.add(uint256(uint8(partition[5])).sub(48).mul(100));\r\n    // The third one is the \u003Cis there a name for a ten year period ?\u003E.\r\n    bondYear = bondYear.add(uint256(uint8(partition[6])).sub(48).mul(10));\r\n    // The fourth one is the year unit.\r\n    bondYear = bondYear.add(uint256(uint8(partition[7])).sub(48));\r\n    // Same for month, but it has only two digits.\r\n    bondMonth = bondMonth.add(uint256(uint8(partition[8])).sub(48).mul(10));\r\n    bondMonth = bondMonth.add(uint256(uint8(partition[9])).sub(48));\r\n\r\n    // Did the boutique decoding fucked up ? :-)\r\n    require (bondYear \u003E= 2000);\r\n    require (bondMonth \u003E= 0 \u0026\u0026 bondMonth \u003C= 12);\r\n\r\n    // Calculating the elapsed time since bond issuance\r\n    uint256 elapsedMonths = (bondYear * 12 \u002B bondMonth) - 23640;\r\n    uint256 currentTime;\r\n    assembly {\r\n      currentTime := timestamp()\r\n    }\r\n\r\n    // conversion of the current time (in sec) since epoch to months\r\n    uint256 currentMonth = currentTime / 2630016;\r\n    uint256 deltaMonths = currentMonth - elapsedMonths;\r\n\r\n    if (partition[0] == \u0022m\u0022 \u0026\u0026 partition[1] == \u0022i\u0022 \u0026\u0026 partition[2] == \u0022d\u0022) {\r\n      // This is a midterm bond, 5 years (60 months) should have passed.\r\n      require (deltaMonths \u003E= 60, \u0022A6\u0022); // Transfer Blocked - Receiver not eligible\r\n    } else if (partition[0] == \u0022l\u0022 \u0026\u0026 partition[1] == \u0022n\u0022 \u0026\u0026 partition[2] == \u0022g\u0022) {\r\n      // This is a longterm bond, 10 years (120 months) should have passed.\r\n      require (deltaMonths \u003E= 120, \u0022A6\u0022); // Transfer Blocked - Receiver not eligible\r\n    } else {\r\n      // This is __not__ possible !\r\n      assert (false);\r\n    }\r\n\r\n    investors[msg.sender].claimingBonds.claiming = claiming;\r\n    investors[msg.sender].claimingBonds.currency = claiming ? currency : bytes32(\u0022\u0022);\r\n    investors[msg.sender].claimingBonds.partitionNameInHex = claiming ? partition : bytes32(\u0022\u0022);\r\n\r\n    emit ModifiedClaimingBonds(\r\n      msg.sender,\r\n      claiming,\r\n      investors[msg.sender].claimingBonds.currency,\r\n      investors[msg.sender].claimingBonds.partitionNameInHex\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev This functions is called after the investor expressed its desire to redeem its bonds using the above\r\n    *      function (claimBonds). It needs to be called __before__ the third party pays the investor its bonds\r\n    *      in fiat.\r\n    *\r\n    * @param claimedAmount The balance of the investor on the redeemed partition.\r\n    */\r\n  function payBonds (address investor, uint256 claimedAmount) external nonReentrant {\r\n    require (_isInterestsController[msg.sender], \u0022A5\u0022); // You are not allowed to perform this action\r\n    require (investors[investor].claimingBonds.claiming, \u0022A6\u0022); // This investor is not currently claiming\r\n    investors[investor].claimingBonds.claiming = false;\r\n\r\n    // This function is only for midterm and longterm bonds, which have a restricted period\r\n    // before they can be withdrawn.\r\n    // We use 3 utf8 characters in each partition to identify it (\u0022mid\u0022 for the midterm ones and \u0022lng\u0022 for the longterm\r\n    // ones).\r\n    bytes32 partition = investors[investor].claimingBonds.partitionNameInHex;\r\n    require ((partition[0] == \u0022m\u0022 \u0026\u0026 partition[1] == \u0022i\u0022 \u0026\u0026 partition[2] == \u0022d\u0022)\r\n              || (partition[0] == \u0022l\u0022 \u0026\u0026 partition[1] == \u0022n\u0022 \u0026\u0026 partition[2] == \u0022g\u0022), \u0022A6\u0022);\r\n\r\n    // If all balances of a partition type are empty, we need to reset the \u0022holding\u0022 variable.\r\n    uint256 midLeft = 0;\r\n    uint256 lngLeft = 0;\r\n    bool emitHoldingEvent = false;\r\n    if (partition[0] == \u0022m\u0022 \u0026\u0026 partition[1] == \u0022i\u0022 \u0026\u0026 partition[2] == \u0022d\u0022) {\r\n      // For the midterm bonds.\r\n      if (claimedAmount \u003C investors[investor].mid.currentBalance) {\r\n        // All partitions of this type are not empty, no need to update holding.\r\n        midLeft = investors[investor].mid.currentBalance.sub(claimedAmount);\r\n      } else if (claimedAmount == investors[investor].mid.currentBalance) {\r\n        // The investor just withdrew all bonds from all partitions of this type.\r\n        // There is a possibility that an investor could refill the __exact same__ amount of the\r\n        // __same partition type__ before we update the interests, i.e. before the end of the month.\r\n        // Example: let\u0027s be an investor with the foolowing balances.\r\n        // mid_201001 = 200, mid_201801 = 200, currentBalance = mid_201001 \u002B mid_201801 = 400\r\n        // If this investor refills mid_201801 with 200, then mid_201801 = 400 = currentBalance.\r\n        // In that case, holding would be reseted whereas the investor still has 200 mid_201001\r\n        // Since this case should be extremly rare, we do not emit an error event.\r\n        investors[investor].mid.previousHolding = 0;\r\n        investors[investor].mid.currentHolding = 0;\r\n        emitHoldingEvent = true;\r\n      } else {\r\n        // This case should normally not occur.\r\n        // If the current holding is not up to date regarding token balances, it means that the\r\n        // investor refilled its balance after claiming bonds but before we update the interests.\r\n        // This period lasts at most one month.\r\n        // We reset holding and balance too (which could mess up adjustmentRate), but we emit an event.\r\n        emit ModifiedHoldingsAndBalanceError(\r\n          investor,\r\n          investors[investor].claimingBonds.partitionNameInHex,\r\n          investors[investor].mid.currentHolding,\r\n          investors[investor].mid.currentBalance\r\n        );\r\n        investors[investor].mid.previousHolding = 0;\r\n        investors[investor].mid.currentHolding = 0;\r\n        emitHoldingEvent = true;\r\n      }\r\n      // There are some units left only if the investor had other partitions of the same type.\r\n      investors[investor].mid.previousBalance = midLeft;\r\n      investors[investor].mid.currentBalance = midLeft;\r\n    } else if (partition[0] == \u0022l\u0022 \u0026\u0026 partition[1] == \u0022n\u0022 \u0026\u0026 partition[2] == \u0022g\u0022) {\r\n      if (claimedAmount \u003C investors[investor].lng.currentBalance) {\r\n        // All partitions of this type are not empty, no need to update holding.\r\n        lngLeft = investors[investor].lng.currentBalance.sub(claimedAmount);\r\n      } else if (claimedAmount == investors[investor].lng.currentBalance) {\r\n        // Same as in the precedent branch, but with longterm bonds.\r\n        investors[investor].lng.previousHolding = 0;\r\n        investors[investor].lng.currentHolding = 0;\r\n        emitHoldingEvent = true;\r\n      } else {\r\n        // See above for the details of this sneaky case..\r\n        emit ModifiedHoldingsAndBalanceError(\r\n          investor,\r\n          investors[investor].claimingBonds.partitionNameInHex,\r\n          investors[investor].lng.currentHolding,\r\n          investors[investor].lng.currentBalance\r\n        );\r\n        investors[investor].lng.previousHolding = 0;\r\n        investors[investor].lng.currentHolding = 0;\r\n        emitHoldingEvent = true;\r\n      }\r\n      // There are some units left only if the investor had other partitions of the same type.\r\n      investors[investor].lng.previousBalance = lngLeft;\r\n      investors[investor].lng.currentBalance = lngLeft;\r\n    } else {\r\n      // We should __not__ get here !\r\n      assert (false);\r\n    }\r\n\r\n    emit WillBePaidBonds(\r\n      investor,\r\n      partition,\r\n      claimedAmount\r\n    );\r\n\r\n    investors[investor].claimingBonds.currency = \u0022\u0022;\r\n    investors[investor].claimingBonds.partitionNameInHex = \u0022\u0022;\r\n    emit ModifiedClaimingBonds(\r\n      investor,\r\n      false,\r\n      investors[investor].claimingBonds.currency,\r\n      investors[investor].claimingBonds.partitionNameInHex\r\n    );\r\n\r\n    if (emitHoldingEvent) {\r\n      emit ModifiedHoldings(\r\n        investor,\r\n        investors[investor].mid.currentHolding,\r\n        investors[investor].lng.currentHolding,\r\n        investors[investor].per.currentHolding\r\n      );\r\n    }\r\n\r\n    emit ModifiedBalances(\r\n      investor,\r\n      investors[investor].mid.currentBalance,\r\n      investors[investor].lng.currentBalance,\r\n      investors[investor].per.currentBalance\r\n    );\r\n\r\n  }\r\n\r\n  /**\r\n    * @dev Set how much time an investor has been holding each bond.\r\n    */\r\n  function setHoldings (address investor, uint256 midHolding, uint256 lngHolding, uint256 perHolding) external onlyOwner {\r\n    investors[investor].mid.previousHolding = midHolding;\r\n    investors[investor].mid.currentHolding = midHolding;\r\n    investors[investor].lng.previousHolding = lngHolding;\r\n    investors[investor].lng.currentHolding = lngHolding;\r\n    investors[investor].per.previousHolding = perHolding;\r\n    investors[investor].per.currentHolding = perHolding;\r\n\r\n    emit ModifiedHoldings(investor, midHolding, lngHolding, perHolding);\r\n  }\r\n\r\n  /**\r\n    * @dev Set custom balances for an investor.\r\n    */\r\n  function setBalances (address investor, uint256 midBalance, uint256 lngBalance, uint256 perBalance) external onlyOwner {\r\n    investors[investor].mid.previousBalance = midBalance;\r\n    investors[investor].mid.currentBalance = midBalance;\r\n    investors[investor].lng.previousBalance = lngBalance;\r\n    investors[investor].lng.currentBalance = lngBalance;\r\n    investors[investor].per.previousBalance = perBalance;\r\n    investors[investor].per.currentBalance = perBalance;\r\n\r\n    emit ModifiedBalances(investor, midBalance, lngBalance, perBalance);\r\n  }\r\n\r\n  /**\r\n    * @dev Set the interests balance of an investor.\r\n    */\r\n  function setInterests (address investor, uint256 value) external onlyOwner {\r\n    investors[investor].balanceInterests = value;\r\n\r\n    emit ModifiedInterests(investor, value);\r\n    emit UpdatedInterests(investor, investors[investor].balanceInterests);\r\n  }\r\n\r\n  /**\r\n    * @dev Add or remove an address from the InterestsController mapping.\r\n    */\r\n  function setInterestsController (address controller, bool value) external onlyOwner {\r\n    _isInterestsController[controller] = value;\r\n\r\n    emit ModifiedInterestsController(controller, value);\r\n  }\r\n\r\n  /**\r\n    * @dev Increases the referer interests balance of a given amount.\r\n    *\r\n    * @param referer The address of the referal initiator\r\n    * @param referee The address of the referal consumer\r\n    * @param percent The percentage of interests earned by the referer\r\n    * @param midAmount How many mid term bonds the referee bought through this referal\r\n    * @param lngAmount How many long term bonds the referee bought through this referal\r\n    * @param perAmount How many perpetual tokens the referee bought through this referal\r\n    */\r\n  function updateReferralInfos (\r\n    address referer,\r\n    address referee,\r\n    uint256 percent,\r\n    uint256 midAmount,\r\n    uint256 lngAmount,\r\n    uint256 perAmount\r\n  ) external onlyOwner {\r\n    // Referee and/or referer address(es) is(/are) not valid.\r\n    require (referer != referee \u0026\u0026 referer != address(0) \u0026\u0026 referee != address(0), \u0022A7\u0022);\r\n    // The given percent parameter is not a valid percentage.\r\n    require (percent \u003E= 1 \u0026\u0026 percent \u003C= 100, \u0022A8\u0022);\r\n\r\n    // Updates referer interests balance accounting for the referee investment\r\n    investors[referer].balanceInterests = investors[referer].balanceInterests.add(midAmount.mul(percent).div(100));\r\n    investors[referer].balanceInterests = investors[referer].balanceInterests.add(lngAmount.mul(percent).div(100));\r\n    investors[referer].balanceInterests = investors[referer].balanceInterests.add(perAmount.mul(percent).div(100));\r\n    emit UpdatedInterests(referer, investors[referer].balanceInterests);\r\n\r\n    investors[referee].mid.refereeBalance = investors[referee].mid.refereeBalance.add(midAmount);\r\n    investors[referee].lng.refereeBalance = investors[referee].lng.refereeBalance.add(lngAmount);\r\n    investors[referee].per.refereeBalance = investors[referee].per.refereeBalance.add(perAmount);\r\n    emit ModifiedReferee(\r\n      referee,\r\n      investors[referee].mid.refereeBalance,\r\n      investors[referee].lng.refereeBalance,\r\n      investors[referee].per.refereeBalance\r\n    );\r\n    emit Refered(referer, referee, midAmount, lngAmount, perAmount);\r\n  }\r\n\r\n  /**\r\n    * @dev Set the referee balance of an investor.\r\n    *\r\n    * @param investor The address of the investor whose balance has to be modified\r\n    * @param midAmount How many mid term bonds the referee bought through referal\r\n    * @param lngAmount How many long term bonds the referee bought through referal\r\n    * @param perAmount How many perpetual tokens the referee bought through referal\r\n    */\r\n  function setRefereeAmount (\r\n    address investor,\r\n    uint256 midAmount,\r\n    uint256 lngAmount,\r\n    uint256 perAmount\r\n  ) external onlyOwner {\r\n    investors[investor].mid.refereeBalance = midAmount;\r\n    investors[investor].lng.refereeBalance = lngAmount;\r\n    investors[investor].per.refereeBalance = perAmount;\r\n    emit ModifiedReferee(investor, midAmount, lngAmount, perAmount);\r\n  }\r\n\r\n  /**\r\n    * @dev Updates an investor\u0027s investment state. Will be called each month.\r\n    *\r\n    * @param investor The address of the investor for which to update interests\r\n    * @param midBalance Balance of mid term bond\r\n    * @param lngBalance Balance of long term bond\r\n    * @param perBalance Balance of perpetual token\r\n    */\r\n  function updateInterests (address investor, uint256 midBalance, uint256 lngBalance, uint256 perBalance) external onlyOwner {\r\n    // Investor\u0027s balance in each bond may have changed since last month\r\n    investors[investor].mid.currentBalance = midBalance;\r\n    investors[investor].lng.currentBalance = lngBalance;\r\n    investors[investor].per.currentBalance = perBalance;\r\n\r\n    // Adjusts investor\u0027s referee balance\r\n    bool adjustedReferee = false;\r\n    if (investors[investor].mid.refereeBalance \u003E investors[investor].mid.currentBalance) {\r\n      investors[investor].mid.refereeBalance = investors[investor].mid.currentBalance;\r\n      adjustedReferee = true;\r\n    }\r\n    if (investors[investor].lng.refereeBalance \u003E investors[investor].lng.currentBalance) {\r\n      investors[investor].lng.refereeBalance = investors[investor].lng.currentBalance;\r\n      adjustedReferee = true;\r\n    }\r\n    if (investors[investor].per.refereeBalance \u003E investors[investor].per.currentBalance) {\r\n      investors[investor].per.refereeBalance = investors[investor].per.currentBalance;\r\n      adjustedReferee = true;\r\n    }\r\n    if (adjustedReferee) {\r\n      emit ModifiedReferee(\r\n        investor,\r\n        investors[investor].mid.refereeBalance,\r\n        investors[investor].lng.refereeBalance,\r\n        investors[investor].per.refereeBalance\r\n      );\r\n    }\r\n\r\n    // Increment the hodling counter : we pass to the next month. The hodling (in months) has to be adjusted\r\n    // if the longterm or perpetual bonds balance has increased, for the midterm the interests are fixed so we\r\n    // can, for one, keep it simple :-).\r\n    if (investors[investor].mid.currentBalance \u003E 0) {\r\n        investors[investor].mid.currentHolding = investors[investor].mid.currentHolding.add(DECIMALS);\r\n    }\r\n    if (investors[investor].lng.currentBalance \u003E 0) {\r\n        if (investors[investor].lng.currentBalance \u003E investors[investor].lng.previousBalance\r\n            \u0026\u0026 investors[investor].lng.previousBalance \u003E 0) {\r\n            uint256 adjustmentRate = (((investors[investor].lng.currentBalance\r\n                                        .sub(investors[investor].lng.previousBalance))\r\n                                        .mul(DECIMALS))\r\n                                        .div(investors[investor].lng.currentBalance));\r\n            investors[investor].lng.currentHolding = (((DECIMALS\r\n                                                        .sub(adjustmentRate))\r\n                                                        .mul(investors[investor].lng.previousHolding\r\n                                                             .add(DECIMALS)))\r\n                                                        .div(DECIMALS));\r\n        }\r\n        else {\r\n            investors[investor].lng.currentHolding = investors[investor].lng.currentHolding.add(DECIMALS);\r\n        }\r\n    }\r\n    if (investors[investor].per.currentBalance \u003E 0) {\r\n        if (investors[investor].per.currentBalance \u003E investors[investor].per.previousBalance\r\n            \u0026\u0026 investors[investor].per.previousBalance \u003E 0) {\r\n            uint256 adjustmentRate = (((investors[investor].per.currentBalance\r\n                                        .sub(investors[investor].per.previousBalance))\r\n                                        .mul(DECIMALS))\r\n                                        .div(investors[investor].per.currentBalance));\r\n            investors[investor].per.currentHolding = (((DECIMALS.sub(adjustmentRate))\r\n                                                        .mul(investors[investor].per.previousHolding\r\n                                                             .add(DECIMALS)))\r\n                                                        .div(DECIMALS));\r\n        }\r\n        else {\r\n            investors[investor].per.currentHolding = investors[investor].per.currentHolding.add(DECIMALS);\r\n        }\r\n    }\r\n\r\n    // We emit ModifiedHoldings later\r\n\r\n    _minterest(investor);\r\n\r\n    // We pass to the next month, hence the previous month is now the current one :D\r\n    investors[investor].mid.previousHolding = investors[investor].mid.currentHolding;\r\n    investors[investor].lng.previousHolding = investors[investor].lng.currentHolding;\r\n    investors[investor].per.previousHolding = investors[investor].per.currentHolding;\r\n\r\n    // Same thing for balances\r\n    investors[investor].mid.previousBalance = investors[investor].mid.currentBalance;\r\n    investors[investor].lng.previousBalance = investors[investor].lng.currentBalance;\r\n    investors[investor].per.previousBalance = investors[investor].per.currentBalance;\r\n\r\n    emit ModifiedBalances(\r\n      investor,\r\n      investors[investor].mid.currentBalance,\r\n      investors[investor].lng.currentBalance,\r\n      investors[investor].per.currentBalance\r\n    );\r\n\r\n    // If the balance of a partition is empty, we need to reset the corresponding \u0022holding\u0022 variable\r\n    if (investors[investor].per.currentBalance == 0) {\r\n      investors[investor].per.previousHolding = 0;\r\n      investors[investor].per.currentHolding = 0;\r\n    }\r\n    if (investors[investor].mid.currentBalance == 0) {\r\n      investors[investor].mid.previousHolding = 0;\r\n      investors[investor].mid.currentHolding = 0;\r\n    }\r\n    if (investors[investor].lng.currentBalance == 0) {\r\n      investors[investor].lng.previousHolding = 0;\r\n      investors[investor].lng.currentHolding = 0;\r\n    }\r\n\r\n    emit ModifiedHoldings(\r\n      investor,\r\n      investors[investor].mid.currentHolding,\r\n      investors[investor].lng.currentHolding,\r\n      investors[investor].per.currentHolding\r\n    );\r\n\r\n    emit UpdatedInterests(investor, investors[investor].balanceInterests);\r\n  }\r\n\r\n\r\n\r\n  /******************** MWT_interests internal functions ************************/\r\n\r\n  /**\r\n    *  @dev Calculates the investor\u0027s total interests given how many tokens he holds, their type, and\r\n    *       for how long he\u0027s been holding them.\r\n    *       For midterm bonds tokens, the interest rate is constant. For longterm and perpetual bonds tokens\r\n    *       rates are given by a table designed by the token issuer (Montessori Worldwide) which is\r\n    *       translated in Solidity as a set of conditions.\r\n    */\r\n  function _minterest (address investor) internal {\r\n    // The interests rates are multiplied by 10^4 to both use integers and have a 10^-4 percent precision\r\n    uint256 rateFactor = 10000; // 10^4\r\n\r\n    // Bonus to referee interest rates are multiplied by 100 to keep 10^-2 precision\r\n    uint256 bonusFactor = 100;\r\n\r\n    // midRate represents the interest rate of the user\u0027s midterm bonds\r\n    uint256 midRate = 575;\r\n\r\n    // lngRate represents the interest rate of the user\u0027s midterm bonds\r\n    uint256 lngRate = 0;\r\n    if (investors[investor].lng.currentBalance \u003E 0) {\r\n      if (investors[investor].lng.currentHolding \u003C DECIMALS.mul(12)) {\r\n        if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(800)) {\r\n          lngRate = 700;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          lngRate = 730;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          lngRate = 749;\r\n        }\r\n        else {\r\n          lngRate = 760;\r\n        }\r\n      }\r\n      else if (investors[investor].lng.currentHolding \u003C DECIMALS.mul(36)) {\r\n        if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(800)) {\r\n          lngRate = 730;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          lngRate = 745;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          lngRate = 756;\r\n        }\r\n        else {\r\n          lngRate = 764;\r\n        }\r\n      }\r\n      else if (investors[investor].lng.currentHolding \u003C DECIMALS.mul(72)) {\r\n        if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(800)) {\r\n          lngRate = 749;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          lngRate = 757;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          lngRate = 763;\r\n        }\r\n        else {\r\n          lngRate = 767;\r\n        }\r\n      }\r\n      else if (investors[investor].lng.currentHolding \u003E= DECIMALS.mul(72)) {\r\n        if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(800)) {\r\n          lngRate = 760;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          lngRate = 764;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          lngRate = 767;\r\n        }\r\n        else if (investors[investor].lng.currentBalance \u003E= DECIMALS.mul(7200)) {\r\n          lngRate = 770;\r\n        }\r\n      }\r\n      assert (lngRate != 0);\r\n    }\r\n\r\n    // perRate represents the interest rate of the user\u0027s midterm bonds\r\n    uint256 perRate = 0;\r\n    if (investors[investor].per.currentBalance \u003E 0) {\r\n      if (investors[investor].per.currentHolding \u003C DECIMALS.mul(12)) {\r\n        if (investors[investor].per.currentBalance \u003C DECIMALS.mul(800)) {\r\n          perRate = 850;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          perRate = 888;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          perRate = 911;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003E= DECIMALS.mul(7200)) {\r\n          perRate = 925;\r\n        }\r\n      }\r\n      else if (investors[investor].per.currentHolding \u003C DECIMALS.mul(36)) {\r\n        if (investors[investor].per.currentBalance \u003C DECIMALS.mul(800)) {\r\n          perRate = 888;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          perRate = 906;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          perRate = 919;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003E= DECIMALS.mul(7200)) {\r\n          perRate = 930;\r\n        }\r\n      }\r\n      else if (investors[investor].per.currentHolding \u003C DECIMALS.mul(72)) {\r\n        if (investors[investor].per.currentBalance \u003C DECIMALS.mul(800)) {\r\n          perRate = 911;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          perRate = 919;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          perRate = 927;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003E= DECIMALS.mul(7200)) {\r\n          perRate = 934;\r\n        }\r\n      }\r\n      else if (investors[investor].per.currentHolding \u003E= DECIMALS.mul(72)) {\r\n        if (investors[investor].per.currentBalance \u003C DECIMALS.mul(800)) {\r\n          perRate = 925;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(2400)) {\r\n          perRate = 930;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003C DECIMALS.mul(7200)) {\r\n          perRate = 934;\r\n        }\r\n        else if (investors[investor].per.currentBalance \u003E= DECIMALS.mul(7200)) {\r\n          perRate = 937;\r\n        }\r\n      }\r\n      assert (perRate != 0);\r\n    }\r\n\r\n    // The total user interests are incremented by this month\u0027s interests in each bond.\r\n    // We divide by 12 because the interest rate is calculated on a yearly basis.\r\n    // If an investor has a \u0022referee balance\u0022 we need to apply a 5% bonus to its interests rate. In this case,\r\n    // we multiply the interests rate by 105 then divide it by 100 so it is increased by 5% without precision loss.\r\n    // In any case, we add the rate of each bond (time the investor\u0027s balance in this bond) on the interests balance.\r\n\r\n    //  Midterm bond interests\r\n    if (investors[investor].mid.refereeBalance \u003E 0) {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((midRate.mul(105) // Rate with 5% bonus\r\n        .mul(investors[investor].mid.refereeBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n        .div(bonusFactor)\r\n      );\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((midRate\r\n        .mul(investors[investor].mid.currentBalance.sub(investors[investor].mid.refereeBalance)))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    } else {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((midRate\r\n        .mul(investors[investor].mid.currentBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    }\r\n    //  Longterm bond interests\r\n    if (investors[investor].lng.refereeBalance \u003E 0) {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((lngRate.mul(105) // Rate with 5% bonus\r\n        .mul(investors[investor].lng.refereeBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n        .div(bonusFactor)\r\n      );\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((lngRate.mul(investors[investor].lng.currentBalance.sub(investors[investor].lng.refereeBalance)))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    } else {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((lngRate.mul(investors[investor].lng.currentBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    }\r\n    //  Perpetual bond interests\r\n    if (investors[investor].per.refereeBalance \u003E 0) {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((perRate.mul(105) // Rate with 5% bonus\r\n        .mul(investors[investor].per.refereeBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n        .div(bonusFactor)\r\n      );\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((perRate.mul(investors[investor].per.currentBalance.sub(investors[investor].per.refereeBalance)))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    } else {\r\n      investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n        ((perRate.mul(investors[investor].per.currentBalance))\r\n        .div(12))\r\n        .div(rateFactor)\r\n      );\r\n    }\r\n  }\r\n}","ABI":"[{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perBalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ModifiedBalances\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022claiming\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022currency\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022partitionNameInHex\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022ModifiedClaimingBonds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022claiming\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022currency\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022ModifiedClaimingInterests\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midHolding\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngHolding\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perHolding\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ModifiedHoldings\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022partitionNameInHex\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022holding\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ModifiedHoldingsAndBalanceError\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ModifiedInterests\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022controller\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022ModifiedInterestsController\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ModifiedReferee\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022referer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022referee\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Refered\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022interests\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022UpdatedInterests\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022partitionNameInHex\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022claimedAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022WillBePaidBonds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022balanceInterests\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022WillBePaidInterests\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022claiming\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_currency\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022partition\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022claimBond\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022claiming\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_currency\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022claimInterests\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022interestsOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isClaimingBonds\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isClaimingInterests\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isInterestsController\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022longtermBondInfosOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022midtermBondInfosOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022claimedAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022payBonds\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022investorsAddresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022payInterests\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022perpetualBondInfosOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perBalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setBalances\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midHolding\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngHolding\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perHolding\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setHoldings\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setInterests\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022controller\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022setInterestsController\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setRefereeAmount\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perBalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updateInterests\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022referer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022referee\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022percent\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022midAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lngAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022perAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updateReferralInfos\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"minterests","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3206e47f80f250942bdf4b01630875fecbb80682f82b19fad67875368313e8b7"}]