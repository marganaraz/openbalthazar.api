[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n*\r\n* ETHPROFIT.SPACE\r\n*\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* \r\n*  - GAIN 3% PER 24 HOURS (interest is charges in equal parts every 10 min)\r\n*  - Life-long payments\r\n*  - The revolutionary reliability\r\n*  - Minimal contribution 0.01 eth\r\n*  - Currency and payment - ETH\r\n*  - Contribution allocation schemes:\r\n*    -- 90% payments\r\n*    --  8% marketing\r\n*    --  2% technical support\r\n* \r\n* ---How to use:\r\n*  1. Send from ETH wallet to the smart contract address \r\n*     any amount from 0.01 ETH.\r\n*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \r\n*     of your wallet.\r\n*  3a. Claim your profit by sending 0 ether transaction (every 10 min, every day, every week, i don\u0027t care unless you\u0027re \r\n*      spending too much on GAS)\r\n*  OR\r\n*  3b. For reinvest, you need to deposit the amount that you want to reinvest and the \r\n*      accrued interest automatically summed to your new contribution.\r\n*  \r\n* RECOMMENDED GAS LIMIT: 250000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* You can check the payments on the etherscan.io site, in the \u0022Internal Txns\u0022 tab of your wallet.\r\n*\r\n* ---Refferral system: remuneration to each contributor is 3%, \r\n*     \r\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \r\n* have private keys.\r\n* \r\n* Contracts reviewed and approved by pros!\r\n* \r\n*/ \r\n\r\n\r\n\r\nlibrary Math {\r\n  function min(uint a, uint b) internal pure returns(uint) {\r\n    if (a \u003E b) {\r\n      return b;\r\n    }\r\n    return a;\r\n  }\r\n}\r\n\r\n\r\nlibrary Zero {\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \u0022require not zero address\u0022);\r\n  }\r\n\r\n  function requireNotZero(uint val) internal pure {\r\n    require(val != 0, \u0022require not zero value\u0022);\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n\r\n  function isZero(uint a) internal pure returns(bool) {\r\n    return a == 0;\r\n  }\r\n\r\n  function notZero(uint a) internal pure returns(bool) {\r\n    return a != 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b \u003E= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a \u002B mul(p, a);\r\n  }\r\n\r\n  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n\r\n  // memory \r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b \u003E= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a \u002B mmul(p, a);\r\n  }\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function toAddress(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n\r\n  function isNotContract(address addr) internal view returns(bool) {\r\n    uint length;\r\n    assembly { length := extcodesize(addr) }\r\n    return length == 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n    // benefit is lost if \u0027b\u0027 is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b \u003E 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c \u002B _a % _b); // There is no case in which this doesn\u0027t hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b \u003C= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a \u002B _b;\r\n    require(c \u003E= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  address private owner;\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \u0022access denied\u0022);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function disown() internal {\r\n    delete owner;\r\n  }\r\n}\r\n\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n  struct Investor {\r\n    uint investment;\r\n    uint paymentTime;\r\n  }\r\n  uint public size;\r\n\r\n  mapping (address =\u003E Investor) private investors;\r\n\r\n  function isInvestor(address addr) public view returns (bool) {\r\n    return investors[addr].investment \u003E 0;\r\n  }\r\n\r\n  function investorInfo(address addr) public view returns(uint investment, uint paymentTime) {\r\n    investment = investors[addr].investment;\r\n    paymentTime = investors[addr].paymentTime;\r\n  }\r\n\r\n  function newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\r\n    Investor storage inv = investors[addr];\r\n    if (inv.investment != 0 || investment == 0) {\r\n      return false;\r\n    }\r\n    inv.investment = investment;\r\n    inv.paymentTime = paymentTime;\r\n    size\u002B\u002B;\r\n    return true;\r\n  }\r\n\r\n  function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\r\n    if (investors[addr].investment == 0) {\r\n      return false;\r\n    }\r\n    investors[addr].investment \u002B= investment;\r\n    return true;\r\n  }\r\n\r\n  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n    if (investors[addr].investment == 0) {\r\n      return false;\r\n    }\r\n    investors[addr].paymentTime = paymentTime;\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract Ethprofitspace is Accessibility {\r\n  using Percent for Percent.percent;\r\n  using SafeMath for uint;\r\n  using Math for uint;\r\n\r\n  // easy read for investors\r\n  using Address for *;\r\n  using Zero for *; \r\n  \r\n  mapping(address =\u003E bool) private m_referrals;\r\n  InvestorsStorage private m_investors;\r\n\r\n  // automatically generates getters\r\n  uint public constant minInvesment = 10 finney; //       0.01 eth\r\n  uint public constant maxBalance = 100e5 ether; // 10 000 000 eth\r\n  address public advertisingAddress;\r\n  address public adminsAddress;\r\n  uint public investmentsNumber;\r\n  uint public waveStartup;\r\n\r\n  // percents\r\n  Percent.percent private m_3_percent = Percent.percent(3, 100);    // 3/100*100% = 3%\r\n  Percent.percent private m_adminsPercent = Percent.percent(2, 100);       //   2/100  *100% = 2%\r\n  Percent.percent private m_advertisingPercent = Percent.percent(8, 100);// 8/100  *100% = 8%\r\n\r\n  // more events for easy read from blockchain\r\n  event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\n  event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\n  event LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\r\n  event LogAutomaticReinvest(address indexed addr, uint when, uint investment);\r\n  event LogPayDividends(address indexed addr, uint when, uint dividends);\r\n  event LogNewInvestor(address indexed addr, uint when);\r\n  event LogBalanceChanged(uint when, uint balance);\r\n  event LogNextWave(uint when);\r\n  event LogDisown(uint when);\r\n\r\n\r\n  modifier balanceChanged {\r\n    _;\r\n    emit LogBalanceChanged(now, address(this).balance);\r\n  }\r\n\r\n  modifier notFromContract() {\r\n    require(msg.sender.isNotContract(), \u0022only externally accounts\u0022);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    adminsAddress = msg.sender;\r\n    advertisingAddress = msg.sender;\r\n    nextWave();\r\n  }\r\n\r\n  function() public payable {\r\n    // investor get him dividends\r\n    if (msg.value.isZero()) {\r\n      getMyDividends();\r\n      return;\r\n    }\r\n\r\n    // sender do invest\r\n    doInvest(msg.data.toAddress());\r\n  }\r\n\r\n  function doDisown() public onlyOwner {\r\n    disown();\r\n    emit LogDisown(now);\r\n  }\r\n\r\n  \r\n\r\n  function setAdvertisingAddress(address addr) public onlyOwner {\r\n    addr.requireNotZero();\r\n    advertisingAddress = addr;\r\n  }\r\n\r\n  function setAdminsAddress(address addr) public onlyOwner {\r\n    addr.requireNotZero();\r\n    adminsAddress = addr;\r\n  }\r\n\r\n  function investorsNumber() public view returns(uint) {\r\n    return m_investors.size();\r\n  }\r\n\r\n  function balanceETH() public view returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function percent3() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_3_percent.num, m_3_percent.den);\r\n  }\r\n\r\n  function advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n  }\r\n\r\n  function adminsPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n  }\r\n\r\n  function investorInfo(address investorAddr) public view returns(uint investment, uint paymentTime, bool isReferral) {\r\n    (investment, paymentTime) = m_investors.investorInfo(investorAddr);\r\n    isReferral = m_referrals[investorAddr];\r\n  }\r\n\r\n  function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\n    dividends = calcDividends(investorAddr);\r\n  }\r\n\r\n  function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n    Percent.percent memory p = dailyPercent();\r\n    (numerator, denominator) = (p.num, p.den);\r\n  }\r\n\r\n  function refBonusPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n    Percent.percent memory p = refBonusPercent();\r\n    (numerator, denominator) = (p.num, p.den);\r\n  }\r\n\r\n  function getMyDividends() public notFromContract balanceChanged {\r\n    // calculate dividends\r\n    uint dividends = calcDividends(msg.sender);\r\n    require (dividends.notZero(), \u0022cannot to pay zero dividends\u0022);\r\n\r\n    // update investor payment timestamp\r\n    assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    // check enough eth - goto next wave if needed\r\n    if (address(this).balance \u003C= dividends) {\r\n      nextWave();\r\n      dividends = address(this).balance;\r\n    } \r\n\r\n    // transfer dividends to investor\r\n    msg.sender.transfer(dividends);\r\n    emit LogPayDividends(msg.sender, now, dividends);\r\n  }\r\n\r\n  function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\n    uint investment = msg.value;\r\n    uint receivedEther = msg.value;\r\n    require(investment \u003E= minInvesment, \u0022investment must be \u003E= minInvesment\u0022);\r\n    require(address(this).balance \u003C= maxBalance, \u0022the contract eth balance limit\u0022);\r\n\r\n    // send excess of ether if needed\r\n    if (receivedEther \u003E investment) {\r\n      uint excess = receivedEther - investment;\r\n      msg.sender.transfer(excess);\r\n      receivedEther = investment;\r\n      emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\r\n    }\r\n\r\n    // commission\r\n    advertisingAddress.send(m_advertisingPercent.mul(receivedEther));\r\n    adminsAddress.send(m_adminsPercent.mul(receivedEther));\r\n\r\n    bool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n    // ref system works only once and only on first invest\r\n    if (referrerAddr.notZero() \u0026\u0026 !senderIsInvestor \u0026\u0026 !m_referrals[msg.sender] \u0026\u0026\r\n      referrerAddr != msg.sender \u0026\u0026 m_investors.isInvestor(referrerAddr)) {\r\n      \r\n      m_referrals[msg.sender] = true;\r\n      // add referral bonus to investor\u0060s and referral\u0060s investments\r\n      uint refBonus = refBonusPercent().mmul(investment);\r\n      assert(m_investors.addInvestment(referrerAddr, refBonus)); // add referrer bonus\r\n      investment \u002B= refBonus;                                    // add referral bonus\r\n      emit LogNewReferral(msg.sender, referrerAddr, now, refBonus);\r\n    }\r\n\r\n    // automatic reinvest - prevent burning dividends\r\n    uint dividends = calcDividends(msg.sender);\r\n    if (senderIsInvestor \u0026\u0026 dividends.notZero()) {\r\n      investment \u002B= dividends;\r\n      emit LogAutomaticReinvest(msg.sender, now, dividends);\r\n    }\r\n\r\n    if (senderIsInvestor) {\r\n      // update existing investor\r\n      assert(m_investors.addInvestment(msg.sender, investment));\r\n      assert(m_investors.setPaymentTime(msg.sender, now));\r\n    } else {\r\n      // create new investor\r\n      assert(m_investors.newInvestor(msg.sender, investment, now));\r\n      emit LogNewInvestor(msg.sender, now);\r\n    }\r\n\r\n    investmentsNumber\u002B\u002B;\r\n    emit LogNewInvesment(msg.sender, now, investment, receivedEther);\r\n  }\r\n\r\n  function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n    (uint investment, uint paymentTime) = m_investors.investorInfo(investorAddr);\r\n    return InvestorsStorage.Investor(investment, paymentTime);\r\n  }\r\n\r\n  function calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n    InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n    // safe gas if dividends will be 0\r\n    if (investor.investment.isZero() || now.sub(investor.paymentTime) \u003C 10 minutes) {\r\n      return 0;\r\n    }\r\n    \r\n    // for prevent burning daily dividends if 24h did not pass - calculate it per 10 min interval\r\n    // if daily percent is X, then 10min percent = X / (24h / 10 min) = X / 144\r\n\r\n    // and we must to get numbers of 10 min interval after investor got payment:\r\n    // (now - investor.paymentTime) / 10min \r\n\r\n    // finaly calculate dividends = ((now - investor.paymentTime) / 10min) * (X * investor.investment)  / 144) \r\n\r\n    Percent.percent memory p = dailyPercent();\r\n    dividends = (now.sub(investor.paymentTime) / 10 minutes) * p.mmul(investor.investment) / 144;\r\n  }\r\n\r\n  function dailyPercent() internal view returns(Percent.percent memory p) {\r\n    uint balance = address(this).balance;\r\n\r\n    // (3) 3% if balance \u003C 10 000 000 ETH\r\n\r\n    if (balance \u003C 10000000 ether) { \r\n      p = m_3_percent.toMemory(); // (3)\r\n    }\r\n  }\r\n\r\n  function refBonusPercent() internal view returns(Percent.percent memory p) {\r\n    uint balance = address(this).balance;\r\n\r\n    \r\n    // (3) 3% if balance \u003C 10 000 000 ETH   \r\n    \r\n    if (balance \u003C 10000000 ether) { \r\n      p = m_3_percent.toMemory(); // (3)\r\n    }     \r\n  }\r\n\r\n  function nextWave() private {\r\n    m_investors = new InvestorsStorage();\r\n    investmentsNumber = 0;\r\n    waveStartup = now;\r\n    emit LogNextWave(now);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022advertisingAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022refBonusPercentAtNow\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022numerator\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022denominator\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022minInvesment\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022adminsAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022investorsNumber\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022maxBalance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022investorAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022investorDividendsAtNow\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022dividends\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022advertisingPercent\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022numerator\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022denominator\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022adminsPercent\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022numerator\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022denominator\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAdminsAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022investmentsNumber\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022dailyPercentAtNow\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022numerator\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022denominator\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022percent3\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022numerator\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022denominator\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAdvertisingAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMyDividends\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022referrerAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022doInvest\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022investorAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022investorInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022investment\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022paymentTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022isReferral\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022waveStartup\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022balanceETH\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022doDisown\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022investment\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022excess\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogSendExcessOfEther\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022referrerAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022refBonus\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogNewReferral\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022investment\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogNewInvesment\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022investment\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogAutomaticReinvest\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022dividends\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogPayDividends\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogNewInvestor\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogBalanceChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogNextWave\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022when\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogDisown\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Ethprofitspace","CompilerVersion":"v0.4.25\u002Bcommit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4b49317588e0db61809faca2f1737ead957e11894585afa192cd39c562a7ddcc"}]