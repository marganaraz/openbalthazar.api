[{"SourceCode":"{\u0022IERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.2;\\n\\n/*\\nThe MIT License (MIT)\\n\\nCopyright (c) 2016 Smart Contract Solutions, Inc.\\n\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\u0022Software\\\u0022), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\n\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\u0022AS IS\\\u0022, WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\u0022},\u0022MerkleProof.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.25 \\u003c0.6.0;\\n\\n/*\\nThe MIT License (MIT)\\n\\nCopyright (c) 2016 Smart Contract Solutions, Inc.\\n\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\u0022Software\\\u0022), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\n\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\u0022AS IS\\\u0022, WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\n/**\\n * @title MerkleProof\\n * @dev Merkle proof verification based on\\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\\n     * and each pair of pre-images are sorted.\\n     * @param proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\\n     * @param root Merkle root\\n     * @param leaf Leaf of Merkle tree\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i \\u003c proof.length; i\u002B\u002B) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash \\u003c proofElement) {\\n                // Hash(current computed hash \u002B current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof \u002B current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\u0022},\u0022Migrations.sol\u0022:{\u0022content\u0022:\u0022pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\u0022},\u0022TownOfSalem.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.2;\\n\\nimport \\\u0022./IERC20.sol\\\u0022;\\nimport \\\u0022./MerkleProof.sol\\\u0022;\\n\\ncontract TownOfSalem\\n{\\n\\tconstructor() public {}\\n\\n  IERC20 CereneumContract = IERC20(0xd9D4A7CA154fe137c808F7EEDBe24b639B7AF5a6);\\n  bytes32 public m_hMerkleTreeRoot = 0x7804aa8223f9eff3d1df195fe18d13b2191a7a3ac890aa970a34ccb42520038a;\\n  mapping(bytes32 =\\u003e bool) public m_claimedMap;\\n  uint256 m_nAirdropAmount = 1000000000;  //10 CER\\n  address m_contractOwner = 0xe0d53E9fd7A9E0251641cB9CC7F70aff579bfbbE;\\n  address m_returnAddress = 0x8eAf4Fec503da352EB66Ef1E2f75C63e5bC635e1;\\n\\n  function ClaimAirdrop(\\n    bytes32 a_hMerkleLeaf,\\n    bytes32[] memory a_hMerkleTreeBranches\\n  ) public returns (bool)\\n  {\\n    require(m_claimedMap[a_hMerkleLeaf] == false, \\\u0022Duplicate claim\\\u0022);\\n\\n    require(MerkleProof.verify(a_hMerkleTreeBranches, m_hMerkleTreeRoot, a_hMerkleLeaf), \\\u0022Merkle Proof Failed\\\u0022);\\n\\n    CereneumContract.transfer(msg.sender, m_nAirdropAmount);\\n\\n    m_claimedMap[a_hMerkleLeaf] = true;\\n  }\\n\\n  modifier restricted()\\n\\t{\\n    if (msg.sender == m_contractOwner) _;\\n  }\\n\\n  function UpdateMerkleRoot(bytes32 a_hMerkleTreeRoot) public restricted()\\n  {\\n    m_hMerkleTreeRoot = a_hMerkleTreeRoot;\\n  }\\n\\n  function ReturnCereneum() public restricted()\\n  {\\n    CereneumContract.transfer(m_returnAddress, CereneumContract.balanceOf(address(this)));\\n  }\\n\\n\\tfunction AdjustAirdropAmount(uint256 a_nAirdropAmount) public restricted()\\n  {\\n    m_nAirdropAmount = a_nAirdropAmount;\\n  }\\n}\\n\u0022}}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ReturnCereneum\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022a_nAirdropAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AdjustAirdropAmount\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022m_hMerkleTreeRoot\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022a_hMerkleLeaf\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022a_hMerkleTreeBranches\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022name\u0022:\u0022ClaimAirdrop\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022m_claimedMap\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022a_hMerkleTreeRoot\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022UpdateMerkleRoot\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"TownOfSalem","CompilerVersion":"v0.5.2\u002Bcommit.1df8f40c","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6558da3ba016c7bae305327f4ec4100fe0a765f8a28433eae7a6d5f0aa50e870"}]