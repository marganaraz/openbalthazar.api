[{"SourceCode":"pragma solidity 0.5.13;\r\nlibrary SafeMath{\r\n    function add(uint256 a,uint256 b)internal pure returns(uint256){uint256 c=a\u002Bb;require(c\u003E=a);return c;}\r\n\tfunction sub(uint256 a,uint256 b)internal pure returns(uint256){require(b\u003C=a);uint256 c=a-b;return c;}\r\n\tfunction div(uint256 a,uint256 b)internal pure returns(uint256){require(b\u003E0);uint256 c=a/b;return c;}\r\n\tfunction mul(uint256 a,uint256 b)internal pure returns(uint256){if(a==0){return 0;}uint256 c=a*b;require(c/a==b);return c;}}\r\ninterface Out{\r\n    function aad(uint256 n)external view returns(address);function bad(uint256 n)external view returns(address);\r\n\tfunction cad(uint256 n)external view returns(address);function dad(uint256 n)external view returns(address);\r\n\tfunction aam(uint256 n)external view returns(uint256);function srs(uint256 n)external view returns(uint256);\r\n\tfunction arw(uint256 n)external view returns(uint256);function brw(uint256 n)external view returns(uint256);\r\n\tfunction crw(uint256 n)external view returns(uint256);function drw(uint256 n)external view returns(uint256);\r\n    function afin(uint256 n)external returns(bool);function bfin(uint256 n)external returns(bool);\r\n\tfunction cfin(uint256 n)external returns(bool);function dfin(uint256 n)external returns(bool);\r\n\tfunction day()external view returns(uint256);\r\n\tfunction mint(address w,uint256 a)external returns(bool);\r\n    function swait(address w,uint256 n)external returns(bool);\r\n\tfunction mined(address w,uint256 n)external returns(bool);}\r\ncontract MINING{\t\r\n    using SafeMath for uint256; modifier onlyOwn{require(own==msg.sender);_;}\r\n    address private del; address private rot; address private own;\r\n    function mining(uint256 n)external returns(bool){\r\n\t\taddress dd = msg.sender;uint256 sr=Out(del).srs(n);uint256 aa=Out(del).aam(n);\r\n\t\tuint256 a; uint256 r=0; uint256 mt=0;\r\n\t\tif(sr==2){if(dd==Out(del).aad(n)){r=Out(del).arw(n);a=aa;}else\r\n\t\tif(dd==Out(del).bad(n)){r=Out(del).brw(n);a=aa.div(5).mul(4);}else\r\n\t\tif(dd==Out(del).cad(n)){r=Out(del).crw(n);a=a.add(aa.div(10));}else\r\n\t\tif(dd==Out(del).dad(n)){r=Out(del).drw(n);a=a.add(aa.div(10));}else{r=0;}}else\r\n\t\tif(sr==1){if(dd==Out(del).aad(n)){r=Out(del).arw(n);a=aa.div(100).mul(172);}else\r\n\t\tif(dd==Out(del).bad(n)){r=Out(del).brw(n);a=aa.div(5).mul(8);}else\r\n\t\tif(dd==Out(del).cad(n)){r=Out(del).crw(n);a=a.add(aa.div(100).mul(18));}else\r\n\t\tif(dd==Out(del).dad(n)){r=Out(del).drw(n);a=a.add(aa.div(10));}else{r=0;}}else\r\n\t\tif(sr==0){if(dd==Out(del).aad(n)){ r=Out(del).arw(n);a=aa.mul(9);}\r\n\t\tif(dd==Out(del).cad(n)){ r=Out(del).crw(n);a=a.add(aa.div(2));}\r\n\t\tif(dd==Out(del).dad(n)){ r=Out(del).drw(n);a=a.add(aa.div(2));}else{r=0;}}\r\n\t\trequire(r\u003E0); uint256 t=Out(del).day().sub(r); if(t\u003C73){mt=t;}else\r\n\t\tif(t\u003C146){mt=73;mt=mt.add((t.sub(73)).mul(3));}else\r\n\t\tif(t\u003C219){mt=292;mt=mt.add((t.sub(146)).mul(9));}else\r\n\t\tif(t\u003C292){mt=949;mt=mt.add((t.sub(219)).mul(27));}else\r\n\t\tif(t\u003C365){mt=2920;mt=mt.add((t.sub(292)).mul(81));}else{mt=8833;}\r\n\t\tif(mt==8833){mt=a;}else{ mt=(a.mul(mt)).div(8833);}\r\n\t\trequire(mt\u003E0\u0026\u0026Out(rot).mint(dd,mt)\u0026\u0026Out(del).mined(dd,mt)\u0026\u0026Out(del).swait(dd,a));\r\n\t\tif(dd==Out(del).aad(n)){require(Out(del).afin(n));}\r\n\t\tif(dd==Out(del).bad(n)){require(Out(del).bfin(n));}\r\n\t\tif(dd==Out(del).cad(n)){require(Out(del).cfin(n));}\r\n\t\tif(dd==Out(del).dad(n)){require(Out(del).dfin(n));}return true;}\r\n\tfunction setrot(address a)external onlyOwn returns(bool){rot=a;return true;}\r\n    function setdel(address a)external onlyOwn returns(bool){del=a;return true;}\r\n    function()external{revert();}\r\n    constructor()public{own=msg.sender;}}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022n\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mining\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022a\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setdel\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022a\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setrot\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"MINING","CompilerVersion":"v0.5.13\u002Bcommit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ac3b053c2cbca413ed5b23982891870e5c06777dda68eeac3f42ac058dab5a5"}]