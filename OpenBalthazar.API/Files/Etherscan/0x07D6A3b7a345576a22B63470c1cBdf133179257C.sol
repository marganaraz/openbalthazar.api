[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary Exclusive {\r\n    struct RoleMembership {\r\n        address member;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.member == memberToCheck;\r\n    }\r\n\r\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\r\n        require(newMember != address(0x0), \u0022Cannot set an exclusive role to 0x0\u0022);\r\n        roleMembership.member = newMember;\r\n    }\r\n\r\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\r\n        return roleMembership.member;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\r\n        resetMember(roleMembership, initialMember);\r\n    }\r\n}\r\n\r\nlibrary Shared {\r\n    struct RoleMembership {\r\n        mapping(address =\u003E bool) members;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.members[memberToCheck];\r\n    }\r\n\r\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\r\n        roleMembership.members[memberToAdd] = true;\r\n    }\r\n\r\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\r\n        roleMembership.members[memberToRemove] = false;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\r\n        for (uint i = 0; i \u003C initialMembers.length; i\u002B\u002B) {\r\n            addMember(roleMembership, initialMembers[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract MultiRole {\r\n    using Exclusive for Exclusive.RoleMembership;\r\n    using Shared for Shared.RoleMembership;\r\n\r\n    enum RoleType { Invalid, Exclusive, Shared }\r\n\r\n    struct Role {\r\n        uint managingRole;\r\n        RoleType roleType;\r\n        Exclusive.RoleMembership exclusiveRoleMembership;\r\n        Shared.RoleMembership sharedRoleMembership;\r\n    }\r\n\r\n    mapping(uint =\u003E Role) private roles;\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the specified roleId.\r\n     */\r\n    modifier onlyRoleHolder(uint roleId) {\r\n        require(holdsRole(roleId, msg.sender), \u0022Sender does not hold required role\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\r\n     */\r\n    modifier onlyRoleManager(uint roleId) {\r\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \u0022Can only be called by a role manager\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\r\n     */\r\n    modifier onlyExclusive(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Exclusive, \u0022Must be called on an initialized Exclusive role\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\r\n     */\r\n    modifier onlyShared(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Shared, \u0022Must be called on an initialized Shared role\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether \u0060memberToCheck\u0060 is a member of roleId.\r\n     * @dev Reverts if roleId does not correspond to an initialized role.\r\n     */\r\n    function holdsRole(uint roleId, address memberToCheck) public view returns (bool) {\r\n        Role storage role = roles[roleId];\r\n        if (role.roleType == RoleType.Exclusive) {\r\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\r\n        } else if (role.roleType == RoleType.Shared) {\r\n            return role.sharedRoleMembership.isMember(memberToCheck);\r\n        }\r\n        require(false, \u0022Invalid roleId\u0022);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the exclusive role holder of \u0060roleId\u0060 to \u0060newMember\u0060.\r\n     * @dev Reverts if the caller is not a member of the managing role for \u0060roleId\u0060 or if \u0060roleId\u0060 is not an\r\n     * initialized, exclusive role.\r\n     */\r\n    function resetMember(uint roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current holder of the exclusive role, \u0060roleId\u0060.\r\n     * @dev Reverts if \u0060roleId\u0060 does not represent an initialized, exclusive role.\r\n     */\r\n    function getMember(uint roleId) public view onlyExclusive(roleId) returns (address) {\r\n        return roles[roleId].exclusiveRoleMembership.getMember();\r\n    }\r\n\r\n    /**\r\n     * @notice Adds \u0060newMember\u0060 to the shared role, \u0060roleId\u0060.\r\n     * @dev Reverts if \u0060roleId\u0060 does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for \u0060roleId\u0060.\r\n     */\r\n    function addMember(uint roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.addMember(newMember);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes \u0060memberToRemove\u0060 from the shared role, \u0060roleId\u0060.\r\n     * @dev Reverts if \u0060roleId\u0060 does not represent an initialized, shared role or if the caller is not a member of the\r\n     * managing role for \u0060roleId\u0060.\r\n     */\r\n    function removeMember(uint roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if \u0060roleId\u0060 is not initialized.\r\n     */\r\n    modifier onlyValidRole(uint roleId) {\r\n        require(roles[roleId].roleType != RoleType.Invalid, \u0022Attempted to use an invalid roleId\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if \u0060roleId\u0060 is initialized.\r\n     */\r\n    modifier onlyInvalidRole(uint roleId) {\r\n        require(roles[roleId].roleType == RoleType.Invalid, \u0022Cannot use a pre-existing role\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a shared role, \u0060roleId\u0060, which will be managed by \u0060managingRoleId\u0060.\r\n     * \u0060initialMembers\u0060 will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createSharedRole(uint roleId, uint managingRoleId, address[] memory initialMembers)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Shared;\r\n        role.managingRole = managingRoleId;\r\n        role.sharedRoleMembership.init(initialMembers);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \u0022Attempted to use an invalid role to manage a shared role\u0022);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a exclusive role, \u0060roleId\u0060, which will be managed by \u0060managingRoleId\u0060.\r\n     * \u0060initialMembers\u0060 will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createExclusiveRole(uint roleId, uint managingRoleId, address initialMember)\r\n        internal\r\n        onlyInvalidRole(roleId)\r\n    {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Exclusive;\r\n        role.managingRole = managingRoleId;\r\n        role.exclusiveRoleMembership.init(initialMember);\r\n        require(roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \u0022Attempted to use an invalid role to manage an exclusive role\u0022);\r\n    }\r\n}\r\n\r\ninterface RegistryInterface {\r\n    /**\r\n     * @dev Registers a new derivative. Only authorized derivative creators can call this method.\r\n     */\r\n    function registerDerivative(address[] calldata counterparties, address derivativeAddress) external;\r\n\r\n    /**\r\n     * @dev Returns whether the derivative has been registered with the registry (and is therefore an authorized.\r\n     * participant in the UMA system).\r\n     */\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered);\r\n\r\n    /**\r\n     * @dev Returns a list of all derivatives that are associated with a particular party.\r\n     */\r\n    function getRegisteredDerivatives(address party) external view returns (address[] memory derivatives);\r\n\r\n    /**\r\n     * @dev Returns all registered derivatives.\r\n     */\r\n    function getAllRegisteredDerivatives() external view returns (address[] memory derivatives);\r\n}\r\n\r\ncontract Registry is RegistryInterface, MultiRole {\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum Roles {\r\n        // The owner manages the set of DerivativeCreators.\r\n        Owner,\r\n        // Can register derivatives.\r\n        DerivativeCreator\r\n    }\r\n\r\n    // Array of all derivatives that are approved to use the UMA Oracle.\r\n    address[] private registeredDerivatives;\r\n\r\n    // This enum is required because a WasValid state is required to ensure that derivatives cannot be re-registered.\r\n    enum PointerValidity {\r\n        Invalid,\r\n        Valid\r\n    }\r\n\r\n    struct Pointer {\r\n        PointerValidity valid;\r\n        uint128 index;\r\n    }\r\n\r\n    // Maps from derivative address to a pointer that refers to that registered derivative in \u0060registeredDerivatives\u0060.\r\n    mapping(address =\u003E Pointer) private derivativePointers;\r\n\r\n    // Note: this must be stored outside of \u0060registeredDerivatives\u0060 because mappings cannot be deleted and copied\r\n    // like normal data. This could be stored in the Pointer struct, but storing it there would muddy the purpose\r\n    // of the Pointer struct and break separation of concern between referential data and data.\r\n    struct PartiesMap {\r\n        mapping(address =\u003E bool) parties;\r\n    }\r\n\r\n    // Maps from derivative address to the set of parties that are involved in that derivative.\r\n    mapping(address =\u003E PartiesMap) private derivativesToParties;\r\n\r\n    event NewDerivativeRegistered(address indexed derivativeAddress, address indexed creator, address[] parties);\r\n\r\n    constructor() public {\r\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\r\n        // Start with no derivative creators registered.\r\n        _createSharedRole(uint(Roles.DerivativeCreator), uint(Roles.Owner), new address[](0));\r\n    }\r\n\r\n    function registerDerivative(address[] calldata parties, address derivativeAddress)\r\n        external\r\n        onlyRoleHolder(uint(Roles.DerivativeCreator))\r\n    {\r\n        // Create derivative pointer.\r\n        Pointer storage pointer = derivativePointers[derivativeAddress];\r\n\r\n        // Ensure that the pointer was not valid in the past (derivatives cannot be re-registered or double\r\n        // registered).\r\n        require(pointer.valid == PointerValidity.Invalid);\r\n        pointer.valid = PointerValidity.Valid;\r\n\r\n        registeredDerivatives.push(derivativeAddress);\r\n\r\n        // No length check necessary because we should never hit (2^127 - 1) derivatives.\r\n        pointer.index = uint128(registeredDerivatives.length.sub(1));\r\n\r\n        // Set up PartiesMap for this derivative.\r\n        PartiesMap storage partiesMap = derivativesToParties[derivativeAddress];\r\n        for (uint i = 0; i \u003C parties.length; i = i.add(1)) {\r\n            partiesMap.parties[parties[i]] = true;\r\n        }\r\n\r\n        address[] memory partiesForEvent = parties;\r\n        emit NewDerivativeRegistered(derivativeAddress, msg.sender, partiesForEvent);\r\n    }\r\n\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered) {\r\n        return derivativePointers[derivative].valid == PointerValidity.Valid;\r\n    }\r\n\r\n    function getRegisteredDerivatives(address party) external view returns (address[] memory derivatives) {\r\n        // This is not ideal - we must statically allocate memory arrays. To be safe, we make a temporary array as long\r\n        // as registeredDerivatives. We populate it with any derivatives that involve the provided party. Then, we copy\r\n        // the array over to the return array, which is allocated using the correct size. Note: this is done by double\r\n        // copying each value rather than storing some referential info (like indices) in memory to reduce the number\r\n        // of storage reads. This is because storage reads are far more expensive than extra memory space (~100:1).\r\n        address[] memory tmpDerivativeArray = new address[](registeredDerivatives.length);\r\n        uint outputIndex = 0;\r\n        for (uint i = 0; i \u003C registeredDerivatives.length; i = i.add(1)) {\r\n            address derivative = registeredDerivatives[i];\r\n            if (derivativesToParties[derivative].parties[party]) {\r\n                // Copy selected derivative to the temporary array.\r\n                tmpDerivativeArray[outputIndex] = derivative;\r\n                outputIndex = outputIndex.add(1);\r\n            }\r\n        }\r\n\r\n        // Copy the temp array to the return array that is set to the correct size.\r\n        derivatives = new address[](outputIndex);\r\n        for (uint j = 0; j \u003C outputIndex; j = j.add(1)) {\r\n            derivatives[j] = tmpDerivativeArray[j];\r\n        }\r\n    }\r\n\r\n    function getAllRegisteredDerivatives() external view returns (address[] memory derivatives) {\r\n        return registeredDerivatives;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022derivativeAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022creator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022parties\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022NewDerivativeRegistered\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022roleId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newMember\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addMember\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAllRegisteredDerivatives\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022derivatives\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022roleId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getMember\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022party\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getRegisteredDerivatives\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022derivatives\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022roleId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022memberToCheck\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022holdsRole\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022derivative\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isDerivativeRegistered\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isRegistered\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022parties\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022derivativeAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022registerDerivative\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022roleId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022memberToRemove\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeMember\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022roleId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newMember\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022resetMember\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"Registry","CompilerVersion":"v0.5.13\u002Bcommit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6a4db415d5be84aeedb2e65d817c16ee03898e2bd8849c9349ecb57ce0b06eef"}]