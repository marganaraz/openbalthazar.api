[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n/**\r\nGet 20% profit every month with a contract PZMT 20 Plus !\r\n* PZMT it is a Token, it is not Prizm !\r\n*\r\n* - OBTAINING 20% PER 1 MONTH. (percentages are charged in equal parts every 1 sec)\r\n* 0.6666% per 1 day\r\n* 0.0275% per 1 hour\r\n* 0.00045% per 1 minute\r\n* 0.0000076% per 1 sec\r\n* - lifetime payments\r\n* - unprecedentedly reliable\r\n* - bring luck\r\n* - first minimum contribution from 0.2 eth, all next from 0.01 eth\r\n* - Currency and Payment - ETH\r\n* - Contribution allocation schemes:\r\n* - 100% of payments - 5% percent for support and 10% percent referral system.\r\n* \r\n* You can purchase PZM Token on a smart contract (the first truly decentralized exchange), \r\n* and also become a co-owner of the token at the address on the Ethereum blockchain\r\n* 0x968a1fEf28252A5F7dC0493B7E442929B4B1DF4C\r\n*\r\n* RECOMMENDED GAS LIMIT: 200,000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* DO NOT TRANSFER DIRECTLY FROM AN EXCHANGE (only use your ETH wallet, from which you have a private key)\r\n* You can check payments on the website etherscan.io, in the \u201CInternal Txns\u201D tab of your wallet.\r\n*\r\n* Referral system 10%.\r\n* Payments to developers 5%\r\n\r\n* Restart of the contract is also absent. If there is no money in the Fund, payments are stopped and resumed after the Fund is filled. Thus, the contract will work forever!\r\n*\r\n* How to use:\r\n* 1. Send from your ETH wallet to the address of the smart contract\r\n* Any amount from 0.2 ETH.\r\n* 2. Confirm your transaction in the history of your application or etherscan.io, indicating the address of your wallet.\r\n* Take profit by sending 0 eth to contract (profit is calculated every second).\r\n*\r\n* The author of this smart contract is Alex Burn.\r\n**/\r\n\r\ncontract ERC20Token\r\n{\r\n    mapping (address =\u003E uint256) public balanceOf;\r\n    function transfer(address _to, uint256 _value) public;\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract PZMT_20_Plus\r\n{\r\n    using SafeMath for uint256;\r\n    \r\n    address payable public owner = 0x76E40e08e10c8D7D088b20D26349ec52932F8BC3;\r\n    \r\n    uint256 minBalance = 100;\r\n    ERC20Token PZM_Token = ERC20Token(0x71ee6E4fD5F2E70eD5e6fBAf853AE3B223564BCa);\r\n    \r\n    struct InvestorData {\r\n        uint256 funds;\r\n        uint256 lastDatetime;\r\n        uint256 totalProfit;\r\n    }\r\n    mapping (address =\u003E InvestorData) investors;\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function withdraw(uint256 amount)  public onlyOwner {\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function changeMinBalance(uint256 newMinBalance) public onlyOwner {\r\n        minBalance = newMinBalance;\r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address payable addr) {\r\n        assembly {\r\n          addr := mload(add(bys,20))\r\n        } \r\n    }\r\n    // function for transfer any token from contract\r\n    function transferTokens (address token, address target, uint256 amount) onlyOwner public\r\n    {\r\n        ERC20Token(token).transfer(target, amount);\r\n    }\r\n    \r\n    function getInfo(address investor) view public returns (uint256 totalFunds, uint256 pendingReward, uint256 totalProfit, uint256 contractBalance)\r\n    {\r\n        InvestorData memory data = investors[investor];\r\n        totalFunds = data.funds;\r\n        if (data.funds \u003E 0) pendingReward = data.funds.mul(20).div(100).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n        totalProfit = data.totalProfit;\r\n        contractBalance = address(this).balance;\r\n    }\r\n    \r\n    function() payable external\r\n    {\r\n        assert(msg.sender == tx.origin); // prevent bots to interact with contract\r\n        \r\n        if (msg.sender == owner) return;\r\n        \r\n        assert(PZM_Token.balanceOf(msg.sender) \u003E= minBalance * 10**18);\r\n        \r\n        \r\n        InvestorData storage data = investors[msg.sender];\r\n        \r\n        if (msg.value \u003E 0)\r\n        {\r\n            // first investment at least 2 ether, all next at least 0.01 ether\r\n            assert(msg.value \u003E= 0.2 ether || (data.funds != 0 \u0026\u0026 msg.value \u003E= 0.01 ether));\r\n            if (msg.data.length == 20) {\r\n                address payable ref = bytesToAddress(msg.data);\r\n                assert(ref != msg.sender);\r\n                ref.transfer(msg.value.mul(10).div(100));   // 10%\r\n                owner.transfer(msg.value.mul(5).div(100));  // 5%\r\n            } else if (msg.data.length == 0) {\r\n                owner.transfer(msg.value.mul(15).div(100));\r\n            } else {\r\n                assert(false); // invalid memo\r\n            }\r\n        }\r\n        \r\n        \r\n        if (data.funds != 0) {\r\n            // 20% per 30 days\r\n            uint256 reward = data.funds.mul(20).div(100).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n            data.totalProfit = data.totalProfit.add(reward);\r\n            \r\n            address(msg.sender).transfer(reward);\r\n        }\r\n\r\n        data.lastDatetime = block.timestamp;\r\n        data.funds = data.funds.add(msg.value.mul(85).div(100));\r\n        \r\n    }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newMinBalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022changeMinBalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferTokens\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022investor\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022totalFunds\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022pendingReward\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022contractBalance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022}]","ContractName":"PZMT_20_Plus","CompilerVersion":"v0.5.7\u002Bcommit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc9d111cf9cc281b2e206e0839d8c8a40a8ae040a97a169e7eda03b68f154e4d"}]