[{"SourceCode":"// hevm: flattened sources of src/Dpass.sol\npragma solidity \u003E=0.4.23 \u003E=0.5.0 \u003C0.6.0 \u003E=0.5.5 \u003C0.6.0 \u003E=0.5.11 \u003C0.6.0;\n\n////// lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003Chttp://www.gnu.org/licenses/\u003E.\n\n/* pragma solidity \u003E=0.4.23; */\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \u0022ds-auth-unauthorized\u0022);\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/src/GSN/Context.sol\n/* pragma solidity ^0.5.0; */\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n////// lib/openzeppelin-contracts/src/math/SafeMath.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a \u002B b;\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003C= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003E 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n////// lib/openzeppelin-contracts/src/drafts/Counters.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022../math/SafeMath.sol\u0022; */\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with \u0060using Counters for Counters.Counter;\u0060\n * Since it is not possible to overflow a 256 bit integer with increments of one, \u0060increment\u0060 can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying \u0060_value\u0060 is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value \u002B= 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n////// lib/openzeppelin-contracts/src/introspection/IERC165.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * \u0060interfaceId\u0060. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n////// lib/openzeppelin-contracts/src/introspection/ERC165.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022./IERC165.sol\u0022; */\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\n     */\n    mapping(bytes4 =\u003E bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * \u0060interfaceId\u0060. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - \u0060interfaceId\u0060 cannot be the ERC165 invalid interface (\u00600xffffffff\u0060).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \u0022ERC165: invalid interface id\u0022);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/IERC721.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022../../introspection/IERC165.sol\u0022; */\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in \u0060owner\u0060\u0027s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by \u0060tokenId\u0060.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\n     * another (\u0060to\u0060).\n     *\n     *\n     *\n     * Requirements:\n     * - \u0060from\u0060, \u0060to\u0060 cannot be zero.\n     * - \u0060tokenId\u0060 must be owned by \u0060from\u0060.\n     * - If the caller is not \u0060from\u0060, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (\u0060tokenId\u0060) from one account (\u0060from\u0060) to\n     * another (\u0060to\u0060).\n     *\n     * Requirements:\n     * - If the caller is not \u0060from\u0060, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/IERC721Receiver.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as \u0060this.onERC721Received.selector\u0060. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called \u0060safeTransferFrom\u0060 function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n////// lib/openzeppelin-contracts/src/utils/Address.sol\n/* pragma solidity ^0.5.5; */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if \u0060account\u0060 is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. \u0060keccak256(\u0027\u0027)\u0060\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an \u0060address\u0060 into \u0060address payable\u0060. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s \u0060transfer\u0060: sends \u0060amount\u0060 wei to\n     * \u0060recipient\u0060, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by \u0060transfer\u0060, making them unable to receive funds via\n     * \u0060transfer\u0060. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to \u0060recipient\u0060, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003E= amount, \u0022Address: insufficient balance\u0022);\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\u0022\u0022);\n        require(success, \u0022Address: unable to send value, recipient may have reverted\u0022);\n    }\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/ERC721.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022../../GSN/Context.sol\u0022; */\n/* import \u0022./IERC721.sol\u0022; */\n/* import \u0022./IERC721Receiver.sol\u0022; */\n/* import \u0022../../math/SafeMath.sol\u0022; */\n/* import \u0022../../utils/Address.sol\u0022; */\n/* import \u0022../../drafts/Counters.sol\u0022; */\n/* import \u0022../../introspection/ERC165.sol\u0022; */\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060\n    // which can be also obtained as \u0060IERC721Receiver(0).onERC721Received.selector\u0060\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 =\u003E address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 =\u003E address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address =\u003E Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address =\u003E mapping (address =\u003E bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256(\u0027balanceOf(address)\u0027)) == 0x70a08231\n     *     bytes4(keccak256(\u0027ownerOf(uint256)\u0027)) == 0x6352211e\n     *     bytes4(keccak256(\u0027approve(address,uint256)\u0027)) == 0x095ea7b3\n     *     bytes4(keccak256(\u0027getApproved(uint256)\u0027)) == 0x081812fc\n     *     bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) == 0xa22cb465\n     *     bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) == 0xe985e9c5\n     *     bytes4(keccak256(\u0027transferFrom(address,address,uint256)\u0027)) == 0x23b872dd\n     *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256)\u0027)) == 0x42842e0e\n     *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,bytes)\u0027)) == 0xb88d4fde\n     *\n     *     =\u003E 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \u0022ERC721: balance query for the zero address\u0022);\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \u0022ERC721: owner query for nonexistent token\u0022);\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \u0022ERC721: approval to current owner\u0022);\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \u0022ERC721: approve caller is not owner nor approved for all\u0022\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \u0022ERC721: approved query for nonexistent token\u0022);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \u0022ERC721: approve to caller\u0022);\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \u0022ERC721: transfer caller is not owner nor approved\u0022);\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \u0022\u0022);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \u0022ERC721: transfer caller is not owner nor approved\u0022);\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \u0022ERC721: transfer to non ERC721Receiver implementer\u0022);\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \u0022ERC721: operator query for nonexistent token\u0022);\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \u0022\u0022);\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \u0022ERC721: transfer to non ERC721Receiver implementer\u0022);\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \u0022ERC721: mint to the zero address\u0022);\n        require(!_exists(tokenId), \u0022ERC721: token already minted\u0022);\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \u0022ERC721: burn of token that is not own\u0022);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \u0022ERC721: transfer of token that is not own\u0022);\n        require(to != address(0), \u0022ERC721: transfer to the zero address\u0022);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/IERC721Enumerable.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022./IERC721.sol\u0022; */\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/ERC721Enumerable.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022../../GSN/Context.sol\u0022; */\n/* import \u0022./IERC721Enumerable.sol\u0022; */\n/* import \u0022./ERC721.sol\u0022; */\n/* import \u0022../../introspection/ERC165.sol\u0022; */\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address =\u003E uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 =\u003E uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 =\u003E uint256) private _allTokensIndex;\n\n    /*\n     *     bytes4(keccak256(\u0027totalSupply()\u0027)) == 0x18160ddd\n     *     bytes4(keccak256(\u0027tokenOfOwnerByIndex(address,uint256)\u0027)) == 0x2f745c59\n     *     bytes4(keccak256(\u0027tokenByIndex(uint256)\u0027)) == 0x4f6ccce7\n     *\n     *     =\u003E 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Constructor function.\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index \u003C balanceOf(owner), \u0022ERC721Enumerable: owner index out of bounds\u0022);\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index \u003C totalSupply(), \u0022ERC721Enumerable: global index out of bounds\u0022);\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {ERC721-_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner.\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the \u0060_ownedTokensIndex\u0060 mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from\u0027s tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn\u0027t been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/IERC721Metadata.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022./IERC721.sol\u0022; */\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/ERC721Metadata.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022../../GSN/Context.sol\u0022; */\n/* import \u0022./ERC721.sol\u0022; */\n/* import \u0022./IERC721Metadata.sol\u0022; */\n/* import \u0022../../introspection/ERC165.sol\u0022; */\n\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 =\u003E string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256(\u0027name()\u0027)) == 0x06fdde03\n     *     bytes4(keccak256(\u0027symbol()\u0027)) == 0x95d89b41\n     *     bytes4(keccak256(\u0027tokenURI(uint256)\u0027)) == 0xc87b56dd\n     *\n     *     =\u003E 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \u0022ERC721Metadata: URI query for nonexistent token\u0022);\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId), \u0022ERC721Metadata: URI set of nonexistent token\u0022);\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/src/token/ERC721/ERC721Full.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \u0022./ERC721.sol\u0022; */\n/* import \u0022./ERC721Enumerable.sol\u0022; */\n/* import \u0022./ERC721Metadata.sol\u0022; */\n\n/**\n * @title Full ERC721 Token\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology.\n *\n * See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n\n////// src/Dpass.sol\n/* pragma solidity ^0.5.11; */\n\n// /**\n//  * How to use dapp and openzeppelin-solidity https://github.com/dapphub/dapp/issues/70\n//  * ERC-721 standart: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n//  *\n//  */\n\n/* import \u0022ds-auth/auth.sol\u0022; */\n/* import \u0022openzeppelin-contracts/token/ERC721/ERC721Full.sol\u0022; */\n\n\ncontract DpassEvents {\n    event LogConfigChange(bytes32 what, bytes32 value1, bytes32 value2);\n    event LogCustodianChanged(uint tokenId, address custodian);\n    event LogDiamondAttributesHashChange(uint indexed tokenId, bytes8 hashAlgorithm);\n    event LogDiamondMinted(\n        address owner,\n        uint indexed tokenId,\n        bytes3 issuer,\n        bytes16 report,\n        bytes8 state\n    );\n    event LogRedeem(uint indexed tokenId);\n    event LogSale(uint indexed tokenId);\n    event LogStateChanged(uint indexed tokenId, bytes32 state);\n}\n\n\ncontract Dpass is DSAuth, ERC721Full, DpassEvents {\n    string private _name = \u0022Diamond Passport\u0022;\n    string private _symbol = \u0022Dpass\u0022;\n\n    struct Diamond {\n        bytes3 issuer;\n        bytes16 report;\n        bytes8 state;\n        bytes20 cccc;\n        uint24 carat;\n        bytes8 currentHashingAlgorithm;                             // Current hashing algorithm to check in the proof mapping\n    }\n    Diamond[] diamonds;                                             // List of Dpasses\n\n    mapping(uint =\u003E address) public custodian;                      // custodian that holds a Dpass token\n    mapping (uint =\u003E mapping(bytes32 =\u003E bytes32)) public proof;     // Prof of attributes integrity [tokenId][hashingAlgorithm] =\u003E hash\n    mapping (bytes32 =\u003E mapping (bytes32 =\u003E bool)) diamondIndex;    // List of dpasses by issuer and report number [issuer][number]\n    mapping (uint256 =\u003E uint256) public recreated;                  // List of recreated tokens. old tokenId =\u003E new tokenId\n    mapping(bytes32 =\u003E mapping(bytes32 =\u003E bool)) public canTransit; // List of state transition rules in format from =\u003E to = true/false\n    mapping(bytes32 =\u003E bool) public ccccs;\n\n    constructor () public ERC721Full(_name, _symbol) {\n        // Create dummy diamond to start real diamond minting from 1\n        Diamond memory _diamond = Diamond({\n            issuer: \u0022Slf\u0022,\n            report: \u00220\u0022,\n            state: \u0022invalid\u0022,\n            cccc: \u0022BR,IF,D,0001\u0022,\n            carat: 1,\n            currentHashingAlgorithm: \u0022\u0022\n        });\n\n        diamonds.push(_diamond);\n        _mint(address(this), 0);\n\n        // Transition rules\n        canTransit[\u0022valid\u0022][\u0022invalid\u0022] = true;\n        canTransit[\u0022valid\u0022][\u0022removed\u0022] = true;\n        canTransit[\u0022valid\u0022][\u0022sale\u0022] = true;\n        canTransit[\u0022valid\u0022][\u0022redeemed\u0022] = true;\n        canTransit[\u0022sale\u0022][\u0022valid\u0022] = true;\n        canTransit[\u0022sale\u0022][\u0022invalid\u0022] = true;\n        canTransit[\u0022sale\u0022][\u0022removed\u0022] = true;\n    }\n\n    modifier onlyOwnerOf(uint _tokenId) {\n        require(ownerOf(_tokenId) == msg.sender, \u0022dpass-access-denied\u0022);\n        _;\n    }\n\n    modifier onlyApproved(uint _tokenId) {\n        require(\n            ownerOf(_tokenId) == msg.sender ||\n            isApprovedForAll(ownerOf(_tokenId), msg.sender) ||\n            getApproved(_tokenId) == msg.sender\n            , \u0022dpass-access-denied\u0022);\n        _;\n    }\n\n    modifier ifExist(uint _tokenId) {\n        require(_exists(_tokenId), \u0022dpass-diamond-does-not-exist\u0022);\n        _;\n    }\n\n    modifier onlyValid(uint _tokenId) {\n        // TODO: DRY, _exists already check\n        require(_exists(_tokenId), \u0022dpass-diamond-does-not-exist\u0022);\n\n        Diamond storage _diamond = diamonds[_tokenId];\n        require(_diamond.state != \u0022invalid\u0022, \u0022dpass-invalid-diamond\u0022);\n        _;\n    }\n\n    /**\n    * @dev Custom accessor to create a unique token\n    * @param _to address of diamond owner\n    * @param _issuer string the issuer agency name\n    * @param _report string the issuer agency unique Nr.\n    * @param _state diamond state, \u0022sale\u0022 is the init state\n    * @param _cccc bytes32 cut, clarity, color, and carat class of diamond\n    * @param _carat uint24 carat of diamond with 2 decimals precision\n    * @param _currentHashingAlgorithm name of hasning algorithm (ex. 20190101)\n    * @param _custodian the custodian of minted dpass\n    * @return Return Diamond tokenId of the diamonds list\n    */\n    function mintDiamondTo(\n        address _to,\n        address _custodian,\n        bytes3 _issuer,\n        bytes16 _report,\n        bytes8 _state,\n        bytes20 _cccc,\n        uint24 _carat,\n        bytes32 _attributesHash,\n        bytes8 _currentHashingAlgorithm\n    )\n        public auth\n        returns(uint)\n    {\n        require(ccccs[_cccc], \u0022dpass-wrong-cccc\u0022);\n        _addToDiamondIndex(_issuer, _report);\n\n        Diamond memory _diamond = Diamond({\n            issuer: _issuer,\n            report: _report,\n            state: _state,\n            cccc: _cccc,\n            carat: _carat,\n            currentHashingAlgorithm: _currentHashingAlgorithm\n        });\n        uint _tokenId = diamonds.push(_diamond) - 1;\n        proof[_tokenId][_currentHashingAlgorithm] = _attributesHash;\n        custodian[_tokenId] = _custodian;\n\n        _mint(_to, _tokenId);\n        emit LogDiamondMinted(_to, _tokenId, _issuer, _report, _state);\n        return _tokenId;\n    }\n\n    /**\n    * @dev Update _tokenId attributes\n    * @param _attributesHash new attibutes hash value\n    * @param _currentHashingAlgorithm name of hasning algorithm (ex. 20190101)\n    */\n    function updateAttributesHash(\n        uint _tokenId,\n        bytes32 _attributesHash,\n        bytes8 _currentHashingAlgorithm\n    ) public auth onlyValid(_tokenId)\n    {\n        Diamond storage _diamond = diamonds[_tokenId];\n        _diamond.currentHashingAlgorithm = _currentHashingAlgorithm;\n\n        proof[_tokenId][_currentHashingAlgorithm] = _attributesHash;\n\n        emit LogDiamondAttributesHashChange(_tokenId, _currentHashingAlgorithm);\n    }\n\n    /**\n    * @dev Link old and the same new dpass\n    */\n    function linkOldToNewToken(uint _tokenId, uint _newTokenId) public auth {\n        require(_exists(_tokenId), \u0022dpass-old-diamond-doesnt-exist\u0022);\n        require(_exists(_newTokenId), \u0022dpass-new-diamond-doesnt-exist\u0022);\n        recreated[_tokenId] = _newTokenId;\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use \u0060safeTransferFrom\u0060 whenever possible\n     * Requires the msg.sender to be the owner, approved, or operator and not invalid token\n     * @param _from current owner of the token\n     * @param _to address to receive the ownership of the given token ID\n     * @param _tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _tokenId) public onlyValid(_tokenId) {\n        _checkTransfer(_tokenId);\n        super.transferFrom(_from, _to, _tokenId);\n    }\n\n    /*\n    * @dev Check if transferPossible\n    */\n    function _checkTransfer(uint256 _tokenId) internal view {\n        bytes32 state = diamonds[_tokenId].state;\n\n        require(state != \u0022removed\u0022, \u0022dpass-token-removed\u0022);\n        require(state != \u0022invalid\u0022, \u0022dpass-token-deleted\u0022);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement \u0060onERC721Received\u0060,\n     * which is called upon a safe transfer, and return the magic value\n     * \u0060bytes4(keccak256(\u0022onERC721Received(address,address,uint256,bytes)\u0022))\u0060; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param _from current owner of the token\n     * @param _to address to receive the ownership of the given token ID\n     * @param _tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\n        _checkTransfer(_tokenId);\n        super.safeTransferFrom(_from, _to, _tokenId);\n    }\n\n    /*\n    * @dev Returns the current state of diamond\n    */\n    function getState(uint _tokenId) public view ifExist(_tokenId) returns (bytes32) {\n        return diamonds[_tokenId].state;\n    }\n\n    /**\n     * @dev Gets the Diamond at a given _tokenId of all the diamonds in this contract\n     * Reverts if the _tokenId is greater or equal to the total number of diamonds\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     * @return Returns all the relevant information about a specific diamond\n     */\n    function getDiamondInfo(uint _tokenId)\n        public\n        view\n        ifExist(_tokenId)\n        returns (\n            address[2] memory ownerCustodian,\n            bytes32[6] memory attrs,\n            uint24 carat_\n        )\n    {\n        Diamond storage _diamond = diamonds[_tokenId];\n        bytes32 attributesHash = proof[_tokenId][_diamond.currentHashingAlgorithm];\n\n        ownerCustodian[0] = ownerOf(_tokenId);\n        ownerCustodian[1] = custodian[_tokenId];\n\n        attrs[0] = _diamond.issuer;\n        attrs[1] = _diamond.report;\n        attrs[2] = _diamond.state;\n        attrs[3] = _diamond.cccc;\n        attrs[4] = attributesHash;\n        attrs[5] = _diamond.currentHashingAlgorithm;\n\n        carat_ = _diamond.carat;\n    }\n\n    /**\n     * @dev Gets the Diamond at a given _tokenId of all the diamonds in this contract\n     * Reverts if the _tokenId is greater or equal to the total number of diamonds\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     * @return Returns all the relevant information about a specific diamond\n     */\n    function getDiamond(uint _tokenId)\n        public\n        view\n        ifExist(_tokenId)\n        returns (\n            bytes3 issuer,\n            bytes16 report,\n            bytes8 state,\n            bytes20 cccc,\n            uint24 carat,\n            bytes32 attributesHash\n        )\n    {\n        Diamond storage _diamond = diamonds[_tokenId];\n        attributesHash = proof[_tokenId][_diamond.currentHashingAlgorithm];\n\n        return (\n            _diamond.issuer,\n            _diamond.report,\n            _diamond.state,\n            _diamond.cccc,\n            _diamond.carat,\n            attributesHash\n        );\n    }\n\n    /**\n     * @dev Gets the Diamond issuer and it unique nr at a given _tokenId of all the diamonds in this contract\n     * Reverts if the _tokenId is greater or equal to the total number of diamonds\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     * @return Issuer and unique Nr. a specific diamond\n     */\n    function getDiamondIssuerAndReport(uint _tokenId) public view ifExist(_tokenId) returns(bytes32, bytes32) {\n        Diamond storage _diamond = diamonds[_tokenId];\n        return (_diamond.issuer, _diamond.report);\n    }\n\n    /**\n    * @dev Set cccc values that are allowed to be entered for diamonds\n    * @param _cccc bytes32 cccc value that will be enabled/disabled\n    * @param _allowed bool allow or disallow cccc\n    */\n    function setCccc(bytes32 _cccc, bool _allowed) public auth {\n        ccccs[_cccc] = _allowed;\n        emit LogConfigChange(\u0022cccc\u0022, _cccc, _allowed ? bytes32(\u00221\u0022) : bytes32(\u00220\u0022));\n    }\n\n    /**\n     * @dev Set new custodian for dpass\n     */\n    function setCustodian(uint _tokenId, address _newCustodian) public auth {\n        require(_newCustodian != address(0), \u0022dpass-wrong-address\u0022);\n        custodian[_tokenId] = _newCustodian;\n        emit LogCustodianChanged(_tokenId, _newCustodian);\n    }\n\n    /**\n    * @dev Get the custodian of Dpass.\n    */\n    function getCustodian(uint _tokenId) public view returns(address) {\n        return custodian[_tokenId];\n    }\n\n    /**\n     * @dev Enable transition _from -\u003E _to state\n    */\n    function enableTransition(bytes32 _from, bytes32 _to) public auth {\n        canTransit[_from][_to] = true;\n        emit LogConfigChange(\u0022canTransit\u0022, _from, _to);\n    }\n\n    /**\n     * @dev Disable transition _from -\u003E _to state\n    */\n    function disableTransition(bytes32 _from, bytes32 _to) public auth {\n        canTransit[_from][_to] = false;\n        emit LogConfigChange(\u0022canNotTransit\u0022, _from, _to);\n    }\n\n    /**\n     * @dev Set Diamond sale state\n     * Reverts if the _tokenId is greater or equal to the total number of diamonds\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     */\n    function setSaleState(uint _tokenId) public ifExist(_tokenId) onlyApproved(_tokenId) {\n        _setState(\u0022sale\u0022, _tokenId);\n        emit LogSale(_tokenId);\n    }\n\n    /**\n     * @dev Set Diamond invalid state\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     */\n    function setInvalidState(uint _tokenId) public ifExist(_tokenId) onlyApproved(_tokenId) {\n        _setState(\u0022invalid\u0022, _tokenId);\n        _removeDiamondFromIndex(_tokenId);\n    }\n\n    /**\n     * @dev Make diamond state as redeemed, change owner to contract owner\n     * Reverts if the _tokenId is greater or equal to the total number of diamonds\n     * @param _tokenId uint representing the index to be accessed of the diamonds list\n     */\n    function redeem(uint _tokenId) public ifExist(_tokenId) onlyOwnerOf(_tokenId) {\n        _setState(\u0022redeemed\u0022, _tokenId);\n        _removeDiamondFromIndex(_tokenId);\n        emit LogRedeem(_tokenId);\n    }\n\n    /**\n     * @dev Change diamond state.\n     * @param _newState new token state\n     * @param _tokenId represent the index of diamond\n     */\n    function setState(bytes8 _newState, uint _tokenId) public ifExist(_tokenId) onlyApproved(_tokenId) {\n        _setState(_newState, _tokenId);\n    }\n\n    // Private functions\n\n    /**\n     * @dev Validate transiton from currentState to newState. Revert on invalid transition\n     * @param _currentState current diamond state\n     * @param _newState new diamond state\n     */\n    function _validateStateTransitionTo(bytes8 _currentState, bytes8 _newState) internal view {\n        require(_currentState != _newState, \u0022dpass-already-in-that-state\u0022);\n        require(canTransit[_currentState][_newState], \u0022dpass-transition-now-allowed\u0022);\n    }\n\n    /**\n     * @dev Add Issuer and report with validation to uniqueness. Revert on invalid existance\n     * @param _issuer issuer like GIA\n     * @param _report issuer unique nr.\n     */\n    function _addToDiamondIndex(bytes32 _issuer, bytes32 _report) internal {\n        require(!diamondIndex[_issuer][_report], \u0022dpass-issuer-report-not-unique\u0022);\n        diamondIndex[_issuer][_report] = true;\n    }\n\n    function _removeDiamondFromIndex(uint _tokenId) internal {\n        Diamond storage _diamond = diamonds[_tokenId];\n        diamondIndex[_diamond.issuer][_diamond.report] = false;\n    }\n\n    /**\n     * @dev Change diamond state with logging. Revert on invalid transition\n     * @param _newState new token state\n     * @param _tokenId represent the index of diamond\n     */\n    function _setState(bytes8 _newState, uint _tokenId) internal {\n        Diamond storage _diamond = diamonds[_tokenId];\n        _validateStateTransitionTo(_diamond.state, _newState);\n        _diamond.state = _newState;\n        emit LogStateChanged(_tokenId, _newState);\n    }\n}\n\n","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022interfaceId\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022supportsInterface\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022recreated\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022custodian\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getApproved\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setSaleState\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getCustodian\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getDiamondInfo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[2]\u0022,\u0022name\u0022:\u0022ownerCustodian\u0022,\u0022type\u0022:\u0022address[2]\u0022},{\u0022internalType\u0022:\u0022bytes32[6]\u0022,\u0022name\u0022:\u0022attrs\u0022,\u0022type\u0022:\u0022bytes32[6]\u0022},{\u0022internalType\u0022:\u0022uint24\u0022,\u0022name\u0022:\u0022carat_\u0022,\u0022type\u0022:\u0022uint24\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_newTokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022linkOldToNewToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_attributesHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022_currentHashingAlgorithm\u0022,\u0022type\u0022:\u0022bytes8\u0022}],\u0022name\u0022:\u0022updateAttributesHash\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenOfOwnerByIndex\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getDiamondIssuerAndReport\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022safeTransferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getState\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenByIndex\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setInvalidState\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022ccccs\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022_newState\u0022,\u0022type\u0022:\u0022bytes8\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setState\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022proof\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022ownerOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022authority_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAuthority\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022canTransit\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_newCustodian\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setCustodian\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_cccc\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022_allowed\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022setCccc\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022approved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022setApprovalForAll\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022safeTransferFrom\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022authority\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022tokenURI\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022enableTransition\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022redeem\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022_tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getDiamond\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes3\u0022,\u0022name\u0022:\u0022issuer\u0022,\u0022type\u0022:\u0022bytes3\u0022},{\u0022internalType\u0022:\u0022bytes16\u0022,\u0022name\u0022:\u0022report\u0022,\u0022type\u0022:\u0022bytes16\u0022},{\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022state\u0022,\u0022type\u0022:\u0022bytes8\u0022},{\u0022internalType\u0022:\u0022bytes20\u0022,\u0022name\u0022:\u0022cccc\u0022,\u0022type\u0022:\u0022bytes20\u0022},{\u0022internalType\u0022:\u0022uint24\u0022,\u0022name\u0022:\u0022carat\u0022,\u0022type\u0022:\u0022uint24\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022attributesHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022disableTransition\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022operator\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022isApprovedForAll\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_custodian\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bytes3\u0022,\u0022name\u0022:\u0022_issuer\u0022,\u0022type\u0022:\u0022bytes3\u0022},{\u0022internalType\u0022:\u0022bytes16\u0022,\u0022name\u0022:\u0022_report\u0022,\u0022type\u0022:\u0022bytes16\u0022},{\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022_state\u0022,\u0022type\u0022:\u0022bytes8\u0022},{\u0022internalType\u0022:\u0022bytes20\u0022,\u0022name\u0022:\u0022_cccc\u0022,\u0022type\u0022:\u0022bytes20\u0022},{\u0022internalType\u0022:\u0022uint24\u0022,\u0022name\u0022:\u0022_carat\u0022,\u0022type\u0022:\u0022uint24\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022_attributesHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022_currentHashingAlgorithm\u0022,\u0022type\u0022:\u0022bytes8\u0022}],\u0022name\u0022:\u0022mintDiamondTo\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022what\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022value1\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022value2\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022LogConfigChange\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022custodian\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogCustodianChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022hashAlgorithm\u0022,\u0022type\u0022:\u0022bytes8\u0022}],\u0022name\u0022:\u0022LogDiamondAttributesHashChange\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes3\u0022,\u0022name\u0022:\u0022issuer\u0022,\u0022type\u0022:\u0022bytes3\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes16\u0022,\u0022name\u0022:\u0022report\u0022,\u0022type\u0022:\u0022bytes16\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes8\u0022,\u0022name\u0022:\u0022state\u0022,\u0022type\u0022:\u0022bytes8\u0022}],\u0022name\u0022:\u0022LogDiamondMinted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogRedeem\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LogSale\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022state\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022LogStateChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022approved\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022tokenId\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022operator\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022approved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022ApprovalForAll\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022authority\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetAuthority\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetOwner\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Dpass","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fa9d260a0fbebc141ee75541b85bec8dac7ca406159a8693a4d5345d7d0d86e6"}]