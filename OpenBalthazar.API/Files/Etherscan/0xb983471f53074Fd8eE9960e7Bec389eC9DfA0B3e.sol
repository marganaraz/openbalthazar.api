[{"SourceCode":"{{\r\n  \u0022language\u0022: \u0022Solidity\u0022,\r\n  \u0022settings\u0022: {\r\n    \u0022remappings\u0022: [\r\n      \u0022main=./src\u0022\r\n    ],\r\n    \u0022optimizer\u0022: {\r\n      \u0022enabled\u0022: true,\r\n      \u0022runs\u0022: 200\r\n    },\r\n    \u0022evmVersion\u0022: \u0022istanbul\u0022,\r\n    \u0022outputSelection\u0022: {\r\n      \u0022*\u0022: {\r\n        \u0022*\u0022: [\r\n          \u0022evm.bytecode\u0022,\r\n          \u0022evm.deployedBytecode\u0022,\r\n          \u0022abi\u0022\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \u0022sources\u0022: {\r\n    \u0022./src/dependencies/DSAuth.sol\u0022: {\r\n      \u0022content\u0022: \u0022/// @notice Modified from DappHub (https://git.io/fpwrq)\\n\\npragma solidity 0.6.1;\\n\\nabstract contract DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) public view virtual returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\u0022ds-auth-unauthorized\\\u0022);\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/DSGuard.sol\u0022: {\r\n      \u0022content\u0022: \u0022/// @notice Retrieved from DappHub (https://git.io/fpwMi)\\n\\npragma solidity 0.6.1;\\n\\nimport \\\u0022./DSAuth.sol\\\u0022;\\n\\ncontract DSGuardEvents {\\n    event LogPermit(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n\\n    event LogForbid(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n}\\n\\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\\n    bytes32 constant public ANY = bytes32(uint(-1));\\n\\n    mapping (bytes32 =\u003E mapping (bytes32 =\u003E mapping (bytes32 =\u003E bool))) acl;\\n\\n    function canCall(\\n        address src_, address dst_, bytes4 sig\\n    ) public view override returns (bool) {\\n        bytes32 src = bytes32(bytes20(src_));\\n        bytes32 dst = bytes32(bytes20(dst_));\\n\\n        return acl[src][dst][sig]\\n            || acl[src][dst][ANY]\\n            || acl[src][ANY][sig]\\n            || acl[src][ANY][ANY]\\n            || acl[ANY][dst][sig]\\n            || acl[ANY][dst][ANY]\\n            || acl[ANY][ANY][sig]\\n            || acl[ANY][ANY][ANY];\\n    }\\n\\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n        acl[src][dst][sig] = true;\\n        emit LogPermit(src, dst, sig);\\n    }\\n\\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n        acl[src][dst][sig] = false;\\n        emit LogForbid(src, dst, sig);\\n    }\\n\\n    function permit(address src, address dst, bytes32 sig) public {\\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n    function forbid(address src, address dst, bytes32 sig) public {\\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n\\n}\\n\\ncontract DSGuardFactory {\\n    mapping (address =\u003E bool)  public  isGuard;\\n\\n    function newGuard() public returns (DSGuard guard) {\\n        guard = new DSGuard();\\n        guard.setOwner(msg.sender);\\n        isGuard[address(guard)] = true;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/DSMath.sol\u0022: {\r\n      \u0022content\u0022: \u0022/// DSMath.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \u003Chttp://www.gnu.org/licenses/\u003E.\\n\\npragma solidity \u003E0.4.13;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x \u002B y) \u003E= x, \\\u0022ds-math-add-overflow\\\u0022);\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) \u003C= x, \\\u0022ds-math-sub-underflow\\\u0022);\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\u0022ds-math-mul-overflow\\\u0022);\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x \u003C= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x \u003E= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x \u003C= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x \u003E= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\u0022exponentiation by squaring\\\u0022\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It\u0027s O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/SafeMath.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\\n    // benefit is lost if \u0027b\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = _a * _b;\\n    require(c / _a == _b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \u003E 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = _a / _b;\\n    // assert(_a == _b * c \u002B _a % _b); // There is no case in which this doesn\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \u003C= _a);\\n    uint256 c = _a - _b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    uint256 c = _a \u002B _b;\\n    require(c \u003E= _a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/token/BurnableToken.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./PreminedToken.sol\\\u0022;\\n\\n/// @dev Just a wrapper for premined tokens which can actually be burnt\\ncontract BurnableToken is PreminedToken {\\n    constructor(string memory _symbol, uint8 _decimals, string memory _name)\\n        public\\n        PreminedToken(_symbol, _decimals, _name)\\n    {}\\n\\n    function burn(uint _amount) public {\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/token/IERC20.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n * Altered from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/ERC20.sol\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address _who) external view returns (uint256);\\n\\n  function allowance(address _owner, address _spender)\\n    external view returns (uint256);\\n\\n  function transfer(address _to, uint256 _value) external returns (bool);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\\n/// @dev Just adds extra functions that we use elsewhere\\nabstract contract ERC20WithFields is IERC20 {\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/token/PreminedToken.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./StandardToken.sol\\\u0022;\\n\\ncontract PreminedToken is StandardToken {\\n    string public symbol;\\n    string public  name;\\n    uint8 public decimals;\\n\\n    constructor(string memory _symbol, uint8 _decimals, string memory _name) public {\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        name = _name;\\n        totalSupply_ = 1000000 * 10**uint(decimals);\\n        balances[msg.sender] = totalSupply_;\\n        emit Transfer(address(0), msg.sender, totalSupply_);\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/token/StandardToken.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./IERC20.sol\\\u0022;\\nimport \\\u0022../SafeMath.sol\\\u0022;\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n * Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/StandardToken.sol\\n */\\ncontract StandardToken is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\u003E uint256) balances;\\n\\n    mapping (address =\u003E mapping (address =\u003E uint256)) allowed;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param _owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public virtual override returns (bool) {\\n        require(_value \u003C= balances[msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n    * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    * @param _spender The address which will spend the funds.\\n        * @param _value The amount of tokens to be spent.\\n        */\\n    function approve(address _spender, uint256 _value) public virtual override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param _from address The address which you want to send tokens from\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint256 the amount of tokens to be transferred\\n    */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        require(_value \u003C= balances[_from]);\\n        require(_value \u003C= allowed[_from][msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed[_spender] == 0. To increment\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param _spender The address which will spend the funds.\\n    * @param _addedValue The amount of tokens to increase the allowance by.\\n    */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue \u003E= oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Internal function that mints an amount of the token and assigns it to\\n    * an account. This encapsulates the modification of balances such that the\\n    * proper events are emitted.\\n    * @param _account The account that will receive the created tokens.\\n    * @param _amount The amount that will be created.\\n     */\\n    function _mint(address _account, uint256 _amount) internal {\\n        require(_account != address(0));\\n        totalSupply_ = totalSupply_.add(_amount);\\n        balances[_account] = balances[_account].add(_amount);\\n        emit Transfer(address(0), _account, _amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param _account The account whose tokens will be burnt.\\n     * @param _amount The amount that will be burnt.\\n     */\\n    function _burn(address _account, uint256 _amount) internal {\\n        require(_account != address(0));\\n        require(_amount \u003C= balances[_account]);\\n\\n        totalSupply_ = totalSupply_.sub(_amount);\\n        balances[_account] = balances[_account].sub(_amount);\\n        emit Transfer(_account, address(0), _amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender\u0027s allowance for said account. Uses the\\n     * internal _burn function.\\n     * @param _account The account whose tokens will be burnt.\\n     * @param _amount The amount that will be burnt.\\n     */\\n    function _burnFrom(address _account, uint256 _amount) internal {\\n        require(_amount \u003C= allowed[_account][msg.sender]);\\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\\n        emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\\n        _burn(_account, _amount);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/TokenUser.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./token/IERC20.sol\\\u0022;\\nimport \\\u0022./DSMath.sol\\\u0022;\\n\\n/// @notice Wrapper to ensure tokens are received\\ncontract TokenUser is DSMath {\\n    function safeTransfer(\\n        address _token,\\n        address _to,\\n        uint _value\\n    ) internal {\\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\\n        IERC20(_token).transfer(_to, _value);\\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\\n        require(\\n            add(receiverPreBalance, _value) == receiverPostBalance,\\n            \\\u0022Receiver did not receive tokens in transfer\\\u0022\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint _value\\n    ) internal {\\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\\n        IERC20(_token).transferFrom(_from, _to, _value);\\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\\n        require(\\n            add(receiverPreBalance, _value) == receiverPostBalance,\\n            \\\u0022Receiver did not receive tokens in transferFrom\\\u0022\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/dependencies/WETH.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ncontract WETH {\\n    string public name     = \\\u0022Wrapped Ether\\\u0022;\\n    string public symbol   = \\\u0022WETH\\\u0022;\\n    uint8  public decimals = 18;\\n\\n    event  Approval(address indexed src, address indexed guy, uint wad);\\n    event  Transfer(address indexed src, address indexed dst, uint wad);\\n    event  Deposit(address indexed dst, uint wad);\\n    event  Withdrawal(address indexed src, uint wad);\\n\\n    mapping (address =\u003E uint)                       public  balanceOf;\\n    mapping (address =\u003E mapping (address =\u003E uint))  public  allowance;\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n    function deposit() public payable {\\n        balanceOf[msg.sender] \u002B= msg.value;\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n    function withdraw(uint wad) public {\\n        require(balanceOf[msg.sender] \u003E= wad);\\n        balanceOf[msg.sender] -= wad;\\n        msg.sender.transfer(wad);\\n        emit Withdrawal(msg.sender, wad);\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n\\n    function approve(address guy, uint wad) public returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n        emit Approval(msg.sender, guy, wad);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint wad) public returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        returns (bool)\\n    {\\n        require(balanceOf[src] \u003E= wad);\\n\\n        if (src != msg.sender \u0026\u0026 allowance[src][msg.sender] != uint(-1)) {\\n            require(allowance[src][msg.sender] \u003E= wad);\\n            allowance[src][msg.sender] -= wad;\\n        }\\n\\n        balanceOf[src] -= wad;\\n        balanceOf[dst] \u002B= wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/engine/AmguConsumer.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../version/IVersion.sol\\\u0022;\\nimport \\\u0022./IEngine.sol\\\u0022;\\nimport \\\u0022../version/Registry.sol\\\u0022;\\n\\n/// @notice Abstract contracts\\n/// @notice inherit this to pay AMGU on a function call\\nabstract contract AmguConsumer is DSMath {\\n\\n    /// @dev each of these must be implemented by the inheriting contract\\n    function engine() public view virtual returns (address);\\n    function mlnToken() public view virtual returns (address);\\n    function priceSource() public view virtual returns (address);\\n    function registry() public view virtual returns (address);\\n    event AmguPaid(address indexed payer, uint256 totalAmguPaidInEth, uint256 amguChargableGas, uint256 incentivePaid);\\n\\n    /// bool deductIncentive is used when sending extra eth beyond amgu\\n    modifier amguPayable(bool deductIncentive) {\\n        uint preGas = gasleft();\\n        _;\\n        uint postGas = gasleft();\\n\\n        uint mlnPerAmgu = IEngine(engine()).getAmguPrice();\\n        uint mlnQuantity = mul(\\n            mlnPerAmgu,\\n            sub(preGas, postGas)\\n        );\\n        address nativeAsset = Registry(registry()).nativeAsset();\\n        uint ethToPay = IPriceSource(priceSource()).convertQuantity(\\n            mlnQuantity,\\n            mlnToken(),\\n            nativeAsset\\n        );\\n        uint incentiveAmount;\\n        if (deductIncentive) {\\n            incentiveAmount = Registry(registry()).incentive();\\n        } else {\\n            incentiveAmount = 0;\\n        }\\n        require(\\n            msg.value \u003E= add(ethToPay, incentiveAmount),\\n            \\\u0022Insufficent AMGU and/or incentive\\\u0022\\n        );\\n        IEngine(engine()).payAmguInEther.value(ethToPay)();\\n\\n        require(\\n            msg.sender.send(\\n                sub(\\n                    sub(msg.value, ethToPay),\\n                    incentiveAmount\\n                )\\n            ),\\n            \\\u0022Refund failed\\\u0022\\n        );\\n        emit AmguPaid(msg.sender, ethToPay, sub(preGas, postGas), incentiveAmount);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/engine/Engine.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../dependencies/token/BurnableToken.sol\\\u0022;\\nimport \\\u0022../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../version/Registry.sol\\\u0022;\\n\\n/// @notice Liquidity contract and token sink\\ncontract Engine is DSMath {\\n\\n    event RegistryChange(address registry);\\n    event SetAmguPrice(uint amguPrice);\\n    event AmguPaid(uint amount);\\n    event Thaw(uint amount);\\n    event Burn(uint amount);\\n\\n    uint public constant MLN_DECIMALS = 18;\\n\\n    Registry public registry;\\n    uint public amguPrice;\\n    uint public frozenEther;\\n    uint public liquidEther;\\n    uint public lastThaw;\\n    uint public thawingDelay;\\n    uint public totalEtherConsumed;\\n    uint public totalAmguConsumed;\\n    uint public totalMlnBurned;\\n\\n    constructor(uint _delay, address _registry) public {\\n        lastThaw = block.timestamp;\\n        thawingDelay = _delay;\\n        _setRegistry(_registry);\\n    }\\n\\n    modifier onlyMGM() {\\n        require(\\n            msg.sender == registry.MGM(),\\n            \\\u0022Only MGM can call this\\\u0022\\n        );\\n        _;\\n    }\\n\\n    /// @dev Registry owner is MTC\\n    modifier onlyMTC() {\\n        require(\\n            msg.sender == registry.owner(),\\n            \\\u0022Only MTC can call this\\\u0022\\n        );\\n        _;\\n    }\\n\\n    function _setRegistry(address _registry) internal {\\n        registry = Registry(_registry);\\n        emit RegistryChange(address(registry));\\n    }\\n\\n    /// @dev only callable by MTC\\n    function setRegistry(address _registry)\\n        external\\n        onlyMTC\\n    {\\n        _setRegistry(_registry);\\n    }\\n\\n    /// @dev set price of AMGU in MLN (base units)\\n    /// @dev only callable by MGM\\n    function setAmguPrice(uint _price)\\n        external\\n        onlyMGM\\n    {\\n        amguPrice = _price;\\n        emit SetAmguPrice(_price);\\n    }\\n\\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\\n\\n    function premiumPercent() public view returns (uint) {\\n        if (liquidEther \u003C 1 ether) {\\n            return 0;\\n        } else if (liquidEther \u003E= 1 ether \u0026\u0026 liquidEther \u003C 5 ether) {\\n            return 5;\\n        } else if (liquidEther \u003E= 5 ether \u0026\u0026 liquidEther \u003C 10 ether) {\\n            return 10;\\n        } else if (liquidEther \u003E= 10 ether) {\\n            return 15;\\n        }\\n    }\\n\\n    function payAmguInEther() external payable {\\n        require(\\n            registry.isFundFactory(msg.sender) ||\\n            registry.isFund(msg.sender),\\n            \\\u0022Sender must be a fund or the factory\\\u0022\\n        );\\n        uint mlnPerAmgu = getAmguPrice();\\n        uint ethPerMln;\\n        (ethPerMln,) = priceSource().getPrice(address(mlnToken()));\\n        uint amguConsumed;\\n        if (mlnPerAmgu \u003E 0 \u0026\u0026 ethPerMln \u003E 0) {\\n            amguConsumed = (mul(msg.value, 10 ** uint(MLN_DECIMALS))) / (mul(ethPerMln, mlnPerAmgu));\\n        } else {\\n            amguConsumed = 0;\\n        }\\n        totalEtherConsumed = add(totalEtherConsumed, msg.value);\\n        totalAmguConsumed = add(totalAmguConsumed, amguConsumed);\\n        frozenEther = add(frozenEther, msg.value);\\n        emit AmguPaid(amguConsumed);\\n    }\\n\\n    /// @notice Move frozen ether to liquid pool after delay\\n    /// @dev Delay only restarts when this function is called\\n    function thaw() external {\\n        require(\\n            block.timestamp \u003E= add(lastThaw, thawingDelay),\\n            \\\u0022Thawing delay has not passed\\\u0022\\n        );\\n        require(frozenEther \u003E 0, \\\u0022No frozen ether to thaw\\\u0022);\\n        lastThaw = block.timestamp;\\n        liquidEther = add(liquidEther, frozenEther);\\n        emit Thaw(frozenEther);\\n        frozenEther = 0;\\n    }\\n\\n    /// @return ETH per MLN including premium\\n    function enginePrice() public view returns (uint) {\\n        uint ethPerMln;\\n        (ethPerMln, ) = priceSource().getPrice(address(mlnToken()));\\n        uint premium = (mul(ethPerMln, premiumPercent()) / 100);\\n        return add(ethPerMln, premium);\\n    }\\n\\n    function ethPayoutForMlnAmount(uint mlnAmount) public view returns (uint) {\\n        return mul(mlnAmount, enginePrice()) / 10 ** uint(MLN_DECIMALS);\\n    }\\n\\n    /// @notice MLN must be approved first\\n    function sellAndBurnMln(uint mlnAmount) external {\\n        require(registry.isFund(msg.sender), \\\u0022Only funds can use the engine\\\u0022);\\n        require(\\n            mlnToken().transferFrom(msg.sender, address(this), mlnAmount),\\n            \\\u0022MLN transferFrom failed\\\u0022\\n        );\\n        uint ethToSend = ethPayoutForMlnAmount(mlnAmount);\\n        require(ethToSend \u003E 0, \\\u0022No ether to pay out\\\u0022);\\n        require(liquidEther \u003E= ethToSend, \\\u0022Not enough liquid ether to send\\\u0022);\\n        liquidEther = sub(liquidEther, ethToSend);\\n        totalMlnBurned = add(totalMlnBurned, mlnAmount);\\n        msg.sender.transfer(ethToSend);\\n        mlnToken().burn(mlnAmount);\\n        emit Burn(mlnAmount);\\n    }\\n\\n    /// @dev Get MLN from the registry\\n    function mlnToken()\\n        public\\n        view\\n        returns (BurnableToken)\\n    {\\n        return BurnableToken(registry.mlnToken());\\n    }\\n\\n    /// @dev Get PriceSource from the registry\\n    function priceSource()\\n        public\\n        view\\n        returns (IPriceSource)\\n    {\\n        return IPriceSource(registry.priceSource());\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/engine/IEngine.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n\\ninterface IEngine {\\n    function payAmguInEther() external payable;\\n    function getAmguPrice() external view returns (uint256);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/EngineAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../engine/Engine.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../dependencies/WETH.sol\\\u0022;\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\nimport \\\u0022../dependencies/TokenUser.sol\\\u0022;\\n\\n/// @notice Trading adapter to Melon Engine\\ncontract EngineAdapter is DSMath, TokenUser, ExchangeAdapter {\\n\\n    /// @notice Buys Ether from the engine, selling MLN\\n    /// @param targetExchange Address of the engine\\n    /// @param orderValues [0] Min Eth to receive from the engine\\n    /// @param orderValues [1] MLN quantity\\n    /// @param orderValues [6] Same as orderValues[1]\\n    /// @param orderAddresses [2] WETH token\\n    /// @param orderAddresses [3] MLN token\\n    function takeOrder (\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override onlyManager notShutDown {\\n        Hub hub = getHub();\\n\\n        address wethAddress = orderAddresses[2];\\n        address mlnAddress = orderAddresses[3];\\n        uint minEthToReceive = orderValues[0];\\n        uint mlnQuantity = orderValues[1];\\n\\n        require(\\n            wethAddress == Registry(hub.registry()).nativeAsset(),\\n            \\\u0022maker asset doesnt match nativeAsset on registry\\\u0022\\n        );\\n        require(\\n            orderValues[1] == orderValues[6],\\n            \\\u0022fillTakerQuantity must equal takerAssetQuantity\\\u0022\\n        );\\n\\n        approveAsset(mlnAddress, targetExchange, mlnQuantity, \\\u0022takerAsset\\\u0022);\\n\\n        uint ethToReceive = Engine(targetExchange).ethPayoutForMlnAmount(mlnQuantity);\\n\\n        require(\\n            ethToReceive \u003E= minEthToReceive,\\n            \\\u0022Expected ETH to receive is less than takerQuantity (minEthToReceive)\\\u0022\\n        );\\n\\n        Engine(targetExchange).sellAndBurnMln(mlnQuantity);\\n        WETH(payable(wethAddress)).deposit.value(ethToReceive)();\\n        safeTransfer(wethAddress, address(Vault(hub.vault())), ethToReceive);\\n\\n        getAccounting().addAssetToOwnedAssets(wethAddress);\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(0),\\n            Trading.UpdateType.take,\\n            [payable(wethAddress), payable(mlnAddress)],\\n            [ethToReceive, mlnQuantity, mlnQuantity]\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/EthfinexAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../version/Registry.sol\\\u0022;\\nimport \\\u0022../dependencies/WETH.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022./interfaces/IZeroExV2.sol\\\u0022;\\nimport \\\u0022./interfaces/IEthfinex.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\n/// @title EthfinexAdapter Contract\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Adapter to EthFinex exchange\\ncontract EthfinexAdapter is DSMath, ExchangeAdapter {\\n    /// @param _orderAddresses [2] Order maker asset\\n    /// @param _orderAddresses [3] Order taker asset\\n    /// @param _orderData [0] Encoded data specific to maker asset\\n    /// @param _orderData [1] Encoded data specific to taker asset\\n    modifier orderAddressesMatchOrderData(\\n        address[8] memory _orderAddresses,\\n        bytes[4] memory _orderData\\n    )\\n    {\\n        require(\\n            getAssetAddress(_orderData[0]) == getWrapperToken(_orderAddresses[2]),\\n            \\\u0022Maker asset data does not match order address in array\\\u0022\\n        );\\n        require(\\n            getAssetAddress(_orderData[1]) == _orderAddresses[3],\\n            \\\u0022Taker asset data does not match order address in array\\\u0022\\n        );\\n        _;\\n    }\\n\\n    //  METHODS\\n\\n    //  PUBLIC METHODS\\n\\n    /// @notice Make order by pre-approving signatures\\n    function makeOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n        orderAddressesMatchOrderData(_orderAddresses, _orderData)\\n    {\\n        ensureCanMakeOrder(_orderAddresses[2]);\\n\\n        IZeroExV2.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\\n        bytes memory wrappedMakerAssetData = _orderData[0];\\n        bytes memory takerAssetData = _orderData[1];\\n        address makerAsset = _orderAddresses[2];\\n        address takerAsset = getAssetAddress(takerAssetData);\\n\\n        // Order parameter checks\\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\\n        ensureNotInOpenMakeOrder(makerAsset);\\n\\n        wrapMakerAsset(_targetExchange, makerAsset, wrappedMakerAssetData, order.makerAssetAmount, order.expirationTimeSeconds);\\n\\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(order);\\n        IZeroExV2(_targetExchange).preSign(orderInfo.orderHash, address(this), _signature);\\n\\n        require(\\n            IZeroExV2(_targetExchange).isValidSignature(\\n                orderInfo.orderHash,\\n                address(this),\\n                _signature\\n            ),\\n            \\\u0022INVALID_ORDER_SIGNATURE\\\u0022\\n        );\\n\\n        updateStateMakeOrder(_targetExchange, order);\\n    }\\n\\n    /// @notice Cancel the 0x make order\\n    function cancelOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        orderAddressesMatchOrderData(_orderAddresses, _orderData)\\n    {\\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(_identifier);\\n        ensureCancelPermitted(_targetExchange, _orderAddresses[2], _identifier);\\n        IZeroExV2(_targetExchange).cancelOrder(order);\\n\\n        updateStateCancelOrder(_targetExchange, order);\\n    }\\n\\n    /// @notice Unwrap (withdraw) tokens, uses _orderAddresses for input list of tokens to be unwrapped\\n    /// @dev Call to \\\u0022withdraw\\\u0022 fails if timestamp \u003C \u0060Wrapper.depositLock(tradingComponent)\u0060\\n    function withdrawTokens(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n    {\\n        Hub hub = getHub();\\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\\n\\n        for (uint i = 0; i \u003C _orderAddresses.length; i\u002B\u002B) {\\n            if (_orderAddresses[i] == address(0)) continue;\\n            address wrappedToken = getWrapperToken(_orderAddresses[i]);\\n            uint balance = IWrapperLock(wrappedToken).balanceOf(address(this));\\n            require(balance \u003E 0, \\\u0022Insufficient balance\\\u0022);\\n            IWrapperLock(wrappedToken).withdraw(balance, 0, bytes32(0), bytes32(0), 0);\\n            if (_orderAddresses[i] == nativeAsset) {\\n                WETH(payable(nativeAsset)).deposit.value(balance)();\\n            }\\n            getTrading().removeOpenMakeOrder(_targetExchange, _orderAddresses[i]);\\n            getTrading().returnAssetToVault(_orderAddresses[i]);\\n        }\\n    }\\n\\n     /// @notice Minor: Wrapped tokens directly sent to the fund are not accounted. To be called by Trading spoke\\n    function getOrder(address _targetExchange, uint256 _id, address _makerAsset)\\n        public\\n        view\\n        override\\n        returns (address, address, uint256, uint256)\\n    {\\n        uint orderId;\\n        uint orderIndex;\\n        address takerAsset;\\n        uint makerQuantity;\\n        uint takerQuantity;\\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(_targetExchange, _makerAsset);\\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\\n\\n        // Check if order has been completely filled\\n        uint takerAssetFilledAmount = IZeroExV2(_targetExchange).filled(bytes32(orderId));\\n        if (sub(takerQuantity, takerAssetFilledAmount) == 0) {\\n            return (_makerAsset, takerAsset, 0, 0);\\n        }\\n\\n        // Check if tokens have been withdrawn (cancelled order may still need to be accounted if there is balance)\\n        uint balance = IWrapperLock(getWrapperTokenFromAdapterContext(_makerAsset)).balanceOf(msg.sender);\\n        if (balance == 0) {\\n            return (_makerAsset, takerAsset, 0, 0);\\n        }\\n        return (_makerAsset, takerAsset, makerQuantity, sub(takerQuantity, takerAssetFilledAmount));\\n    }\\n\\n    // INTERNAL METHODS\\n\\n    /// @notice needed to avoid stack too deep error\\n    /// @dev deposit time should be greater than 1 hour\\n    function wrapMakerAsset(\\n        address _targetExchange,\\n        address _makerAsset,\\n        bytes memory _wrappedMakerAssetData,\\n        uint _makerQuantity,\\n        uint _orderExpirationTime\\n    )\\n        internal\\n    {\\n        Hub hub = getHub();\\n\\n        // Deposit to rounded up value of time difference of expiration time and current time (in hours)\\n        uint depositTime = (\\n            sub(_orderExpirationTime, block.timestamp) / 1 hours\\n        ) \u002B 1;\\n\\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\\n        address wrappedToken = getWrapperToken(_makerAsset);\\n        // Handle case for WETH vs ERC20\\n        if (_makerAsset == nativeAsset) {\\n            Vault vault = Vault(hub.vault());\\n            vault.withdraw(_makerAsset, _makerQuantity);\\n            WETH(payable(nativeAsset)).withdraw(_makerQuantity);\\n            IWrapperLockEth(wrappedToken).deposit.value(_makerQuantity)(_makerQuantity, depositTime);\\n        } else {\\n            approveAsset(\\n                _makerAsset,\\n                wrappedToken,\\n                _makerQuantity,\\n                \\\u0022makerAsset\\\u0022\\n            );\\n            IWrapperLock(wrappedToken).deposit(_makerQuantity, depositTime);\\n        }\\n    }\\n\\n    // @dev avoids stack too deep error\\n    function updateStateCancelOrder(address _targetExchange, IZeroExV2.Order memory _order)\\n        internal\\n    {\\n        // Order is not removed from OpenMakeOrder mapping as it\u0027s needed for accounting (wrapped tokens)\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            IZeroExV2(_targetExchange).getOrderInfo(_order).orderHash,\\n            Trading.UpdateType.cancel,\\n            [address(0), address(0)],\\n            [uint(0), uint(0), uint(0)]\\n        );\\n    }\\n\\n    // @dev avoids stack too deep error\\n    function updateStateMakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\\n        internal\\n    {\\n        address wrapperRegistry = Registry(getTrading().registry()).ethfinexWrapperRegistry();\\n        address wrappedMakerAsset = getAssetAddress(_order.makerAssetData);\\n        address makerAsset = IWrapperRegistryEFX(\\n            wrapperRegistry\\n        ).wrapper2TokenLookup(wrappedMakerAsset);\\n        address takerAsset = getAssetAddress(_order.takerAssetData);\\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(_order);\\n\\n        getAccounting().addAssetToOwnedAssets(takerAsset);\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            orderInfo.orderHash,\\n            Trading.UpdateType.make,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [_order.makerAssetAmount, _order.takerAssetAmount, uint(0)]\\n        );\\n        getTrading().addOpenMakeOrder(\\n            _targetExchange,\\n            makerAsset,\\n            takerAsset,\\n            address(0),\\n            uint256(orderInfo.orderHash),\\n            _order.expirationTimeSeconds\\n        );\\n        getTrading().addZeroExV2OrderData(orderInfo.orderHash, _order);\\n    }\\n\\n    // VIEW METHODS\\n\\n    function constructOrderStruct(\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData\\n    )\\n        internal\\n        view\\n        returns (IZeroExV2.Order memory _order)\\n    {\\n        _order = IZeroExV2.Order({\\n            makerAddress: _orderAddresses[0],\\n            takerAddress: _orderAddresses[1],\\n            feeRecipientAddress: _orderAddresses[4],\\n            senderAddress: _orderAddresses[5],\\n            makerAssetAmount: _orderValues[0],\\n            takerAssetAmount: _orderValues[1],\\n            makerFee: _orderValues[2],\\n            takerFee: _orderValues[3],\\n            expirationTimeSeconds: _orderValues[4],\\n            salt: _orderValues[5],\\n            makerAssetData: _orderData[0],\\n            takerAssetData: _orderData[1]\\n        });\\n    }\\n\\n    function getAssetProxy(address _targetExchange, bytes memory _assetData)\\n        internal\\n        view\\n        returns (address assetProxy_)\\n    {\\n        bytes4 assetProxyId;\\n        assembly {\\n            assetProxyId := and(mload(\\n                add(_assetData, 32)),\\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n        assetProxy_ = IZeroExV2(_targetExchange).getAssetProxy(assetProxyId);\\n    }\\n\\n    function getAssetAddress(bytes memory _assetData)\\n        internal\\n        view\\n        returns (address assetAddress_)\\n    {\\n        assembly {\\n            assetAddress_ := mload(add(_assetData, 36))\\n        }\\n    }\\n\\n    /// @dev Function to be called from Trading spoke context (Delegate call)\\n    function getWrapperToken(address _token)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        address wrapperRegistry = Registry(getTrading().registry()).ethfinexWrapperRegistry();\\n        return IWrapperRegistryEFX(wrapperRegistry).token2WrapperLookup(_token);\\n    }\\n\\n    /// @dev Function to be called by Trading spoke without change of context (Non delegate call)\\n    function getWrapperTokenFromAdapterContext(address _token)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        address wrapperRegistry = Registry(Trading(msg.sender).registry()).ethfinexWrapperRegistry();\\n        return IWrapperRegistryEFX(wrapperRegistry).token2WrapperLookup(_token);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/ExchangeAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\n\\n/// @title Exchange Adapter base contract\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Override the public methods to implement an adapter\\ncontract ExchangeAdapter is DSMath {\\n\\n    modifier onlyManager() {\\n        require(\\n            getManager() == msg.sender,\\n            \\\u0022Manager must be sender\\\u0022\\n        );\\n        _;\\n    }\\n\\n    modifier notShutDown() {\\n        require(\\n            !hubShutDown(),\\n            \\\u0022Hub must not be shut down\\\u0022\\n        );\\n        _;\\n    }\\n\\n    /// @dev Either manager sends, fund shut down, or order expired\\n    function ensureCancelPermitted(address _exchange, address _asset, bytes32 _id) internal {\\n        require(\\n            getManager() == msg.sender ||\\n            hubShutDown() ||\\n            getTrading().isOrderExpired(_exchange, _asset),\\n            \\\u0022No cancellation condition met\\\u0022\\n        );\\n        uint256 storedId;\\n        (storedId,,,,) = getTrading().exchangesToOpenMakeOrders(_exchange, _asset);\\n        require(\\n            uint256(_id) == storedId,\\n            \\\u0022Passed identifier does not match that stored in Trading\\\u0022\\n        );\\n    }\\n\\n    function getTrading() internal view returns (Trading) {\\n        return Trading(payable(address(this)));\\n    }\\n\\n    function getHub() internal view returns (Hub) {\\n        return Hub(getTrading().hub());\\n    }\\n\\n    function getAccounting() internal view returns (Accounting) {\\n        return Accounting(getHub().accounting());\\n    }\\n\\n    function hubShutDown() internal view returns (bool) {\\n        return getHub().isShutDown();\\n    }\\n\\n    function getManager() internal view returns (address) {\\n        return getHub().manager();\\n    }\\n\\n    function ensureNotInOpenMakeOrder(address _asset) internal view {\\n        require(\\n            !getTrading().isInOpenMakeOrder(_asset),\\n            \\\u0022This asset is already in an open make order\\\u0022\\n        );\\n    }\\n\\n    function ensureCanMakeOrder(address _asset) internal view {\\n        require(\\n            block.timestamp \u003E= getTrading().makerAssetCooldown(_asset),\\n            \\\u0022Cooldown for the maker asset not reached\\\u0022\\n        );\\n    }\\n\\n    /// @notice Increment allowance of an asset for some target\\n    function approveAsset(\\n        address _asset,\\n        address _target,\\n        uint256 _amount,\\n        string memory _assetType\\n    )\\n        internal\\n    {\\n        Hub hub = getHub();\\n        Vault vault = Vault(hub.vault());\\n\\n        require(\\n            IERC20(_asset).balanceOf(address(vault)) \u003E= _amount,\\n            string(abi.encodePacked(\\\u0022Insufficient balance: \\\u0022, _assetType))\\n        );\\n\\n        vault.withdraw(_asset, _amount);\\n        uint256 allowance = IERC20(_asset).allowance(address(this), _target);\\n        require(\\n            IERC20(_asset).approve(_target, add(allowance, _amount)),\\n            string(abi.encodePacked(\\\u0022Approval failed: \\\u0022, _assetType))\\n        );\\n    }\\n\\n    /// @notice Reduce allowance of an asset for some target\\n    function revokeApproveAsset(\\n        address _asset,\\n        address _target,\\n        uint256 _amount,\\n        string memory _assetType\\n    )\\n        internal\\n    {\\n        uint256 allowance = IERC20(_asset).allowance(address(this), _target);\\n        uint256 newAllowance = (_amount \u003E allowance) ? allowance : sub(allowance, _amount);\\n        require(\\n            IERC20(_asset).approve(_target, newAllowance),\\n            string(abi.encodePacked(\\\u0022Revoke approval failed: \\\u0022, _assetType))\\n        );\\n    }\\n\\n    /// @param orderAddresses [0] Order maker\\n    /// @param orderAddresses [1] Order taker\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param orderAddresses [3] Order taker asset\\n    /// @param orderAddresses [4] feeRecipientAddress\\n    /// @param orderAddresses [5] senderAddress\\n    /// @param orderAddresses [6] maker fee asset\\n    /// @param orderAddresses [7] taker fee asset\\n    /// @param orderValues [0] makerAssetAmount\\n    /// @param orderValues [1] takerAssetAmount\\n    /// @param orderValues [2] Maker fee\\n    /// @param orderValues [3] Taker fee\\n    /// @param orderValues [4] expirationTimeSeconds\\n    /// @param orderValues [5] Salt/nonce\\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\\n    /// @param orderValues [7] Dexy signature mode\\n    /// @param orderData [0] Encoded data specific to maker asset\\n    /// @param orderData [1] Encoded data specific to taker asset\\n    /// @param orderData [2] Encoded data specific to maker asset fee\\n    /// @param orderData [3] Encoded data specific to taker asset fee\\n    /// @param identifier Order identifier\\n    /// @param signature Signature of order maker\\n\\n    // Responsibilities of makeOrder are:\\n    // - check sender\\n    // - check fund not shut down\\n    // - check price recent\\n    // - check risk management passes\\n    // - approve funds to be traded (if necessary)\\n    // - make order on the exchange\\n    // - check order was made (if possible)\\n    // - place asset in ownedAssets if not already tracked\\n    function makeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public virtual { revert(\\\u0022Unimplemented\\\u0022); }\\n\\n    // Responsibilities of takeOrder are:\\n    // - check sender\\n    // - check fund not shut down\\n    // - check not buying own fund tokens\\n    // - check price exists for asset pair\\n    // - check price is recent\\n    // - check price passes risk management\\n    // - approve funds to be traded (if necessary)\\n    // - take order from the exchange\\n    // - check order was taken (if possible)\\n    // - place asset in ownedAssets if not already tracked\\n    function takeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public virtual { revert(\\\u0022Unimplemented\\\u0022); }\\n\\n    // responsibilities of cancelOrder are:\\n    // - check sender is owner, or that order expired, or that fund shut down\\n    // - remove order from tracking array\\n    // - cancel order on exchange\\n    function cancelOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public virtual { revert(\\\u0022Unimplemented\\\u0022); }\\n\\n    // PUBLIC METHODS\\n    // PUBLIC VIEW METHODS\\n    /*\\n    @return {\\n        \\\u0022makerAsset\\\u0022: \\\u0022Maker asset\\\u0022,\\n        \\\u0022takerAsset\\\u0022: \\\u0022Taker asset\\\u0022,\\n        \\\u0022makerQuantity\\\u0022: \\\u0022Amount of maker asset\\\u0022\\n        \\\u0022takerQuantity\\\u0022: \\\u0022Amount of taker asset\\\u0022\\n    }\\n    */\\n    function getOrder(\\n        address onExchange,\\n        uint id,\\n        address makerAsset\\n    ) public view virtual returns (\\n        address,\\n        address,\\n        uint,\\n        uint\\n    ) { revert(\\\u0022Unimplemented\\\u0022); }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IEthfinex.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n// pragma experimental ABIEncoderV2;\\n\\n/// @dev Minimal interface for our interactions with EthFinex WrapperLock\\ninterface IWrapperLock {\\n    function balanceOf(address) external view returns (uint256);\\n    function withdraw(uint256, uint8, bytes32, bytes32, uint256) external returns (bool);\\n    function deposit(uint256, uint256) external returns (bool);\\n}\\n\\n/// @dev Minimal interface for our interactions with EthFinex WrapperLockEth\\ninterface IWrapperLockEth {\\n    function balanceOf(address) external view returns (uint256);\\n    function deposit(uint256, uint256) external payable returns (bool);\\n}\\n\\n/// @dev Minimal interface for our interactions with EthFinex WrapperRegistryEFX\\ninterface IWrapperRegistryEFX {\\n    function token2WrapperLookup(address) external view returns (address);\\n    function wrapper2TokenLookup(address) external view returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IKyberNetworkProxy.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n\\n/// @title Kyber Network interface\\ninterface IKyberNetworkProxy {\\n    function maxGasPrice() external view returns(uint256);\\n    function getUserCapInWei(address) external view returns(uint256);\\n    function getUserCapInTokenWei(address, address) external view returns(uint256);\\n    function enabled() external view returns(bool);\\n    function info(bytes32) external view returns(uint256);\\n    function swapEtherToToken(address, uint256) external payable returns(uint256);\\n    function swapTokenToEther(address, uint256, uint256) external returns(uint256);\\n    function swapTokenToToken(address, uint256, address, uint256) external returns(uint);\\n    function getExpectedRate(address, address, uint256) external view returns (uint256, uint256);\\n    function tradeWithHint(\\n        address, uint256, address, address, uint256, uint256, address, bytes calldata\\n    ) external payable returns(uint256);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IOasisDex.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @dev Minimal interface for our interactions with OasisDex MatchingMarket\\ninterface IOasisDex {\\n    function getFirstUnsortedOffer() external view returns(uint256);\\n    function getNextUnsortedOffer(uint256) external view returns(uint256);\\n    function getBestOffer(address, address) external view returns(uint256);\\n    function getOffer(uint256) external view returns (uint256, address, uint256, address);\\n    function getWorseOffer(uint256) external view returns(uint256);\\n    function isActive(uint256) external view returns (bool);\\n    function buy(uint256, uint256) external returns (bool);\\n    function cancel(uint256) external returns (bool);\\n    function offer(uint256, address, uint256, address) external returns (uint256);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IUniswapExchange.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @dev Minimal interface for our interactions with UniswapExchange\\ninterface IUniswapExchange {\\n    // Trade ETH to ERC20\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient)\\n        external\\n        payable\\n        returns (uint256 tokens_bought);\\n    // Trade ERC20 to ETH\\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline)\\n        external\\n        returns (uint256 eth_bought);\\n    // Trade ERC20 to ERC20\\n    function tokenToTokenTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address recipient,\\n        address token_addr\\n    )\\n        external\\n        returns (uint256 tokens_bought);\\n\\n    /// @dev The following functions are only used in tests\\n    // Provide Liquidity\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256);\\n    // Get Prices\\n    function getEthToTokenInputPrice(uint256 eth_sold)\\n        external\\n        view\\n        returns (uint256 tokens_bought);\\n    function getTokenToEthInputPrice(uint256 tokens_sold)\\n        external\\n        view\\n        returns (uint256 eth_bought);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IUniswapFactory.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @dev Minimal interface for our interactions with UniswapFactory\\ninterface IUniswapFactory {\\n    function getExchange(address token) external view returns (address exchange);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IZeroExV2.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\\ninterface IZeroExV2 {\\n    struct Order {\\n        address makerAddress;\\n        address takerAddress;\\n        address feeRecipientAddress;\\n        address senderAddress;\\n        uint256 makerAssetAmount;\\n        uint256 takerAssetAmount;\\n        uint256 makerFee;\\n        uint256 takerFee;\\n        uint256 expirationTimeSeconds;\\n        uint256 salt;\\n        bytes makerAssetData;\\n        bytes takerAssetData;\\n    }\\n\\n    struct OrderInfo {\\n        uint8 orderStatus;\\n        bytes32 orderHash;\\n        uint256 orderTakerAssetFilledAmount;\\n    }\\n\\n    struct FillResults {\\n        uint256 makerAssetFilledAmount;\\n        uint256 takerAssetFilledAmount;\\n        uint256 makerFeePaid;\\n        uint256 takerFeePaid;\\n    }\\n\\n    function ZRX_ASSET_DATA() external view returns (bytes memory);\\n    function filled(bytes32) external view returns (uint256);\\n    function cancelled(bytes32) external view returns (bool);\\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\\n    function getAssetProxy(bytes4) external view returns (address);\\n    function isValidSignature(bytes32, address, bytes calldata) external view returns (bool);\\n    function preSign(bytes32, address, bytes calldata) external;\\n    function cancelOrder(Order calldata) external;\\n    function fillOrder(Order calldata, uint256, bytes calldata) external returns (FillResults memory);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/interfaces/IZeroExV3.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\\ninterface IZeroExV3 {\\n    struct Order {\\n        address makerAddress;\\n        address takerAddress;\\n        address feeRecipientAddress;\\n        address senderAddress;\\n        uint256 makerAssetAmount;\\n        uint256 takerAssetAmount;\\n        uint256 makerFee;\\n        uint256 takerFee;\\n        uint256 expirationTimeSeconds;\\n        uint256 salt;\\n        bytes makerAssetData;\\n        bytes takerAssetData;\\n        bytes makerFeeAssetData;\\n        bytes takerFeeAssetData;\\n    }\\n\\n    struct OrderInfo {\\n        uint8 orderStatus;\\n        bytes32 orderHash;\\n        uint256 orderTakerAssetFilledAmount;\\n    }\\n\\n    struct FillResults {\\n        uint256 makerAssetFilledAmount;\\n        uint256 takerAssetFilledAmount;\\n        uint256 makerFeePaid;\\n        uint256 takerFeePaid;\\n        uint256 protocolFeePaid;\\n    }\\n\\n    function cancelled(bytes32) external view returns (bool);\\n    function cancelOrder(Order calldata) external;\\n    function filled(bytes32) external view returns (uint256);\\n    function fillOrder(Order calldata, uint256, bytes calldata) external payable returns (FillResults memory);\\n    function getAssetProxy(bytes4) external view returns (address);\\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\\n    function isValidOrderSignature(Order calldata, bytes calldata) external view returns (bool);\\n    function preSign(bytes32) external;\\n    function protocolFeeCollector() external view returns (address);\\n    function protocolFeeMultiplier() external view returns (uint256);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/KyberAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/WETH.sol\\\u0022;\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022./interfaces/IKyberNetworkProxy.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\ncontract KyberAdapter is DSMath, ExchangeAdapter {\\n    address public constant ETH_TOKEN_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\\n\\n    // NON-CONSTANT METHODS\\n\\n    // Responsibilities of takeOrder (Kybers swapToken) are:\\n    // - check price recent\\n    // - check risk management passes\\n    // - approve funds to be traded (if necessary)\\n    // - perform swap order on the exchange\\n    // - place asset in ownedAssets if not already tracked\\n    /// @notice Swaps srcAmount of srcToken for destAmount of destToken\\n    /// @dev Variable naming to be close to Kyber\u0027s naming\\n    /// @dev For the purpose of PriceTolerance, fillTakerQuantity == takerAssetQuantity = Dest token amount\\n    /// @param targetExchange Address of the exchange\\n    /// @param orderAddresses [2] Maker asset (Dest token)\\n    /// @param orderAddresses [3] Taker asset (Src token)\\n    /// @param orderValues [0] Maker asset quantity (Dest token amount)\\n    /// @param orderValues [1] Taker asset quantity (Src token amount)\\n    function takeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override onlyManager notShutDown {\\n        Hub hub = getHub();\\n\\n        require(\\n            orderValues[1] == orderValues[6],\\n            \\\u0022fillTakerQuantity must equal takerAssetQuantity\\\u0022\\n        );\\n\\n        address makerAsset = orderAddresses[2];\\n        address takerAsset = orderAddresses[3];\\n        uint makerAssetAmount = orderValues[0];\\n        uint takerAssetAmount = orderValues[1];\\n\\n        uint minRate = calcMinRate(\\n            takerAsset,\\n            makerAsset,\\n            takerAssetAmount,\\n            makerAssetAmount\\n        );\\n\\n        uint actualReceiveAmount = dispatchSwap(\\n            targetExchange, takerAsset, takerAssetAmount, makerAsset, minRate\\n        );\\n        require(\\n            actualReceiveAmount \u003E= makerAssetAmount,\\n            \\\u0022Received less than expected from Kyber swap\\\u0022\\n        );\\n\\n        getAccounting().addAssetToOwnedAssets(makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\\n        if (\\n            !getTrading().isInOpenMakeOrder(makerAsset) \u0026\u0026\\n            timesMakerAssetUsedAsFee == 0\\n        ) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(0),\\n            Trading.UpdateType.take,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [actualReceiveAmount, takerAssetAmount, takerAssetAmount]\\n        );\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    /// @notice Call different functions based on type of assets supplied\\n    function dispatchSwap(\\n        address targetExchange,\\n        address srcToken,\\n        uint srcAmount,\\n        address destToken,\\n        uint minRate\\n    )\\n        internal\\n        returns (uint actualReceiveAmount)\\n    {\\n\\n        Hub hub = getHub();\\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\\n\\n        if (srcToken == nativeAsset) {\\n            actualReceiveAmount = swapNativeAssetToToken(targetExchange, nativeAsset, srcAmount, destToken, minRate);\\n        }\\n        else if (destToken == nativeAsset) {\\n            actualReceiveAmount = swapTokenToNativeAsset(targetExchange, srcToken, srcAmount, nativeAsset, minRate);\\n        }\\n        else {\\n            actualReceiveAmount = swapTokenToToken(targetExchange, srcToken, srcAmount, destToken, minRate);\\n        }\\n    }\\n\\n    /// @dev If minRate is not defined, uses expected rate from the network\\n    /// @param targetExchange Address of Kyber proxy contract\\n    /// @param nativeAsset Native asset address as src token\\n    /// @param srcAmount Amount of native asset supplied\\n    /// @param destToken Address of dest token\\n    /// @param minRate Minimum rate supplied to the Kyber proxy\\n    /// @return receivedAmount Actual amount of destToken received from the exchange\\n    function swapNativeAssetToToken(\\n        address targetExchange,\\n        address nativeAsset,\\n        uint srcAmount,\\n        address destToken,\\n        uint minRate\\n    )\\n        internal\\n        returns (uint receivedAmount)\\n    {\\n        // Convert WETH to ETH\\n        Hub hub = getHub();\\n        Vault vault = Vault(hub.vault());\\n        vault.withdraw(nativeAsset, srcAmount);\\n        WETH(payable(nativeAsset)).withdraw(srcAmount);\\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapEtherToToken.value(srcAmount)(destToken, minRate);\\n    }\\n\\n    /// @dev If minRate is not defined, uses expected rate from the network\\n    /// @param targetExchange Address of Kyber proxy contract\\n    /// @param srcToken Address of src token\\n    /// @param srcAmount Amount of src token supplied\\n    /// @param nativeAsset Native asset address as src token\\n    /// @param minRate Minimum rate supplied to the Kyber proxy\\n    /// @return receivedAmount Actual amount of destToken received from the exchange\\n    function swapTokenToNativeAsset(\\n        address targetExchange,\\n        address srcToken,\\n        uint srcAmount,\\n        address nativeAsset,\\n        uint minRate\\n    )\\n        internal\\n        returns (uint receivedAmount)\\n    {\\n        approveAsset(srcToken, targetExchange, srcAmount, \\\u0022takerAsset\\\u0022);\\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapTokenToEther(srcToken, srcAmount, minRate);\\n\\n        // Convert ETH to WETH\\n        WETH(payable(nativeAsset)).deposit.value(receivedAmount)();\\n    }\\n\\n    /// @dev If minRate is not defined, uses expected rate from the network\\n    /// @param targetExchange Address of Kyber proxy contract\\n    /// @param srcToken Address of src token\\n    /// @param srcAmount Amount of src token supplied\\n    /// @param destToken Address of dest token\\n    /// @param minRate Minimum rate supplied to the Kyber proxy\\n    /// @return receivedAmount Actual amount of destToken received from the exchange\\n    function swapTokenToToken(\\n        address targetExchange,\\n        address srcToken,\\n        uint srcAmount,\\n        address destToken,\\n        uint minRate\\n    )\\n        internal\\n        returns (uint receivedAmount)\\n    {\\n        approveAsset(srcToken, targetExchange, srcAmount, \\\u0022takerAsset\\\u0022);\\n\\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapTokenToToken(srcToken, srcAmount, destToken, minRate);\\n    }\\n\\n    /// @param srcToken Address of src token\\n    /// @param destToken Address of dest token\\n    /// @param srcAmount Amount of src token\\n    /// @return minRate Minimum rate to be supplied to the network for some order params\\n    function calcMinRate(\\n        address srcToken,\\n        address destToken,\\n        uint srcAmount,\\n        uint destAmount\\n    )\\n        internal\\n        view\\n        returns (uint minRate)\\n    {\\n        IPriceSource pricefeed = IPriceSource(getHub().priceSource());\\n        minRate = pricefeed.getOrderPriceInfo(\\n            srcToken,\\n            srcAmount,\\n            destAmount\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/OasisDexAccessor.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./interfaces/IOasisDex.sol\\\u0022;\\n\\ncontract OasisDexAccessor {\\n    function getUnsortedOfferIds(\\n        address targetExchange,\\n        address sellAsset,\\n        address buyAsset\\n    )\\n    public\\n    view\\n    returns (uint[] memory)\\n    {\\n        IOasisDex market = IOasisDex(targetExchange);\\n        uint[] memory ids = new uint[](1000);\\n        uint count = 0;\\n\\n        // Iterate over all unsorted offers up to 1000 iterations.\\n        uint id = market.getFirstUnsortedOffer();\\n        for (uint i = 0; i \u003C 1000; i\u002B\u002B) {\\n            if (id == 0) {\\n                break;\\n            }\\n\\n            if (market.isActive(id)) {\\n                address sellGem;\\n                address buyGem;\\n                (, sellGem, , buyGem) = market.getOffer(id);\\n\\n                if (sellGem == sellAsset \u0026\u0026 buyGem == buyAsset) {\\n                    ids[count\u002B\u002B] = id;\\n                }\\n            }\\n\\n            // Get the next offer and repeat.\\n            id = market.getNextUnsortedOffer(id);\\n        }\\n\\n        // Create a new array of offers with the correct size.\\n        uint[] memory copy = new uint[](count);\\n        for (uint i = 0; i \u003C count; i\u002B\u002B) {\\n            copy[i] = ids[i];\\n        }\\n\\n        return copy;\\n    }\\n\\n    function getSortedOfferIds(\\n        address targetExchange,\\n        address sellAsset,\\n        address buyAsset\\n    )\\n    public\\n    view\\n    returns(uint[] memory)\\n    {\\n        IOasisDex market = IOasisDex(targetExchange);\\n        uint[] memory ids = new uint[](1000);\\n        uint count = 0;\\n\\n        // Iterate over all sorted offers.\\n        uint id = market.getBestOffer(sellAsset, buyAsset);\\n        for (uint i = 0; i \u003C 1000 ; i\u002B\u002B ) {\\n            if (id == 0) {\\n                break;\\n            }\\n\\n            if (market.isActive(id)) {\\n                ids[count\u002B\u002B] = id;\\n            }\\n\\n            // Get the next offer and repeat.\\n            id = market.getWorseOffer(id);\\n        }\\n\\n        // Create a new array of offers with the correct size.\\n        uint[] memory copy = new uint[](count);\\n        for (uint i = 0; i \u003C count; i\u002B\u002B) {\\n            copy[i] = ids[i];\\n        }\\n\\n        return copy;\\n    }\\n\\n    function getOrders(\\n        address targetExchange,\\n        address sellAsset,\\n        address buyAsset\\n    )\\n    public\\n    view\\n    returns (uint[] memory, uint[] memory, uint[] memory) {\\n        IOasisDex market = IOasisDex(targetExchange);\\n        uint[] memory sIds = getSortedOfferIds(targetExchange, sellAsset, buyAsset);\\n        uint[] memory uIds = getUnsortedOfferIds(targetExchange, sellAsset, buyAsset);\\n        uint[] memory ids = new uint[](uIds.length \u002B sIds.length);\\n        uint[] memory sellQtys = new uint[](ids.length);\\n        uint[] memory buyQtys = new uint[](ids.length);\\n\\n        for (uint i = 0; i \u003C sIds.length; i\u002B\u002B) {\\n            ids[i] = sIds[i];\\n        }\\n\\n        for (uint i = 0; i \u003C uIds.length; i\u002B\u002B) {\\n            ids[i \u002B sIds.length] = uIds[i];\\n        }\\n\\n        for (uint i = 0; i \u003C ids.length; i\u002B\u002B) {\\n            uint sellQty;\\n            uint buyQty;\\n            (sellQty, , buyQty,) = market.getOffer(ids[i]);\\n            sellQtys[i] = sellQty;\\n            buyQtys[i] = buyQty;\\n        }\\n\\n        return (ids, sellQtys, buyQtys);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/OasisDexAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022./interfaces/IOasisDex.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\n/// @title OasisDexAdapter Contract\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Adapter between Melon and OasisDex Matching Market\\ncontract OasisDexAdapter is DSMath, ExchangeAdapter {\\n\\n    event OrderCreated(uint256 id);\\n\\n    //  METHODS\\n\\n    //  PUBLIC METHODS\\n\\n    // Responsibilities of makeOrder are:\\n    // - check sender\\n    // - check fund not shut down\\n    // - check price recent\\n    // - check risk management passes\\n    // - approve funds to be traded (if necessary)\\n    // - make order on the exchange\\n    // - check order was made (if possible)\\n    // - place asset in ownedAssets if not already tracked\\n    /// @notice Makes an order on the selected exchange\\n    /// @dev These orders are not expected to settle immediately\\n    /// @param targetExchange Address of the exchange\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param orderAddresses [3] Order taker asset\\n    /// @param orderValues [0] Maker token quantity\\n    /// @param orderValues [1] Taker token quantity\\n    function makeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override onlyManager notShutDown {\\n        ensureCanMakeOrder(orderAddresses[2]);\\n        address makerAsset = orderAddresses[2];\\n        address takerAsset = orderAddresses[3];\\n        uint256 makerQuantity = orderValues[0];\\n        uint256 takerQuantity = orderValues[1];\\n\\n        // Order parameter checks\\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\\n        ensureNotInOpenMakeOrder(makerAsset);\\n\\n        approveAsset(makerAsset, targetExchange, makerQuantity, \\\u0022makerAsset\\\u0022);\\n\\n        uint256 orderId = IOasisDex(targetExchange).offer(makerQuantity, makerAsset, takerQuantity, takerAsset);\\n\\n        // defines success in MatchingMarket\\n        require(orderId != 0, \\\u0022Order ID should not be zero\\\u0022);\\n\\n        getAccounting().addAssetToOwnedAssets(takerAsset);\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(orderId),\\n            Trading.UpdateType.make,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [makerQuantity, takerQuantity, uint256(0)]\\n        );\\n        getTrading().addOpenMakeOrder(\\n            targetExchange,\\n            makerAsset,\\n            takerAsset,\\n            address(0),\\n            orderId,\\n            orderValues[4]\\n        );\\n        emit OrderCreated(orderId);\\n    }\\n\\n    // Responsibilities of takeOrder are:\\n    // - check sender\\n    // - check fund not shut down\\n    // - check not buying own fund tokens\\n    // - check price exists for asset pair\\n    // - check price is recent\\n    // - check price passes risk management\\n    // - approve funds to be traded (if necessary)\\n    // - take order from the exchange\\n    // - check order was taken (if possible)\\n    // - place asset in ownedAssets if not already tracked\\n    /// @notice Takes an active order on the selected exchange\\n    /// @dev These orders are expected to settle immediately\\n    /// @param targetExchange Address of the exchange\\n    /// @param orderValues [6] Fill amount : amount of taker token to fill\\n    /// @param identifier Active order id\\n    function takeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override onlyManager notShutDown {\\n        Hub hub = getHub();\\n        uint256 fillTakerQuantity = orderValues[6];\\n        uint256 maxMakerQuantity;\\n        address makerAsset;\\n        uint256 maxTakerQuantity;\\n        address takerAsset;\\n        (\\n            maxMakerQuantity,\\n            makerAsset,\\n            maxTakerQuantity,\\n            takerAsset\\n        ) = IOasisDex(targetExchange).getOffer(uint256(identifier));\\n        uint256 fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\\n\\n        require(\\n            makerAsset == orderAddresses[2] \u0026\u0026 takerAsset == orderAddresses[3],\\n            \\\u0022Maker and taker assets do not match the order addresses\\\u0022\\n        );\\n        require(\\n            makerAsset != takerAsset,\\n            \\\u0022Maker and taker assets cannot be the same\\\u0022\\n        );\\n        require(fillMakerQuantity \u003C= maxMakerQuantity, \\\u0022Maker amount to fill above max\\\u0022);\\n        require(fillTakerQuantity \u003C= maxTakerQuantity, \\\u0022Taker amount to fill above max\\\u0022);\\n\\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \\\u0022takerAsset\\\u0022);\\n\\n        require(\\n            IOasisDex(targetExchange).buy(uint256(identifier), fillMakerQuantity),\\n            \\\u0022Buy on matching market failed\\\u0022\\n        );\\n\\n        getAccounting().addAssetToOwnedAssets(makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\\n        if (\\n            !getTrading().isInOpenMakeOrder(makerAsset) \u0026\u0026\\n            timesMakerAssetUsedAsFee == 0\\n        ) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(identifier),\\n            Trading.UpdateType.take,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\\n        );\\n    }\\n\\n    // responsibilities of cancelOrder are:\\n    // - check sender is owner, or that order expired, or that fund shut down\\n    // - remove order from tracking array\\n    // - cancel order on exchange\\n    /// @notice Cancels orders that were not expected to settle immediately\\n    /// @param targetExchange Address of the exchange\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param identifier Order ID on the exchange\\n    function cancelOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override {\\n        require(uint256(identifier) != 0, \\\u0022ID cannot be zero\\\u0022);\\n        address makerAsset;\\n        (, makerAsset, ,) = IOasisDex(targetExchange).getOffer(uint256(identifier));\\n        ensureCancelPermitted(targetExchange, makerAsset, identifier);\\n\\n        require(\\n            address(makerAsset) == orderAddresses[2],\\n            \\\u0022Retrieved and passed assets do not match\\\u0022\\n        );\\n\\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\\n        IOasisDex(targetExchange).cancel(uint256(identifier));\\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\\n        if (timesMakerAssetUsedAsFee == 0) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(identifier),\\n            Trading.UpdateType.cancel,\\n            [address(0), address(0)],\\n            [uint256(0), uint256(0), uint256(0)]\\n        );\\n    }\\n\\n    // VIEW METHODS\\n\\n    function getOrder(address targetExchange, uint256 id, address makerAsset)\\n        public\\n        view\\n        override\\n        returns (address, address, uint256, uint256)\\n    {\\n        uint256 sellQuantity;\\n        address sellAsset;\\n        uint256 buyQuantity;\\n        address buyAsset;\\n        (\\n            sellQuantity,\\n            sellAsset,\\n            buyQuantity,\\n            buyAsset\\n        ) = IOasisDex(targetExchange).getOffer(id);\\n        return (\\n            sellAsset,\\n            buyAsset,\\n            sellQuantity,\\n            buyQuantity\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/UniswapAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../dependencies/WETH.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022./interfaces/IUniswapFactory.sol\\\u0022;\\nimport \\\u0022./interfaces/IUniswapExchange.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\ncontract UniswapAdapter is DSMath, ExchangeAdapter {\\n    /// @notice Take order that uses a user-defined src token amount to trade for a dest token amount\\n    /// @dev For the purpose of PriceTolerance, _orderValues [1] == _orderValues [6] = Dest token amount\\n    /// @param _targetExchange Address of Uniswap factory contract\\n    /// @param _orderAddresses [2] Maker asset (Dest token)\\n    /// @param _orderAddresses [3] Taker asset (Src token)\\n    /// @param _orderValues [0] Maker asset quantity (Dest token amount)\\n    /// @param _orderValues [1] Taker asset quantity (Src token amount)\\n    /// @param _orderValues [6] Taker asset fill amount\\n    function takeOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n    {\\n        Hub hub = getHub();\\n\\n        require(\\n            _orderValues[1] == _orderValues[6],\\n            \\\u0022Taker asset amount must equal taker asset fill amount\\\u0022\\n        );\\n\\n        address makerAsset = _orderAddresses[2];\\n        address takerAsset = _orderAddresses[3];\\n        uint makerAssetAmount = _orderValues[0];\\n        uint takerAssetAmount = _orderValues[1];\\n\\n        uint actualReceiveAmount = dispatchSwap(\\n            _targetExchange, takerAsset, takerAssetAmount, makerAsset, makerAssetAmount\\n        );\\n        require(\\n            actualReceiveAmount \u003E= makerAssetAmount,\\n            \\\u0022Received less than expected from Uniswap exchange\\\u0022\\n        );\\n\\n        updateStateTakeOrder(\\n            _targetExchange,\\n            makerAsset,\\n            takerAsset,\\n            takerAssetAmount,\\n            actualReceiveAmount\\n        );\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    /// @notice Call different functions based on type of assets supplied\\n    /// @param _targetExchange Address of Uniswap factory contract\\n    /// @param _srcToken Address of src token\\n    /// @param _srcAmount Amount of src token supplied\\n    /// @param _destToken Address of dest token\\n    /// @param _minDestAmount Minimum amount of dest token to receive\\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\\n    function dispatchSwap(\\n        address _targetExchange,\\n        address _srcToken,\\n        uint _srcAmount,\\n        address _destToken,\\n        uint _minDestAmount\\n    )\\n        internal\\n        returns (uint actualReceiveAmount_)\\n    {\\n        require(\\n            _srcToken != _destToken,\\n            \\\u0022Src token cannot be the same as dest token\\\u0022\\n        );\\n\\n        Hub hub = getHub();\\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\\n\\n        if (_srcToken == nativeAsset) {\\n            actualReceiveAmount_ = swapNativeAssetToToken(\\n                _targetExchange,\\n                nativeAsset,\\n                _srcAmount,\\n                _destToken,\\n                _minDestAmount\\n            );\\n        } else if (_destToken == nativeAsset) {\\n            actualReceiveAmount_ = swapTokenToNativeAsset(\\n                _targetExchange,\\n                _srcToken,\\n                _srcAmount,\\n                nativeAsset,\\n                _minDestAmount\\n            );\\n        } else {\\n            actualReceiveAmount_ = swapTokenToToken(\\n                _targetExchange,\\n                _srcToken,\\n                _srcAmount,\\n                _destToken,\\n                _minDestAmount\\n            );\\n        }\\n    }\\n\\n    /// @param _targetExchange Address of Uniswap factory contract\\n    /// @param _nativeAsset Native asset address as src token\\n    /// @param _srcAmount Amount of native asset supplied\\n    /// @param _destToken Address of dest token\\n    /// @param _minDestAmount Minimum amount of dest token to get back\\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\\n    function swapNativeAssetToToken(\\n        address _targetExchange,\\n        address _nativeAsset,\\n        uint _srcAmount,\\n        address _destToken,\\n        uint _minDestAmount\\n    )\\n        internal\\n        returns (uint actualReceiveAmount_)\\n    {\\n        // Convert WETH to ETH\\n        Hub hub = getHub();\\n        Vault vault = Vault(hub.vault());\\n        vault.withdraw(_nativeAsset, _srcAmount);\\n        WETH(payable(_nativeAsset)).withdraw(_srcAmount);\\n\\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_destToken);\\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).ethToTokenTransferInput.value(\\n            _srcAmount\\n        )\\n        (\\n            _minDestAmount,\\n            add(block.timestamp, 1),\\n            address(vault)\\n        );\\n    }\\n\\n    /// @param _targetExchange Address of Uniswap factory contract\\n    /// @param _srcToken Address of src token\\n    /// @param _srcAmount Amount of src token supplied\\n    /// @param _nativeAsset Native asset address as dest token\\n    /// @param _minDestAmount Minimum amount of dest token to get back\\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\\n    function swapTokenToNativeAsset(\\n        address _targetExchange,\\n        address _srcToken,\\n        uint _srcAmount,\\n        address _nativeAsset,\\n        uint _minDestAmount\\n    )\\n        internal\\n        returns (uint actualReceiveAmount_)\\n    {\\n        Hub hub = getHub();\\n        Vault vault = Vault(hub.vault());\\n        vault.withdraw(_srcToken, _srcAmount);\\n\\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_srcToken);\\n        approveAsset(_srcToken, tokenExchange, _srcAmount, \\\u0022takerAsset\\\u0022);\\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).tokenToEthSwapInput(\\n            _srcAmount,\\n            _minDestAmount,\\n            add(block.timestamp, 1)\\n        );\\n\\n        // Convert ETH to WETH and move to Vault\\n        WETH(payable(_nativeAsset)).deposit.value(actualReceiveAmount_)();\\n        uint256 timesNativeAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(_nativeAsset);\\n        if (\\n            !getTrading().isInOpenMakeOrder(_nativeAsset) \u0026\u0026\\n            timesNativeAssetUsedAsFee == 0\\n        ) {\\n            getTrading().returnAssetToVault(_nativeAsset);\\n        }\\n    }\\n\\n    /// @param _targetExchange Address of Uniswap factory contract\\n    /// @param _srcToken Address of src token\\n    /// @param _srcAmount Amount of src token supplied\\n    /// @param _destToken Address of dest token\\n    /// @param _minDestAmount Minimum amount of dest token to get back\\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\\n    function swapTokenToToken(\\n        address _targetExchange,\\n        address _srcToken,\\n        uint _srcAmount,\\n        address _destToken,\\n        uint _minDestAmount\\n    )\\n        internal\\n        returns (uint actualReceiveAmount_)\\n    {\\n        Hub hub = getHub();\\n        Vault vault = Vault(hub.vault());\\n        vault.withdraw(_srcToken, _srcAmount);\\n\\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_srcToken);\\n        approveAsset(_srcToken, tokenExchange, _srcAmount, \\\u0022takerAsset\\\u0022);\\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).tokenToTokenTransferInput(\\n            _srcAmount,\\n            _minDestAmount,\\n            1,\\n            add(block.timestamp, 1),\\n            address(vault),\\n            _destToken\\n        );\\n    }\\n\\n    function updateStateTakeOrder(\\n        address _targetExchange,\\n        address _makerAsset,\\n        address _takerAsset,\\n        uint256 _takerAssetAmount,\\n        uint256 _actualReceiveAmount\\n    )\\n        internal\\n    {\\n        getAccounting().addAssetToOwnedAssets(_makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            bytes32(0),\\n            Trading.UpdateType.take,\\n            [payable(_makerAsset), payable(_takerAsset)],\\n            [_actualReceiveAmount, _takerAssetAmount, _takerAssetAmount]\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/ZeroExV2Adapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022./interfaces/IZeroExV2.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\n/// @title ZeroExV2Adapter Contract\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Adapter to 0xV2 Exchange Contract\\ncontract ZeroExV2Adapter is DSMath, ExchangeAdapter {\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param orderAddresses [3] Order taker asset\\n    /// @param orderData [0] Order maker asset data\\n    /// @param orderData [1] Order taker asset data\\n    modifier orderAddressesMatchOrderData(\\n        address[8] memory orderAddresses,\\n        bytes[4] memory orderData\\n    )\\n    {\\n        require(\\n            getAssetAddress(orderData[0]) == orderAddresses[2],\\n            \\\u0022Maker asset data does not match order address in array\\\u0022\\n        );\\n        require(\\n            getAssetAddress(orderData[1]) == orderAddresses[3],\\n            \\\u0022Taker asset data does not match order address in array\\\u0022\\n        );\\n        _;\\n    }\\n\\n    //  METHODS\\n\\n    //  PUBLIC METHODS\\n\\n    /// @notice Make order by pre-approving signatures\\n    function makeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n        orderAddressesMatchOrderData(orderAddresses, orderData)\\n    {\\n        ensureCanMakeOrder(orderAddresses[2]);\\n\\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\\n        address makerAsset = getAssetAddress(orderData[0]);\\n        address takerAsset = getAssetAddress(orderData[1]);\\n\\n        // Order parameter checks\\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\\n        ensureNotInOpenMakeOrder(makerAsset);\\n\\n        approveAssetsMakeOrder(targetExchange, order);\\n\\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\\n        IZeroExV2(targetExchange).preSign(orderInfo.orderHash, address(this), signature);\\n\\n        require(\\n            IZeroExV2(targetExchange).isValidSignature(\\n                orderInfo.orderHash,\\n                address(this),\\n                signature\\n            ),\\n            \\\u0022INVALID_ORDER_SIGNATURE\\\u0022\\n        );\\n\\n        updateStateMakeOrder(targetExchange, order);\\n    }\\n\\n    // Responsibilities of takeOrder are:\\n    // - check sender\\n    // - check fund not shut down\\n    // - check not buying own fund tokens\\n    // - check price exists for asset pair\\n    // - check price is recent\\n    // - check price passes risk management\\n    // - approve funds to be traded (if necessary)\\n    // - take order from the exchange\\n    // - check order was taken (if possible)\\n    // - place asset in ownedAssets if not already tracked\\n    /// @notice Takes an active order on the selected exchange\\n    /// @dev These orders are expected to settle immediately\\n    /// @param targetExchange Address of the exchange\\n    /// @param orderAddresses [0] Order maker\\n    /// @param orderAddresses [1] Order taker\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param orderAddresses [3] Order taker asset\\n    /// @param orderAddresses [4] feeRecipientAddress\\n    /// @param orderAddresses [5] senderAddress\\n    /// @param orderValues [0] makerAssetAmount\\n    /// @param orderValues [1] takerAssetAmount\\n    /// @param orderValues [2] Maker fee\\n    /// @param orderValues [3] Taker fee\\n    /// @param orderValues [4] expirationTimeSeconds\\n    /// @param orderValues [5] Salt/nonce\\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\\n    /// @param orderValues [7] Dexy signature mode\\n    /// @param orderData [0] Encoded data specific to maker asset\\n    /// @param orderData [1] Encoded data specific to taker asset\\n    /// @param orderData [2] Encoded data specific to maker asset fee\\n    /// @param orderData [3] Encoded data specific to taker asset fee\\n    /// @param identifier Order identifier\\n    /// @param signature Signature of the order.\\n    function takeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n        orderAddressesMatchOrderData(orderAddresses, orderData)\\n    {\\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\\n\\n        uint fillTakerQuantity = orderValues[6];\\n\\n        approveAssetsTakeOrder(targetExchange, order);\\n\\n        uint takerAssetFilledAmount = executeFill(targetExchange, order, fillTakerQuantity, signature);\\n        require(\\n            takerAssetFilledAmount == fillTakerQuantity,\\n            \\\u0022Filled amount does not match desired fill amount\\\u0022\\n        );\\n\\n        updateStateTakeOrder(targetExchange, order, fillTakerQuantity);\\n    }\\n\\n    /// @notice Cancel the 0x make order\\n    function cancelOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    )\\n        public\\n        override\\n        orderAddressesMatchOrderData(orderAddresses, orderData)\\n    {\\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(identifier);\\n        ensureCancelPermitted(targetExchange, orderAddresses[2], identifier);\\n\\n        if (order.expirationTimeSeconds \u003E block.timestamp) {\\n            IZeroExV2(targetExchange).cancelOrder(order);\\n        }\\n\\n        revokeApproveAssetsCancelOrder(targetExchange, order);\\n\\n        updateStateCancelOrder(targetExchange, order);\\n    }\\n\\n    /// @dev Get order details\\n    function getOrder(address targetExchange, uint256 id, address makerAsset)\\n        public\\n        view\\n        override\\n        returns (address, address, uint256, uint256)\\n    {\\n        uint orderId;\\n        uint orderIndex;\\n        address takerAsset;\\n        uint makerQuantity;\\n        uint takerQuantity;\\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(targetExchange, makerAsset);\\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\\n        uint takerAssetFilledAmount = IZeroExV2(targetExchange).filled(bytes32(orderId));\\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, makerQuantity) / takerQuantity;\\n        if (IZeroExV2(targetExchange).cancelled(bytes32(orderId)) || sub(takerQuantity, takerAssetFilledAmount) == 0) {\\n            return (makerAsset, takerAsset, 0, 0);\\n        }\\n        return (\\n            makerAsset,\\n            takerAsset,\\n            sub(makerQuantity, makerAssetFilledAmount),\\n            sub(takerQuantity, takerAssetFilledAmount)\\n        );\\n    }\\n\\n    // INTERNAL METHODS\\n\\n    /// @notice Approves makerAsset, makerFee\\n    function approveAssetsMakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\\n        internal\\n    {\\n        approveAsset(\\n            getAssetAddress(_order.makerAssetData),\\n            getAssetProxy(_targetExchange, _order.makerAssetData),\\n            _order.makerAssetAmount,\\n            \\\u0022makerAsset\\\u0022\\n        );\\n        if (_order.makerFee \u003E 0) {\\n            bytes memory zrxAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\\n            approveAsset(\\n                getAssetAddress(zrxAssetData),\\n                getAssetProxy(_targetExchange, zrxAssetData),\\n                _order.makerFee,\\n                \\\u0022makerFeeAsset\\\u0022\\n            );\\n        }\\n    }\\n\\n    /// @notice Approves takerAsset, takerFee\\n    function approveAssetsTakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\\n        internal\\n    {\\n        approveAsset(\\n            getAssetAddress(_order.takerAssetData),\\n            getAssetProxy(_targetExchange, _order.takerAssetData),\\n            _order.takerAssetAmount,\\n            \\\u0022takerAsset\\\u0022\\n        );\\n        if (_order.takerFee \u003E 0) {\\n            bytes memory zrxAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\\n            approveAsset(\\n                getAssetAddress(zrxAssetData),\\n                getAssetProxy(_targetExchange, zrxAssetData),\\n                _order.takerFee,\\n                \\\u0022takerFeeAsset\\\u0022\\n            );\\n        }\\n    }\\n\\n    /// @dev Needed to avoid stack too deep error\\n    function executeFill(\\n        address targetExchange,\\n        IZeroExV2.Order memory order,\\n        uint256 takerAssetFillAmount,\\n        bytes memory signature\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        address makerAsset = getAssetAddress(order.makerAssetData);\\n        uint preMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\\n\\n        IZeroExV2.FillResults memory fillResults = IZeroExV2(targetExchange).fillOrder(\\n            order,\\n            takerAssetFillAmount,\\n            signature\\n        );\\n\\n        uint256 postMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\\n\\n        // Account for case where makerAsset is ZRX (same as takerFee)\\n        uint256 makerAssetFeesTotal;\\n        if (makerAsset == getAssetAddress(IZeroExV2(targetExchange).ZRX_ASSET_DATA())) {\\n            makerAssetFeesTotal = add(makerAssetFeesTotal, order.takerFee);\\n        }\\n\\n        require(\\n            postMakerAssetBalance == sub(\\n                add(preMakerAssetBalance, fillResults.makerAssetFilledAmount),\\n                makerAssetFeesTotal\\n            ),\\n            \\\u0022Maker asset balance different than expected\\\u0022\\n        );\\n\\n        return fillResults.takerAssetFilledAmount;\\n    }\\n\\n    /// @notice Revoke asset approvals and return assets to vault\\n    function revokeApproveAssetsCancelOrder(\\n        address _targetExchange,\\n        IZeroExV2.Order memory _order\\n    )\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n        bytes memory makerFeeAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\\n        address makerFeeAsset = getAssetAddress(makerFeeAssetData);\\n        bytes32 orderHash = IZeroExV2(_targetExchange).getOrderInfo(_order).orderHash;\\n        uint takerAssetFilledAmount = IZeroExV2(_targetExchange).filled(orderHash);\\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, _order.makerAssetAmount) / _order.takerAssetAmount;\\n        uint256 makerAssetRemainingInOrder = sub(_order.makerAssetAmount, makerAssetFilledAmount);\\n        uint256 makerFeeRemainingInOrder = mul(_order.makerFee, makerAssetRemainingInOrder) / _order.makerAssetAmount;\\n\\n        revokeApproveAsset(\\n            makerAsset,\\n            getAssetProxy(_targetExchange, _order.makerAssetData),\\n            makerAssetRemainingInOrder,\\n            \\\u0022makerAsset\\\u0022\\n        );\\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\\n        // only return makerAsset early when it is not being used as a fee anywhere\\n        if (timesMakerAssetUsedAsFee == 0) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n\\n        if (_order.makerFee \u003E 0) {\\n            revokeApproveAsset(\\n                makerFeeAsset,\\n                getAssetProxy(_targetExchange, makerFeeAssetData),\\n                makerFeeRemainingInOrder,\\n                \\\u0022makerFeeAsset\\\u0022\\n            );\\n            // only return feeAsset when not used in another makeOrder AND\\n            //  when it is only used as a fee in this order that we are cancelling\\n            uint256 timesFeeAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerFeeAsset);\\n            if (\\n                !getTrading().isInOpenMakeOrder(makerFeeAsset) \u0026\u0026\\n                timesFeeAssetUsedAsFee == 1\\n            ) {\\n                getTrading().returnAssetToVault(makerFeeAsset);\\n            }\\n        }\\n    }\\n\\n    /// @dev Avoids stack too deep error\\n    function updateStateCancelOrder(address targetExchange, IZeroExV2.Order memory order)\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(order.makerAssetData);\\n\\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            IZeroExV2(targetExchange).getOrderInfo(order).orderHash,\\n            Trading.UpdateType.cancel,\\n            [address(0), address(0)],\\n            [uint(0), uint(0), uint(0)]\\n        );\\n    }\\n\\n    /// @dev Avoids stack too deep error\\n    function updateStateMakeOrder(address targetExchange, IZeroExV2.Order memory order)\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(order.makerAssetData);\\n        address takerAsset = getAssetAddress(order.takerAssetData);\\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\\n\\n        getAccounting().addAssetToOwnedAssets(takerAsset);\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            orderInfo.orderHash,\\n            Trading.UpdateType.make,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [order.makerAssetAmount, order.takerAssetAmount, uint(0)]\\n        );\\n        getTrading().addOpenMakeOrder(\\n            targetExchange,\\n            makerAsset,\\n            takerAsset,\\n            getAssetAddress(IZeroExV2(targetExchange).ZRX_ASSET_DATA()),\\n            uint256(orderInfo.orderHash),\\n            order.expirationTimeSeconds\\n        );\\n        getTrading().addZeroExV2OrderData(orderInfo.orderHash, order);\\n    }\\n\\n    /// @dev avoids stack too deep error\\n    function updateStateTakeOrder(\\n        address targetExchange,\\n        IZeroExV2.Order memory order,\\n        uint256 fillTakerQuantity\\n    )\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(order.makerAssetData);\\n        address takerAsset = getAssetAddress(order.takerAssetData);\\n\\n        getAccounting().addAssetToOwnedAssets(makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        if (\\n            !getTrading().isInOpenMakeOrder(makerAsset) \u0026\u0026\\n            getTrading().openMakeOrdersUsingAssetAsFee(makerAsset) == 0\\n        ) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            IZeroExV2(targetExchange).getOrderInfo(order).orderHash,\\n            Trading.UpdateType.take,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [order.makerAssetAmount, order.takerAssetAmount, fillTakerQuantity]\\n        );\\n    }\\n\\n    // VIEW METHODS\\n\\n    function constructOrderStruct(\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData\\n    )\\n        internal\\n        view\\n        returns (IZeroExV2.Order memory order)\\n    {\\n        order = IZeroExV2.Order({\\n            makerAddress: orderAddresses[0],\\n            takerAddress: orderAddresses[1],\\n            feeRecipientAddress: orderAddresses[4],\\n            senderAddress: orderAddresses[5],\\n            makerAssetAmount: orderValues[0],\\n            takerAssetAmount: orderValues[1],\\n            makerFee: orderValues[2],\\n            takerFee: orderValues[3],\\n            expirationTimeSeconds: orderValues[4],\\n            salt: orderValues[5],\\n            makerAssetData: orderData[0],\\n            takerAssetData: orderData[1]\\n        });\\n    }\\n\\n    function getAssetProxy(address targetExchange, bytes memory assetData)\\n        internal\\n        view\\n        returns (address assetProxy)\\n    {\\n        bytes4 assetProxyId;\\n        assembly {\\n            assetProxyId := and(mload(\\n                add(assetData, 32)),\\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n        assetProxy = IZeroExV2(targetExchange).getAssetProxy(assetProxyId);\\n    }\\n\\n    function getAssetAddress(bytes memory assetData)\\n        internal\\n        view\\n        returns (address assetAddress)\\n    {\\n        assembly {\\n            assetAddress := mload(add(assetData, 36))\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/exchanges/ZeroExV3Adapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/vault/Vault.sol\\\u0022;\\nimport \\\u0022../fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022./interfaces/IZeroExV3.sol\\\u0022;\\nimport \\\u0022./ExchangeAdapter.sol\\\u0022;\\n\\n/// @title ZeroExV3Adapter Contract\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Adapter to 0xV3 Exchange Contract\\ncontract ZeroExV3Adapter is DSMath, ExchangeAdapter {\\n\\n    /// @param _orderAddresses [2] Order maker asset\\n    /// @param _orderAddresses [3] Order taker asset\\n    /// @param _orderAddresses [6] Order maker fee asset\\n    /// @param _orderAddresses [7] Order taker fee asset\\n    /// @param _orderValues [2] Order maker fee amount\\n    /// @param _orderValues [3] Order taker fee amount\\n    modifier orderAddressesMatchOrderData(\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData\\n    )\\n    {\\n        require(\\n            getAssetAddress(_orderData[0]) == _orderAddresses[2],\\n            \\\u0022Maker asset data does not match order address in array\\\u0022\\n        );\\n        require(\\n            getAssetAddress(_orderData[1]) == _orderAddresses[3],\\n            \\\u0022Taker asset data does not match order address in array\\\u0022\\n        );\\n        if (_orderValues[2] \u003E 0) {\\n            require(\\n                getAssetAddress(_orderData[2]) == _orderAddresses[6],\\n                \\\u0022Maker fee asset data does not match order address in array\\\u0022\\n            );\\n        }\\n        if (_orderValues[3] \u003E 0) {\\n            require(\\n                getAssetAddress(_orderData[3]) == _orderAddresses[7],\\n                \\\u0022Taker fee asset data does not match order address in array\\\u0022\\n            );\\n        }\\n        _;\\n    }\\n\\n    //  METHODS\\n\\n    //  PUBLIC METHODS\\n\\n    /// @notice Make order by pre-approving signatures\\n    /// @param _targetExchange Address of the exchange\\n    /// @param _orderAddresses [2] Maker asset (Dest token)\\n    /// @param _orderAddresses [3] Taker asset (Src token)\\n    /// @param _orderData [0] Encoded data specific to maker asset\\n    /// @param _orderData [1] Encoded data specific to taker asset\\n    /// @param _signature _signature of the order.\\n    function makeOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\\n    {\\n        ensureCanMakeOrder(_orderAddresses[2]);\\n\\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\\n        address makerAsset = getAssetAddress(_orderData[0]);\\n        address takerAsset = getAssetAddress(_orderData[1]);\\n\\n        // Order parameter checks\\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\\n        ensureNotInOpenMakeOrder(makerAsset);\\n\\n        approveAssetsMakeOrder(_targetExchange, order);\\n\\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(order);\\n        IZeroExV3(_targetExchange).preSign(orderInfo.orderHash);\\n\\n        require(\\n            IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature),\\n            \\\u0022INVALID_ORDER_SIGNATURE\\\u0022\\n        );\\n\\n        updateStateMakeOrder(_targetExchange, order);\\n    }\\n\\n    /// @notice Takes an active order on the selected exchange\\n    /// @dev These orders are expected to settle immediately\\n    /// @param _targetExchange Address of the exchange\\n    /// @param _orderAddresses [2] Order maker asset\\n    /// @param _orderAddresses [3] Order taker asset\\n    /// @param _orderValues [6] Fill amount: amount of taker token to be traded\\n    /// @param _signature _signature of the order.\\n    function takeOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        onlyManager\\n        notShutDown\\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\\n    {\\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\\n        require(IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature), \\\u0022Order _signature is invalid\\\u0022);\\n\\n        uint256 fillTakerQuantity = _orderValues[6];\\n\\n        approveAssetsTakeOrder(_targetExchange, order);\\n\\n        uint256 takerAssetFilledAmount = executeFill(_targetExchange, order, fillTakerQuantity, _signature);\\n        require(\\n            takerAssetFilledAmount == fillTakerQuantity,\\n            \\\u0022Filled amount does not match desired fill amount\\\u0022\\n        );\\n\\n        updateStateTakeOrder(_targetExchange, order, fillTakerQuantity);\\n    }\\n\\n    /// @notice Cancel the 0x make order\\n    /// @param _targetExchange Address of the exchange\\n    /// @param _orderAddresses [2] Order maker asset\\n    /// @param _identifier Order _identifier\\n    function cancelOrder(\\n        address _targetExchange,\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData,\\n        bytes32 _identifier,\\n        bytes memory _signature\\n    )\\n        public\\n        override\\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\\n    {\\n        IZeroExV3.Order memory order = getTrading().getZeroExV3OrderDetails(_identifier);\\n        ensureCancelPermitted(_targetExchange, getAssetAddress(order.makerAssetData), _identifier);\\n        if (order.expirationTimeSeconds \u003E block.timestamp) {\\n            IZeroExV3(_targetExchange).cancelOrder(order);\\n        }\\n\\n        revokeApproveAssetsCancelOrder(_targetExchange, order);\\n\\n        updateStateCancelOrder(_targetExchange, order);\\n    }\\n\\n    /// @dev Get order details\\n    function getOrder(address _targetExchange, uint256 _id, address _makerAsset)\\n        public\\n        view\\n        override\\n        returns (address, address, uint256, uint256)\\n    {\\n        uint orderId;\\n        uint orderIndex;\\n        address takerAsset;\\n        uint makerQuantity;\\n        uint takerQuantity;\\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(_targetExchange, _makerAsset);\\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\\n        uint takerAssetFilledAmount = IZeroExV3(_targetExchange).filled(bytes32(orderId));\\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, makerQuantity) / takerQuantity;\\n        if (IZeroExV3(_targetExchange).cancelled(bytes32(orderId)) || sub(takerQuantity, takerAssetFilledAmount) == 0) {\\n            return (_makerAsset, takerAsset, 0, 0);\\n        }\\n        return (\\n            _makerAsset,\\n            takerAsset,\\n            sub(makerQuantity, makerAssetFilledAmount),\\n            sub(takerQuantity, takerAssetFilledAmount)\\n        );\\n    }\\n\\n    // INTERNAL METHODS\\n\\n    /// @notice Approves makerAsset, makerFeeAsset\\n    function approveAssetsMakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\\n        internal\\n    {\\n        approveAsset(\\n            getAssetAddress(_order.makerAssetData),\\n            getAssetProxy(_targetExchange, _order.makerAssetData),\\n            _order.makerAssetAmount,\\n            \\\u0022makerAsset\\\u0022\\n        );\\n        if (_order.makerFee \u003E 0) {\\n            approveAsset(\\n                getAssetAddress(_order.makerFeeAssetData),\\n                getAssetProxy(_targetExchange, _order.makerFeeAssetData),\\n                _order.makerFee,\\n                \\\u0022makerFeeAsset\\\u0022\\n            );\\n        }\\n    }\\n\\n    /// @notice Approves takerAsset, takerFeeAsset, protocolFee\\n    function approveAssetsTakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\\n        internal\\n    {\\n        approveProtocolFeeAsset(_targetExchange);\\n        approveAsset(\\n            getAssetAddress(_order.takerAssetData),\\n            getAssetProxy(_targetExchange, _order.takerAssetData),\\n            _order.takerAssetAmount,\\n            \\\u0022takerAsset\\\u0022\\n        );\\n        if (_order.takerFee \u003E 0) {\\n            approveAsset(\\n                getAssetAddress(_order.takerFeeAssetData),\\n                getAssetProxy(_targetExchange, _order.takerFeeAssetData),\\n                _order.takerFee,\\n                \\\u0022takerFeeAsset\\\u0022\\n            );\\n        }\\n    }\\n\\n    function approveProtocolFeeAsset(address _targetExchange) internal {\\n        address protocolFeeCollector = IZeroExV3(_targetExchange).protocolFeeCollector();\\n        uint256 protocolFeeAmount = calcProtocolFeeAmount(_targetExchange);\\n        if (protocolFeeCollector == address(0) || protocolFeeAmount == 0) return;\\n\\n        Hub hub = getHub();\\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\\n\\n        approveAsset(nativeAsset, protocolFeeCollector, protocolFeeAmount, \\\u0022protocolFee\\\u0022);\\n    }\\n\\n    /// @dev Needed to avoid stack too deep error\\n    function executeFill(\\n        address _targetExchange,\\n        IZeroExV3.Order memory _order,\\n        uint256 _takerAssetFillAmount,\\n        bytes memory _signature\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        Hub hub = getHub();\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n        uint preMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\\n\\n        IZeroExV3.FillResults memory fillResults = IZeroExV3(_targetExchange).fillOrder(\\n            _order,\\n            _takerAssetFillAmount,\\n            _signature\\n        );\\n\\n        uint256 postMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\\n\\n        // Account for case where makerAsset, takerFee, protocolFee are the same\\n        uint256 makerAssetFeesTotal;\\n        if (\\n            makerAsset == Accounting(hub.accounting()).NATIVE_ASSET() \u0026\u0026\\n            IZeroExV3(_targetExchange).protocolFeeCollector() != address(0)\\n        )\\n        {\\n            makerAssetFeesTotal = calcProtocolFeeAmount(_targetExchange);\\n        }\\n        if (makerAsset == getAssetAddress(_order.takerFeeAssetData)) {\\n            makerAssetFeesTotal = add(makerAssetFeesTotal, _order.takerFee);\\n        }\\n\\n        require(\\n            postMakerAssetBalance == sub(\\n                add(preMakerAssetBalance, fillResults.makerAssetFilledAmount),\\n                makerAssetFeesTotal\\n            ),\\n            \\\u0022Maker asset balance different than expected\\\u0022\\n        );\\n\\n        return fillResults.takerAssetFilledAmount;\\n    }\\n\\n    /// @notice Revoke asset approvals and return assets to vault\\n    function revokeApproveAssetsCancelOrder(\\n        address _targetExchange,\\n        IZeroExV3.Order memory _order\\n    )\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n        address makerFeeAsset = getAssetAddress(_order.makerFeeAssetData);\\n        bytes32 orderHash = IZeroExV3(_targetExchange).getOrderInfo(_order).orderHash;\\n        uint takerAssetFilledAmount = IZeroExV3(_targetExchange).filled(orderHash);\\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, _order.makerAssetAmount) / _order.takerAssetAmount;\\n        uint256 makerAssetRemainingInOrder = sub(_order.makerAssetAmount, makerAssetFilledAmount);\\n        uint256 makerFeeRemainingInOrder = mul(_order.makerFee, makerAssetRemainingInOrder) / _order.makerAssetAmount;\\n\\n        revokeApproveAsset(\\n            makerAsset,\\n            getAssetProxy(_targetExchange, _order.makerAssetData),\\n            makerAssetRemainingInOrder,\\n            \\\u0022makerAsset\\\u0022\\n        );\\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\\n        // only return makerAsset early when it is not being used as a fee anywhere\\n        if (timesMakerAssetUsedAsFee == 0) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n\\n        if (_order.makerFee \u003E 0) {\\n            revokeApproveAsset(\\n                makerFeeAsset,\\n                getAssetProxy(_targetExchange, _order.makerFeeAssetData),\\n                makerFeeRemainingInOrder,\\n                \\\u0022makerFeeAsset\\\u0022\\n            );\\n            // only return feeAsset when not used in another makeOrder AND\\n            //  when it is only used as a fee in this order that we are cancelling\\n            uint256 timesFeeAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerFeeAsset);\\n            if (\\n                !getTrading().isInOpenMakeOrder(makerFeeAsset) \u0026\u0026\\n                timesFeeAssetUsedAsFee == 1\\n            ) getTrading().returnAssetToVault(makerFeeAsset);\\n        }\\n    }\\n\\n    function updateStateCancelOrder(address _targetExchange, IZeroExV3.Order memory _order)\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n\\n        getTrading().removeOpenMakeOrder(_targetExchange, makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            IZeroExV3(_targetExchange).getOrderInfo(_order).orderHash,\\n            Trading.UpdateType.cancel,\\n            [address(0), address(0)],\\n            [uint(0), uint(0), uint(0)]\\n        );\\n    }\\n\\n    function updateStateMakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n        address takerAsset = getAssetAddress(_order.takerAssetData);\\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(_order);\\n\\n        getAccounting().addAssetToOwnedAssets(takerAsset);\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            orderInfo.orderHash,\\n            Trading.UpdateType.make,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [_order.makerAssetAmount, _order.takerAssetAmount, uint(0)]\\n        );\\n        getTrading().addOpenMakeOrder(\\n            _targetExchange,\\n            makerAsset,\\n            takerAsset,\\n            getAssetAddress(_order.makerFeeAssetData),\\n            uint256(orderInfo.orderHash),\\n            _order.expirationTimeSeconds\\n        );\\n        getTrading().addZeroExV3OrderData(orderInfo.orderHash, _order);\\n    }\\n\\n    /// @dev Avoids stack too deep error\\n    function updateStateTakeOrder(\\n        address _targetExchange,\\n        IZeroExV3.Order memory _order,\\n        uint256 _fillTakerQuantity\\n    )\\n        internal\\n    {\\n        address makerAsset = getAssetAddress(_order.makerAssetData);\\n        address takerAsset = getAssetAddress(_order.takerAssetData);\\n\\n        getAccounting().addAssetToOwnedAssets(makerAsset);\\n        getAccounting().updateOwnedAssets();\\n        if (\\n            !getTrading().isInOpenMakeOrder(makerAsset) \u0026\u0026\\n            getTrading().openMakeOrdersUsingAssetAsFee(makerAsset) == 0\\n        ) {\\n            getTrading().returnAssetToVault(makerAsset);\\n        }\\n        getTrading().orderUpdateHook(\\n            _targetExchange,\\n            IZeroExV3(_targetExchange).getOrderInfo(_order).orderHash,\\n            Trading.UpdateType.take,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [_order.makerAssetAmount, _order.takerAssetAmount, _fillTakerQuantity]\\n        );\\n    }\\n\\n    // VIEW METHODS\\n    function calcProtocolFeeAmount(address _targetExchange) internal view returns (uint256) {\\n        return mul(IZeroExV3(_targetExchange).protocolFeeMultiplier(), tx.gasprice);\\n    }\\n\\n    function constructOrderStruct(\\n        address[8] memory _orderAddresses,\\n        uint[8] memory _orderValues,\\n        bytes[4] memory _orderData\\n    )\\n        internal\\n        view\\n        returns (IZeroExV3.Order memory order_)\\n    {\\n        order_ = IZeroExV3.Order({\\n            makerAddress: _orderAddresses[0],\\n            takerAddress: _orderAddresses[1],\\n            feeRecipientAddress: _orderAddresses[4],\\n            senderAddress: _orderAddresses[5],\\n            makerAssetAmount: _orderValues[0],\\n            takerAssetAmount: _orderValues[1],\\n            makerFee: _orderValues[2],\\n            takerFee: _orderValues[3],\\n            expirationTimeSeconds: _orderValues[4],\\n            salt: _orderValues[5],\\n            makerAssetData: _orderData[0],\\n            takerAssetData: _orderData[1],\\n            makerFeeAssetData: _orderData[2],\\n            takerFeeAssetData: _orderData[3]\\n        });\\n    }\\n\\n    function getAssetProxy(address _targetExchange, bytes memory _assetData)\\n        internal\\n        view\\n        returns (address assetProxy_)\\n    {\\n        bytes4 assetProxyId;\\n        assembly {\\n            assetProxyId := and(mload(\\n                add(_assetData, 32)),\\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n        assetProxy_ = IZeroExV3(_targetExchange).getAssetProxy(assetProxyId);\\n    }\\n\\n    function getAssetAddress(bytes memory _assetData)\\n        internal\\n        view\\n        returns (address assetAddress_)\\n    {\\n        assembly {\\n            assetAddress_ := mload(add(_assetData, 36))\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/factory/Factory.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n\\ncontract Factory {\\n    mapping (address =\u003E bool) public childExists;\\n\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance\\n    );\\n\\n    function isInstance(address _child) public view returns (bool) {\\n        return childExists[_child];\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/factory/FundFactory.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../fund/accounting/IAccounting.sol\\\u0022;\\nimport \\\u0022../fund/fees/IFeeManager.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../fund/policies/IPolicyManager.sol\\\u0022;\\nimport \\\u0022../fund/participation/IParticipation.sol\\\u0022;\\nimport \\\u0022../fund/shares/IShares.sol\\\u0022;\\nimport \\\u0022../fund/trading/ITrading.sol\\\u0022;\\nimport \\\u0022../fund/vault/IVault.sol\\\u0022;\\nimport \\\u0022../version/IVersion.sol\\\u0022;\\nimport \\\u0022../engine/AmguConsumer.sol\\\u0022;\\nimport \\\u0022./Factory.sol\\\u0022;\\n\\n/// @notice Creates fund routes and links them together\\ncontract FundFactory is AmguConsumer, Factory {\\n\\n    event NewFund(\\n        address indexed manager,\\n        address indexed hub,\\n        address[11] routes\\n    );\\n\\n    IVersion public version;\\n    Registry public associatedRegistry;\\n    IAccountingFactory public accountingFactory;\\n    IFeeManagerFactory public feeManagerFactory;\\n    IParticipationFactory public participationFactory;\\n    IPolicyManagerFactory public policyManagerFactory;\\n    ISharesFactory public sharesFactory;\\n    ITradingFactory public tradingFactory;\\n    IVaultFactory public vaultFactory;\\n\\n    address[] public funds;\\n    mapping (address =\u003E address) public managersToHubs;\\n    mapping (address =\u003E Hub.Routes) public managersToRoutes;\\n    mapping (address =\u003E Settings) public managersToSettings;\\n\\n    /// @dev Parameters stored when beginning setup\\n    struct Settings {\\n        string name;\\n        address[] exchanges;\\n        address[] adapters;\\n        address denominationAsset;\\n        address[] defaultInvestmentAssets;\\n        address[] fees;\\n        uint[] feeRates;\\n        uint[] feePeriods;\\n    }\\n\\n    constructor(\\n        address _accountingFactory,\\n        address _feeManagerFactory,\\n        address _participationFactory,\\n        address _sharesFactory,\\n        address _tradingFactory,\\n        address _vaultFactory,\\n        address _policyManagerFactory,\\n        address _version\\n    )\\n        public\\n    {\\n        accountingFactory = IAccountingFactory(_accountingFactory);\\n        feeManagerFactory = IFeeManagerFactory(_feeManagerFactory);\\n        participationFactory = IParticipationFactory(_participationFactory);\\n        sharesFactory = ISharesFactory(_sharesFactory);\\n        tradingFactory = ITradingFactory(_tradingFactory);\\n        vaultFactory = IVaultFactory(_vaultFactory);\\n        policyManagerFactory = IPolicyManagerFactory(_policyManagerFactory);\\n        version = IVersion(_version);\\n    }\\n\\n    function componentExists(address _component) internal pure returns (bool) {\\n        return _component != address(0);\\n    }\\n\\n    function ensureComponentNotSet(address _component) internal {\\n        require(\\n            !componentExists(_component),\\n            \\\u0022This step has already been run\\\u0022\\n        );\\n    }\\n\\n    function ensureComponentSet(address _component) internal {\\n        require(\\n            componentExists(_component),\\n            \\\u0022Component preprequisites not met\\\u0022\\n        );\\n    }\\n\\n    function beginSetup(\\n        string memory _name,\\n        address[] memory _fees,\\n        uint[] memory _feeRates,\\n        uint[] memory _feePeriods,\\n        address[] memory _exchanges,\\n        address[] memory _adapters,\\n        address _denominationAsset,\\n        address[] memory _defaultInvestmentAssets\\n    )\\n        public\\n    {\\n        ensureComponentNotSet(managersToHubs[msg.sender]);\\n        associatedRegistry.reserveFundName(\\n            msg.sender,\\n            _name\\n        );\\n        require(\\n            associatedRegistry.assetIsRegistered(_denominationAsset),\\n            \\\u0022Denomination asset must be registered\\\u0022\\n        );\\n\\n        managersToHubs[msg.sender] = address(new Hub(msg.sender, _name));\\n        managersToSettings[msg.sender] = Settings(\\n            _name,\\n            _exchanges,\\n            _adapters,\\n            _denominationAsset,\\n            _defaultInvestmentAssets,\\n            _fees,\\n            _feeRates,\\n            _feePeriods\\n        );\\n        managersToRoutes[msg.sender].registry = address(associatedRegistry);\\n        managersToRoutes[msg.sender].version = address(version);\\n        managersToRoutes[msg.sender].engine = engine();\\n        managersToRoutes[msg.sender].mlnToken = mlnToken();\\n    }\\n\\n    function _createAccountingFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].accounting);\\n        managersToRoutes[_manager].accounting = accountingFactory.createInstance(\\n            managersToHubs[_manager],\\n            managersToSettings[_manager].denominationAsset,\\n            associatedRegistry.nativeAsset()\\n        );\\n    }\\n\\n    function createAccountingFor(address _manager) external amguPayable(false) payable { _createAccountingFor(_manager); }\\n    function createAccounting() external amguPayable(false) payable { _createAccountingFor(msg.sender); }\\n\\n    function _createFeeManagerFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].feeManager);\\n        managersToRoutes[_manager].feeManager = feeManagerFactory.createInstance(\\n            managersToHubs[_manager],\\n            managersToSettings[_manager].denominationAsset,\\n            managersToSettings[_manager].fees,\\n            managersToSettings[_manager].feeRates,\\n            managersToSettings[_manager].feePeriods,\\n            managersToRoutes[_manager].registry\\n        );\\n    }\\n\\n    function createFeeManagerFor(address _manager) external amguPayable(false) payable { _createFeeManagerFor(_manager); }\\n    function createFeeManager() external amguPayable(false) payable { _createFeeManagerFor(msg.sender); }\\n\\n    function _createParticipationFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].participation);\\n        managersToRoutes[_manager].participation = participationFactory.createInstance(\\n            managersToHubs[_manager],\\n            managersToSettings[_manager].defaultInvestmentAssets,\\n            managersToRoutes[_manager].registry\\n        );\\n    }\\n\\n    function createParticipationFor(address _manager) external amguPayable(false) payable { _createParticipationFor(_manager); }\\n    function createParticipation() external amguPayable(false) payable { _createParticipationFor(msg.sender); }\\n\\n    function _createPolicyManagerFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].policyManager);\\n        managersToRoutes[_manager].policyManager = policyManagerFactory.createInstance(\\n            managersToHubs[_manager]\\n        );\\n    }\\n\\n    function createPolicyManagerFor(address _manager) external amguPayable(false) payable { _createPolicyManagerFor(_manager); }\\n    function createPolicyManager() external amguPayable(false) payable { _createPolicyManagerFor(msg.sender); }\\n\\n    function _createSharesFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].shares);\\n        managersToRoutes[_manager].shares = sharesFactory.createInstance(\\n            managersToHubs[_manager]\\n        );\\n    }\\n\\n    function createSharesFor(address _manager) external amguPayable(false) payable { _createSharesFor(_manager); }\\n    function createShares() external amguPayable(false) payable { _createSharesFor(msg.sender); }\\n\\n    function _createTradingFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].trading);\\n        managersToRoutes[_manager].trading = tradingFactory.createInstance(\\n            managersToHubs[_manager],\\n            managersToSettings[_manager].exchanges,\\n            managersToSettings[_manager].adapters,\\n            managersToRoutes[_manager].registry\\n        );\\n    }\\n\\n    function createTradingFor(address _manager) external amguPayable(false) payable { _createTradingFor(_manager); }\\n    function createTrading() external amguPayable(false) payable { _createTradingFor(msg.sender); }\\n\\n    function _createVaultFor(address _manager)\\n        internal\\n    {\\n        ensureComponentSet(managersToHubs[_manager]);\\n        ensureComponentNotSet(managersToRoutes[_manager].vault);\\n        managersToRoutes[_manager].vault = vaultFactory.createInstance(\\n            managersToHubs[_manager]\\n        );\\n    }\\n\\n    function createVaultFor(address _manager) external amguPayable(false) payable { _createVaultFor(_manager); }\\n    function createVault() external amguPayable(false) payable { _createVaultFor(msg.sender); }\\n\\n    function _completeSetupFor(address _manager) internal {\\n        Hub.Routes memory routes = managersToRoutes[_manager];\\n        Hub hub = Hub(managersToHubs[_manager]);\\n        require(!childExists[address(hub)], \\\u0022Setup already complete\\\u0022);\\n        require(\\n            componentExists(address(hub)) \u0026\u0026\\n            componentExists(routes.accounting) \u0026\u0026\\n            componentExists(routes.feeManager) \u0026\u0026\\n            componentExists(routes.participation) \u0026\u0026\\n            componentExists(routes.policyManager) \u0026\u0026\\n            componentExists(routes.shares) \u0026\u0026\\n            componentExists(routes.trading) \u0026\u0026\\n            componentExists(routes.vault),\\n            \\\u0022Components must be set before completing setup\\\u0022\\n        );\\n        childExists[address(hub)] = true;\\n        hub.initializeAndSetPermissions([\\n            routes.accounting,\\n            routes.feeManager,\\n            routes.participation,\\n            routes.policyManager,\\n            routes.shares,\\n            routes.trading,\\n            routes.vault,\\n            routes.registry,\\n            routes.version,\\n            routes.engine,\\n            routes.mlnToken\\n        ]);\\n        funds.push(address(hub));\\n        associatedRegistry.registerFund(\\n            address(hub),\\n            _manager,\\n            managersToSettings[_manager].name\\n        );\\n\\n        emit NewFund(\\n            msg.sender,\\n            address(hub),\\n            [\\n                routes.accounting,\\n                routes.feeManager,\\n                routes.participation,\\n                routes.policyManager,\\n                routes.shares,\\n                routes.trading,\\n                routes.vault,\\n                routes.registry,\\n                routes.version,\\n                routes.engine,\\n                routes.mlnToken\\n            ]\\n        );\\n    }\\n\\n    function completeSetupFor(address _manager) external amguPayable(false) payable { _completeSetupFor(_manager); }\\n    function completeSetup() external amguPayable(false) payable { _completeSetupFor(msg.sender); }\\n\\n    function getFundById(uint withId) external view returns (address) { return funds[withId]; }\\n    function getLastFundId() external view returns (uint) { return funds.length - 1; }\\n\\n    function mlnToken() public view override returns (address) {\\n        return address(associatedRegistry.mlnToken());\\n    }\\n    function engine() public view override returns (address) {\\n        return address(associatedRegistry.engine());\\n    }\\n    function priceSource() public view override returns (address) {\\n        return address(associatedRegistry.priceSource());\\n    }\\n    function registry() public view override returns (address) { return address(associatedRegistry); }\\n    function getExchangesInfo(address user) public view returns (address[] memory) {\\n        return (managersToSettings[user].exchanges);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/accounting/Accounting.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../dependencies/token/StandardToken.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../fees/FeeManager.sol\\\u0022;\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../shares/Shares.sol\\\u0022;\\nimport \\\u0022../trading/ITrading.sol\\\u0022;\\nimport \\\u0022../vault/Vault.sol\\\u0022;\\nimport \\\u0022../../engine/AmguConsumer.sol\\\u0022;\\n\\ncontract Accounting is AmguConsumer, Spoke {\\n\\n    event AssetAddition(address indexed asset);\\n    event AssetRemoval(address indexed asset);\\n\\n    struct Calculations {\\n        uint gav;\\n        uint nav;\\n        uint allocatedFees;\\n        uint totalSupply;\\n        uint timestamp;\\n    }\\n\\n    uint constant public MAX_OWNED_ASSETS = 20;\\n    address[] public ownedAssets;\\n    mapping (address =\u003E bool) public isInAssetList;\\n    uint public constant SHARES_DECIMALS = 18;\\n    address public NATIVE_ASSET;\\n    address public DENOMINATION_ASSET;\\n    uint public DENOMINATION_ASSET_DECIMALS;\\n    uint public DEFAULT_SHARE_PRICE;\\n    Calculations public atLastAllocation;\\n\\n    constructor(address _hub, address _denominationAsset, address _nativeAsset)\\n        public\\n        Spoke(_hub)\\n    {\\n        DENOMINATION_ASSET = _denominationAsset;\\n        NATIVE_ASSET = _nativeAsset;\\n        DENOMINATION_ASSET_DECIMALS = ERC20WithFields(DENOMINATION_ASSET).decimals();\\n        DEFAULT_SHARE_PRICE = 10 ** uint(DENOMINATION_ASSET_DECIMALS);\\n    }\\n\\n    function getOwnedAssetsLength() external view returns (uint256) {\\n        return ownedAssets.length;\\n    }\\n\\n    function getOwnedAssets() external view returns (address[] memory) {\\n        return ownedAssets;\\n    }\\n\\n    function assetHoldings(address _asset) public returns (uint256) {\\n        return add(\\n            uint256(ERC20WithFields(_asset).balanceOf(routes.vault)),\\n            ITrading(routes.trading).updateAndGetQuantityBeingTraded(_asset)\\n        );\\n    }\\n\\n    /// @dev Returns sparse array\\n    function getFundHoldings() external returns (uint[] memory, address[] memory) {\\n        uint[] memory _quantities = new uint[](ownedAssets.length);\\n        address[] memory _assets = new address[](ownedAssets.length);\\n        for (uint i = 0; i \u003C ownedAssets.length; i\u002B\u002B) {\\n            address ofAsset = ownedAssets[i];\\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\\n            uint quantityHeld = assetHoldings(ofAsset);\\n            _assets[i] = ofAsset;\\n            _quantities[i] = quantityHeld;\\n        }\\n        return (_quantities, _assets);\\n    }\\n\\n    function calcAssetGAV(address _queryAsset) external returns (uint) {\\n        uint queryAssetQuantityHeld = assetHoldings(_queryAsset);\\n        return IPriceSource(priceSource()).convertQuantity(\\n            queryAssetQuantityHeld, _queryAsset, DENOMINATION_ASSET\\n        );\\n    }\\n\\n    // prices are quoted in DENOMINATION_ASSET so they use denominationDecimals\\n    function calcGav() public returns (uint gav) {\\n        for (uint i = 0; i \u003C ownedAssets.length; \u002B\u002Bi) {\\n            address asset = ownedAssets[i];\\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimals)\\n            uint quantityHeld = assetHoldings(asset);\\n            // Dont bother with the calculations if the balance of the asset is 0\\n            if (quantityHeld == 0) {\\n                continue;\\n            }\\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\\n            gav = add(\\n                gav,\\n                IPriceSource(priceSource()).convertQuantity(\\n                    quantityHeld, asset, DENOMINATION_ASSET\\n                )\\n            );\\n        }\\n        return gav;\\n    }\\n\\n    function calcNav(uint gav, uint unclaimedFeesInDenominationAsset) public pure returns (uint) {\\n        return sub(gav, unclaimedFeesInDenominationAsset);\\n    }\\n\\n    function valuePerShare(uint totalValue, uint numShares) public pure returns (uint) {\\n        require(numShares \u003E 0, \\\u0022No shares to calculate value for\\\u0022);\\n        return (totalValue * 10 ** uint(SHARES_DECIMALS)) / numShares;\\n    }\\n\\n    function performCalculations()\\n        public\\n        returns (\\n            uint gav,\\n            uint feesInDenominationAsset,  // unclaimed amount\\n            uint feesInShares,             // unclaimed amount\\n            uint nav,\\n            uint sharePrice,\\n            uint gavPerShareNetManagementFee\\n        )\\n    {\\n        gav = calcGav();\\n        uint totalSupply = Shares(routes.shares).totalSupply();\\n        feesInShares = FeeManager(routes.feeManager).totalFeeAmount();\\n        feesInDenominationAsset = (totalSupply == 0) ?\\n            0 :\\n            mul(feesInShares, gav) / add(totalSupply, feesInShares);\\n        nav = calcNav(gav, feesInDenominationAsset);\\n\\n        // The total share supply including the value of feesInDenominationAsset, measured in shares of this fund\\n        uint totalSupplyAccountingForFees = add(totalSupply, feesInShares);\\n        sharePrice = (totalSupply \u003E 0) ?\\n            valuePerShare(gav, totalSupplyAccountingForFees) :\\n            DEFAULT_SHARE_PRICE;\\n        gavPerShareNetManagementFee = (totalSupply \u003E 0) ?\\n            valuePerShare(gav, add(totalSupply, FeeManager(routes.feeManager).managementFeeAmount())) :\\n            DEFAULT_SHARE_PRICE;\\n        return (gav, feesInDenominationAsset, feesInShares, nav, sharePrice, gavPerShareNetManagementFee);\\n    }\\n\\n    function calcGavPerShareNetManagementFee()\\n        public\\n        returns (uint gavPerShareNetManagementFee)\\n    {\\n        (,,,,,gavPerShareNetManagementFee) = performCalculations();\\n        return gavPerShareNetManagementFee;\\n    }\\n\\n    function getShareCostInAsset(uint _numShares, address _altAsset)\\n        external\\n        returns (uint)\\n    {\\n        uint denominationAssetQuantity = mul(\\n            _numShares,\\n            calcGavPerShareNetManagementFee()\\n        ) / 10 ** uint(SHARES_DECIMALS);\\n        return IPriceSource(priceSource()).convertQuantity(\\n            denominationAssetQuantity, DENOMINATION_ASSET, _altAsset\\n        );\\n    }\\n\\n    /// @notice Reward all fees and perform some updates\\n    /// @dev Anyone can call this\\n    function triggerRewardAllFees()\\n        external\\n        amguPayable(false)\\n        payable\\n    {\\n        updateOwnedAssets();\\n        uint256 gav;\\n        uint256 feesInDenomination;\\n        uint256 feesInShares;\\n        uint256 nav;\\n        (gav, feesInDenomination, feesInShares, nav,,) = performCalculations();\\n        uint256 totalSupply = Shares(routes.shares).totalSupply();\\n        FeeManager(routes.feeManager).rewardAllFees();\\n        atLastAllocation = Calculations({\\n            gav: gav,\\n            nav: nav,\\n            allocatedFees: feesInDenomination,\\n            totalSupply: totalSupply,\\n            timestamp: block.timestamp\\n        });\\n    }\\n\\n    /// @dev Check holdings for all assets, and adjust list\\n    function updateOwnedAssets() public {\\n        for (uint i = 0; i \u003C ownedAssets.length; i\u002B\u002B) {\\n            address asset = ownedAssets[i];\\n            if (\\n                assetHoldings(asset) == 0 \u0026\u0026\\n                !(asset == address(DENOMINATION_ASSET)) \u0026\u0026\\n                ITrading(routes.trading).getOpenMakeOrdersAgainstAsset(asset) == 0\\n            ) {\\n                _removeFromOwnedAssets(asset);\\n            }\\n        }\\n    }\\n\\n    function addAssetToOwnedAssets(address _asset) external auth {\\n        _addAssetToOwnedAssets(_asset);\\n    }\\n\\n    function removeFromOwnedAssets(address _asset) external auth {\\n        _removeFromOwnedAssets(_asset);\\n    }\\n\\n    /// @dev Just pass if asset already in list\\n    function _addAssetToOwnedAssets(address _asset) internal {\\n        if (isInAssetList[_asset]) { return; }\\n\\n        require(\\n            ownedAssets.length \u003C MAX_OWNED_ASSETS,\\n            \\\u0022Max owned asset limit reached\\\u0022\\n        );\\n        isInAssetList[_asset] = true;\\n        ownedAssets.push(_asset);\\n        emit AssetAddition(_asset);\\n    }\\n\\n    /// @dev Just pass if asset not in list\\n    function _removeFromOwnedAssets(address _asset) internal {\\n        if (!isInAssetList[_asset]) { return; }\\n\\n        isInAssetList[_asset] = false;\\n        for (uint i; i \u003C ownedAssets.length; i\u002B\u002B) {\\n            if (ownedAssets[i] == _asset) {\\n                ownedAssets[i] = ownedAssets[ownedAssets.length - 1];\\n                ownedAssets.pop();\\n                break;\\n            }\\n        }\\n        emit AssetRemoval(_asset);\\n    }\\n\\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\\n}\\n\\ncontract AccountingFactory is Factory {\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance,\\n        address denominationAsset,\\n        address nativeAsset\\n    );\\n\\n    function createInstance(address _hub, address _denominationAsset, address _nativeAsset) external returns (address) {\\n        address accounting = address(new Accounting(_hub, _denominationAsset, _nativeAsset));\\n        childExists[accounting] = true;\\n        emit NewInstance(_hub, accounting, _denominationAsset, _nativeAsset);\\n        return accounting;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/accounting/IAccounting.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @notice Gives metrics about a Fund\\ninterface IAccounting {\\n    function getOwnedAssetsLength() external view returns (uint);\\n    function getFundHoldings() external returns (uint[] memory, address[] memory);\\n    function calcAssetGAV(address ofAsset) external returns (uint);\\n    function calcGav() external returns (uint gav);\\n    function calcNav(uint gav, uint unclaimedFees) external pure returns (uint);\\n    function valuePerShare(uint totalValue, uint numShares) external view returns (uint);\\n    function performCalculations() external returns (\\n        uint gav,\\n        uint unclaimedFees,\\n        uint feesInShares,\\n        uint nav,\\n        uint sharePrice,\\n        uint gavPerShareNetManagementFee\\n    );\\n    function calcGavPerShareNetManagementFee() external returns (uint);\\n}\\n\\ninterface IAccountingFactory {\\n    function createInstance(address _hub, address _denominationAsset, address _nativeAsset) external returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/fees/FeeManager.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022./IFee.sol\\\u0022;\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../shares/Shares.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../../version/Registry.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022./IFeeManager.sol\\\u0022;\\n\\n/// @notice Manages and allocates fees for a particular fund\\ncontract FeeManager is DSMath, Spoke {\\n\\n    event FeeReward(uint shareQuantity);\\n    event FeeRegistration(address fee);\\n\\n    struct FeeInfo {\\n        address feeAddress;\\n        uint feeRate;\\n        uint feePeriod;\\n    }\\n\\n    IFee[] public fees;\\n    mapping (address =\u003E bool) public feeIsRegistered;\\n\\n    constructor(address _hub, address _denominationAsset, address[] memory _fees, uint[] memory _rates, uint[] memory _periods, address _registry) Spoke(_hub) public {\\n        for (uint i = 0; i \u003C _fees.length; i\u002B\u002B) {\\n            require(\\n                Registry(_registry).isFeeRegistered(_fees[i]),\\n                \\\u0022Fee must be known to Registry\\\u0022\\n            );\\n            register(_fees[i], _rates[i], _periods[i], _denominationAsset);\\n        }\\n        if (fees.length \u003E 0) {\\n            require(\\n                fees[0].identifier() == 0,\\n                \\\u0022Management fee must be at 0 index\\\u0022\\n            );\\n        }\\n        if (fees.length \u003E 1) {\\n            require(\\n                fees[1].identifier() == 1,\\n                \\\u0022Performance fee must be at 1 index\\\u0022\\n            );\\n        }\\n    }\\n\\n    function register(address feeAddress, uint feeRate, uint feePeriod, address denominationAsset) internal {\\n        require(!feeIsRegistered[feeAddress], \\\u0022Fee already registered\\\u0022);\\n        feeIsRegistered[feeAddress] = true;\\n        fees.push(IFee(feeAddress));\\n        IFee(feeAddress).initializeForUser(feeRate, feePeriod, denominationAsset);  // initialize state\\n        emit FeeRegistration(feeAddress);\\n    }\\n\\n    function totalFeeAmount() external returns (uint total) {\\n        for (uint i = 0; i \u003C fees.length; i\u002B\u002B) {\\n            total = add(total, fees[i].feeAmount());\\n        }\\n        return total;\\n    }\\n\\n    /// @dev Shares to be inflated after update state\\n    function _rewardFee(IFee fee) internal {\\n        require(feeIsRegistered[address(fee)], \\\u0022Fee is not registered\\\u0022);\\n        uint rewardShares = fee.feeAmount();\\n        fee.updateState();\\n        Shares(routes.shares).createFor(hub.manager(), rewardShares);\\n        emit FeeReward(rewardShares);\\n    }\\n\\n    function _rewardAllFees() internal {\\n        for (uint i = 0; i \u003C fees.length; i\u002B\u002B) {\\n            _rewardFee(fees[i]);\\n        }\\n    }\\n\\n    /// @dev Used when calling from other components\\n    function rewardAllFees() public auth { _rewardAllFees(); }\\n\\n    /// @dev Convenience function; anyone can reward management fee any time\\n    /// @dev Convention that management fee is 0\\n    function rewardManagementFee() public {\\n        if (fees.length \u003E= 1) _rewardFee(fees[0]);\\n    }\\n\\n    /// @dev Convenience function\\n    /// @dev Convention that management fee is 0\\n    function managementFeeAmount() external returns (uint) {\\n        if (fees.length \u003C 1) return 0;\\n        return fees[0].feeAmount();\\n    }\\n\\n    /// @dev Convenience function\\n    /// @dev Convention that performace fee is 1\\n    function performanceFeeAmount() external returns (uint) {\\n        if (fees.length \u003C 2) return 0;\\n        return fees[1].feeAmount();\\n    }\\n}\\n\\ncontract FeeManagerFactory is Factory {\\n    function createInstance(\\n        address _hub,\\n        address _denominationAsset,\\n        address[] memory _fees,\\n        uint[] memory _feeRates,\\n        uint[] memory _feePeriods,\\n        address _registry\\n    ) public returns (address) {\\n        address feeManager = address(\\n            new FeeManager(_hub, _denominationAsset, _fees, _feeRates, _feePeriods, _registry)\\n        );\\n        childExists[feeManager] = true;\\n        emit NewInstance(_hub, feeManager);\\n        return feeManager;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/fees/IFee.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @dev Exposes \\\u0022feeAmount\\\u0022, which maps fund state and fee state to uint\\n/// @dev Notice that \\\u0022feeAmount\\\u0022 *may* change contract state\\n/// @dev Also exposes \\\u0022updateState\\\u0022, which changes fee\u0027s internal state\\ninterface IFee {\\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external;\\n    function feeAmount() external returns (uint);\\n    function updateState() external;\\n\\n    /// @notice Used to enforce a convention\\n    function identifier() external view returns (uint);\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/fees/IFeeManager.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ninterface IFeeManagerFactory {\\n    function createInstance(\\n        address _hub,\\n        address _denominationAsset,\\n        address[] calldata _fees,\\n        uint[] calldata _feeRates,\\n        uint[] calldata _feePeriods,\\n        address _registry\\n    ) external returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/fees/ManagementFee.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./FeeManager.sol\\\u0022;\\nimport \\\u0022../hub/Hub.sol\\\u0022;\\nimport \\\u0022../shares/Shares.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSMath.sol\\\u0022;\\n\\ncontract ManagementFee is DSMath {\\n\\n    uint public DIVISOR = 10 ** 18;\\n\\n    mapping (address =\u003E uint) public managementFeeRate;\\n    mapping (address =\u003E uint) public lastPayoutTime;\\n\\n    function feeAmount() external view returns (uint feeInShares) {\\n        Hub hub = FeeManager(msg.sender).hub();\\n        Shares shares = Shares(hub.shares());\\n        if (shares.totalSupply() == 0 || managementFeeRate[msg.sender] == 0) {\\n            feeInShares = 0;\\n        } else {\\n            uint timePassed = sub(block.timestamp, lastPayoutTime[msg.sender]);\\n            uint preDilutionFeeShares = mul(mul(shares.totalSupply(), managementFeeRate[msg.sender]) / DIVISOR, timePassed) / 365 days;\\n            feeInShares =\\n                mul(preDilutionFeeShares, shares.totalSupply()) /\\n                sub(shares.totalSupply(), preDilutionFeeShares);\\n        }\\n        return feeInShares;\\n    }\\n\\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\\n        require(lastPayoutTime[msg.sender] == 0);\\n        managementFeeRate[msg.sender] = feeRate;\\n        lastPayoutTime[msg.sender] = block.timestamp;\\n    }\\n\\n    function updateState() external {\\n        lastPayoutTime[msg.sender] = block.timestamp;\\n    }\\n\\n    function identifier() external pure returns (uint) {\\n        return 0;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/fees/PerformanceFee.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./FeeManager.sol\\\u0022;\\nimport \\\u0022../accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../hub/Hub.sol\\\u0022;\\nimport \\\u0022../shares/Shares.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSMath.sol\\\u0022;\\n\\ncontract PerformanceFee is DSMath {\\n\\n    event HighWaterMarkUpdate(address indexed feeManager, uint indexed hwm);\\n\\n    uint public constant DIVISOR = 10 ** 18;\\n    uint public constant REDEEM_WINDOW = 1 weeks;\\n\\n    mapping(address =\u003E uint) public highWaterMark;\\n    mapping(address =\u003E uint) public lastPayoutTime;\\n    mapping(address =\u003E uint) public initializeTime;\\n    mapping(address =\u003E uint) public performanceFeeRate;\\n    mapping(address =\u003E uint) public performanceFeePeriod;\\n\\n    /// @notice Sets initial state of the fee for a user\\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\\n        require(lastPayoutTime[msg.sender] == 0, \\\u0022Already initialized\\\u0022);\\n        performanceFeeRate[msg.sender] = feeRate;\\n        performanceFeePeriod[msg.sender] = feePeriod;\\n        highWaterMark[msg.sender] = 10 ** uint(ERC20WithFields(denominationAsset).decimals());\\n        lastPayoutTime[msg.sender] = block.timestamp;\\n        initializeTime[msg.sender] = block.timestamp;\\n    }\\n\\n    /// @notice Assumes management fee is zero\\n    function feeAmount() external returns (uint feeInShares) {\\n        Hub hub = FeeManager(msg.sender).hub();\\n        Accounting accounting = Accounting(hub.accounting());\\n        Shares shares = Shares(hub.shares());\\n        uint gav = accounting.calcGav();\\n        uint gavPerShare = shares.totalSupply() \u003E 0 ?\\n            accounting.valuePerShare(gav, shares.totalSupply())\\n            : accounting.DEFAULT_SHARE_PRICE();\\n        if (\\n            gavPerShare \u003E highWaterMark[msg.sender] \u0026\u0026\\n            shares.totalSupply() != 0 \u0026\u0026\\n            gav != 0\\n        ) {\\n            uint sharePriceGain = sub(gavPerShare, highWaterMark[msg.sender]);\\n            uint totalGain = mul(sharePriceGain, shares.totalSupply()) / DIVISOR;\\n            uint feeInAsset = mul(totalGain, performanceFeeRate[msg.sender]) / DIVISOR;\\n            uint preDilutionFee = mul(shares.totalSupply(), feeInAsset) / gav;\\n            feeInShares =\\n                mul(preDilutionFee, shares.totalSupply()) /\\n                sub(shares.totalSupply(), preDilutionFee);\\n        }\\n        else {\\n            feeInShares = 0;\\n        }\\n        return feeInShares;\\n    }\\n\\n    function canUpdate(address _who) public view returns (bool) {\\n        uint timeSinceInit = sub(\\n            block.timestamp,\\n            initializeTime[_who]\\n        );\\n        uint secondsSinceLastPeriod = timeSinceInit % performanceFeePeriod[_who];\\n        uint lastPeriodEnd = sub(block.timestamp, secondsSinceLastPeriod);\\n        return (\\n            secondsSinceLastPeriod \u003C= REDEEM_WINDOW \u0026\u0026\\n            lastPayoutTime[_who] \u003C lastPeriodEnd\\n        );\\n    }\\n\\n    /// @notice Assumes management fee is zero\\n    function updateState() external {\\n        require(lastPayoutTime[msg.sender] != 0, \\\u0022Not initialized\\\u0022);\\n        require(\\n            canUpdate(msg.sender),\\n            \\\u0022Not within a update window or already updated this period\\\u0022\\n        );\\n        Hub hub = FeeManager(msg.sender).hub();\\n        Accounting accounting = Accounting(hub.accounting());\\n        Shares shares = Shares(hub.shares());\\n        uint gav = accounting.calcGav();\\n        uint currentGavPerShare = accounting.valuePerShare(gav, shares.totalSupply());\\n        require(\\n            currentGavPerShare \u003E highWaterMark[msg.sender],\\n            \\\u0022Current share price does not pass high water mark\\\u0022\\n        );\\n        lastPayoutTime[msg.sender] = block.timestamp;\\n        highWaterMark[msg.sender] = currentGavPerShare;\\n        emit HighWaterMarkUpdate(msg.sender, currentGavPerShare);\\n    }\\n\\n    function identifier() external pure returns (uint) {\\n        return 1;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/hub/Hub.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../dependencies/DSGuard.sol\\\u0022;\\nimport \\\u0022./Spoke.sol\\\u0022;\\nimport \\\u0022../../version/Registry.sol\\\u0022;\\n\\n/// @notice Router for communication between components\\n/// @notice Has one or more Spokes\\ncontract Hub is DSGuard {\\n\\n    event FundShutDown();\\n\\n    struct Routes {\\n        address accounting;\\n        address feeManager;\\n        address participation;\\n        address policyManager;\\n        address shares;\\n        address trading;\\n        address vault;\\n        address registry;\\n        address version;\\n        address engine;\\n        address mlnToken;\\n    }\\n\\n    Routes public routes;\\n    address public manager;\\n    address public creator;\\n    string public name;\\n    bool public isShutDown;\\n    bool public fundInitialized;\\n    uint public creationTime;\\n    mapping (address =\u003E bool) public isSpoke;\\n\\n    constructor(address _manager, string memory _name) public {\\n        creator = msg.sender;\\n        manager = _manager;\\n        name = _name;\\n        creationTime = block.timestamp;\\n    }\\n\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\u0022Only creator can do this\\\u0022);\\n        _;\\n    }\\n\\n    function shutDownFund() external {\\n        require(msg.sender == routes.version);\\n        isShutDown = true;\\n        emit FundShutDown();\\n    }\\n\\n    function initializeAndSetPermissions(address[11] calldata _spokes) external onlyCreator {\\n        require(!fundInitialized, \\\u0022Fund is already initialized\\\u0022);\\n        for (uint i = 0; i \u003C _spokes.length; i\u002B\u002B) {\\n            isSpoke[_spokes[i]] = true;\\n        }\\n        routes.accounting = _spokes[0];\\n        routes.feeManager = _spokes[1];\\n        routes.participation = _spokes[2];\\n        routes.policyManager = _spokes[3];\\n        routes.shares = _spokes[4];\\n        routes.trading = _spokes[5];\\n        routes.vault = _spokes[6];\\n        routes.registry = _spokes[7];\\n        routes.version = _spokes[8];\\n        routes.engine = _spokes[9];\\n        routes.mlnToken = _spokes[10];\\n\\n        Spoke(routes.accounting).initialize(_spokes);\\n        Spoke(routes.feeManager).initialize(_spokes);\\n        Spoke(routes.participation).initialize(_spokes);\\n        Spoke(routes.policyManager).initialize(_spokes);\\n        Spoke(routes.shares).initialize(_spokes);\\n        Spoke(routes.trading).initialize(_spokes);\\n        Spoke(routes.vault).initialize(_spokes);\\n\\n        permit(routes.participation, routes.vault, bytes4(keccak256(\u0027withdraw(address,uint256)\u0027)));\\n        permit(routes.trading, routes.vault, bytes4(keccak256(\u0027withdraw(address,uint256)\u0027)));\\n        permit(routes.participation, routes.shares, bytes4(keccak256(\u0027createFor(address,uint256)\u0027)));\\n        permit(routes.participation, routes.shares, bytes4(keccak256(\u0027destroyFor(address,uint256)\u0027)));\\n        permit(routes.feeManager, routes.shares, bytes4(keccak256(\u0027createFor(address,uint256)\u0027)));\\n        permit(routes.participation, routes.accounting, bytes4(keccak256(\u0027addAssetToOwnedAssets(address)\u0027)));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256(\u0027addAssetToOwnedAssets(address)\u0027)));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256(\u0027removeFromOwnedAssets(address)\u0027)));\\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256(\u0027rewardAllFees()\u0027)));\\n        permit(manager, routes.policyManager, bytes4(keccak256(\u0027register(bytes4,address)\u0027)));\\n        permit(manager, routes.policyManager, bytes4(keccak256(\u0027batchRegister(bytes4[],address[])\u0027)));\\n        permit(manager, routes.participation, bytes4(keccak256(\u0027enableInvestment(address[])\u0027)));\\n        permit(manager, routes.participation, bytes4(keccak256(\u0027disableInvestment(address[])\u0027)));\\n        permit(manager, routes.trading, bytes4(keccak256(\u0027addExchange(address,address)\u0027)));\\n        fundInitialized = true;\\n    }\\n\\n    function vault() external view returns (address) { return routes.vault; }\\n    function accounting() external view returns (address) { return routes.accounting; }\\n    function priceSource() external view returns (address) { return Registry(routes.registry).priceSource(); }\\n    function participation() external view returns (address) { return routes.participation; }\\n    function trading() external view returns (address) { return routes.trading; }\\n    function shares() external view returns (address) { return routes.shares; }\\n    function registry() external view returns (address) { return routes.registry; }\\n    function version() external view returns (address) { return routes.version; }\\n    function policyManager() external view returns (address) { return routes.policyManager; }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/hub/Spoke.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022./Hub.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSAuth.sol\\\u0022;\\n\\n/// @notice Has one Hub\\ncontract Spoke is DSAuth {\\n    Hub public hub;\\n    Hub.Routes public routes;\\n    bool public initialized;\\n\\n    modifier onlyInitialized() {\\n        require(initialized, \\\u0022Component not yet initialized\\\u0022);\\n        _;\\n    }\\n\\n    modifier notShutDown() {\\n        require(!hub.isShutDown(), \\\u0022Hub is shut down\\\u0022);\\n        _;\\n    }\\n\\n    constructor(address _hub) public {\\n        hub = Hub(_hub);\\n        setAuthority(hub);\\n        setOwner(address(hub)); // temporary, to allow initialization\\n    }\\n\\n    function initialize(address[11] calldata _spokes) external auth {\\n        require(msg.sender == address(hub));\\n        require(!initialized, \\\u0022Already initialized\\\u0022);\\n        routes = Hub.Routes(\\n            _spokes[0],\\n            _spokes[1],\\n            _spokes[2],\\n            _spokes[3],\\n            _spokes[4],\\n            _spokes[5],\\n            _spokes[6],\\n            _spokes[7],\\n            _spokes[8],\\n            _spokes[9],\\n            _spokes[10]\\n        );\\n        initialized = true;\\n        setOwner(address(0));\\n    }\\n\\n    function engine() public view virtual returns (address) { return routes.engine; }\\n    function mlnToken() public view virtual returns (address) { return routes.mlnToken; }\\n    function priceSource() public view virtual returns (address) { return hub.priceSource(); }\\n    function version() public view virtual returns (address) { return routes.version; }\\n    function registry() public view virtual returns (address) { return routes.registry; }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/participation/IParticipation.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @notice Investor Fund interactions\\n/// @notice Handles redemptions and requests for investment\\ninterface IParticipation {\\n    function requestInvestment(\\n        uint requestedShares,\\n        uint investmentAmount,\\n        address investmentAsset\\n    ) external payable;\\n    function hasRequest(address) external view returns (bool);\\n    function cancelRequest() external payable;\\n    function executeRequestFor(address requestOwner) external payable;\\n    function redeem() external;\\n    function redeemWithConstraints(uint shareQuantity, address[] calldata requestedAssets) external;\\n}\\n\\ninterface IParticipationFactory {\\n    function createInstance(address _hub, address[] calldata _defaultAssets, address _registry) external returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/participation/Participation.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../vault/Vault.sol\\\u0022;\\nimport \\\u0022../shares/Shares.sol\\\u0022;\\nimport \\\u0022../policies/PolicyManager.sol\\\u0022;\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../../engine/AmguConsumer.sol\\\u0022;\\nimport \\\u0022../../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../../dependencies/TokenUser.sol\\\u0022;\\n\\n/// @notice Entry and exit point for investors\\ncontract Participation is TokenUser, AmguConsumer, Spoke {\\n    event EnableInvestment (address[] asset);\\n    event DisableInvestment (address[] assets);\\n\\n    event InvestmentRequest (\\n        address indexed requestOwner,\\n        address indexed investmentAsset,\\n        uint requestedShares,\\n        uint investmentAmount\\n    );\\n\\n    event RequestExecution (\\n        address indexed requestOwner,\\n        address indexed executor,\\n        address indexed investmentAsset,\\n        uint investmentAmount,\\n        uint requestedShares\\n    );\\n\\n    event CancelRequest (\\n        address indexed requestOwner\\n    );\\n\\n    event Redemption (\\n        address indexed redeemer,\\n        address[] assets,\\n        uint[] assetQuantities,\\n        uint redeemedShares\\n    );\\n\\n    struct Request {\\n        address investmentAsset;\\n        uint investmentAmount;\\n        uint requestedShares;\\n        uint timestamp;\\n    }\\n\\n    uint constant public SHARES_DECIMALS = 18;\\n    uint constant public REQUEST_LIFESPAN = 1 days;\\n\\n    mapping (address =\u003E Request) public requests;\\n    mapping (address =\u003E bool) public investAllowed;\\n    mapping (address =\u003E bool) public hasInvested; // for information purposes only (read)\\n\\n    address[] public historicalInvestors; // for information purposes only (read)\\n\\n    constructor(address _hub, address[] memory _defaultAssets, address _registry)\\n        public\\n        Spoke(_hub)\\n    {\\n        routes.registry = _registry;\\n        _enableInvestment(_defaultAssets);\\n    }\\n\\n    receive() external payable {}\\n\\n    function _enableInvestment(address[] memory _assets) internal {\\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\\n            require(\\n                Registry(routes.registry).assetIsRegistered(_assets[i]),\\n                \\\u0022Asset not registered\\\u0022\\n            );\\n            investAllowed[_assets[i]] = true;\\n        }\\n        emit EnableInvestment(_assets);\\n    }\\n\\n    function enableInvestment(address[] calldata _assets) external auth {\\n        _enableInvestment(_assets);\\n    }\\n\\n    function disableInvestment(address[] calldata _assets) external auth {\\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\\n            investAllowed[_assets[i]] = false;\\n        }\\n        emit DisableInvestment(_assets);\\n    }\\n\\n    function hasRequest(address _who) public view returns (bool) {\\n        return requests[_who].timestamp \u003E 0;\\n    }\\n\\n    function hasExpiredRequest(address _who) public view returns (bool) {\\n        return block.timestamp \u003E add(requests[_who].timestamp, REQUEST_LIFESPAN);\\n    }\\n\\n    /// @notice Whether request is OK and invest delay is being respected\\n    /// @dev Request valid if price update happened since request and not expired\\n    /// @dev If no shares exist and not expired, request can be executed immediately\\n    function hasValidRequest(address _who) public view returns (bool) {\\n        IPriceSource priceSource = IPriceSource(priceSource());\\n        bool delayRespectedOrNoShares = requests[_who].timestamp \u003C priceSource.getLastUpdate() ||\\n            Shares(routes.shares).totalSupply() == 0;\\n\\n        return hasRequest(_who) \u0026\u0026\\n            delayRespectedOrNoShares \u0026\u0026\\n            !hasExpiredRequest(_who) \u0026\u0026\\n            requests[_who].investmentAmount \u003E 0 \u0026\u0026\\n            requests[_who].requestedShares \u003E 0;\\n    }\\n\\n    function requestInvestment(\\n        uint requestedShares,\\n        uint investmentAmount,\\n        address investmentAsset\\n    )\\n        external\\n        notShutDown\\n        payable\\n        amguPayable(true)\\n        onlyInitialized\\n    {\\n        PolicyManager(routes.policyManager).preValidate(\\n            msg.sig,\\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\\n            [uint(0), uint(0), uint(0)],\\n            bytes32(0)\\n        );\\n        require(\\n            investAllowed[investmentAsset],\\n            \\\u0022Investment not allowed in this asset\\\u0022\\n        );\\n        safeTransferFrom(\\n            investmentAsset, msg.sender, address(this), investmentAmount\\n        );\\n        require(\\n            requests[msg.sender].timestamp == 0,\\n            \\\u0022Only one request can exist at a time\\\u0022\\n        );\\n        requests[msg.sender] = Request({\\n            investmentAsset: investmentAsset,\\n            investmentAmount: investmentAmount,\\n            requestedShares: requestedShares,\\n            timestamp: block.timestamp\\n        });\\n        PolicyManager(routes.policyManager).postValidate(\\n            msg.sig,\\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\\n            [uint(0), uint(0), uint(0)],\\n            bytes32(0)\\n        );\\n\\n        emit InvestmentRequest(\\n            msg.sender,\\n            investmentAsset,\\n            requestedShares,\\n            investmentAmount\\n        );\\n    }\\n\\n    function _cancelRequestFor(address requestOwner) internal {\\n        require(hasRequest(requestOwner), \\\u0022No request to cancel\\\u0022);\\n        IPriceSource priceSource = IPriceSource(priceSource());\\n        Request memory request = requests[requestOwner];\\n        require(\\n            !priceSource.hasValidPrice(request.investmentAsset) ||\\n            hasExpiredRequest(requestOwner) ||\\n            hub.isShutDown(),\\n            \\\u0022No cancellation condition was met\\\u0022\\n        );\\n        IERC20 investmentAsset = IERC20(request.investmentAsset);\\n        uint investmentAmount = request.investmentAmount;\\n        delete requests[requestOwner];\\n        msg.sender.transfer(Registry(routes.registry).incentive());\\n        safeTransfer(address(investmentAsset), requestOwner, investmentAmount);\\n\\n        emit CancelRequest(requestOwner);\\n    }\\n\\n    /// @notice Can only cancel when no price, request expired or fund shut down\\n    /// @dev Only request owner can cancel their request\\n    function cancelRequest() external payable amguPayable(false) {\\n        _cancelRequestFor(msg.sender);\\n    }\\n\\n    function cancelRequestFor(address requestOwner)\\n        external\\n        payable\\n        amguPayable(false)\\n    {\\n        _cancelRequestFor(requestOwner);\\n    }\\n\\n    function executeRequestFor(address requestOwner)\\n        external\\n        notShutDown\\n        amguPayable(false)\\n        payable\\n    {\\n        Request memory request = requests[requestOwner];\\n        require(\\n            hasValidRequest(requestOwner),\\n            \\\u0022No valid request for this address\\\u0022\\n        );\\n\\n        FeeManager(routes.feeManager).rewardManagementFee();\\n\\n        uint totalShareCostInInvestmentAsset = Accounting(routes.accounting)\\n            .getShareCostInAsset(\\n                request.requestedShares,\\n                request.investmentAsset\\n            );\\n\\n        require(\\n            totalShareCostInInvestmentAsset \u003C= request.investmentAmount,\\n            \\\u0022Invested amount too low\\\u0022\\n        );\\n        // send necessary amount of investmentAsset to vault\\n        safeTransfer(\\n            request.investmentAsset,\\n            routes.vault,\\n            totalShareCostInInvestmentAsset\\n        );\\n\\n        uint investmentAssetChange = sub(\\n            request.investmentAmount,\\n            totalShareCostInInvestmentAsset\\n        );\\n\\n        // return investmentAsset change to request owner\\n        if (investmentAssetChange \u003E 0) {\\n            safeTransfer(\\n                request.investmentAsset,\\n                requestOwner,\\n                investmentAssetChange\\n            );\\n        }\\n\\n        msg.sender.transfer(Registry(routes.registry).incentive());\\n\\n        Shares(routes.shares).createFor(requestOwner, request.requestedShares);\\n        Accounting(routes.accounting).addAssetToOwnedAssets(request.investmentAsset);\\n\\n        if (!hasInvested[requestOwner]) {\\n            hasInvested[requestOwner] = true;\\n            historicalInvestors.push(requestOwner);\\n        }\\n\\n        emit RequestExecution(\\n            requestOwner,\\n            msg.sender,\\n            request.investmentAsset,\\n            request.investmentAmount,\\n            request.requestedShares\\n        );\\n        delete requests[requestOwner];\\n    }\\n\\n    function getOwedPerformanceFees(uint shareQuantity)\\n        public\\n        returns (uint remainingShareQuantity)\\n    {\\n        Shares shares = Shares(routes.shares);\\n\\n        uint totalPerformanceFee = FeeManager(routes.feeManager).performanceFeeAmount();\\n        // The denominator is augmented because performanceFeeAmount() accounts for inflation\\n        // Since shares are directly transferred, we don\u0027t need to account for inflation in this case\\n        uint performanceFeePortion = mul(\\n            totalPerformanceFee,\\n            shareQuantity\\n        ) / add(shares.totalSupply(), totalPerformanceFee);\\n        return performanceFeePortion;\\n    }\\n\\n    /// @dev \\\u0022Happy path\\\u0022 (no asset throws \u0026 quantity available)\\n    /// @notice Redeem all shares and across all assets\\n    function redeem() external {\\n        uint ownedShares = Shares(routes.shares).balanceOf(msg.sender);\\n        redeemQuantity(ownedShares);\\n    }\\n\\n    /// @notice Redeem shareQuantity across all assets\\n    function redeemQuantity(uint shareQuantity) public {\\n        address[] memory assetList;\\n        assetList = Accounting(routes.accounting).getOwnedAssets();\\n        redeemWithConstraints(shareQuantity, assetList);\\n    }\\n\\n    // TODO: reconsider the scenario where the user has enough funds to force shutdown on a large trade (any way around this?)\\n    /// @dev Redeem only selected assets (used only when an asset throws)\\n    function redeemWithConstraints(uint shareQuantity, address[] memory requestedAssets) public {\\n        Shares shares = Shares(routes.shares);\\n        require(\\n            shares.balanceOf(msg.sender) \u003E= shareQuantity \u0026\u0026\\n            shares.balanceOf(msg.sender) \u003E 0,\\n            \\\u0022Sender does not have enough shares to fulfill request\\\u0022\\n        );\\n\\n        uint owedPerformanceFees = 0;\\n        if (\\n            IPriceSource(priceSource()).hasValidPrices(requestedAssets) \u0026\u0026\\n            msg.sender != hub.manager()\\n        ) {\\n            FeeManager(routes.feeManager).rewardManagementFee();\\n            owedPerformanceFees = getOwedPerformanceFees(shareQuantity);\\n            shares.destroyFor(msg.sender, owedPerformanceFees);\\n            shares.createFor(hub.manager(), owedPerformanceFees);\\n        }\\n        uint remainingShareQuantity = sub(shareQuantity, owedPerformanceFees);\\n\\n        address ofAsset;\\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\\n        // Check whether enough assets held by fund\\n        Accounting accounting = Accounting(routes.accounting);\\n        for (uint i = 0; i \u003C requestedAssets.length; \u002B\u002Bi) {\\n            ofAsset = requestedAssets[i];\\n            require(\\n                accounting.isInAssetList(ofAsset),\\n                \\\u0022Requested asset not in asset list\\\u0022\\n            );\\n            for (uint j = 0; j \u003C redeemedAssets.length; j\u002B\u002B) {\\n                require(\\n                    ofAsset != redeemedAssets[j],\\n                    \\\u0022Asset can only be redeemed once\\\u0022\\n                );\\n            }\\n            redeemedAssets[i] = ofAsset;\\n            uint quantityHeld = accounting.assetHoldings(ofAsset);\\n            if (quantityHeld == 0) continue;\\n\\n            // participant\u0027s ownership percentage of asset holdings\\n            ownershipQuantities[i] = mul(quantityHeld, remainingShareQuantity) / shares.totalSupply();\\n        }\\n\\n        shares.destroyFor(msg.sender, remainingShareQuantity);\\n\\n        // Transfer owned assets\\n        for (uint k = 0; k \u003C requestedAssets.length; \u002B\u002Bk) {\\n            ofAsset = requestedAssets[k];\\n            if (ownershipQuantities[k] == 0) {\\n                continue;\\n            } else {\\n                Vault(routes.vault).withdraw(ofAsset, ownershipQuantities[k]);\\n                safeTransfer(ofAsset, msg.sender, ownershipQuantities[k]);\\n            }\\n        }\\n        emit Redemption(\\n            msg.sender,\\n            requestedAssets,\\n            ownershipQuantities,\\n            remainingShareQuantity\\n        );\\n    }\\n\\n    function getHistoricalInvestors() external view returns (address[] memory) {\\n        return historicalInvestors;\\n    }\\n\\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\\n}\\n\\ncontract ParticipationFactory is Factory {\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance,\\n        address[] defaultAssets,\\n        address registry\\n    );\\n\\n    function createInstance(address _hub, address[] calldata _defaultAssets, address _registry)\\n        external\\n        returns (address)\\n    {\\n        address participation = address(\\n            new Participation(_hub, _defaultAssets, _registry)\\n        );\\n        childExists[participation] = true;\\n        emit NewInstance(_hub, participation, _defaultAssets, _registry);\\n        return participation;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/AddressList.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../dependencies/DSAuth.sol\\\u0022;\\n\\n/// @notice Generic AddressList\\ncontract AddressList is DSAuth {\\n\\n    event ListAddition(address[] ones);\\n\\n    mapping(address =\u003E bool) internal list;\\n    address[] internal mirror;\\n\\n    constructor(address[] memory _assets) public {\\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\\n            if (!isMember(_assets[i])) { // filter duplicates in _assets\\n                list[_assets[i]] = true;\\n                mirror.push(_assets[i]);\\n            }\\n        }\\n        emit ListAddition(_assets);\\n    }\\n\\n    /// @return whether an asset is in the list\\n    function isMember(address _asset) public view returns (bool) {\\n        return list[_asset];\\n    }\\n\\n    /// @return number of assets specified in the list\\n    function getMemberCount() external view returns (uint) {\\n        return mirror.length;\\n    }\\n\\n    /// @return array of all listed asset addresses\\n    function getMembers() external view returns (address[] memory) { return mirror; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/compliance/UserWhitelist.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../../dependencies/DSAuth.sol\\\u0022;\\n\\ncontract UserWhitelist is DSAuth {\\n    enum Applied { pre, post }\\n\\n    event ListAddition(address indexed who);\\n    event ListRemoval(address indexed who);\\n\\n    mapping (address =\u003E bool) public whitelisted;\\n\\n    constructor(address[] memory _preApproved) public {\\n        batchAddToWhitelist(_preApproved);\\n    }\\n\\n    function addToWhitelist(address _who) public auth {\\n        whitelisted[_who] = true;\\n        emit ListAddition(_who);\\n    }\\n\\n    function removeFromWhitelist(address _who) public auth {\\n        whitelisted[_who] = false;\\n        emit ListRemoval(_who);\\n    }\\n\\n    function batchAddToWhitelist(address[] memory _members) public auth {\\n        for (uint i = 0; i \u003C _members.length; i\u002B\u002B) {\\n            addToWhitelist(_members[i]);\\n        }\\n    }\\n\\n    function batchRemoveFromWhitelist(address[] memory _members) public auth {\\n        for (uint i = 0; i \u003C _members.length; i\u002B\u002B) {\\n            removeFromWhitelist(_members[i]);\\n        }\\n    }\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\\n        return whitelisted[addresses[0]];\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.pre; }\\n    function identifier() external pure returns (string memory) { return \u0027UserWhitelist\u0027; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/IPolicy.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ninterface IPolicy {\\n    enum Applied { pre, post }\\n\\n    // In Trading context:\\n    // addresses: Order maker, Order taker, Order maker asset, Order taker asset, Exchange address\\n    // values: Maker token quantity, Taker token quantity, Fill Taker Quantity\\n\\n    // In Participation context:\\n    // address[0]: Investor address, address[3]: Investment asset\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool);\\n\\n    function position() external view returns (Applied);\\n    function identifier() external view returns (string memory);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/IPolicyManager.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n\\ninterface IPolicyManagerFactory {\\n    function createInstance(address _hub) external returns (address);\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/PolicyManager.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022./IPolicy.sol\\\u0022;\\n\\ncontract PolicyManager is Spoke {\\n\\n    event Registration(\\n        bytes4 indexed sig,\\n        IPolicy.Applied position,\\n        address indexed policy\\n    );\\n\\n    struct Entry {\\n        IPolicy[] pre;\\n        IPolicy[] post;\\n    }\\n\\n    mapping(bytes4 =\u003E Entry) policies;\\n\\n    constructor (address _hub) public Spoke(_hub) {}\\n\\n    function register(bytes4 sig, address _policy) public auth {\\n        IPolicy.Applied position = IPolicy(_policy).position();\\n        if (position == IPolicy.Applied.pre) {\\n            policies[sig].pre.push(IPolicy(_policy));\\n        } else if (position == IPolicy.Applied.post) {\\n            policies[sig].post.push(IPolicy(_policy));\\n        } else {\\n            revert(\\\u0022Only pre and post allowed\\\u0022);\\n        }\\n        emit Registration(sig, position, _policy);\\n    }\\n\\n    function batchRegister(bytes4[] memory sig, address[] memory _policies) public auth {\\n        require(sig.length == _policies.length, \\\u0022Arrays lengths unequal\\\u0022);\\n        for (uint i = 0; i \u003C sig.length; i\u002B\u002B) {\\n            register(sig[i], _policies[i]);\\n        }\\n    }\\n\\n    function PoliciesToAddresses(IPolicy[] storage _policies) internal view returns (address[] memory) {\\n        address[] memory res = new address[](_policies.length);\\n        for(uint i = 0; i \u003C _policies.length; i\u002B\u002B) {\\n            res[i] = address(_policies[i]);\\n        }\\n        return res;\\n    }\\n\\n    function getPoliciesBySig(bytes4 sig) public view returns (address[] memory, address[] memory) {\\n        return (PoliciesToAddresses(policies[sig].pre), PoliciesToAddresses(policies[sig].post));\\n    }\\n\\n    modifier isValidPolicyBySig(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\\n        preValidate(sig, addresses, values, identifier);\\n        _;\\n        postValidate(sig, addresses, values, identifier);\\n    }\\n\\n    modifier isValidPolicy(address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\\n        preValidate(msg.sig, addresses, values, identifier);\\n        _;\\n        postValidate(msg.sig, addresses, values, identifier);\\n    }\\n\\n    function preValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\\n        validate(policies[sig].pre, sig, addresses, values, identifier);\\n    }\\n\\n    function postValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\\n        validate(policies[sig].post, sig, addresses, values, identifier);\\n    }\\n\\n    function validate(IPolicy[] storage aux, bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) internal {\\n        for(uint i = 0; i \u003C aux.length; i\u002B\u002B) {\\n            require(\\n                aux[i].rule(sig, addresses, values, identifier),\\n                string(abi.encodePacked(\\\u0022Rule evaluated to false: \\\u0022, aux[i].identifier()))\\n            );\\n        }\\n    }\\n}\\n\\ncontract PolicyManagerFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address policyManager = address(new PolicyManager(_hub));\\n        childExists[policyManager] = true;\\n        emit NewInstance(_hub, policyManager);\\n        return policyManager;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/risk-management/AssetBlacklist.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../AddressList.sol\\\u0022;\\nimport \\\u0022../TradingSignatures.sol\\\u0022;\\n\\n/// @notice Assets can be added but not removed from blacklist\\ncontract AssetBlacklist is TradingSignatures, AddressList {\\n    enum Applied { pre, post }\\n\\n    // bytes4 constant public MAKE_ORDER = 0x79705be7; // makeOrderSignature\\n    // bytes4 constant public TAKE_ORDER = 0xe51be6e8; // takeOrderSignature\\n\\n    constructor(address[] memory _assets) AddressList(_assets) public {}\\n\\n    function addToBlacklist(address _asset) external auth {\\n        require(!isMember(_asset), \\\u0022Asset already in blacklist\\\u0022);\\n        list[_asset] = true;\\n        mirror.push(_asset);\\n    }\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\\n        return !isMember(incomingToken);\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.pre; }\\n    function identifier() external pure returns (string memory) { return \u0027AssetBlacklist\u0027; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/risk-management/AssetWhitelist.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../AddressList.sol\\\u0022;\\nimport \\\u0022../TradingSignatures.sol\\\u0022;\\n\\n/// @notice Assets can be removed from but not added to whitelist\\ncontract AssetWhitelist is TradingSignatures, AddressList {\\n    enum Applied { pre, post }\\n\\n    constructor(address[] memory _assets) public AddressList(_assets) {}\\n\\n    function removeFromWhitelist(address _asset) external auth {\\n        require(isMember(_asset), \\\u0022Asset not in whitelist\\\u0022);\\n        delete list[_asset];\\n        uint i = getAssetIndex(_asset);\\n        for (i; i \u003C mirror.length-1; i\u002B\u002B){\\n            mirror[i] = mirror[i\u002B1];\\n        }\\n        mirror.pop();\\n    }\\n\\n    function getAssetIndex(address _asset) public view returns (uint) {\\n        for (uint i = 0; i \u003C mirror.length; i\u002B\u002B) {\\n            if (mirror[i] == _asset) { return i; }\\n        }\\n    }\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\\n        return isMember(incomingToken);\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.pre; }\\n    function identifier() external pure returns (string memory) { return \u0027AssetWhitelist\u0027; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/risk-management/MaxConcentration.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../../../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../../accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../../trading/Trading.sol\\\u0022;\\nimport \\\u0022../TradingSignatures.sol\\\u0022;\\nimport \\\u0022../../../prices/IPriceSource.sol\\\u0022;\\n\\ncontract MaxConcentration is TradingSignatures, DSMath {\\n    enum Applied { pre, post }\\n\\n    uint internal constant ONE_HUNDRED_PERCENT = 10 ** 18;  // 100%\\n    uint public maxConcentration;\\n\\n    constructor(uint _maxConcentration) public {\\n        require(\\n            _maxConcentration \u003C= ONE_HUNDRED_PERCENT,\\n            \\\u0022Max concentration cannot exceed 100%\\\u0022\\n        );\\n        maxConcentration = _maxConcentration;\\n    }\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier)\\n        external\\n        returns (bool)\\n    {\\n        Accounting accounting = Accounting(Hub(Trading(msg.sender).hub()).accounting());\\n        address denominationAsset = accounting.DENOMINATION_ASSET();\\n        // Max concentration is only checked for non-quote assets\\n        address takerToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\\n        if (denominationAsset == takerToken) { return true; }\\n\\n        uint concentration;\\n        uint totalGav = accounting.calcGav();\\n        if (sig == MAKE_ORDER) {\\n            IPriceSource priceSource = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\\n            address makerToken = addresses[2];\\n            uint makerQuantiyBeingTraded = values[0];\\n            uint takerQuantityBeingTraded = values[1];\\n\\n            uint takerTokenGavBeingTraded = priceSource.convertQuantity(\\n                takerQuantityBeingTraded, takerToken, denominationAsset\\n            );\\n\\n            uint makerTokenGavBeingTraded;\\n            if (makerToken == denominationAsset) {\\n                makerTokenGavBeingTraded = makerQuantiyBeingTraded;\\n            }\\n            else {\\n                makerTokenGavBeingTraded = priceSource.convertQuantity(\\n                    makerQuantiyBeingTraded, makerToken, denominationAsset\\n                );\\n            }\\n            concentration = _calcConcentration(\\n                add(accounting.calcAssetGAV(takerToken), takerTokenGavBeingTraded),\\n                add(takerTokenGavBeingTraded, sub(totalGav, makerTokenGavBeingTraded))\\n            );\\n        }\\n        else {\\n            concentration = _calcConcentration(\\n                accounting.calcAssetGAV(takerToken),\\n                totalGav\\n            );\\n        }\\n        return concentration \u003C= maxConcentration;\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.post; }\\n    function identifier() external pure returns (string memory) { return \u0027MaxConcentration\u0027; }\\n\\n    function _calcConcentration(uint assetGav, uint totalGav) internal returns (uint) {\\n        return mul(assetGav, ONE_HUNDRED_PERCENT) / totalGav;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/risk-management/MaxPositions.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../accounting/Accounting.sol\\\u0022;\\nimport \\\u0022../../trading/Trading.sol\\\u0022;\\nimport \\\u0022../TradingSignatures.sol\\\u0022;\\n\\ncontract MaxPositions is TradingSignatures {\\n    enum Applied { pre, post }\\n\\n    uint public maxPositions;\\n\\n    /// @dev _maxPositions = 10 means max 10 different asset tokens\\n    /// @dev _maxPositions = 0 means no asset tokens are investable\\n    constructor(uint _maxPositions) public { maxPositions = _maxPositions; }\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier)\\n        external\\n        returns (bool)\\n    {\\n        Accounting accounting = Accounting(Hub(Trading(msg.sender).hub()).accounting());\\n        address denominationAsset = accounting.DENOMINATION_ASSET();\\n        // Always allow a trade INTO the quote asset\\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\\n        if (denominationAsset == incomingToken) { return true; }\\n        return accounting.getOwnedAssetsLength() \u003C= maxPositions;\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.post; }\\n    function identifier() external pure returns (string memory) { return \u0027MaxPositions\u0027; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/risk-management/PriceTolerance.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../../hub/Hub.sol\\\u0022;\\nimport \\\u0022../../../prices/IPriceSource.sol\\\u0022;\\nimport \\\u0022../TradingSignatures.sol\\\u0022;\\nimport \\\u0022../../../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../../trading/Trading.sol\\\u0022;\\nimport \\\u0022../../../exchanges/interfaces/IOasisDex.sol\\\u0022;\\n\\ncontract PriceTolerance is TradingSignatures, DSMath {\\n    enum Applied { pre, post }\\n\\n    uint256 public tolerance;\\n\\n    uint256 constant MULTIPLIER = 10 ** 16; // to give effect of a percentage\\n    uint256 constant DIVISOR = 10 ** 18;\\n\\n    // _tolerance: 10 equals to 10% of tolerance\\n    constructor(uint256 _tolerancePercent) public {\\n        require(_tolerancePercent \u003C= 100, \\\u0022Tolerance range is 0% - 100%\\\u0022);\\n        tolerance = mul(_tolerancePercent, MULTIPLIER);\\n    }\\n\\n    /// @notice Taken from OpenZeppelin (https://git.io/fhQqo)\\n   function signedSafeSub(int256 _a, int256 _b) internal pure returns (int256) {\\n        int256 c = _a - _b;\\n        require((_b \u003E= 0 \u0026\u0026 c \u003C= _a) || (_b \u003C 0 \u0026\u0026 c \u003E _a));\\n\\n        return c;\\n    }\\n\\n    function checkPriceToleranceTakeOrder(\\n        address _makerAsset,\\n        address _takerAsset,\\n        uint256 _fillMakerQuantity,\\n        uint256 _fillTakerQuantity\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        IPriceSource pricefeed = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\\n        uint256 referencePrice;\\n        (referencePrice,) = pricefeed.getReferencePriceInfo(_takerAsset, _makerAsset);\\n\\n        uint256 orderPrice = pricefeed.getOrderPriceInfo(\\n            _takerAsset,\\n            _fillTakerQuantity,\\n            _fillMakerQuantity\\n        );\\n\\n        return orderPrice \u003E= sub(\\n            referencePrice,\\n            mul(tolerance, referencePrice) / DIVISOR\\n        );\\n    }\\n\\n    function takeGenericOrder(\\n        address _makerAsset,\\n        address _takerAsset,\\n        uint256[3] memory _values\\n    ) public view returns (bool) {\\n        uint256 fillTakerQuantity = _values[2];\\n        uint256 fillMakerQuantity = mul(fillTakerQuantity, _values[0]) / _values[1];\\n        return checkPriceToleranceTakeOrder(\\n            _makerAsset, _takerAsset, fillMakerQuantity, fillTakerQuantity\\n        );\\n    }\\n\\n    function takeOasisDex(\\n        address _exchange,\\n        bytes32 _identifier,\\n        uint256 _fillTakerQuantity\\n    ) public view returns (bool) {\\n        uint256 maxMakerQuantity;\\n        address makerAsset;\\n        uint256 maxTakerQuantity;\\n        address takerAsset;\\n        (\\n            maxMakerQuantity,\\n            makerAsset,\\n            maxTakerQuantity,\\n            takerAsset\\n        ) = IOasisDex(_exchange).getOffer(uint256(_identifier));\\n\\n        uint256 fillMakerQuantity = mul(_fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\\n        return checkPriceToleranceTakeOrder(\\n            makerAsset, takerAsset, fillMakerQuantity, _fillTakerQuantity\\n        );\\n    }\\n\\n    function takeOrder(\\n        address[5] memory _addresses,\\n        uint256[3] memory _values,\\n        bytes32 _identifier\\n    ) public view returns (bool) {\\n        if (_identifier == 0x0) {\\n            return takeGenericOrder(_addresses[2], _addresses[3], _values);\\n        } else {\\n            return takeOasisDex(_addresses[4], _identifier, _values[2]);\\n        }\\n    }\\n\\n    function makeOrder(\\n        address[5] memory _addresses,\\n        uint256[3] memory _values,\\n        bytes32 _identifier\\n    ) public view returns (bool) {\\n        IPriceSource pricefeed = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\\n\\n        uint256 ratio;\\n        (ratio,) = IPriceSource(pricefeed).getReferencePriceInfo(_addresses[2], _addresses[3]);\\n        uint256 value = IPriceSource(pricefeed).getOrderPriceInfo(_addresses[2], _values[0], _values[1]);\\n\\n        int res = signedSafeSub(int(ratio), int(value));\\n        if (res \u003C 0) {\\n            return true;\\n        } else {\\n            return wdiv(uint256(res), ratio) \u003C= tolerance;\\n        }\\n    }\\n\\n    function rule(\\n        bytes4 _sig,\\n        address[5] calldata _addresses,\\n        uint256[3] calldata _values,\\n        bytes32 _identifier\\n    ) external returns (bool) {\\n        if (_sig == MAKE_ORDER) {\\n            return makeOrder(_addresses, _values, _identifier);\\n        } else if (_sig == TAKE_ORDER) {\\n            return takeOrder(_addresses, _values, _identifier);\\n        }\\n        revert(\\\u0022Signature was neither MakeOrder nor TakeOrder\\\u0022);\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.pre; }\\n    function identifier() external pure returns (string memory) { return \u0027PriceTolerance\u0027; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/policies/TradingSignatures.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ncontract TradingSignatures {\\n    bytes4 constant public MAKE_ORDER = 0x5f08e909; // makeOrderSignature\\n    bytes4 constant public TAKE_ORDER = 0x63b24ef1; // takeOrderSignature\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/shares/IShares.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @notice Token representing ownership of the Fund\\ninterface IShares {\\n    function createFor(address who, uint amount) external;\\n    function destroyFor(address who, uint amount) external;\\n}\\n\\ninterface ISharesFactory {\\n    function createInstance(address _hub) external returns (address);\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/shares/Shares.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../../dependencies/token/StandardToken.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\n\\ncontract Shares is Spoke, StandardToken {\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n\\n    constructor(address _hub) public Spoke(_hub) {\\n        name = hub.name();\\n        symbol = \\\u0022MLNF\\\u0022;\\n        decimals = 18;\\n    }\\n\\n    function createFor(address who, uint amount) public auth {\\n        _mint(who, amount);\\n    }\\n\\n    function destroyFor(address who, uint amount) public auth {\\n        _burn(who, amount);\\n    }\\n\\n    function transfer(address to, uint amount) public override returns (bool) {\\n        revert(\\\u0022Unimplemented\\\u0022);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\u0022Unimplemented\\\u0022);\\n    }\\n\\n    function approve(address spender, uint amount) public override returns (bool) {\\n        revert(\\\u0022Unimplemented\\\u0022);\\n    }\\n\\n    function increaseApproval(\\n        address spender,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\u0022Unimplemented\\\u0022);\\n    }\\n\\n    function decreaseApproval(\\n        address spender,\\n        uint amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\u0022Unimplemented\\\u0022);\\n    }\\n}\\n\\ncontract SharesFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address shares = address(new Shares(_hub));\\n        childExists[shares] = true;\\n        emit NewInstance(_hub, shares);\\n        return shares;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/fund/trading/ITrading.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\npragma experimental ABIEncoderV2;\\n\\n// TODO: Restore indexed params\\n\\n/// @notice Mediation between a Fund and exchanges\\ninterface ITrading {\\n    function callOnExchange(\\n        uint exchangeIndex,\\n        string calldata methodSignature,\\n        address[8] calldata orderAddresses,\\n        uint[8] calldata orderValues,\\n        bytes[4] calldata orderData,\\n        bytes32 identifier,\\n        bytes calldata signature\\n    ) external;\\n\\n    function addOpenMakeOrder(\\n        address ofExchange,\\n        address ofSellAsset,\\n        address ofBuyAsset,\\n        address ofFeeAsset,\\n        uint orderId,\\n        uint expiryTime\\n    ) external;\\n\\n    function removeOpenMakeOrder(\\n        address ofExchange,\\n        address ofSellAsset\\n    ) external;\\n\\n    function updateAndGetQuantityBeingTraded(address _asset) external returns (uint256);\\n    function getOpenMakeOrdersAgainstAsset(address _asset) external view returns (uint256);\\n}\\n\\ninterface ITradingFactory {\\n     function createInstance(\\n        address _hub,\\n        address[] calldata _exchanges,\\n        address[] calldata _adapters,\\n        address _registry\\n    ) external returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/trading/Trading.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../vault/Vault.sol\\\u0022;\\nimport \\\u0022../policies/PolicyManager.sol\\\u0022;\\nimport \\\u0022../policies/TradingSignatures.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../../exchanges/ExchangeAdapter.sol\\\u0022;\\nimport \\\u0022../../exchanges/interfaces/IZeroExV2.sol\\\u0022;\\nimport \\\u0022../../exchanges/interfaces/IZeroExV3.sol\\\u0022;\\nimport \\\u0022../../version/Registry.sol\\\u0022;\\nimport \\\u0022../../dependencies/TokenUser.sol\\\u0022;\\n\\ncontract Trading is DSMath, TokenUser, Spoke, TradingSignatures {\\n    event ExchangeMethodCall(\\n        address indexed exchangeAddress,\\n        string indexed methodSignature,\\n        address[8] orderAddresses,\\n        uint[8] orderValues,\\n        bytes[4] orderData,\\n        bytes32 identifier,\\n        bytes signature\\n    );\\n\\n    struct Exchange {\\n        address exchange;\\n        address adapter;\\n        bool takesCustody;\\n    }\\n\\n    enum UpdateType { make, take, cancel }\\n\\n    struct Order {\\n        address exchangeAddress;\\n        bytes32 orderId;\\n        UpdateType updateType;\\n        address makerAsset;\\n        address takerAsset;\\n        uint makerQuantity;\\n        uint takerQuantity;\\n        uint timestamp;\\n        uint fillTakerQuantity;\\n    }\\n\\n    struct OpenMakeOrder {\\n        uint id; // Order Id from exchange\\n        uint expiresAt; // Timestamp when the order expires\\n        uint orderIndex; // Index of the order in the orders array\\n        address buyAsset; // Address of the buy asset in the order\\n        address feeAsset;\\n    }\\n\\n    Exchange[] public exchanges;\\n    Order[] public orders;\\n    mapping (address =\u003E bool) public adapterIsAdded;\\n    mapping (address =\u003E mapping(address =\u003E OpenMakeOrder)) public exchangesToOpenMakeOrders;\\n    mapping (address =\u003E uint) public openMakeOrdersAgainstAsset;\\n    mapping (address =\u003E uint) public openMakeOrdersUsingAssetAsFee;\\n    mapping (address =\u003E bool) public isInOpenMakeOrder;\\n    mapping (address =\u003E uint) public makerAssetCooldown;\\n    mapping (bytes32 =\u003E IZeroExV2.Order) internal orderIdToZeroExV2Order;\\n    mapping (bytes32 =\u003E IZeroExV3.Order) internal orderIdToZeroExV3Order;\\n\\n    uint public constant ORDER_LIFESPAN = 1 days;\\n    uint public constant MAKE_ORDER_COOLDOWN = 30 minutes;\\n\\n    modifier delegateInternal() {\\n        require(msg.sender == address(this), \\\u0022Sender is not this contract\\\u0022);\\n        _;\\n    }\\n\\n    constructor(\\n        address _hub,\\n        address[] memory _exchanges,\\n        address[] memory _adapters,\\n        address _registry\\n    )\\n        public\\n        Spoke(_hub)\\n    {\\n        routes.registry = _registry;\\n        require(_exchanges.length == _adapters.length, \\\u0022Array lengths unequal\\\u0022);\\n        for (uint i = 0; i \u003C _exchanges.length; i\u002B\u002B) {\\n            _addExchange(_exchanges[i], _adapters[i]);\\n        }\\n    }\\n\\n    /// @notice Receive ether function (used to receive ETH from WETH)\\n    receive() external payable {}\\n\\n    function addExchange(address _exchange, address _adapter) external auth {\\n        _addExchange(_exchange, _adapter);\\n    }\\n\\n    function _addExchange(\\n        address _exchange,\\n        address _adapter\\n    ) internal {\\n        require(!adapterIsAdded[_adapter], \\\u0022Adapter already added\\\u0022);\\n        adapterIsAdded[_adapter] = true;\\n        Registry registry = Registry(routes.registry);\\n        require(\\n            registry.exchangeAdapterIsRegistered(_adapter),\\n            \\\u0022Adapter is not registered\\\u0022\\n        );\\n\\n        address registeredExchange;\\n        bool takesCustody;\\n        (registeredExchange, takesCustody) = registry.getExchangeInformation(_adapter);\\n\\n        require(\\n            registeredExchange == _exchange,\\n            \\\u0022Exchange and adapter do not match\\\u0022\\n        );\\n        exchanges.push(Exchange(_exchange, _adapter, takesCustody));\\n    }\\n\\n    /// @notice Universal method for calling exchange functions through adapters\\n    /// @notice See adapter contracts for parameters needed for each exchange\\n    /// @param exchangeIndex Index of the exchange in the \\\u0022exchanges\\\u0022 array\\n    /// @param orderAddresses [0] Order maker\\n    /// @param orderAddresses [1] Order taker\\n    /// @param orderAddresses [2] Order maker asset\\n    /// @param orderAddresses [3] Order taker asset\\n    /// @param orderAddresses [4] feeRecipientAddress\\n    /// @param orderAddresses [5] senderAddress\\n    /// @param orderAddresses [6] maker fee asset\\n    /// @param orderAddresses [7] taker fee asset\\n    /// @param orderValues [0] makerAssetAmount\\n    /// @param orderValues [1] takerAssetAmount\\n    /// @param orderValues [2] Maker fee\\n    /// @param orderValues [3] Taker fee\\n    /// @param orderValues [4] expirationTimeSeconds\\n    /// @param orderValues [5] Salt/nonce\\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\\n    /// @param orderValues [7] Dexy signature mode\\n    /// @param orderData [0] Encoded data specific to maker asset\\n    /// @param orderData [1] Encoded data specific to taker asset\\n    /// @param orderData [2] Encoded data specific to maker asset fee\\n    /// @param orderData [3] Encoded data specific to taker asset fee\\n    /// @param identifier Order identifier\\n    /// @param signature Signature of order maker\\n    function callOnExchange(\\n        uint exchangeIndex,\\n        string memory methodSignature,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    )\\n        public\\n        onlyInitialized\\n    {\\n        bytes4 methodSelector = bytes4(keccak256(bytes(methodSignature)));\\n        require(\\n            Registry(routes.registry).adapterMethodIsAllowed(\\n                exchanges[exchangeIndex].adapter,\\n                methodSelector\\n            ),\\n            \\\u0022Adapter method not allowed\\\u0022\\n        );\\n        PolicyManager(routes.policyManager).preValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\\n        if (\\n            methodSelector == MAKE_ORDER ||\\n            methodSelector == TAKE_ORDER\\n        ) {\\n            require(Registry(routes.registry).assetIsRegistered(\\n                orderAddresses[2]), \u0027Maker asset not registered\u0027\\n            );\\n            require(Registry(routes.registry).assetIsRegistered(\\n                orderAddresses[3]), \u0027Taker asset not registered\u0027\\n            );\\n            if (orderAddresses[6] != address(0) \u0026\u0026 methodSelector == MAKE_ORDER) {\\n                require(\\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[6]),\\n                    \u0027Maker fee asset not registered\u0027\\n                );\\n            }\\n            if (orderAddresses[7] != address(0) \u0026\u0026 methodSelector == TAKE_ORDER) {\\n                require(\\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[7]),\\n                    \u0027Taker fee asset not registered\u0027\\n                );\\n            }\\n        }\\n        (bool success, bytes memory returnData) = exchanges[exchangeIndex].adapter.delegatecall(\\n            abi.encodeWithSignature(\\n                methodSignature,\\n                exchanges[exchangeIndex].exchange,\\n                orderAddresses,\\n                orderValues,\\n                orderData,\\n                identifier,\\n                signature\\n            )\\n        );\\n        require(success, string(returnData));\\n        PolicyManager(routes.policyManager).postValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\\n        emit ExchangeMethodCall(\\n            exchanges[exchangeIndex].exchange,\\n            methodSignature,\\n            orderAddresses,\\n            orderValues,\\n            orderData,\\n            identifier,\\n            signature\\n        );\\n    }\\n\\n    /// @dev Make sure this is called after orderUpdateHook in adapters\\n    function addOpenMakeOrder(\\n        address ofExchange,\\n        address sellAsset,\\n        address buyAsset,\\n        address feeAsset,\\n        uint orderId,\\n        uint expirationTime\\n    ) public delegateInternal {\\n        require(!isInOpenMakeOrder[sellAsset], \\\u0022Asset already in open order\\\u0022);\\n        require(orders.length \u003E 0, \\\u0022No orders in array\\\u0022);\\n\\n        // If expirationTime is 0, actualExpirationTime is set to ORDER_LIFESPAN from now\\n        uint actualExpirationTime = (expirationTime == 0) ? add(block.timestamp, ORDER_LIFESPAN) : expirationTime;\\n\\n        require(\\n            actualExpirationTime \u003C= add(block.timestamp, ORDER_LIFESPAN) \u0026\u0026\\n            actualExpirationTime \u003E block.timestamp,\\n            \\\u0022Expiry time greater than max order lifespan or has already passed\\\u0022\\n        );\\n        isInOpenMakeOrder[sellAsset] = true;\\n        makerAssetCooldown[sellAsset] = add(actualExpirationTime, MAKE_ORDER_COOLDOWN);\\n        openMakeOrdersAgainstAsset[buyAsset] = add(openMakeOrdersAgainstAsset[buyAsset], 1);\\n        if (feeAsset != address(0)) {\\n            openMakeOrdersUsingAssetAsFee[feeAsset] = add(openMakeOrdersUsingAssetAsFee[feeAsset], 1);\\n        }\\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].id = orderId;\\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].expiresAt = actualExpirationTime;\\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].orderIndex = sub(orders.length, 1);\\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].buyAsset = buyAsset;\\n    }\\n\\n    function _removeOpenMakeOrder(\\n        address exchange,\\n        address sellAsset\\n    ) internal {\\n        if (isInOpenMakeOrder[sellAsset]) {\\n            makerAssetCooldown[sellAsset] = add(block.timestamp, MAKE_ORDER_COOLDOWN);\\n            address buyAsset = exchangesToOpenMakeOrders[exchange][sellAsset].buyAsset;\\n            address feeAsset = exchangesToOpenMakeOrders[exchange][sellAsset].feeAsset;\\n            delete exchangesToOpenMakeOrders[exchange][sellAsset];\\n            openMakeOrdersAgainstAsset[buyAsset] = sub(openMakeOrdersAgainstAsset[buyAsset], 1);\\n            if (feeAsset != address(0)) {\\n                openMakeOrdersUsingAssetAsFee[feeAsset] = sub(openMakeOrdersUsingAssetAsFee[feeAsset], 1);\\n            }\\n        }\\n    }\\n\\n    function removeOpenMakeOrder(\\n        address exchange,\\n        address sellAsset\\n    ) public delegateInternal {\\n        _removeOpenMakeOrder(exchange, sellAsset);\\n    }\\n\\n    /// @dev Bit of Redundancy for now\\n    function addZeroExV2OrderData(\\n        bytes32 orderId,\\n        IZeroExV2.Order memory zeroExOrderData\\n    ) public delegateInternal {\\n        orderIdToZeroExV2Order[orderId] = zeroExOrderData;\\n    }\\n    function addZeroExV3OrderData(\\n        bytes32 orderId,\\n        IZeroExV3.Order memory zeroExOrderData\\n    ) public delegateInternal {\\n        orderIdToZeroExV3Order[orderId] = zeroExOrderData;\\n    }\\n\\n    function orderUpdateHook(\\n        address ofExchange,\\n        bytes32 orderId,\\n        UpdateType updateType,\\n        address payable[2] memory orderAddresses,\\n        uint[3] memory orderValues\\n    ) public delegateInternal {\\n        // only save make/take\\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\\n            orders.push(Order({\\n                exchangeAddress: ofExchange,\\n                orderId: orderId,\\n                updateType: updateType,\\n                makerAsset: orderAddresses[0],\\n                takerAsset: orderAddresses[1],\\n                makerQuantity: orderValues[0],\\n                takerQuantity: orderValues[1],\\n                timestamp: block.timestamp,\\n                fillTakerQuantity: orderValues[2]\\n            }));\\n        }\\n    }\\n\\n    function updateAndGetQuantityBeingTraded(address _asset) external returns (uint) {\\n        uint quantityHere = IERC20(_asset).balanceOf(address(this));\\n        return add(updateAndGetQuantityHeldInExchange(_asset), quantityHere);\\n    }\\n\\n    function updateAndGetQuantityHeldInExchange(address ofAsset) public returns (uint) {\\n        uint totalSellQuantity; // quantity in custody across exchanges\\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\\n        for (uint i; i \u003C exchanges.length; i\u002B\u002B) {\\n            uint256 orderId = exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id;\\n            if (orderId == 0) {\\n                continue;\\n            }\\n            address sellAsset;\\n            uint remainingSellQuantity;\\n            (sellAsset, , remainingSellQuantity, ) =\\n                ExchangeAdapter(exchanges[i].adapter)\\n                .getOrder(\\n                    exchanges[i].exchange,\\n                    orderId,\\n                    ofAsset\\n                );\\n            if (remainingSellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\\n                _removeOpenMakeOrder(exchanges[i].exchange, ofAsset);\\n            }\\n            totalSellQuantity = add(totalSellQuantity, remainingSellQuantity);\\n            if (!exchanges[i].takesCustody) {\\n                totalSellQuantityInApprove \u002B= remainingSellQuantity;\\n            }\\n        }\\n        if (totalSellQuantity == 0) {\\n            isInOpenMakeOrder[ofAsset] = false;\\n        }\\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\\n    }\\n\\n    function returnBatchToVault(address[] calldata _tokens) external {\\n        for (uint i = 0; i \u003C _tokens.length; i\u002B\u002B) {\\n            returnAssetToVault(_tokens[i]);\\n        }\\n    }\\n\\n    function returnAssetToVault(address _token) public {\\n        require(\\n            msg.sender == address(this) ||\\n            msg.sender == hub.manager() ||\\n            hub.isShutDown()            ||\\n            (!isInOpenMakeOrder[_token] \u0026\u0026 openMakeOrdersUsingAssetAsFee[_token] == 0),\\n            \\\u0022returnAssetToVault: No return condition was met\\\u0022\\n        );\\n        safeTransfer(_token, routes.vault, IERC20(_token).balanceOf(address(this)));\\n    }\\n\\n    function getExchangeInfo() public view returns (address[] memory, address[] memory, bool[] memory) {\\n        address[] memory ofExchanges = new address[](exchanges.length);\\n        address[] memory ofAdapters = new address[](exchanges.length);\\n        bool[] memory takesCustody = new bool[](exchanges.length);\\n        for (uint i = 0; i \u003C exchanges.length; i\u002B\u002B) {\\n            ofExchanges[i] = exchanges[i].exchange;\\n            ofAdapters[i] = exchanges[i].adapter;\\n            takesCustody[i] = exchanges[i].takesCustody;\\n        }\\n        return (ofExchanges, ofAdapters, takesCustody);\\n    }\\n\\n    function getOpenOrderInfo(address ofExchange, address ofAsset) public view returns (uint, uint, uint) {\\n        OpenMakeOrder memory order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\\n        return (order.id, order.expiresAt, order.orderIndex);\\n    }\\n\\n    function isOrderExpired(address exchange, address asset) public view returns(bool) {\\n        return (\\n            exchangesToOpenMakeOrders[exchange][asset].expiresAt \u003C= block.timestamp \u0026\u0026\\n            exchangesToOpenMakeOrders[exchange][asset].expiresAt \u003E 0\\n        );\\n    }\\n\\n    function getOrderDetails(uint orderIndex) public view returns (address, address, uint, uint) {\\n        Order memory order = orders[orderIndex];\\n        return (order.makerAsset, order.takerAsset, order.makerQuantity, order.takerQuantity);\\n    }\\n\\n    function getZeroExV2OrderDetails(bytes32 orderId) public view returns (IZeroExV2.Order memory) {\\n        return orderIdToZeroExV2Order[orderId];\\n    }\\n\\n    function getZeroExV3OrderDetails(bytes32 orderId) public view returns (IZeroExV3.Order memory) {\\n        return orderIdToZeroExV3Order[orderId];\\n    }\\n\\n    function getOpenMakeOrdersAgainstAsset(address _asset) external view returns (uint256) {\\n        return openMakeOrdersAgainstAsset[_asset];\\n    }\\n}\\n\\ncontract TradingFactory is Factory {\\n    event NewInstance(\\n        address indexed hub,\\n        address indexed instance,\\n        address[] exchanges,\\n        address[] adapters,\\n        address registry\\n    );\\n\\n    function createInstance(\\n        address _hub,\\n        address[] memory _exchanges,\\n        address[] memory _adapters,\\n        address _registry\\n    ) public returns (address) {\\n        address trading = address(new Trading(_hub, _exchanges, _adapters, _registry));\\n        childExists[trading] = true;\\n        emit NewInstance(\\n            _hub,\\n            trading,\\n            _exchanges,\\n            _adapters,\\n            _registry\\n        );\\n        return trading;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/vault/IVault.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @notice Custody component\\ninterface IVault {\\n    function withdraw(address token, uint amount) external;\\n}\\n\\ninterface IVaultFactory {\\n    function createInstance(address _hub) external returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/fund/vault/Vault.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../hub/Spoke.sol\\\u0022;\\nimport \\\u0022../../factory/Factory.sol\\\u0022;\\nimport \\\u0022../../dependencies/TokenUser.sol\\\u0022;\\n\\n/// @notice Dumb custody component\\ncontract Vault is TokenUser, Spoke {\\n\\n    constructor(address _hub) public Spoke(_hub) {}\\n\\n    function withdraw(address token, uint amount) external auth {\\n        safeTransfer(token, msg.sender, amount);\\n    }\\n}\\n\\ncontract VaultFactory is Factory {\\n    function createInstance(address _hub) external returns (address) {\\n        address vault = address(new Vault(_hub));\\n        childExists[vault] = true;\\n        emit NewInstance(_hub, vault);\\n        return vault;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/prices/IPriceSource.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @notice Must return a value for an asset\\ninterface IPriceSource {\\n    function getQuoteAsset() external view returns (address);\\n    function getLastUpdate() external view returns (uint);\\n\\n    /// @notice Returns false if asset not applicable, or price not recent\\n    function hasValidPrice(address) external view returns (bool);\\n    function hasValidPrices(address[] calldata) external view returns (bool);\\n\\n    /// @notice Return the last known price, and when it was issued\\n    function getPrice(address _asset) external view returns (uint price, uint timestamp);\\n    function getPrices(address[] calldata _assets) external view returns (uint[] memory prices, uint[] memory timestamps);\\n\\n    /// @notice Get price info, and revert if not valid\\n    function getPriceInfo(address _asset) external view returns (uint price, uint decimals);\\n    function getInvertedPriceInfo(address ofAsset) external view returns (uint price, uint decimals);\\n\\n    function getReferencePriceInfo(address _base, address _quote) external view returns (uint referencePrice, uint decimal);\\n    function getOrderPriceInfo(address sellAsset, uint sellQuantity, uint buyQuantity) external view returns (uint orderPrice);\\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) external view returns (bool isExistent);\\n    function convertQuantity(\\n        uint fromAssetQuantity,\\n        address fromAsset,\\n        address toAsset\\n    ) external view returns (uint);\\n}\\n\u0022\r\n    },\r\n    \u0022./src/prices/KyberPriceFeed.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022../dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022../dependencies/DSAuth.sol\\\u0022; // TODO: remove? this may not be used at all\\nimport \\\u0022../exchanges/interfaces/IKyberNetworkProxy.sol\\\u0022;\\nimport \\\u0022../version/Registry.sol\\\u0022;\\n\\n/// @title Price Feed Template\\n/// @author Melonport AG \u003Cteam@melonport.com\u003E\\n/// @notice Routes external data to smart contracts\\n/// @notice Where external data includes sharePrice of Melon funds\\n/// @notice PriceFeed operator could be staked and sharePrice input validated on chain\\ncontract KyberPriceFeed is DSMath, DSAuth {\\n    event PriceUpdate(address[] token, uint[] price);\\n\\n    address public KYBER_NETWORK_PROXY;\\n    address public QUOTE_ASSET;\\n    address public UPDATER;\\n    Registry public REGISTRY;\\n    uint public MAX_SPREAD;\\n    address public constant KYBER_ETH_TOKEN = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\\n    uint public constant KYBER_PRECISION = 18;\\n    uint public constant VALIDITY_INTERVAL = 2 days;\\n    uint public lastUpdate;\\n\\n    // FIELDS\\n\\n    mapping (address =\u003E uint) public prices;\\n\\n    // METHODS\\n\\n    // CONSTRUCTOR\\n\\n    /// @dev Define and register a quote asset against which all prices are measured/based against\\n    constructor(\\n        address ofRegistry,\\n        address ofKyberNetworkProxy,\\n        uint ofMaxSpread,\\n        address ofQuoteAsset,\\n        address initialUpdater\\n    )\\n        public\\n    {\\n        KYBER_NETWORK_PROXY = ofKyberNetworkProxy;\\n        MAX_SPREAD = ofMaxSpread;\\n        QUOTE_ASSET = ofQuoteAsset;\\n        REGISTRY = Registry(ofRegistry);\\n        UPDATER = initialUpdater;\\n    }\\n\\n    /// @dev Stores zero as a convention for invalid price\\n    function update() external {\\n        require(\\n            msg.sender == REGISTRY.owner() || msg.sender == UPDATER,\\n            \\\u0022Only registry owner or updater can call\\\u0022\\n        );\\n        address[] memory assets = REGISTRY.getRegisteredAssets();\\n        uint[] memory newPrices = new uint[](assets.length);\\n        for (uint i; i \u003C assets.length; i\u002B\u002B) {\\n            bool isValid;\\n            uint price;\\n            if (assets[i] == QUOTE_ASSET) {\\n                isValid = true;\\n                price = 1 ether;\\n            } else {\\n                (isValid, price) = getKyberPrice(assets[i], QUOTE_ASSET);\\n            }\\n            newPrices[i] = isValid ? price : 0;\\n            prices[assets[i]] = newPrices[i];\\n        }\\n        lastUpdate = block.timestamp;\\n        emit PriceUpdate(assets, newPrices);\\n    }\\n\\n    function setUpdater(address _updater) external {\\n        require(msg.sender == REGISTRY.owner(), \\\u0022Only registry owner can set\\\u0022);\\n        UPDATER = _updater;\\n    }\\n\\n    /// @notice _maxSpread becomes a percentage when divided by 10^18\\n    /// @notice (e.g. 10^17 becomes 10%)\\n    function setMaxSpread(uint _maxSpread) external {\\n        require(msg.sender == REGISTRY.owner(), \\\u0022Only registry owner can set\\\u0022);\\n        MAX_SPREAD = _maxSpread;\\n    }\\n\\n    // PUBLIC VIEW METHODS\\n\\n    // FEED INFORMATION\\n\\n    function getQuoteAsset() public view returns (address) { return QUOTE_ASSET; }\\n\\n    // PRICES\\n\\n    /**\\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\\n    @dev Asset has been registered\\n    @param _asset Asset for which price should be returned\\n    @return price Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\\n    @return timestamp When the asset\u0027s price was updated\\n    }\\n    */\\n    function getPrice(address _asset)\\n        public\\n        view\\n        returns (uint price, uint timestamp)\\n    {\\n        (price, ) =  getReferencePriceInfo(_asset, QUOTE_ASSET);\\n        timestamp = now;\\n    }\\n\\n    function getPrices(address[] memory _assets)\\n        public\\n        view\\n        returns (uint256[] memory, uint256[] memory)\\n    {\\n        uint[] memory newPrices = new uint[](_assets.length);\\n        uint[] memory timestamps = new uint[](_assets.length);\\n        for (uint i; i \u003C _assets.length; i\u002B\u002B) {\\n            (newPrices[i], timestamps[i]) = getPrice(_assets[i]);\\n        }\\n        return (newPrices, timestamps);\\n    }\\n\\n    function hasValidPrice(address _asset)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        bool isRegistered = REGISTRY.assetIsRegistered(_asset);\\n        bool isFresh = block.timestamp \u003C add(lastUpdate, VALIDITY_INTERVAL);\\n        return prices[_asset] != 0 \u0026\u0026 isRegistered \u0026\u0026 isFresh;\\n    }\\n\\n    function hasValidPrices(address[] memory _assets)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        for (uint i; i \u003C _assets.length; i\u002B\u002B) {\\n            if (!hasValidPrice(_assets[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n    @param _baseAsset Address of base asset\\n    @param _quoteAsset Address of quote asset\\n    @return referencePrice Quantity of quoteAsset per whole baseAsset\\n    @return decimals Decimal places for quoteAsset\\n    }\\n    */\\n    function getReferencePriceInfo(address _baseAsset, address _quoteAsset)\\n        public\\n        view\\n        returns (uint referencePrice, uint decimals)\\n    {\\n        bool isValid;\\n        (\\n            isValid,\\n            referencePrice,\\n            decimals\\n        ) = getRawReferencePriceInfo(_baseAsset, _quoteAsset);\\n        require(isValid, \\\u0022Price is not valid\\\u0022);\\n        return (referencePrice, decimals);\\n    }\\n\\n    function getRawReferencePriceInfo(address _baseAsset, address _quoteAsset)\\n        public\\n        view\\n        returns (bool isValid, uint256 referencePrice, uint256 decimals)\\n    {\\n        isValid = hasValidPrice(_baseAsset) \u0026\u0026 hasValidPrice(_quoteAsset);\\n        uint256 quoteDecimals = ERC20WithFields(_quoteAsset).decimals();\\n\\n        if (prices[_quoteAsset] == 0) {\\n            return (false, 0, 0);  // return early and avoid revert\\n        }\\n\\n        referencePrice = mul(\\n            prices[_baseAsset],\\n            10 ** uint(quoteDecimals)\\n        ) / prices[_quoteAsset];\\n\\n        return (isValid, referencePrice, quoteDecimals);\\n    }\\n\\n    function getPriceInfo(address _asset)\\n        public\\n        view\\n        returns (uint256 price, uint256 assetDecimals)\\n    {\\n        return getReferencePriceInfo(_asset, QUOTE_ASSET);\\n    }\\n\\n    /**\\n    @notice Gets inverted price of an asset\\n    @dev Asset has been initialised and its price is non-zero\\n    @param _asset Asset for which inverted price should be return\\n    @return invertedPrice Price based (instead of quoted) against QUOTE_ASSET\\n    @return assetDecimals Decimal places for this asset\\n    }\\n    */\\n    function getInvertedPriceInfo(address _asset)\\n        public\\n        view\\n        returns (uint256 invertedPrice, uint256 assetDecimals)\\n    {\\n        return getReferencePriceInfo(QUOTE_ASSET, _asset);\\n    }\\n\\n    /// @dev Get Kyber representation of ETH if necessary\\n    function getKyberMaskAsset(address _asset) public view returns (address) {\\n        if (_asset == REGISTRY.nativeAsset()) {\\n            return KYBER_ETH_TOKEN;\\n        }\\n        return _asset;\\n    }\\n\\n    /// @notice Returns validity and price from Kyber\\n    function getKyberPrice(address _baseAsset, address _quoteAsset)\\n        public\\n        view\\n        returns (bool, uint)\\n    {\\n        uint bidRate;\\n        uint bidRateOfReversePair;\\n        (bidRate,) = IKyberNetworkProxy(KYBER_NETWORK_PROXY).getExpectedRate(\\n            getKyberMaskAsset(_baseAsset),\\n            getKyberMaskAsset(_quoteAsset),\\n            REGISTRY.getReserveMin(_baseAsset)\\n        );\\n        (bidRateOfReversePair,) = IKyberNetworkProxy(KYBER_NETWORK_PROXY).getExpectedRate(\\n            getKyberMaskAsset(_quoteAsset),\\n            getKyberMaskAsset(_baseAsset),\\n            REGISTRY.getReserveMin(_quoteAsset)\\n        );\\n\\n        if (bidRate == 0 || bidRateOfReversePair == 0) {\\n            return (false, 0);  // return early and avoid revert\\n        }\\n\\n        uint askRate = 10 ** (KYBER_PRECISION * 2) / bidRateOfReversePair;\\n        /**\\n          Average the bid/ask prices:\\n          avgPriceFromKyber = (bidRate \u002B askRate) / 2\\n          kyberPrice = (avgPriceFromKyber * 10^quoteDecimals) / 10^kyberPrecision\\n          or, rearranged:\\n          kyberPrice = ((bidRate \u002B askRate) * 10^quoteDecimals) / 2 * 10^kyberPrecision\\n        */\\n        uint kyberPrice = mul(\\n            add(bidRate, askRate),\\n            10 ** uint(ERC20WithFields(_quoteAsset).decimals()) // use original quote decimals (not defined on mask)\\n        ) / mul(2, 10 ** uint(KYBER_PRECISION));\\n\\n        // Find the \\\u0022quoted spread\\\u0022, to inform caller whether it is below maximum\\n        uint spreadFromKyber;\\n        if (bidRate \u003E askRate) {\\n            spreadFromKyber = 0; // crossed market condition\\n        } else {\\n            spreadFromKyber = mul(\\n                sub(askRate, bidRate),\\n                10 ** uint(KYBER_PRECISION)\\n            ) / askRate;\\n        }\\n\\n        return (\\n            spreadFromKyber \u003C= MAX_SPREAD \u0026\u0026 bidRate != 0 \u0026\u0026 askRate != 0,\\n            kyberPrice\\n        );\\n    }\\n\\n    /// @notice Gets price of Order\\n    /// @param sellAsset Address of the asset to be sold\\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\\n    /// @return orderPrice Price as determined by an order\\n    function getOrderPriceInfo(\\n        address sellAsset,\\n        uint sellQuantity,\\n        uint buyQuantity\\n    )\\n        public\\n        view\\n        returns (uint orderPrice)\\n    {\\n        // TODO: decimals\\n        return mul(buyQuantity, 10 ** uint(ERC20WithFields(sellAsset).decimals())) / sellQuantity;\\n    }\\n\\n    /// @notice Checks whether data exists for a given asset pair\\n    /// @dev Prices are only upated against QUOTE_ASSET\\n    /// @param sellAsset Asset for which check to be done if data exists\\n    /// @param buyAsset Asset for which check to be done if data exists\\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return\\n            hasValidPrice(sellAsset) \u0026\u0026 // Is tradable asset (TODO cleaner) and datafeed delivering data\\n            hasValidPrice(buyAsset);\\n    }\\n\\n    /// @notice Get quantity of toAsset equal in value to given quantity of fromAsset\\n    function convertQuantity(\\n        uint fromAssetQuantity,\\n        address fromAsset,\\n        address toAsset\\n    )\\n        public\\n        view\\n        returns (uint)\\n    {\\n        uint fromAssetPrice;\\n        (fromAssetPrice,) = getReferencePriceInfo(fromAsset, toAsset);\\n        uint fromAssetDecimals = ERC20WithFields(fromAsset).decimals();\\n        return mul(\\n            fromAssetQuantity,\\n            fromAssetPrice\\n        ) / (10 ** uint(fromAssetDecimals));\\n    }\\n\\n    function getLastUpdate() public view returns (uint) { return lastUpdate; }\\n}\\n\u0022\r\n    },\r\n    \u0022./src/version/IVersion.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ninterface IVersion {\\n    function shutDownFund(address) external;\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/version/Registry.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022../dependencies/DSAuth.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\nimport \\\u0022../dependencies/token/IERC20.sol\\\u0022;\\n\\ncontract Registry is DSAuth {\\n\\n    // EVENTS\\n    event AssetUpsert (\\n        address indexed asset,\\n        string name,\\n        string symbol,\\n        uint decimals,\\n        string url,\\n        uint reserveMin,\\n        uint[] standards,\\n        bytes4[] sigs\\n    );\\n\\n    event ExchangeAdapterUpsert (\\n        address indexed exchange,\\n        address indexed adapter,\\n        bool takesCustody,\\n        bytes4[] sigs\\n    );\\n\\n    event AssetRemoval (address indexed asset);\\n    event EfxWrapperRegistryChange(address indexed registry);\\n    event EngineChange(address indexed engine);\\n    event ExchangeAdapterRemoval (address indexed exchange);\\n    event IncentiveChange(uint incentiveAmount);\\n    event MGMChange(address indexed MGM);\\n    event MlnTokenChange(address indexed mlnToken);\\n    event NativeAssetChange(address indexed nativeAsset);\\n    event PriceSourceChange(address indexed priceSource);\\n    event VersionRegistration(address indexed version);\\n\\n    // TYPES\\n    struct Asset {\\n        bool exists;\\n        string name;\\n        string symbol;\\n        uint decimals;\\n        string url;\\n        uint reserveMin;\\n        uint[] standards;\\n        bytes4[] sigs;\\n    }\\n\\n    struct Exchange {\\n        bool exists;\\n        address exchangeAddress;\\n        bool takesCustody;\\n        bytes4[] sigs;\\n    }\\n\\n    struct Version {\\n        bool exists;\\n        bytes32 name;\\n    }\\n\\n    // CONSTANTS\\n    uint public constant MAX_REGISTERED_ENTITIES = 20;\\n    uint public constant MAX_FUND_NAME_BYTES = 66;\\n\\n    // FIELDS\\n    mapping (address =\u003E Asset) public assetInformation;\\n    address[] public registeredAssets;\\n\\n    // Mapping from adapter address to exchange Information (Adapters are unique)\\n    mapping (address =\u003E Exchange) public exchangeInformation;\\n    address[] public registeredExchangeAdapters;\\n\\n    mapping (address =\u003E Version) public versionInformation;\\n    address[] public registeredVersions;\\n\\n    mapping (address =\u003E bool) public isFeeRegistered;\\n\\n    mapping (address =\u003E address) public fundsToVersions;\\n    mapping (bytes32 =\u003E bool) public versionNameExists;\\n    mapping (bytes32 =\u003E address) public fundNameHashToOwner;\\n\\n\\n    uint public incentive = 10 finney;\\n    address public priceSource;\\n    address public mlnToken;\\n    address public nativeAsset;\\n    address public engine;\\n    address public ethfinexWrapperRegistry;\\n    address public MGM;\\n\\n    modifier onlyVersion() {\\n        require(\\n            versionInformation[msg.sender].exists,\\n            \\\u0022Only a Version can do this\\\u0022\\n        );\\n        _;\\n    }\\n\\n    // METHODS\\n\\n    constructor(address _postDeployOwner) public {\\n        setOwner(_postDeployOwner);\\n    }\\n\\n    // PUBLIC METHODS\\n\\n    /// @notice Whether _name has only valid characters\\n    function isValidFundName(string memory _name) public pure returns (bool) {\\n        bytes memory b = bytes(_name);\\n        if (b.length \u003E MAX_FUND_NAME_BYTES) return false;\\n        for (uint i; i \u003C b.length; i\u002B\u002B){\\n            bytes1 char = b[i];\\n            if(\\n                !(char \u003E= 0x30 \u0026\u0026 char \u003C= 0x39) \u0026\u0026 // 9-0\\n                !(char \u003E= 0x41 \u0026\u0026 char \u003C= 0x5A) \u0026\u0026 // A-Z\\n                !(char \u003E= 0x61 \u0026\u0026 char \u003C= 0x7A) \u0026\u0026 // a-z\\n                !(char == 0x20 || char == 0x2D) \u0026\u0026 // space, dash\\n                !(char == 0x2E || char == 0x5F) \u0026\u0026 // period, underscore\\n                !(char == 0x2A) // *\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Whether _user can use _name for their fund\\n    function canUseFundName(address _user, string memory _name) public view returns (bool) {\\n        bytes32 nameHash = keccak256(bytes(_name));\\n        return (\\n            isValidFundName(_name) \u0026\u0026\\n            (\\n                fundNameHashToOwner[nameHash] == address(0) ||\\n                fundNameHashToOwner[nameHash] == _user\\n            )\\n        );\\n    }\\n\\n    function reserveFundName(address _owner, string calldata _name)\\n        external\\n        onlyVersion\\n    {\\n        require(canUseFundName(_owner, _name), \\\u0022Fund name cannot be used\\\u0022);\\n        fundNameHashToOwner[keccak256(bytes(_name))] = _owner;\\n    }\\n\\n    function registerFund(address _fund, address _owner, string calldata _name)\\n        external\\n        onlyVersion\\n    {\\n        require(canUseFundName(_owner, _name), \\\u0022Fund name cannot be used\\\u0022);\\n        fundsToVersions[_fund] = msg.sender;\\n    }\\n\\n    /// @notice Registers an Asset information entry\\n    /// @dev Pre: Only registrar owner should be able to register\\n    /// @dev Post: Address _asset is registered\\n    /// @param _asset Address of asset to be registered\\n    /// @param _name Human-readable name of the Asset\\n    /// @param _symbol Human-readable symbol of the Asset\\n    /// @param _url Url for extended information of the asset\\n    /// @param _standards Integers of EIP standards this asset adheres to\\n    /// @param _sigs Function signatures for whitelisted asset functions\\n    function registerAsset(\\n        address _asset,\\n        string calldata _name,\\n        string calldata _symbol,\\n        string calldata _url,\\n        uint _reserveMin,\\n        uint[] calldata _standards,\\n        bytes4[] calldata _sigs\\n    ) external auth {\\n        require(registeredAssets.length \u003C MAX_REGISTERED_ENTITIES);\\n        require(!assetInformation[_asset].exists);\\n        assetInformation[_asset].exists = true;\\n        registeredAssets.push(_asset);\\n        updateAsset(\\n            _asset,\\n            _name,\\n            _symbol,\\n            _url,\\n            _reserveMin,\\n            _standards,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Register an exchange information entry (A mapping from exchange adapter -\u003E Exchange information)\\n    /// @dev Adapters are unique so are used as the mapping key. There may be different adapters for same exchange (0x / Ethfinex)\\n    /// @dev Pre: Only registrar owner should be able to register\\n    /// @dev Post: Address _exchange is registered\\n    /// @param _exchange Address of the exchange for the adapter\\n    /// @param _adapter Address of exchange adapter\\n    /// @param _takesCustody Whether this exchange takes custody of tokens before trading\\n    /// @param _sigs Function signatures for whitelisted exchange functions\\n    function registerExchangeAdapter(\\n        address _exchange,\\n        address _adapter,\\n        bool _takesCustody,\\n        bytes4[] calldata _sigs\\n    ) external auth {\\n        require(!exchangeInformation[_adapter].exists, \\\u0022Adapter already exists\\\u0022);\\n        exchangeInformation[_adapter].exists = true;\\n        require(registeredExchangeAdapters.length \u003C MAX_REGISTERED_ENTITIES, \\\u0022Exchange limit reached\\\u0022);\\n        registeredExchangeAdapters.push(_adapter);\\n        updateExchangeAdapter(\\n            _exchange,\\n            _adapter,\\n            _takesCustody,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Versions cannot be removed from registry\\n    /// @param _version Address of the version contract\\n    /// @param _name Name of the version\\n    function registerVersion(\\n        address _version,\\n        bytes32 _name\\n    ) external auth {\\n        require(!versionInformation[_version].exists, \\\u0022Version already exists\\\u0022);\\n        require(!versionNameExists[_name], \\\u0022Version name already exists\\\u0022);\\n        versionInformation[_version].exists = true;\\n        versionNameExists[_name] = true;\\n        versionInformation[_version].name = _name;\\n        registeredVersions.push(_version);\\n        emit VersionRegistration(_version);\\n    }\\n\\n    function setIncentive(uint _weiAmount) external auth {\\n        incentive = _weiAmount;\\n        emit IncentiveChange(_weiAmount);\\n    }\\n\\n    function setPriceSource(address _priceSource) external auth {\\n        priceSource = _priceSource;\\n        emit PriceSourceChange(_priceSource);\\n    }\\n\\n    function setMlnToken(address _mlnToken) external auth {\\n        mlnToken = _mlnToken;\\n        emit MlnTokenChange(_mlnToken);\\n    }\\n\\n    function setNativeAsset(address _nativeAsset) external auth {\\n        nativeAsset = _nativeAsset;\\n        emit NativeAssetChange(_nativeAsset);\\n    }\\n\\n    function setEngine(address _engine) external auth {\\n        engine = _engine;\\n        emit EngineChange(_engine);\\n    }\\n\\n    function setMGM(address _MGM) external auth {\\n        MGM = _MGM;\\n        emit MGMChange(_MGM);\\n    }\\n\\n    function setEthfinexWrapperRegistry(address _registry) external auth {\\n        ethfinexWrapperRegistry = _registry;\\n        emit EfxWrapperRegistryChange(_registry);\\n    }\\n\\n    /// @notice Updates description information of a registered Asset\\n    /// @dev Pre: Owner can change an existing entry\\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\\n    /// @param _asset Address of the asset to be updated\\n    /// @param _name Human-readable name of the Asset\\n    /// @param _symbol Human-readable symbol of the Asset\\n    /// @param _url Url for extended information of the asset\\n    function updateAsset(\\n        address _asset,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _url,\\n        uint _reserveMin,\\n        uint[] memory _standards,\\n        bytes4[] memory _sigs\\n    ) public auth {\\n        require(assetInformation[_asset].exists);\\n        Asset storage asset = assetInformation[_asset];\\n        asset.name = _name;\\n        asset.symbol = _symbol;\\n        asset.decimals = ERC20WithFields(_asset).decimals();\\n        asset.url = _url;\\n        asset.reserveMin = _reserveMin;\\n        asset.standards = _standards;\\n        asset.sigs = _sigs;\\n        emit AssetUpsert(\\n            _asset,\\n            _name,\\n            _symbol,\\n            asset.decimals,\\n            _url,\\n            _reserveMin,\\n            _standards,\\n            _sigs\\n        );\\n    }\\n\\n    function updateExchangeAdapter(\\n        address _exchange,\\n        address _adapter,\\n        bool _takesCustody,\\n        bytes4[] memory _sigs\\n    ) public auth {\\n        require(exchangeInformation[_adapter].exists, \\\u0022Exchange with adapter doesn\u0027t exist\\\u0022);\\n        Exchange storage exchange = exchangeInformation[_adapter];\\n        exchange.exchangeAddress = _exchange;\\n        exchange.takesCustody = _takesCustody;\\n        exchange.sigs = _sigs;\\n        emit ExchangeAdapterUpsert(\\n            _exchange,\\n            _adapter,\\n            _takesCustody,\\n            _sigs\\n        );\\n    }\\n\\n    /// @notice Deletes an existing entry\\n    /// @dev Owner can delete an existing entry\\n    /// @param _asset address for which specific information is requested\\n    function removeAsset(\\n        address _asset,\\n        uint _assetIndex\\n    ) external auth {\\n        require(assetInformation[_asset].exists);\\n        require(registeredAssets[_assetIndex] == _asset);\\n        delete assetInformation[_asset];\\n        delete registeredAssets[_assetIndex];\\n        for (uint i = _assetIndex; i \u003C registeredAssets.length-1; i\u002B\u002B) {\\n            registeredAssets[i] = registeredAssets[i\u002B1];\\n        }\\n        registeredAssets.pop();\\n        emit AssetRemoval(_asset);\\n    }\\n\\n    /// @notice Deletes an existing entry\\n    /// @dev Owner can delete an existing entry\\n    /// @param _adapter address of the adapter of the exchange that is to be removed\\n    /// @param _adapterIndex index of the exchange in array\\n    function removeExchangeAdapter(\\n        address _adapter,\\n        uint _adapterIndex\\n    ) external auth {\\n        require(exchangeInformation[_adapter].exists, \\\u0022Exchange with adapter doesn\u0027t exist\\\u0022);\\n        require(registeredExchangeAdapters[_adapterIndex] == _adapter, \\\u0022Incorrect adapter index\\\u0022);\\n        delete exchangeInformation[_adapter];\\n        delete registeredExchangeAdapters[_adapterIndex];\\n        for (uint i = _adapterIndex; i \u003C registeredExchangeAdapters.length-1; i\u002B\u002B) {\\n            registeredExchangeAdapters[i] = registeredExchangeAdapters[i\u002B1];\\n        }\\n        registeredExchangeAdapters.pop();\\n        emit ExchangeAdapterRemoval(_adapter);\\n    }\\n\\n    function registerFees(address[] calldata _fees) external auth {\\n        for (uint i; i \u003C _fees.length; i\u002B\u002B) {\\n            isFeeRegistered[_fees[i]] = true;\\n        }\\n    }\\n\\n    function deregisterFees(address[] calldata _fees) external auth {\\n        for (uint i; i \u003C _fees.length; i\u002B\u002B) {\\n            delete isFeeRegistered[_fees[i]];\\n        }\\n    }\\n\\n    // PUBLIC VIEW METHODS\\n\\n    // get asset specific information\\n    function getName(address _asset) external view returns (string memory) {\\n        return assetInformation[_asset].name;\\n    }\\n    function getSymbol(address _asset) external view returns (string memory) {\\n        return assetInformation[_asset].symbol;\\n    }\\n    function getDecimals(address _asset) external view returns (uint) {\\n        return assetInformation[_asset].decimals;\\n    }\\n    function getReserveMin(address _asset) external view returns (uint) {\\n        return assetInformation[_asset].reserveMin;\\n    }\\n    function assetIsRegistered(address _asset) external view returns (bool) {\\n        return assetInformation[_asset].exists;\\n    }\\n    function getRegisteredAssets() external view returns (address[] memory) {\\n        return registeredAssets;\\n    }\\n    function assetMethodIsAllowed(address _asset, bytes4 _sig)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        bytes4[] memory signatures = assetInformation[_asset].sigs;\\n        for (uint i = 0; i \u003C signatures.length; i\u002B\u002B) {\\n            if (signatures[i] == _sig) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // get exchange-specific information\\n    function exchangeAdapterIsRegistered(address _adapter) external view returns (bool) {\\n        return exchangeInformation[_adapter].exists;\\n    }\\n    function getRegisteredExchangeAdapters() external view returns (address[] memory) {\\n        return registeredExchangeAdapters;\\n    }\\n    function getExchangeInformation(address _adapter)\\n        public\\n        view\\n        returns (address, bool)\\n    {\\n        Exchange memory exchange = exchangeInformation[_adapter];\\n        return (\\n            exchange.exchangeAddress,\\n            exchange.takesCustody\\n        );\\n    }\\n    function exchangeForAdapter(address _adapter) external view returns (address) {\\n        Exchange memory exchange = exchangeInformation[_adapter];\\n        return exchange.exchangeAddress;\\n    }\\n    function getAdapterFunctionSignatures(address _adapter)\\n        public\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        return exchangeInformation[_adapter].sigs;\\n    }\\n    function adapterMethodIsAllowed(\\n        address _adapter, bytes4 _sig\\n    )\\n        external\\n        view\\n        returns (bool)\\n    {\\n        bytes4[] memory signatures = exchangeInformation[_adapter].sigs;\\n        for (uint i = 0; i \u003C signatures.length; i\u002B\u002B) {\\n            if (signatures[i] == _sig) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // get version and fund information\\n    function getRegisteredVersions() external view returns (address[] memory) {\\n        return registeredVersions;\\n    }\\n\\n    function isFund(address _who) external view returns (bool) {\\n        if (fundsToVersions[_who] != address(0)) {\\n            return true; // directly from a hub\\n        } else {\\n            Hub hub = Hub(Spoke(_who).hub());\\n            require(\\n                hub.isSpoke(_who),\\n                \\\u0022Call from either a spoke or hub\\\u0022\\n            );\\n            return fundsToVersions[address(hub)] != address(0);\\n        }\\n    }\\n\\n    function isFundFactory(address _who) external view returns (bool) {\\n        return versionInformation[_who].exists;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./src/version/Version.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022../factory/FundFactory.sol\\\u0022;\\nimport \\\u0022../fund/hub/Hub.sol\\\u0022;\\n\\n/// @notice Controlled by governance\\ncontract Version is FundFactory, DSAuth {\\n\\n    constructor(\\n        address _accountingFactory,\\n        address _feeManagerFactory,\\n        address _participationFactory,\\n        address _sharesFactory,\\n        address _tradingFactory,\\n        address _vaultFactory,\\n        address _policyManagerFactory,\\n        address _registry,\\n        address _postDeployOwner\\n    )\\n        public\\n        FundFactory(\\n            _accountingFactory,\\n            _feeManagerFactory,\\n            _participationFactory,\\n            _sharesFactory,\\n            _tradingFactory,\\n            _vaultFactory,\\n            _policyManagerFactory,\\n            address(this)\\n        )\\n    {\\n        associatedRegistry = Registry(_registry);\\n        setOwner(_postDeployOwner);\\n    }\\n\\n    function shutDownFund(address _hub) external {\\n        require(\\n            managersToHubs[msg.sender] == _hub,\\n            \\\u0022Conditions not met for fund shutdown\\\u0022\\n        );\\n        Hub(_hub).shutDownFund();\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/BooleanPolicy.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ncontract BooleanPolicy {\\n    enum Applied { pre, post }\\n\\n    bool allowed;\\n\\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\\n        return allowed;\\n    }\\n\\n    function position() external pure returns (Applied) { return Applied.pre; }\\n}\\n\\ncontract TruePolicy is BooleanPolicy {\\n    constructor() public { allowed = true; }\\n    function identifier() external pure returns (string memory) { return \\\u0022TruePolicy\\\u0022; }\\n}\\n\\ncontract FalsePolicy is BooleanPolicy {\\n    constructor() public { allowed = false; }\\n    function identifier() external pure returns (string memory) { return \\\u0022FalsePolicy\\\u0022; }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MaliciousToken.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/dependencies/token/PreminedToken.sol\\\u0022;\\n\\ncontract MaliciousToken is PreminedToken {\\n\\n    bool public isReverting = false;\\n\\n    constructor(string memory _symbol, uint8 _decimals, string memory _name)\\n        public\\n        PreminedToken(_symbol, _decimals, _name)\\n    {}\\n\\n    function startReverting() public {\\n        isReverting = true;\\n    }\\n\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(!isReverting, \\\u0022I\u0027m afraid I can\u0027t do that, Dave\\\u0022);\\n        super.transfer(_to, _value);\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(!isReverting, \\\u0022I\u0027m afraid I can\u0027t do that, Dave\\\u0022);\\n        super.transferFrom(_from, _to, _value);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockAccounting.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/fund/hub/Spoke.sol\\\u0022;\\n\\n/// @dev Balances are fake and can be set by anyone (testing)\\ncontract MockAccounting is Spoke {\\n\\n    uint public gav;\\n    uint public nav;\\n    uint public unclaimedFees;\\n    uint public mockValuePerShare;\\n\\n    address[] public ownedAssets;\\n    mapping (address =\u003E bool) public isInAssetList;\\n    mapping (address =\u003E uint) public held; // mock total held across all components\\n    mapping (address =\u003E uint) public assetGav;\\n    address public DENOMINATION_ASSET;\\n    address public NATIVE_ASSET;\\n    uint public DEFAULT_SHARE_PRICE;\\n    uint public SHARES_DECIMALS;\\n\\n    constructor(address _hub, address _denominationAsset, address _nativeAsset)\\n        public\\n        Spoke(_hub)\\n    {\\n        DENOMINATION_ASSET = _denominationAsset;\\n        NATIVE_ASSET = _nativeAsset;\\n        SHARES_DECIMALS = 18;\\n        DEFAULT_SHARE_PRICE = 10 ** uint(SHARES_DECIMALS);\\n    }\\n\\n    function setOwnedAssets(address[] memory _assets) public { ownedAssets = _assets; }\\n    function getOwnedAssetsLength() public view returns (uint) { return ownedAssets.length; }\\n    function setGav(uint _gav) public { gav = _gav; }\\n    function setNav(uint _nav) public { nav = _nav; }\\n    function setAssetGAV(address _asset, uint _amt) public { assetGav[_asset] = _amt; }\\n    function setFundHoldings(uint[] memory _amounts, address[] memory _assets) public {\\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\\n            held[_assets[i]] = _amounts[i];\\n        }\\n    }\\n\\n    function getFundHoldings() public view returns (uint[] memory, address[] memory) {\\n        uint[] memory _quantities = new uint[](ownedAssets.length);\\n        address[] memory _assets = new address[](ownedAssets.length);\\n        for (uint i = 0; i \u003C ownedAssets.length; i\u002B\u002B) {\\n            address ofAsset = ownedAssets[i];\\n            // holdings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\\n            uint quantityHeld = held[ofAsset];\\n\\n            if (quantityHeld != 0) {\\n                _assets[i] = ofAsset;\\n                _quantities[i] = quantityHeld;\\n            }\\n        }\\n        return (_quantities, _assets);\\n    }\\n\\n    function calcGav() public view returns (uint) { return gav; }\\n    function calcNav() public view returns (uint) { return nav; }\\n\\n    function calcAssetGAV(address _a) public view returns (uint) { return assetGav[_a]; }\\n\\n    function valuePerShare(uint totalValue, uint numShares) public view returns (uint) {\\n        return mockValuePerShare;\\n    }\\n\\n    function performCalculations() public view returns (uint, uint, uint, uint, uint) {\\n        return (gav, unclaimedFees, 0, nav, mockValuePerShare);\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockAdapter.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022main/fund/trading/Trading.sol\\\u0022;\\nimport \\\u0022main/fund/accounting/Accounting.sol\\\u0022;\\nimport \\\u0022main/exchanges/ExchangeAdapter.sol\\\u0022;\\n\\ncontract MockAdapter is ExchangeAdapter {\\n\\n    //  METHODS\\n\\n    //  PUBLIC METHODS\\n\\n    /// @notice Mock make order\\n    function makeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override {\\n        address makerAsset = orderAddresses[2];\\n        address takerAsset = orderAddresses[3];\\n        uint makerQuantity = orderValues[0];\\n        uint takerQuantity = orderValues[1];\\n\\n        approveAsset(makerAsset, targetExchange, makerQuantity, \\\u0022makerAsset\\\u0022);\\n\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            identifier,\\n            Trading.UpdateType.make,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [makerQuantity, takerQuantity, uint(0)]\\n        );\\n        getTrading().addOpenMakeOrder(targetExchange, makerAsset, takerAsset, address(0), uint(identifier), 0);\\n    }\\n\\n    /// @notice Mock take order\\n    function takeOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override {\\n        address makerAsset = orderAddresses[2];\\n        address takerAsset = orderAddresses[3];\\n        uint makerQuantity = orderValues[0];\\n        uint takerQuantity = orderValues[1];\\n        uint fillTakerQuantity = orderValues[6];\\n\\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \\\u0022takerAsset\\\u0022);\\n\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(identifier),\\n            Trading.UpdateType.take,\\n            [payable(makerAsset), payable(takerAsset)],\\n            [makerQuantity, takerQuantity, fillTakerQuantity]\\n        );\\n    }\\n\\n    /// @notice Mock cancel order\\n    function cancelOrder(\\n        address targetExchange,\\n        address[8] memory orderAddresses,\\n        uint[8] memory orderValues,\\n        bytes[4] memory orderData,\\n        bytes32 identifier,\\n        bytes memory signature\\n    ) public override {\\n        address makerAsset = orderAddresses[2];\\n        uint makerQuantity = orderValues[0];\\n\\n        revokeApproveAsset(makerAsset, targetExchange, makerQuantity, \\\u0022makerAsset\\\u0022);\\n\\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\\n        getTrading().orderUpdateHook(\\n            targetExchange,\\n            bytes32(identifier),\\n            Trading.UpdateType.cancel,\\n            [address(0), address(0)],\\n            [uint(0), uint(0), uint(0)]\\n        );\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockFee.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\ncontract MockFee {\\n\\n    uint public fee;\\n    uint public FEE_RATE;\\n    uint public FEE_PERIOD;\\n    uint public feeNumber;\\n\\n    constructor(uint _feeNumber) public {\\n        feeNumber = _feeNumber;\\n    }\\n\\n    function setFeeAmount(uint amount) public {\\n        fee = amount;\\n    }\\n\\n    function feeAmount() external returns (uint feeInShares) {\\n        return fee;\\n    }\\n\\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\\n        fee = 0;\\n        FEE_RATE = feeRate;\\n        FEE_PERIOD = feePeriod;\\n    }\\n\\n    function updateState() external {\\n        fee = 0;\\n    }\\n\\n    function identifier() external view returns (uint) {\\n        return feeNumber;\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockFeeManager.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\u0022main/fund/hub/Spoke.sol\\\u0022;\\nimport \\\u0022main/fund/shares/Shares.sol\\\u0022;\\nimport \\\u0022main/factory/Factory.sol\\\u0022;\\nimport \\\u0022main/dependencies/DSMath.sol\\\u0022;\\nimport \\\u0022main/engine/AmguConsumer.sol\\\u0022;\\n\\ncontract MockFeeManager is DSMath, Spoke, AmguConsumer {\\n\\n    struct FeeInfo {\\n        address feeAddress;\\n        uint feeRate;\\n        uint feePeriod;\\n    }\\n\\n    uint totalFees;\\n    uint performanceFees;\\n\\n    constructor(\\n        address _hub,\\n        address _denominationAsset,\\n        address[] memory _fees,\\n        uint[] memory _periods,\\n        uint _rates,\\n        address registry\\n    ) Spoke(_hub) public {}\\n\\n    function setTotalFeeAmount(uint _amt) public { totalFees = _amt; }\\n    function setPerformanceFeeAmount(uint _amt) public { performanceFees = _amt; }\\n\\n    function rewardManagementFee() public { return; }\\n    function performanceFeeAmount() external returns (uint) { return performanceFees; }\\n    function totalFeeAmount() external returns (uint) { return totalFees; }\\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return routes.engine; }\\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return routes.mlnToken; }\\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return hub.priceSource(); }\\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return routes.registry; }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockHub.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/dependencies/DSGuard.sol\\\u0022;\\nimport \\\u0022main/fund/hub/Spoke.sol\\\u0022;\\nimport \\\u0022main/version/Registry.sol\\\u0022;\\n\\n/// @notice Hub used for testing\\ncontract MockHub is DSGuard {\\n\\n    struct Routes {\\n        address accounting;\\n        address feeManager;\\n        address participation;\\n        address policyManager;\\n        address shares;\\n        address trading;\\n        address vault;\\n        address registry;\\n        address version;\\n        address engine;\\n        address mlnAddress;\\n    }\\n    Routes public routes;\\n    address public manager;\\n    string public name;\\n    bool public isShutDown;\\n\\n    function setManager(address _manager) public { manager = _manager; }\\n\\n    function setName(string memory _name) public { name = _name; }\\n\\n    function shutDownFund() public { isShutDown = true; }\\n\\n    function setShutDownState(bool _state) public { isShutDown = _state; }\\n\\n    function setSpokes(address[11] memory _spokes) public {\\n        routes.accounting = _spokes[0];\\n        routes.feeManager = _spokes[1];\\n        routes.participation = _spokes[2];\\n        routes.policyManager = _spokes[3];\\n        routes.shares = _spokes[4];\\n        routes.trading = _spokes[5];\\n        routes.vault = _spokes[6];\\n        routes.registry = _spokes[7];\\n        routes.version = _spokes[8];\\n        routes.engine = _spokes[9];\\n        routes.mlnAddress = _spokes[10];\\n    }\\n\\n    function setRouting() public {\\n        address[11] memory spokes = [\\n            routes.accounting, routes.feeManager, routes.participation,\\n            routes.policyManager, routes.shares, routes.trading,\\n            routes.vault, routes.registry, routes.version,\\n            routes.engine, routes.mlnAddress\\n        ];\\n        Spoke(routes.accounting).initialize(spokes);\\n        Spoke(routes.feeManager).initialize(spokes);\\n        Spoke(routes.participation).initialize(spokes);\\n        Spoke(routes.policyManager).initialize(spokes);\\n        Spoke(routes.shares).initialize(spokes);\\n        Spoke(routes.trading).initialize(spokes);\\n        Spoke(routes.vault).initialize(spokes);\\n    }\\n\\n    function setPermissions() public {\\n        permit(routes.participation, routes.vault, bytes4(keccak256(\u0027withdraw(address,uint256)\u0027)));\\n        permit(routes.trading, routes.vault, bytes4(keccak256(\u0027withdraw(address,uint256)\u0027)));\\n        permit(routes.participation, routes.shares, bytes4(keccak256(\u0027createFor(address,uint256)\u0027)));\\n        permit(routes.participation, routes.shares, bytes4(keccak256(\u0027destroyFor(address,uint256)\u0027)));\\n        permit(routes.feeManager, routes.shares, bytes4(keccak256(\u0027createFor(address,uint256)\u0027)));\\n        permit(routes.participation, routes.accounting, bytes4(keccak256(\u0027addAssetToOwnedAssets(address)\u0027)));\\n        permit(routes.participation, routes.accounting, bytes4(keccak256(\u0027removeFromOwnedAssets(address)\u0027)));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256(\u0027addAssetToOwnedAssets(address)\u0027)));\\n        permit(routes.trading, routes.accounting, bytes4(keccak256(\u0027removeFromOwnedAssets(address)\u0027)));\\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256(\u0027rewardAllFees()\u0027)));\\n        permit(manager, routes.feeManager, bytes4(keccak256(\u0027register(address)\u0027)));\\n        permit(manager, routes.feeManager, bytes4(keccak256(\u0027batchRegister(address[])\u0027)));\\n        permit(manager, routes.policyManager, bytes4(keccak256(\u0027register(bytes4,address)\u0027)));\\n        permit(manager, routes.policyManager, bytes4(keccak256(\u0027batchRegister(bytes4[],address[])\u0027)));\\n        permit(manager, routes.participation, bytes4(keccak256(\u0027enableInvestment(address[])\u0027)));\\n        permit(manager, routes.participation, bytes4(keccak256(\u0027disableInvestment(address[])\u0027)));\\n        permit(bytes32(bytes20(msg.sender)), ANY, ANY);\\n    }\\n\\n    function permitSomething(address _from, address _to, bytes4 _sig) public {\\n        permit(\\n            bytes32(bytes20(_from)),\\n            bytes32(bytes20(_to)),\\n            _sig\\n        );\\n    }\\n\\n    function initializeSpoke(address _spoke) public {\\n        address[11] memory spokes = [\\n            routes.accounting, routes.feeManager, routes.participation,\\n            routes.policyManager, routes.shares, routes.trading,\\n            routes.vault, routes.registry, routes.version,\\n            routes.engine, routes.mlnAddress\\n        ];\\n        Spoke(_spoke).initialize(spokes);\\n    }\\n\\n    function vault() public view returns (address) { return routes.vault; }\\n    function accounting() public view returns (address) { return routes.accounting; }\\n    function priceSource() public view returns (address) { return Registry(routes.registry).priceSource(); }\\n    function participation() public view returns (address) { return routes.participation; }\\n    function trading() public view returns (address) { return routes.trading; }\\n    function shares() public view returns (address) { return routes.shares; }\\n    function policyManager() public view returns (address) { return routes.policyManager; }\\n    function registry() public view returns (address) { return routes.registry; }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockRegistry.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/dependencies/DSAuth.sol\\\u0022;\\n\\n/// @dev Simplified for testing, and by default rigged to always return true\\ncontract MockRegistry is DSAuth {\\n\\n    bool public alwaysRegistered = true;\\n    bool public methodAllowed = true;\\n\\n    address public priceSource;\\n    address public mlnToken;\\n    address public nativeAsset;\\n    address public engine;\\n    address public fundFactory;\\n    address[] public assets;\\n    uint public incentive;\\n    mapping (address =\u003E bool) public registered;\\n    mapping (address =\u003E bool) public fundExists;\\n    mapping (address =\u003E address) public exchangeForAdapter;\\n    mapping (address =\u003E bool) public takesCustodyForAdapter;\\n\\n\\n    function register(address _addr) public {\\n        registered[_addr] = true;\\n        assets.push(_addr);\\n    }\\n\\n    function remove(address _addr) public {\\n        delete registered[_addr];\\n    }\\n\\n    function assetIsRegistered(address _asset) public view returns (bool) {\\n        return alwaysRegistered || registered[_asset];\\n    }\\n\\n    function exchangeAdapterIsRegistered(address _adapter) public view returns (bool) {\\n        return alwaysRegistered || registered[_adapter];\\n    }\\n\\n    function registerExchangeAdapter(\\n        address _exchange,\\n        address _adapter\\n    ) public {\\n        exchangeForAdapter[_adapter] = _exchange;\\n        takesCustodyForAdapter[_adapter] = true;\\n    }\\n\\n    function adapterMethodIsAllowed(\\n        address _adapter,\\n        bytes4 _sig\\n    ) public view returns (bool) { return methodAllowed; }\\n\\n    function setPriceSource(address _a) public { priceSource = _a; }\\n    function setMlnToken(address _a) public { mlnToken = _a; }\\n    function setNativeAsset(address _a) public { nativeAsset = _a; }\\n    function setEngine(address _a) public { engine = _a; }\\n    function setFundFactory(address _a) public { fundFactory = _a; }\\n    function setIsFund(address _who) public { fundExists[_who] = true; }\\n\\n    function isFund(address _who) public view returns (bool) { return fundExists[_who]; }\\n    function isFundFactory(address _who) public view returns (bool) {\\n        return _who == fundFactory;\\n    }\\n    function getRegisteredAssets() public view returns (address[] memory) { return assets; }\\n    function getReserveMin(address _asset) public view returns (uint) { return 0; }\\n    function isFeeRegistered(address _fee) public view returns (bool) {\\n        return alwaysRegistered;\\n    }\\n    function getExchangeInformation(address _adapter)\\n        public\\n        view\\n        returns (address, bool)\\n    {\\n        return (\\n            exchangeForAdapter[_adapter],\\n            takesCustodyForAdapter[_adapter]\\n        );\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockShares.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/fund/hub/Spoke.sol\\\u0022;\\nimport \\\u0022main/dependencies/token/StandardToken.sol\\\u0022;\\n\\n/// @dev Shares can be destroyed and created by anyone (testing)\\ncontract MockShares is Spoke, StandardToken {\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n\\n    constructor(address _hub) public Spoke(_hub) {\\n        name = hub.name();\\n        symbol = \\\u0022MOCK\\\u0022;\\n        decimals = 18;\\n    }\\n\\n    function createFor(address who, uint amount) public {\\n        _mint(who, amount);\\n    }\\n\\n    function destroyFor(address who, uint amount) public {\\n        _burn(who, amount);\\n    }\\n\\n    function setBalanceFor(address who, uint newBalance) public {\\n        uint currentBalance = balances[who];\\n        if (currentBalance \u003E newBalance) {\\n            destroyFor(who, currentBalance.sub(newBalance));\\n        } else if (balances[who] \u003C newBalance) {\\n            createFor(who, newBalance.sub(currentBalance));\\n        }\\n    }\\n}\\n\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/MockVersion.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/fund/hub/Hub.sol\\\u0022;\\n\\n/// @notice Version contract useful for testing\\ncontract MockVersion {\\n    uint public amguPrice;\\n    bool public isShutDown;\\n\\n    function setAmguPrice(uint _price) public { amguPrice = _price; }\\n    function securityShutDown() external { isShutDown = true; }\\n    function shutDownFund(address _hub) external { Hub(_hub).shutDownFund(); }\\n    function getShutDownStatus() external view returns (bool) {return isShutDown;}\\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/PermissiveAuthority.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/dependencies/DSAuth.sol\\\u0022;\\n\\ncontract PermissiveAuthority is DSAuthority {\\n    function canCall(address src, address dst, bytes4 sig)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return true;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/SelfDestructing.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\n/// @dev Useful for testing force-sending of funds\\ncontract SelfDestructing {\\n    function bequeath(address payable _heir) public {\\n        selfdestruct(_heir);\\n    }\\n\\n    receive() external payable {}\\n}\\n\u0022\r\n    },\r\n    \u0022./tests/contracts/TestingPriceFeed.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity 0.6.1;\\n\\nimport \\\u0022main/dependencies/token/IERC20.sol\\\u0022;\\nimport \\\u0022main/dependencies/DSMath.sol\\\u0022;\\n\\n/// @notice Intended for testing purposes only\\n/// @notice Updates and exposes price information\\ncontract TestingPriceFeed is DSMath {\\n    event PriceUpdate(address[] token, uint[] price);\\n\\n    struct Data {\\n        uint price;\\n        uint timestamp;\\n    }\\n\\n    address public QUOTE_ASSET;\\n    uint public updateId;\\n    uint public lastUpdate;\\n    mapping(address =\u003E Data) public assetsToPrices;\\n    mapping(address =\u003E uint) public assetsToDecimals;\\n    bool mockIsRecent = true;\\n    bool neverValid = false;\\n\\n    constructor(address _quoteAsset, uint _quoteDecimals) public {\\n        QUOTE_ASSET = _quoteAsset;\\n        setDecimals(_quoteAsset, _quoteDecimals);\\n    }\\n\\n    /**\\n      Input price is how much quote asset you would get\\n      for one unit of _asset (10**assetDecimals)\\n     */\\n    function update(address[] calldata _assets, uint[] calldata _prices) external {\\n        require(_assets.length == _prices.length, \\\u0022Array lengths unequal\\\u0022);\\n        updateId\u002B\u002B;\\n        for (uint i = 0; i \u003C _assets.length; \u002B\u002Bi) {\\n            assetsToPrices[_assets[i]] = Data({\\n                timestamp: block.timestamp,\\n                price: _prices[i]\\n            });\\n        }\\n        lastUpdate = block.timestamp;\\n        emit PriceUpdate(_assets, _prices);\\n    }\\n\\n    function getPrice(address ofAsset)\\n        public\\n        view\\n        returns (uint price, uint timestamp)\\n    {\\n        Data storage data = assetsToPrices[ofAsset];\\n        return (data.price, data.timestamp);\\n    }\\n\\n    function getPrices(address[] memory ofAssets)\\n        public\\n        view\\n        returns (uint[] memory, uint[] memory)\\n    {\\n        uint[] memory prices = new uint[](ofAssets.length);\\n        uint[] memory timestamps = new uint[](ofAssets.length);\\n        for (uint i; i \u003C ofAssets.length; i\u002B\u002B) {\\n            uint price;\\n            uint timestamp;\\n            (price, timestamp) = getPrice(ofAssets[i]);\\n            prices[i] = price;\\n            timestamps[i] = timestamp;\\n        }\\n        return (prices, timestamps);\\n    }\\n\\n    function getPriceInfo(address ofAsset)\\n        public\\n        view\\n        returns (uint price, uint assetDecimals)\\n    {\\n        (price, ) = getPrice(ofAsset);\\n        assetDecimals = assetsToDecimals[ofAsset];\\n    }\\n\\n    function getInvertedPriceInfo(address ofAsset)\\n        public\\n        view\\n        returns (uint invertedPrice, uint assetDecimals)\\n    {\\n        uint inputPrice;\\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\\n        (inputPrice, assetDecimals) = getPriceInfo(ofAsset);\\n\\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\\n        uint quoteDecimals = assetsToDecimals[QUOTE_ASSET];\\n\\n        return (\\n            mul(\\n                10 ** uint(quoteDecimals),\\n                10 ** uint(assetDecimals)\\n            ) / inputPrice,\\n            quoteDecimals\\n        );\\n    }\\n\\n    function setNeverValid(bool _state) public {\\n        neverValid = _state;\\n    }\\n\\n    function setIsRecent(bool _state) public {\\n        mockIsRecent = _state;\\n    }\\n\\n    // NB: not permissioned; anyone can change this in a test\\n    function setDecimals(address _asset, uint _decimal) public {\\n        assetsToDecimals[_asset] = _decimal;\\n    }\\n\\n    // needed just to get decimals for prices\\n    function batchSetDecimals(address[] memory _assets, uint[] memory _decimals) public {\\n        require(_assets.length == _decimals.length, \\\u0022Array lengths unequal\\\u0022);\\n        for (uint i = 0; i \u003C _assets.length; i\u002B\u002B) {\\n            setDecimals(_assets[i], _decimals[i]);\\n        }\\n    }\\n\\n    function getReferencePriceInfo(address ofBase, address ofQuote)\\n        public\\n        view\\n        returns (uint referencePrice, uint decimal)\\n    {\\n        uint quoteDecimals = assetsToDecimals[ofQuote];\\n\\n        bool bothValid = hasValidPrice(ofBase) \u0026\u0026 hasValidPrice(ofQuote);\\n        require(bothValid, \\\u0022Price not valid\\\u0022);\\n        // Price of 1 unit for the pair of same asset\\n        if (ofBase == ofQuote) {\\n            return (10 ** uint(quoteDecimals), quoteDecimals);\\n        }\\n\\n        referencePrice = mul(\\n            assetsToPrices[ofBase].price,\\n            10 ** uint(quoteDecimals)\\n        ) / assetsToPrices[ofQuote].price;\\n\\n        return (referencePrice, quoteDecimals);\\n    }\\n\\n    function getOrderPriceInfo(\\n        address sellAsset,\\n        uint sellQuantity,\\n        uint buyQuantity\\n    )\\n        public\\n        view\\n        returns (uint orderPrice)\\n    {\\n        return mul(buyQuantity, 10 ** uint(assetsToDecimals[sellAsset])) / sellQuantity;\\n    }\\n\\n    /// @notice Doesn\u0027t check validity as TestingPriceFeed has no validity variable\\n    /// @param _asset Asset in registrar\\n    /// @return isValid Price information ofAsset is recent\\n    function hasValidPrice(address _asset)\\n        public\\n        view\\n        returns (bool isValid)\\n    {\\n        uint price;\\n        (price, ) = getPrice(_asset);\\n\\n        return !neverValid \u0026\u0026 price != 0;\\n    }\\n\\n    function hasValidPrices(address[] memory _assets)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        for (uint i; i \u003C _assets.length; i\u002B\u002B) {\\n            if (!hasValidPrice(_assets[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Checks whether data exists for a given asset pair\\n    /// @dev Prices are only upated against QUOTE_ASSET\\n    /// @param sellAsset Asset for which check to be done if data exists\\n    /// @param buyAsset Asset for which check to be done if data exists\\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\\n        public\\n        view\\n        returns (bool isExistent)\\n    {\\n        return\\n            hasValidPrice(sellAsset) \u0026\u0026\\n            hasValidPrice(buyAsset);\\n    }\\n\\n    function getLastUpdateId() public view returns (uint) { return updateId; }\\n    function getQuoteAsset() public view returns (address) { return QUOTE_ASSET; }\\n\\n    /// @notice Get quantity of toAsset equal in value to given quantity of fromAsset\\n    function convertQuantity(\\n        uint fromAssetQuantity,\\n        address fromAsset,\\n        address toAsset\\n    )\\n        public\\n        view\\n        returns (uint)\\n    {\\n        uint fromAssetPrice;\\n        (fromAssetPrice,) = getReferencePriceInfo(fromAsset, toAsset);\\n        uint fromAssetDecimals = ERC20WithFields(fromAsset).decimals();\\n        return mul(\\n            fromAssetQuantity,\\n            fromAssetPrice\\n        ) / (10 ** uint(fromAssetDecimals));\\n    }\\n\\n    function getLastUpdate() public view returns (uint) { return lastUpdate; }\\n}\\n\\n\u0022\r\n    }\r\n  }\r\n}}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022_preApproved\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ListAddition\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022who\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022ListRemoval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022authority\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetAuthority\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022LogSetOwner\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_who\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addToWhitelist\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022authority\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022_members\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022batchAddToWhitelist\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022_members\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022batchRemoveFromWhitelist\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022identifier\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022name\u0022:\u0022position\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022enum UserWhitelist.Applied\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022_who\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeFromWhitelist\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022sig\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022internalType\u0022:\u0022address[5]\u0022,\u0022name\u0022:\u0022addresses\u0022,\u0022type\u0022:\u0022address[5]\u0022},{\u0022internalType\u0022:\u0022uint256[3]\u0022,\u0022name\u0022:\u0022values\u0022,\u0022type\u0022:\u0022uint256[3]\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022identifier\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022rule\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract DSAuthority\u0022,\u0022name\u0022:\u0022authority_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setAuthority\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setOwner\u0022,\u0022outputs\u0022:[],\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022whitelisted\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"UserWhitelist","CompilerVersion":"v0.6.1\u002Bcommit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000d580ae50b58fe08514deab4e38c0dfdb0d30adc","Library":"","SwarmSource":"://f24d4fba486a45dffdaaa5f387b4257d2c2846f1f3f10bdd48a22ba9c20a70ca"}]