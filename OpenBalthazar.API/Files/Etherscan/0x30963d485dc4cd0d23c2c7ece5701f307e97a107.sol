[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \u0022only owner\u0022);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner {\r\n        emit TransferOwnership(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n// File: contracts/commons/AddressMinHeap.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n/*\r\n    @author Agustin Aguilar \u003Cagusxrun@gmail.com\u003E\r\n*/\r\n\r\n\r\nlibrary AddressMinHeap {\r\n    using AddressMinHeap for AddressMinHeap.Heap;\r\n\r\n    struct Heap {\r\n        uint256[] entries;\r\n        mapping(address =\u003E uint256) index;\r\n    }\r\n\r\n    function initialize(Heap storage _heap) internal {\r\n        require(_heap.entries.length == 0, \u0022already initialized\u0022);\r\n        _heap.entries.push(0);\r\n    }\r\n\r\n    function encode(address _addr, uint256 _value) internal pure returns (uint256 _entry) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _entry := not(or(and(0xffffffffffffffffffffffffffffffffffffffff, _addr), shl(160, _value)))\r\n        }\r\n    }\r\n\r\n    function decode(uint256 _entry) internal pure returns (address _addr, uint256 _value) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            let entry := not(_entry)\r\n            _addr := and(entry, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            _value := shr(160, entry)\r\n        }\r\n    }\r\n\r\n    function decodeAddress(uint256 _entry) internal pure returns (address _addr) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _addr := and(not(_entry), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    function top(Heap storage _heap) internal view returns(address, uint256) {\r\n        if (_heap.entries.length \u003C 2) {\r\n            return (address(0), 0);\r\n        }\r\n\r\n        return decode(_heap.entries[1]);\r\n    }\r\n\r\n    function has(Heap storage _heap, address _addr) internal view returns (bool) {\r\n        return _heap.index[_addr] != 0;\r\n    }\r\n\r\n    function size(Heap storage _heap) internal view returns (uint256) {\r\n        return _heap.entries.length - 1;\r\n    }\r\n\r\n    function entry(Heap storage _heap, uint256 _i) internal view returns (address, uint256) {\r\n        return decode(_heap.entries[_i \u002B 1]);\r\n    }\r\n\r\n    // RemoveMax pops off the root element of the heap (the highest value here) and rebalances the heap\r\n    function popTop(Heap storage _heap) internal returns(address _addr, uint256 _value) {\r\n        // Ensure the heap exists\r\n        uint256 heapLength = _heap.entries.length;\r\n        require(heapLength \u003E 1, \u0022The heap does not exists\u0022);\r\n\r\n        // take the root value of the heap\r\n        (_addr, _value) = decode(_heap.entries[1]);\r\n        _heap.index[_addr] = 0;\r\n\r\n        if (heapLength == 2) {\r\n            _heap.entries.length = 1;\r\n        } else {\r\n            // Takes the last element of the array and put it at the root\r\n            uint256 val = _heap.entries[heapLength - 1];\r\n            _heap.entries[1] = val;\r\n\r\n            // Delete the last element from the array\r\n            _heap.entries.length = heapLength - 1;\r\n\r\n            // Start at the top\r\n            uint256 ind = 1;\r\n\r\n            // Bubble down\r\n            ind = _heap.bubbleDown(ind, val);\r\n\r\n            // Update index\r\n            _heap.index[decodeAddress(val)] = ind;\r\n        }\r\n    }\r\n\r\n    // Inserts adds in a value to our heap.\r\n    function insert(Heap storage _heap, address _addr, uint256 _value) internal {\r\n        require(_heap.index[_addr] == 0, \u0022The entry already exists\u0022);\r\n\r\n        // Add the value to the end of our array\r\n        uint256 encoded = encode(_addr, _value);\r\n        _heap.entries.push(encoded);\r\n\r\n        // Start at the end of the array\r\n        uint256 currentIndex = _heap.entries.length - 1;\r\n\r\n        // Bubble Up\r\n        currentIndex = _heap.bubbleUp(currentIndex, encoded);\r\n\r\n        // Update index\r\n        _heap.index[_addr] = currentIndex;\r\n    }\r\n\r\n    function update(Heap storage _heap, address _addr, uint256 _value) internal {\r\n        uint256 ind = _heap.index[_addr];\r\n        require(ind != 0, \u0022The entry does not exists\u0022);\r\n\r\n        uint256 can = encode(_addr, _value);\r\n        uint256 val = _heap.entries[ind];\r\n        uint256 newInd;\r\n\r\n        if (can \u003C val) {\r\n            // Bubble down\r\n            newInd = _heap.bubbleDown(ind, can);\r\n        } else if (can \u003E val) {\r\n            // Bubble up\r\n            newInd = _heap.bubbleUp(ind, can);\r\n        } else {\r\n            // no changes needed\r\n            return;\r\n        }\r\n\r\n        // Update entry\r\n        _heap.entries[newInd] = can;\r\n\r\n        // Update index\r\n        if (newInd != ind) {\r\n            _heap.index[_addr] = newInd;\r\n        }\r\n    }\r\n\r\n    function bubbleUp(Heap storage _heap, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n        // Bubble up\r\n        ind = _ind;\r\n        if (ind != 1) {\r\n            uint256 parent = _heap.entries[ind / 2];\r\n            while (parent \u003C _val) {\r\n                // If the parent value is lower than our current value, we swap them\r\n                (_heap.entries[ind / 2], _heap.entries[ind]) = (_val, parent);\r\n\r\n                // Update moved Index\r\n                _heap.index[decodeAddress(parent)] = ind;\r\n\r\n                // change our current Index to go up to the parent\r\n                ind = ind / 2;\r\n                if (ind == 1) {\r\n                    break;\r\n                }\r\n\r\n                // Update parent\r\n                parent = _heap.entries[ind / 2];\r\n            }\r\n        }\r\n    }\r\n\r\n    function bubbleDown(Heap storage _heap, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n        // Bubble down\r\n        ind = _ind;\r\n\r\n        uint256 lenght = _heap.entries.length;\r\n        uint256 target = lenght - 1;\r\n\r\n        while (ind * 2 \u003C lenght) {\r\n            // get the current index of the children\r\n            uint256 j = ind * 2;\r\n\r\n            // left child value\r\n            uint256 leftChild = _heap.entries[j];\r\n\r\n            // Store the value of the child\r\n            uint256 childValue;\r\n\r\n            if (target \u003E j) {\r\n                // The parent has two childs \uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC66\r\n\r\n                // Load right child value\r\n                uint256 rightChild = _heap.entries[j \u002B 1];\r\n\r\n                // Compare the left and right child.\r\n                // if the rightChild is greater, then point j to it\u0027s index\r\n                // and save the value\r\n                if (leftChild \u003C rightChild) {\r\n                    childValue = rightChild;\r\n                    j = j \u002B 1;\r\n                } else {\r\n                    // The left child is greater\r\n                    childValue = leftChild;\r\n                }\r\n            } else {\r\n                // The parent has a single child \uD83D\uDC68\u200D\uD83D\uDC66\r\n                childValue = leftChild;\r\n            }\r\n\r\n            // Check if the child has a lower value\r\n            if (_val \u003E childValue) {\r\n                break;\r\n            }\r\n\r\n            // else swap the value\r\n            (_heap.entries[ind], _heap.entries[j]) = (childValue, _val);\r\n\r\n            // Update moved Index\r\n            _heap.index[decodeAddress(childValue)] = ind;\r\n\r\n            // and let\u0027s keep going down the heap\r\n            ind = j;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Heap.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\ncontract Heap is Ownable {\r\n    using AddressMinHeap for AddressMinHeap.Heap;\r\n\r\n    // heap\r\n    AddressMinHeap.Heap private heap;\r\n\r\n    // Heap events\r\n    event JoinHeap(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n    event LeaveHeap(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n\r\n    uint256 public constant TOP_SIZE = 512;\r\n\r\n    constructor() public {\r\n        heap.initialize();\r\n    }\r\n\r\n    function topSize() external pure returns (uint256) {\r\n        return TOP_SIZE;\r\n    }\r\n\r\n    function addressAt(uint256 _i) external view returns (address addr) {\r\n        (addr, ) = heap.entry(_i);\r\n    }\r\n\r\n    function indexOf(address _addr) external view returns (uint256) {\r\n        return heap.index[_addr];\r\n    }\r\n\r\n    function entry(uint256 _i) external view returns (address, uint256) {\r\n        return heap.entry(_i);\r\n    }\r\n\r\n    function top() external view returns (address, uint256) {\r\n        return heap.top();\r\n    }\r\n\r\n    function size() external view returns (uint256) {\r\n        return heap.size();\r\n    }\r\n\r\n    function update(address _addr, uint256 _new) external onlyOwner {\r\n        uint256 _size = heap.size();\r\n\r\n        // If the heap is empty\r\n        // join the _addr\r\n        if (_size == 0) {\r\n            emit JoinHeap(_addr, _new, 0);\r\n            heap.insert(_addr, _new);\r\n            return;\r\n        }\r\n\r\n        // Load top value of the heap\r\n        (, uint256 lastBal) = heap.top();\r\n\r\n        // If our target address already is in the heap\r\n        if (heap.has(_addr)) {\r\n            // Update the target address value\r\n            heap.update(_addr, _new);\r\n            // If the new value is 0\r\n            // always pop the heap\r\n            // we updated the heap, so our address should be on top\r\n            if (_new == 0) {\r\n                heap.popTop();\r\n                emit LeaveHeap(_addr, 0, _size);\r\n            }\r\n        } else {\r\n            // IF heap is full or new balance is higher than pop heap\r\n            if (_new != 0 \u0026\u0026 (_size \u003C TOP_SIZE || lastBal \u003C _new)) {\r\n                // If heap is full pop heap\r\n                if (_size \u003E= TOP_SIZE) {\r\n                    (address _poped, uint256 _balance) = heap.popTop();\r\n                    emit LeaveHeap(_poped, _balance, _size);\r\n                }\r\n\r\n                // Insert new value\r\n                heap.insert(_addr, _new);\r\n                emit JoinHeap(_addr, _new, _size);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_i\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022addressAt\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022setOwner\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022TOP_SIZE\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022topSize\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022size\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_new\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022update\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_i\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022entry\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022indexOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022top\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_balance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_prevSize\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022JoinHeap\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_address\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_balance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_prevSize\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LeaveHeap\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TransferOwnership\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Heap","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2bf26f45bb12b8ec6258f5039e299408732938409649721fca33bd765b3c5af8"}]