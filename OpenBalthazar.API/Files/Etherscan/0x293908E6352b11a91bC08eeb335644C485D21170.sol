[{"SourceCode":"// File: contracts/Proxiable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\u0022PROXIABLE\u0022) = \u00220xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\u0022\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(\r\n                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\r\n                ) ==\r\n                Proxiable(newAddress).proxiableUUID(),\r\n            \u0022Not compatible\u0022\r\n        );\r\n        assembly {\r\n            // solium-disable-line\r\n            sstore(\r\n                0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7,\r\n                newAddress\r\n            )\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return\r\n            0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\n// File: contracts/RTokenStructs.sol\r\n\r\npragma solidity \u003E=0.5.10 \u003C0.6.0;\r\n\r\ncontract RTokenStructs {\r\n    /**\r\n     * @notice Global stats\r\n     */\r\n    struct GlobalStats {\r\n        /// @notice Total redeemable tokens supply\r\n        uint256 totalSupply;\r\n        /// @notice Total saving assets in redeemable amount\r\n        uint256 totalSavingsAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Account stats stored\r\n     */\r\n    struct AccountStatsView {\r\n        /// @notice Current hat ID\r\n        uint256 hatID;\r\n        /// @notice Current redeemable amount\r\n        uint256 rAmount;\r\n        /// @notice Interest portion of the rAmount\r\n        uint256 rInterest;\r\n        /// @notice Current loan debt amount\r\n        uint256 lDebt;\r\n        /// @notice Current internal savings amount\r\n        uint256 sInternalAmount;\r\n        /// @notice Interest payable\r\n        uint256 rInterestPayable;\r\n        /// @notice Cumulative interest generated for the account\r\n        uint256 cumulativeInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice Account stats stored\r\n     */\r\n    struct AccountStatsStored {\r\n        /// @notice Cumulative interest generated for the account\r\n        uint256 cumulativeInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat stats view\r\n     */\r\n    struct HatStatsView {\r\n        /// @notice Number of addresses has the hat\r\n        uint256 useCount;\r\n        /// @notice Total net loans distributed through the hat\r\n        uint256 totalLoans;\r\n        /// @notice Total net savings distributed through the hat\r\n        uint256 totalSavings;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat stats stored\r\n     */\r\n    struct HatStatsStored {\r\n        /// @notice Number of addresses has the hat\r\n        uint256 useCount;\r\n        /// @notice Total net loans distributed through the hat\r\n        uint256 totalLoans;\r\n        /// @notice Total net savings distributed through the hat\r\n        uint256 totalInternalSavings;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat structure describes who are the recipients of the interest\r\n     *\r\n     * To be a valid hat structure:\r\n     *   - at least one recipient\r\n     *   - recipients.length == proportions.length\r\n     *   - each value in proportions should be greater than 0\r\n     */\r\n    struct Hat {\r\n        address[] recipients;\r\n        uint32[] proportions;\r\n    }\r\n\r\n    /// @dev Account structure\r\n    struct Account {\r\n        uint256 hatID;\r\n        uint256 rAmount;\r\n        uint256 rInterest;\r\n        mapping(address =\u003E uint256) lRecipients;\r\n        uint256 lDebt;\r\n        uint256 sInternalAmount;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to {approve}. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IRToken.sol\r\n\r\n/**\r\n * Because the use of ABIEncoderV2 , the pragma should be locked above 0.5.10 ,\r\n * as there is a known bug in array storage:\r\n * https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs/\r\n */\r\npragma solidity \u003E=0.5.10 \u003C0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n * @notice RToken interface a ERC20 interface and one can mint new tokens by\r\n *      trasfering underlying token into the contract, configure _hats_ for\r\n *      addresses and pay earned interest in new _rTokens_.\r\n */\r\ncontract IRToken is RTokenStructs, IERC20 {\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // For external transactions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mint(uint256 mintAmount) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a selected hat for the account.\r\n     * @param hatID The id of the selected Hat\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a new hat for the account.\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mintWithNewHat(\r\n        uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from the caller\u0027s account to \u0060dst\u0060.\r\n     * @param dst The destination address.\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function transferAll(address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from \u0060src\u0060 account to \u0060dst\u0060.\r\n     * @param src The source address which approved the msg.sender to spend\r\n     * @param dst The destination address.\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function transferAllFrom(address src, address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeem(uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAll() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAndTransferAll(address redeemTo) external returns (bool);\r\n\r\n    /**\r\n     * @notice Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @param doChangeHat Should the hat of the \u0060msg.sender\u0060 be switched to the new one\r\n     * @return uint256 ID of the newly creatd Hat.\r\n     */\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat\r\n    ) external returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Change the hat for \u0060msg.sender\u0060\r\n     * @param hatID The id of the Hat\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function changeHat(uint256 hatID) external returns (bool);\r\n\r\n    /**\r\n     * @notice pay interest to the owner\r\n     * @param owner Account owner address\r\n     * @return bool true=success, otherwise a failure\r\n     *\r\n     * Anyone can trigger the interest distribution on behalf of the recipient,\r\n     * due to the fact that the recipient can be a contract code that has not\r\n     * implemented the interaction with the rToken contract internally\u0060.\r\n     *\r\n     * A interest lock-up period may apply, in order to mitigate the \u0022hat\r\n     * inheritance scam\u0022.\r\n     */\r\n    function payInterest(address owner) external returns (bool);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Essential info views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the maximum hatID in the system\r\n     */\r\n    function getMaximumHatID() external view returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Get the hatID of the owner and the hat structure\r\n     * @param owner Account owner address\r\n     * @return hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient\u0027s relative proportions\r\n     */\r\n    function getHatByAddress(address owner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions\r\n        );\r\n\r\n    /**\r\n     * @notice Get the hat structure\r\n     * @param hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient\u0027s relative proportions\r\n     */\r\n    function getHatByID(uint256 hatID)\r\n        external\r\n        view\r\n        returns (address[] memory recipients, uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Amount of saving assets given to the recipient along with the\r\n     *         loans.\r\n     * @param owner Account owner address\r\n     */\r\n    function receivedSavingsOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Amount of token loaned to the recipient along with the savings\r\n     *         assets.\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function receivedLoanOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Get the current interest balance of the owner.\r\n               It is equivalent of: receivedSavings - receivedLoan - freeBalance\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function interestPayableOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // statistics views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the current saving strategy contract\r\n     * @return Saving strategy address\r\n     */\r\n    function getCurrentSavingStrategy() external view returns (address);\r\n\r\n    /**\r\n    * @notice Get saving asset balance for specific saving strategy\r\n    * @return rAmount Balance in redeemable amount\r\n    * @return sOriginalAmount Balance in native amount of the strategy\r\n    */\r\n    function getSavingAssetBalance()\r\n        external\r\n        view\r\n        returns (uint256 rAmount, uint256 sOriginalAmount);\r\n\r\n    /**\r\n    * @notice Get global stats\r\n    * @return global stats\r\n    */\r\n    function getGlobalStats() external view returns (GlobalStats memory);\r\n\r\n    /**\r\n    * @notice Get account stats\r\n    * @param owner Account owner address\r\n    * @return account stats\r\n    */\r\n    function getAccountStats(address owner)\r\n        external\r\n        view\r\n        returns (AccountStatsView memory);\r\n\r\n    /**\r\n    * @notice Get hat stats\r\n    * @param hatID Hat ID\r\n    * @return hat stats\r\n    */\r\n    function getHatStats(uint256 hatID)\r\n        external\r\n        view\r\n        returns (HatStatsView memory);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Events\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Event emitted when loans get transferred\r\n     */\r\n    event LoansTransferred(\r\n        address indexed owner,\r\n        address indexed recipient,\r\n        uint256 indexed hatId,\r\n        bool isDistribution,\r\n        uint256 redeemableAmount,\r\n        uint256 internalSavingsAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when interest paid\r\n     */\r\n    event InterestPaid(address indexed recipient, uint256 amount);\r\n\r\n    /**\r\n     * @notice A new hat is created\r\n     */\r\n    event HatCreated(uint256 indexed hatID);\r\n\r\n    /**\r\n     * @notice Hat is changed for the account\r\n     */\r\n    event HatChanged(address indexed account, uint256 indexed oldHatID, uint256 indexed newHatID);\r\n}\r\n\r\n// File: contracts/IAllocationStrategy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n * @notice Allocation strategy for assets.\r\n *         - It invests the underlying assets into some yield generating contracts,\r\n *           usually lending contracts, in return it gets new assets aka. saving assets.\r\n *         - Sainv assets can be redeemed back to the underlying assets plus interest any time.\r\n */\r\ninterface IAllocationStrategy {\r\n\r\n    /**\r\n     * @notice Underlying asset for the strategy\r\n     * @return address Underlying asset address\r\n     */\r\n    function underlying() external view returns (address);\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from underlying to saving assets\r\n     * @return uint256 Calculated exchange rate scaled by 1e18\r\n     *\r\n     * NOTE:\r\n     *\r\n     *   underlying = savingAssets \u00D7 exchangeRate\r\n     */\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Applies accrued interest to all savings\r\n      * @dev This should calculates interest accrued from the last checkpointed\r\n      *      block up to the current block and writes new checkpoint to storage.\r\n      * @return bool success(true) or failure(false)\r\n      */\r\n    function accrueInterest() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies underlying assets into the market and receives saving assets in exchange\r\n     * @dev Interst shall be accrued\r\n     * @param investAmount The amount of the underlying asset to supply\r\n     * @return uint256 Amount of saving assets created\r\n     */\r\n    function investUnderlying(uint256 investAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Sender redeems saving assets in exchange for a specified amount of underlying asset\r\n     * @dev Interst shall be accrued\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint256 Amount of saving assets burned\r\n     */\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/RTokenStorage.sol\r\n\r\n/**\r\n * Because the use of ABIEncoderV2 , the pragma should be locked above 0.5.10 ,\r\n * as there is a known bug in array storage:\r\n * https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs/\r\n */\r\npragma solidity \u003E=0.5.10 \u003C0.6.0;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract RTokenStorage is RTokenStructs, IERC20 {\r\n    /* WARNING: NEVER RE-ORDER VARIABLES! Always double-check that new variables are added APPEND-ONLY. Re-ordering variables can permanently BREAK the deployed proxy contract.*/\r\n    address public _owner;\r\n    bool public initialized;\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 public _guardCounter;\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint256 public decimals;\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint256 public totalSupply;\r\n    /// @dev Current saving strategy\r\n    IAllocationStrategy public ias;\r\n    /// @dev Underlying token\r\n    IERC20 public token;\r\n    /// @dev Saving assets original amount\r\n    /// This amount is in the same unit used in allocation strategy\r\n    uint256 public savingAssetOrignalAmount;\r\n    /// @dev Saving asset original to internal amount conversion rate.\r\n    ///      - It has 18 decimals\r\n    ///      - It starts with value 1.\r\n    ///      - Each strategy switching results a new conversion rate\r\n    ///\r\n    /// NOTE:\r\n    ///\r\n    /// 1. The reason there is an exchange rate is that, each time the\r\n    ///    allocation strategy is switched, the unit of the original amount gets\r\n    ///    changed, it is impossible to change all the internal savings\r\n    ///    accounting entries for all accounts, hence instead a conversaion rate\r\n    ///    is used to simplify the process.\r\n    /// 2. internalSavings == originalSavings * savingAssetConversionRate\r\n    uint256 public savingAssetConversionRate;\r\n    /// @dev Approved token transfer amounts on behalf of others\r\n    mapping(address =\u003E mapping(address =\u003E uint256)) public transferAllowances;\r\n    /// @dev Hat list\r\n    Hat[] internal hats;\r\n    /// @dev Account mapping\r\n    mapping(address =\u003E Account) public accounts;\r\n    /// @dev AccountStats mapping\r\n    mapping(address =\u003E AccountStatsStored) public accountStats;\r\n    /// @dev HatStats mapping\r\n    mapping(uint256 =\u003E HatStatsStored) public hatStats;\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Ownable is RTokenStorage {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * \u003E Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \u0022Ownable: new owner is the zero address\u0022\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/LibraryLock.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract LibraryLock is RTokenStorage {\r\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\r\n    // PARITY WALLET HACK PREVENTION\r\n\r\n    modifier delegatedOnly() {\r\n        require(\r\n            initialized == true,\r\n            \u0022The library is locked. No direct \u0027call\u0027 is allowed.\u0022\r\n        );\r\n        _;\r\n    }\r\n    function initialize() internal {\r\n        initialized = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ReentrancyGuard is RTokenStorage {\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a \u0060nonReentrant\u0060 function from another \u0060nonReentrant\u0060\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the \u0060nonReentrant\u0060 function external, and make it call a\r\n     * \u0060private\u0060 function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter \u002B= 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(\r\n            localCounter == _guardCounter,\r\n            \u0022ReentrancyGuard: reentrant call\u0022\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/IRTokenAdmin.sol\r\n\r\n/**\r\n * In order to build a Aragon App, it is required to have a solidity requirement\r\n * that is without ABIEncoderV2.\r\n */\r\npragma solidity \u003E= 0.4.24;\r\n\r\n/**\r\n * IRTokenAdmin interface\r\n */\r\ninterface IRTokenAdmin {\r\n\r\n    /**\r\n     * @notice Get current owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     *\r\n     * To be implemented by Ownable\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n    * @notice Get the current allocation strategy\r\n    */\r\n    function getCurrentAllocationStrategy()\r\n        external view returns (address allocationStrategy);\r\n\r\n    /**\r\n    * @notice Change allocation strategy for the contract instance\r\n    * @param allocationStrategy Allocation strategy instance\r\n    */\r\n    function changeAllocationStrategy(address allocationStrategy)\r\n        external;\r\n\r\n    /**\r\n     * @notice Change hat for the contract address\r\n     * @param contractAddress contract address\r\n     * @param hatID Hat ID\r\n     */\r\n    function changeHatFor(address contractAddress, uint256 hatID)\r\n        external;\r\n\r\n    /**\r\n     * @notice Update the rToken logic contract code\r\n     */\r\n    function updateCode(address newCode) external;\r\n\r\n    /**\r\n     * @notice Code updated event\r\n     */\r\n    event CodeUpdated(address newCode);\r\n\r\n    /**\r\n     * @notice Allocation strategy changed event\r\n     * @param strategy New strategy address\r\n     * @param conversionRate New saving asset conversion rate\r\n     */\r\n    event AllocationStrategyChanged(address strategy, uint256 conversionRate);\r\n}\r\n\r\n// File: contracts/RToken.sol\r\n\r\n/**\r\n * Because the use of ABIEncoderV2 , the pragma should be locked above 0.5.10 ,\r\n * as there is a known bug in array storage:\r\n * https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs/\r\n */\r\npragma solidity \u003E=0.5.10 \u003C0.6.0;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice RToken an ERC20 token that is 1:1 redeemable to its underlying ERC20 token.\r\n */\r\ncontract RToken is\r\n    RTokenStorage,\r\n    IRToken,\r\n    IRTokenAdmin,\r\n    Ownable,\r\n    Proxiable,\r\n    LibraryLock,\r\n    ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    uint256 public constant ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE = 1e18;\r\n    uint256 public constant INITIAL_SAVING_ASSET_CONVERSION_RATE = 1e18;\r\n    uint256 public constant MAX_UINT256 = uint256(int256(-1));\r\n    uint256 public constant SELF_HAT_ID = MAX_UINT256;\r\n    uint32 public constant PROPORTION_BASE = 0xFFFFFFFF;\r\n    uint256 public constant MAX_NUM_HAT_RECIPIENTS = 50;\r\n\r\n    /**\r\n     * @notice Create rToken linked with cToken at \u0060cToken_\u0060\r\n     */\r\n    function initialize(\r\n        IAllocationStrategy allocationStrategy,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        uint256 decimals_) external {\r\n        require(!initialized, \u0022The library has already been initialized.\u0022);\r\n        LibraryLock.initialize();\r\n        _owner = msg.sender;\r\n        _guardCounter = 1;\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n        savingAssetConversionRate = INITIAL_SAVING_ASSET_CONVERSION_RATE;\r\n        ias = allocationStrategy;\r\n        token = IERC20(ias.underlying());\r\n\r\n        // special hat aka. zero hat : hatID = 0\r\n        hats.push(Hat(new address[](0), new uint32[](0)));\r\n\r\n        // everyone is using it by default!\r\n        hatStats[0].useCount = MAX_UINT256;\r\n\r\n        emit AllocationStrategyChanged(address(ias), savingAssetConversionRate);\r\n    }\r\n\r\n    //\r\n    // ERC20 Interface\r\n    //\r\n\r\n    /**\r\n     * @notice Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accounts[owner].rAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060dst\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     * May also emit \u0060InterestPaid\u0060 event.\r\n     */\r\n    function transfer(address dst, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        transferInternal(src, src, dst, amount);\r\n        payInterestInternal(dst);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.transferAll implementation\r\n    function transferAll(address dst) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        transferInternal(src, src, dst, accounts[src].rAmount);\r\n        payInterestInternal(dst);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.transferAllFrom implementation\r\n    function transferAllFrom(address src, address dst)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        payInterestInternal(src);\r\n        transferInternal(msg.sender, src, dst, accounts[src].rAmount);\r\n        payInterestInternal(dst);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        payInterestInternal(src);\r\n        transferInternal(msg.sender, src, dst, amount);\r\n        payInterestInternal(dst);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // rToken interface\r\n    //\r\n\r\n    /// @dev IRToken.mint implementation\r\n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\r\n        mintInternal(mintAmount);\r\n        payInterestInternal(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.mintWithSelectedHat implementation\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        changeHatInternal(msg.sender, hatID);\r\n        mintInternal(mintAmount);\r\n        payInterestInternal(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.mintWithNewHat implementation\r\n     */\r\n    function mintWithNewHat(\r\n        uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions\r\n    ) external nonReentrant returns (bool) {\r\n        uint256 hatID = createHatInternal(recipients, proportions);\r\n        changeHatInternal(msg.sender, hatID);\r\n        mintInternal(mintAmount);\r\n        payInterestInternal(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.redeem implementation\r\n     *      It withdraws equal amount of initially supplied underlying assets\r\n     */\r\n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAll implementation\r\n    function redeemAll() external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransfer implementation\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransferAll implementation\r\n    function redeemAndTransferAll(address redeemTo)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.createHat implementation\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat\r\n    ) external nonReentrant returns (uint256 hatID) {\r\n        hatID = createHatInternal(recipients, proportions);\r\n        if (doChangeHat) {\r\n            changeHatInternal(msg.sender, hatID);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.changeHat implementation\r\n    function changeHat(uint256 hatID) external nonReentrant returns (bool) {\r\n        changeHatInternal(msg.sender, hatID);\r\n        payInterestInternal(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.getMaximumHatID implementation\r\n    function getMaximumHatID() external view returns (uint256 hatID) {\r\n        return hats.length - 1;\r\n    }\r\n\r\n    /// @dev IRToken.getHatByAddress implementation\r\n    function getHatByAddress(address owner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions\r\n        )\r\n    {\r\n        hatID = accounts[owner].hatID;\r\n        (recipients, proportions) = _getHatByID(hatID);\r\n    }\r\n\r\n    /// @dev IRToken.getHatByID implementation\r\n    function getHatByID(uint256 hatID)\r\n        external\r\n        view\r\n        returns (address[] memory recipients, uint32[] memory proportions) {\r\n        (recipients, proportions) = _getHatByID(hatID);\r\n    }\r\n\r\n    function _getHatByID(uint256 hatID)\r\n        private\r\n        view\r\n        returns (address[] memory recipients, uint32[] memory proportions) {\r\n        if (hatID != 0 \u0026\u0026 hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.receivedSavingsOf implementation\r\n    function receivedSavingsOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        uint256 rGross = sInternalToR(account.sInternalAmount);\r\n        return rGross;\r\n    }\r\n\r\n    /// @dev IRToken.receivedLoanOf implementation\r\n    function receivedLoanOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        return account.lDebt;\r\n    }\r\n\r\n    /// @dev IRToken.interestPayableOf implementation\r\n    function interestPayableOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        return getInterestPayableOf(account);\r\n    }\r\n\r\n    /// @dev IRToken.payInterest implementation\r\n    function payInterest(address owner) external nonReentrant returns (bool) {\r\n        payInterestInternal(owner);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation!1\r\n    function getGlobalStats() external view returns (GlobalStats memory) {\r\n        uint256 totalSavingsAmount;\r\n        totalSavingsAmount \u002B= sOriginalToR(savingAssetOrignalAmount);\r\n        return\r\n            GlobalStats({\r\n                totalSupply: totalSupply,\r\n                totalSavingsAmount: totalSavingsAmount\r\n            });\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation\r\n    function getAccountStats(address owner)\r\n        external\r\n        view\r\n        returns (AccountStatsView memory stats)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        stats.hatID = account.hatID;\r\n        stats.rAmount = account.rAmount;\r\n        stats.rInterest = account.rInterest;\r\n        stats.lDebt = account.lDebt;\r\n        stats.sInternalAmount = account.sInternalAmount;\r\n\r\n        stats.rInterestPayable = getInterestPayableOf(account);\r\n\r\n        AccountStatsStored storage statsStored = accountStats[owner];\r\n        stats.cumulativeInterest = statsStored.cumulativeInterest;\r\n\r\n        return stats;\r\n    }\r\n\r\n    /// @dev IRToken.getHatStats implementation\r\n    function getHatStats(uint256 hatID)\r\n        external\r\n        view\r\n        returns (HatStatsView memory stats) {\r\n        HatStatsStored storage statsStored = hatStats[hatID];\r\n        stats.useCount = statsStored.useCount;\r\n        stats.totalLoans = statsStored.totalLoans;\r\n\r\n        stats.totalSavings = sInternalToR(statsStored.totalInternalSavings);\r\n        return stats;\r\n    }\r\n\r\n    /// @dev IRToken.getCurrentSavingStrategy implementation\r\n    function getCurrentSavingStrategy() external view returns (address) {\r\n        return address(ias);\r\n    }\r\n\r\n    /// @dev IRToken.getSavingAssetBalance implementation\r\n    function getSavingAssetBalance()\r\n        external\r\n        view\r\n        returns (uint256 rAmount, uint256 sOriginalAmount)\r\n    {\r\n        sOriginalAmount = savingAssetOrignalAmount;\r\n        rAmount = sOriginalToR(sOriginalAmount);\r\n    }\r\n\r\n    /// @dev IRToken.changeAllocationStrategy implementation\r\n    function changeAllocationStrategy(address allocationStrategy_)\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        IAllocationStrategy allocationStrategy = IAllocationStrategy(allocationStrategy_);\r\n        require(\r\n            allocationStrategy.underlying() == address(token),\r\n            \u0022New strategy should have the same underlying asset\u0022\r\n        );\r\n        IAllocationStrategy oldIas = ias;\r\n        ias = allocationStrategy;\r\n        // redeem everything from the old strategy\r\n        uint256 sOriginalBurned = oldIas.redeemUnderlying(totalSupply);\r\n        // invest everything into the new strategy\r\n        require(token.approve(address(ias), totalSupply), \u0022token approve failed\u0022);\r\n        uint256 sOriginalCreated = ias.investUnderlying(totalSupply);\r\n\r\n        // calculate new saving asset conversion rate\r\n        //\r\n        // NOTE:\r\n        //   - savingAssetConversionRate should be scaled by 1e18\r\n        //   - to keep internalSavings constant:\r\n        //     internalSavings == sOriginalBurned * savingAssetConversionRateOld\r\n        //     internalSavings == sOriginalCreated * savingAssetConversionRateNew\r\n        //     =\u003E\r\n        //     savingAssetConversionRateNew = sOriginalBurned\r\n        //          * savingAssetConversionRateOld\r\n        //          / sOriginalCreated\r\n        //\r\n        uint256 savingAssetConversionRateOld = savingAssetConversionRate;\r\n        savingAssetConversionRate = sOriginalBurned\r\n            .mul(savingAssetConversionRateOld)\r\n            .div(sOriginalCreated);\r\n\r\n        emit AllocationStrategyChanged(allocationStrategy_, savingAssetConversionRate);\r\n    }\r\n\r\n    /// @dev IRToken.changeHatFor implementation\r\n    function getCurrentAllocationStrategy()\r\n        external view returns (address allocationStrategy) {\r\n        return address(ias);\r\n    }\r\n\r\n    /// @dev IRToken.changeHatFor implementation\r\n    function changeHatFor(address contractAddress, uint256 hatID) external onlyOwner {\r\n        require(_isContract(contractAddress), \u0022Admin can only change hat for contract address\u0022);\r\n        changeHatInternal(contractAddress, hatID);\r\n    }\r\n\r\n    /// @dev Update the rToken logic contract code\r\n    function updateCode(address newCode) external onlyOwner delegatedOnly {\r\n        updateCodeAddress(newCode);\r\n        emit CodeUpdated(newCode);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer \u0060tokens\u0060 tokens from \u0060src\u0060 to \u0060dst\u0060 by \u0060spender\u0060\r\n            Called by both \u0060transfer\u0060 and \u0060transferFrom\u0060 internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferInternal(\r\n        address spender,\r\n        address src,\r\n        address dst,\r\n        uint256 tokens\r\n    ) internal {\r\n        require(src != dst, \u0022src should not equal dst\u0022);\r\n\r\n        require(\r\n            accounts[src].rAmount \u003E= tokens,\r\n            \u0022Not enough balance to transfer\u0022\r\n        );\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint256 startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = MAX_UINT256;\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n        require(\r\n            startingAllowance \u003E= tokens,\r\n            \u0022Not enough allowance for transfer\u0022\r\n        );\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        uint256 allowanceNew = startingAllowance.sub(tokens);\r\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\r\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\r\n\r\n        /////////////////////////\r\n        // EFFECTS \u0026 INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // check if src \u0026 dst have the same hat\r\n        bool sameHat = accounts[src].hatID == accounts[dst].hatID;\r\n\r\n        // apply hat inheritance rule\r\n        if ((accounts[src].hatID != 0 \u0026\u0026\r\n            accounts[dst].hatID == 0 \u0026\u0026\r\n            accounts[src].hatID != SELF_HAT_ID)) {\r\n            changeHatInternal(dst, accounts[src].hatID);\r\n        }\r\n\r\n        accounts[src].rAmount = srcTokensNew;\r\n        accounts[dst].rAmount = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != MAX_UINT256) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        // lRecipients adjustments\r\n        if (!sameHat) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\r\n                src,\r\n                tokens\r\n            );\r\n            distributeLoans(dst, tokens, sInternalAmountCollected);\r\n        } else {\r\n            // apply same hat optimization\r\n            sameHatTransfer(src, dst, accounts[src].hatID, tokens);\r\n        }\r\n\r\n        // rInterest adjustment for src\r\n        //\r\n        // rInterest should be the portion that is from interest payment, by\r\n        // definition it should not be larger than rAmount.\r\n        // It could happen because of rounding errors.\r\n        if (accounts[src].rInterest \u003E accounts[src].rAmount) {\r\n            accounts[src].rInterest = accounts[src].rAmount;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Sender supplies assets into the market and receives rTokens in exchange\r\n     * @dev Invest into underlying assets immediately\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     */\r\n    function mintInternal(uint256 mintAmount) internal {\r\n        require(\r\n            token.allowance(msg.sender, address(this)) \u003E= mintAmount,\r\n            \u0022Not enough allowance\u0022\r\n        );\r\n\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        // create saving assets\r\n        require(token.transferFrom(msg.sender, address(this), mintAmount), \u0022token transfer failed\u0022);\r\n        require(token.approve(address(ias), mintAmount), \u0022token approve failed\u0022);\r\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\r\n\r\n        // update global and account r balances\r\n        totalSupply = totalSupply.add(mintAmount);\r\n        account.rAmount = account.rAmount.add(mintAmount);\r\n\r\n        // update global stats\r\n        savingAssetOrignalAmount = savingAssetOrignalAmount.add(sOriginalCreated);\r\n\r\n        // distribute saving assets as loans to recipients\r\n        uint256 sInternalCreated = sOriginalToSInternal(sOriginalCreated);\r\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\r\n\r\n        emit Transfer(address(0), msg.sender, mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @dev Withdraw equal amount of initially supplied underlying assets\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemAmount The number of rTokens to redeem into underlying\r\n     */\r\n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\r\n        Account storage account = accounts[msg.sender];\r\n        require(redeemAmount \u003E 0, \u0022Redeem amount cannot be zero\u0022);\r\n        require(\r\n            redeemAmount \u003C= account.rAmount,\r\n            \u0022Not enough balance to redeem\u0022\r\n        );\r\n\r\n        uint256 sOriginalBurned = redeemAndRecollectLoans(\r\n            msg.sender,\r\n            redeemAmount\r\n        );\r\n\r\n        // update Account r balances and global statistics\r\n        account.rAmount = account.rAmount.sub(redeemAmount);\r\n        if (account.rInterest \u003E account.rAmount) {\r\n            account.rInterest = account.rAmount;\r\n        }\r\n        totalSupply = totalSupply.sub(redeemAmount);\r\n\r\n        // update global stats\r\n        if (savingAssetOrignalAmount \u003E sOriginalBurned) {\r\n            savingAssetOrignalAmount -= sOriginalBurned;\r\n        } else {\r\n            savingAssetOrignalAmount = 0;\r\n        }\r\n\r\n        // transfer the token back\r\n        require(token.transfer(redeemTo, redeemAmount), \u0022token transfer failed\u0022);\r\n\r\n        emit Transfer(msg.sender, address(0), redeemAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n*    * @param proportions Relative proportions of benefits received by the recipients\r\n     */\r\n    function createHatInternal(\r\n        address[] memory recipients,\r\n        uint32[] memory proportions\r\n    ) internal returns (uint256 hatID) {\r\n        uint256 i;\r\n\r\n        require(recipients.length \u003E 0, \u0022Invalid hat: at least one recipient\u0022);\r\n        require(recipients.length \u003C= MAX_NUM_HAT_RECIPIENTS, \u0022Invalild hat: maximum number of recipients reached\u0022);\r\n        require(\r\n            recipients.length == proportions.length,\r\n            \u0022Invalid hat: length not matching\u0022\r\n        );\r\n\r\n        // normalize the proportions\r\n        // safemath is not used here, because:\r\n        // proportions are uint32, there is no overflow concern\r\n        uint256 totalProportions = 0;\r\n        for (i = 0; i \u003C recipients.length; \u002B\u002Bi) {\r\n            require(\r\n                proportions[i] \u003E 0,\r\n                \u0022Invalid hat: proportion should be larger than 0\u0022\r\n            );\r\n            require(recipients[i] != address(0), \u0022Invalid hat: recipient should not be 0x0\u0022);\r\n            // don\u0027t panic, no safemath, look above comment\r\n            totalProportions \u002B= uint256(proportions[i]);\r\n        }\r\n        for (i = 0; i \u003C proportions.length; \u002B\u002Bi) {\r\n            proportions[i] = uint32(\r\n                // don\u0027t panic, no safemath, look above comment\r\n                (uint256(proportions[i]) * uint256(PROPORTION_BASE)) /\r\n                    totalProportions\r\n            );\r\n        }\r\n\r\n        hatID = hats.push(Hat(recipients, proportions)) - 1;\r\n        emit HatCreated(hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the hat for \u0060owner\u0060\r\n     * @param owner Account owner\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHatInternal(address owner, uint256 hatID) internal {\r\n        require(hatID == SELF_HAT_ID || hatID \u003C hats.length, \u0022Invalid hat ID\u0022);\r\n        Account storage account = accounts[owner];\r\n        uint256 oldHatID = account.hatID;\r\n        HatStatsStored storage oldHatStats = hatStats[oldHatID];\r\n        HatStatsStored storage newHatStats = hatStats[hatID];\r\n        account.hatID = hatID;\r\n        if (account.rAmount \u003E 0) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\r\n                owner,\r\n                account.rAmount\r\n            );\r\n            distributeLoans(owner, account.rAmount, sInternalAmountCollected);\r\n        }\r\n        oldHatStats.useCount -= 1;\r\n        newHatStats.useCount \u002B= 1;\r\n        emit HatChanged(owner, oldHatID, hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Get interest payable of the account\r\n     */\r\n    function getInterestPayableOf(Account storage account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 rGross = sInternalToR(account.sInternalAmount);\r\n        if (rGross \u003E (account.lDebt.add(account.rInterest))) {\r\n            // don\u0027t panic, the condition guarantees that safemath is not needed\r\n            return rGross - account.lDebt - account.rInterest;\r\n        } else {\r\n            // no interest accumulated yet or even negative interest rate!?\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the incoming tokens to the recipients as loans.\r\n     *      The tokens are immediately invested into the saving strategy and\r\n     *      add to the sAmount of the recipient account.\r\n     *      Recipient also inherits the owner\u0027s hat if it does already have one.\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount being loaned to the recipients\r\n     * @param sInternalAmount Amount of saving assets (internal amount) being given to the recipients\r\n     */\r\n    function distributeLoans(\r\n        address owner,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount\r\n    ) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\r\n            ? 0\r\n            : account.hatID];\r\n        uint256 i;\r\n        if (hat.recipients.length \u003E 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i \u003C hat.proportions.length; \u002B\u002Bi) {\r\n                address recipientAddress = hat.recipients[i];\r\n                Account storage recipientAccount = accounts[recipientAddress];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // calculate the loan amount of the recipient\r\n                uint256 lDebtRecipient = isLastRecipient\r\n                    ? rLeft\r\n                    : (rAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\r\n                // distribute the loan to the recipient\r\n                account.lRecipients[recipientAddress] = account.lRecipients[recipientAddress]\r\n                    .add(lDebtRecipient);\r\n                recipientAccount.lDebt = recipientAccount.lDebt\r\n                    .add(lDebtRecipient);\r\n                // remaining value adjustments\r\n                rLeft = gentleSub(rLeft, lDebtRecipient);\r\n\r\n                // calculate the savings holdings of the recipient\r\n                uint256 sInternalAmountRecipient = isLastRecipient\r\n                    ? sInternalLeft\r\n                    : (sInternalAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\r\n                recipientAccount.sInternalAmount = recipientAccount.sInternalAmount\r\n                    .add(sInternalAmountRecipient);\r\n                // remaining value adjustments\r\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\r\n\r\n                _updateLoanStats(owner, recipientAddress, account.hatID, true, lDebtRecipient, sInternalAmountRecipient);\r\n            }\r\n        } else {\r\n            // Account uses the zero/self hat, give all interest to the owner\r\n            account.lDebt = account.lDebt.add(rAmount);\r\n            account.sInternalAmount = account.sInternalAmount\r\n                .add(sInternalAmount);\r\n\r\n            _updateLoanStats(owner, owner, account.hatID, true, rAmount, sInternalAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      without actually redeeming the saving assets\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by giving back estimated amount of saving assets\r\n     * @return Estimated amount of saving assets (internal) needs to recollected\r\n     */\r\n    function estimateAndRecollectLoans(address owner, uint256 rAmount)\r\n        internal\r\n        returns (uint256 sInternalAmount)\r\n    {\r\n        // accrue interest so estimate is up to date\r\n        require(ias.accrueInterest(), \u0022accrueInterest failed\u0022);\r\n        sInternalAmount = rToSInternal(rAmount);\r\n        recollectLoans(owner, rAmount, sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      by redeeming the saving assets in \u0060rAmount\u0060\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by redeeming equivalent value of the saving assets\r\n     * @return Amount of saving assets redeemed for rAmount of tokens.\r\n     */\r\n    function redeemAndRecollectLoans(address owner, uint256 rAmount)\r\n        internal\r\n        returns (uint256 sOriginalBurned)\r\n    {\r\n        sOriginalBurned = ias.redeemUnderlying(rAmount);\r\n        uint256 sInternalBurned = sOriginalToSInternal(sOriginalBurned);\r\n        recollectLoans(owner, rAmount, sInternalBurned);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loan from the recipients\r\n     * @param owner   Owner address\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     * @param sInternalAmount Amount of sasving assets (internal amount) recollected from the recipients\r\n     */\r\n    function recollectLoans(\r\n        address owner,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount\r\n    ) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\r\n            ? 0\r\n            : account.hatID];\r\n        if (hat.recipients.length \u003E 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            uint256 i;\r\n            for (i = 0; i \u003C hat.proportions.length; \u002B\u002Bi) {\r\n                address recipientAddress = hat.recipients[i];\r\n                Account storage recipientAccount = accounts[recipientAddress];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // calulate loans to be collected from the recipient\r\n                uint256 lDebtRecipient = isLastRecipient\r\n                    ? rLeft\r\n                    : (rAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\r\n                recipientAccount.lDebt = gentleSub(\r\n                    recipientAccount.lDebt,\r\n                    lDebtRecipient);\r\n                account.lRecipients[recipientAddress] = gentleSub(\r\n                    account.lRecipients[recipientAddress],\r\n                    lDebtRecipient);\r\n                // loans leftover adjustments\r\n                rLeft = gentleSub(rLeft, lDebtRecipient);\r\n\r\n                // calculate savings to be collected from the recipient\r\n                uint256 sInternalAmountRecipient = isLastRecipient\r\n                    ? sInternalLeft\r\n                    : (sInternalAmount.mul(hat.proportions[i])) / PROPORTION_BASE;\r\n                recipientAccount.sInternalAmount = gentleSub(\r\n                    recipientAccount.sInternalAmount,\r\n                    sInternalAmountRecipient);\r\n                // savings leftover adjustments\r\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\r\n\r\n                _updateLoanStats(owner, recipientAddress, account.hatID, false, lDebtRecipient, sInternalAmountRecipient);\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, recollect interests from the owner\r\n            account.lDebt = gentleSub(account.lDebt, rAmount);\r\n            account.sInternalAmount = gentleSub(account.sInternalAmount, sInternalAmount);\r\n\r\n            _updateLoanStats(owner, owner, account.hatID, false, rAmount, sInternalAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Optimized recollect and distribute loan for the same hat\r\n     * @param src Source address\r\n     * @param dst Destination address\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     */\r\n    function sameHatTransfer(\r\n        address src,\r\n        address dst,\r\n        uint256 hatID,\r\n        uint256 rAmount) internal {\r\n        // accrue interest so estimate is up to date\r\n        require(ias.accrueInterest(), \u0022accrueInterest failed\u0022);\r\n\r\n        Account storage srcAccount = accounts[src];\r\n        Account storage dstAccount = accounts[dst];\r\n\r\n        uint256 sInternalAmount = rToSInternal(rAmount);\r\n\r\n        srcAccount.lDebt = gentleSub(srcAccount.lDebt, rAmount);\r\n        srcAccount.sInternalAmount = gentleSub(srcAccount.sInternalAmount, sInternalAmount);\r\n        _updateLoanStats(src, src, hatID, false, rAmount, sInternalAmount);\r\n\r\n        dstAccount.lDebt = dstAccount.lDebt.add(rAmount);\r\n        dstAccount.sInternalAmount = dstAccount.sInternalAmount.add(sInternalAmount);\r\n        _updateLoanStats(dst, dst, hatID, true, rAmount, sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev pay interest to the owner\r\n     * @param owner Account owner address\r\n     */\r\n    function payInterestInternal(address owner) internal {\r\n        Account storage account = accounts[owner];\r\n        AccountStatsStored storage stats = accountStats[owner];\r\n\r\n        require(ias.accrueInterest(), \u0022accrueInterest failed\u0022);\r\n        uint256 interestAmount = getInterestPayableOf(account);\r\n\r\n        if (interestAmount \u003E 0) {\r\n            stats.cumulativeInterest = stats\r\n                .cumulativeInterest\r\n                .add(interestAmount);\r\n            account.rInterest = account.rInterest.add(interestAmount);\r\n            account.rAmount = account.rAmount.add(interestAmount);\r\n            totalSupply = totalSupply.add(interestAmount);\r\n            emit InterestPaid(owner, interestAmount);\r\n            emit Transfer(address(0), owner, interestAmount);\r\n        }\r\n    }\r\n\r\n    function _updateLoanStats(\r\n        address owner,\r\n        address recipient,\r\n        uint256 hatID,\r\n        bool isDistribution,\r\n        uint256 redeemableAmount,\r\n        uint256 sInternalAmount) private {\r\n        HatStatsStored storage hatStats = hatStats[hatID];\r\n\r\n        emit LoansTransferred(owner, recipient, hatID,\r\n            isDistribution,\r\n            redeemableAmount,\r\n            sInternalAmount);\r\n\r\n        if (isDistribution) {\r\n            hatStats.totalLoans = hatStats.totalLoans.add(redeemableAmount);\r\n            hatStats.totalInternalSavings = hatStats.totalInternalSavings\r\n                .add(sInternalAmount);\r\n        } else {\r\n            hatStats.totalLoans = gentleSub(hatStats.totalLoans, redeemableAmount);\r\n            hatStats.totalInternalSavings = gentleSub(\r\n                hatStats.totalInternalSavings,\r\n                sInternalAmount);\r\n        }\r\n    }\r\n\r\n    function _isContract(address addr) private view returns (bool) {\r\n      uint size;\r\n      assembly { size := extcodesize(addr) }\r\n      return size \u003E 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gently subtract b from a without revert\r\n     *\r\n     * Due to the use of integer arithmatic, imprecision may cause a tiny\r\n     * amount to be off when substracting the otherwise precise proportions.\r\n     */\r\n    function gentleSub(uint256 a, uint256 b) private pure returns (uint256) {\r\n        if (a \u003C b) return 0;\r\n        else return a - b;\r\n    }\r\n\r\n    /// @dev convert internal savings amount to redeemable amount\r\n    function sInternalToR(uint256 sInternalAmount)\r\n        private view\r\n        returns (uint256 rAmount) {\r\n        // - rGross is in underlying(redeemable) asset unit\r\n        // - Both ias.exchangeRateStored and savingAssetConversionRate are scaled by 1e18\r\n        //   they should cancel out\r\n        // - Formula:\r\n        //   savingsOriginalAmount = sInternalAmount / savingAssetConversionRate\r\n        //   rGross = savingAssetOrignalAmount * ias.exchangeRateStored\r\n        //   =\u003E\r\n        return sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate);\r\n    }\r\n\r\n    /// @dev convert redeemable amount to internal savings amount\r\n    function rToSInternal(uint256 rAmount)\r\n        private view\r\n        returns (uint256 sInternalAmount) {\r\n        return rAmount\r\n            .mul(savingAssetConversionRate)\r\n            .div(ias.exchangeRateStored());\r\n    }\r\n\r\n    /// @dev convert original savings amount to redeemable amount\r\n    function sOriginalToR(uint sOriginalAmount)\r\n        private view\r\n        returns (uint256 sInternalAmount) {\r\n        return sOriginalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\r\n    }\r\n\r\n    // @dev convert from original savings amount to internal savings amount\r\n    function sOriginalToSInternal(uint sOriginalAmount)\r\n        private view\r\n        returns (uint256 sInternalAmount) {\r\n        // savingAssetConversionRate is scaled by 1e18\r\n        return sOriginalAmount\r\n            .mul(savingAssetConversionRate)\r\n            .div(ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE);\r\n    }\r\n}","ABI":"[{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022strategy\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022conversionRate\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AllocationStrategyChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newCode\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CodeUpdated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022oldHatID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newHatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022HatChanged\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022HatCreated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022InterestPaid\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatId\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022isDistribution\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022redeemableAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022internalSavingsAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LoansTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ALLOCATION_STRATEGY_EXCHANGE_RATE_SCALE\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022INITIAL_SAVING_ASSET_CONVERSION_RATE\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_NUM_HAT_RECIPIENTS\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_UINT256\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022PROPORTION_BASE\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022SELF_HAT_ID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_guardCounter\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022accountStats\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022cumulativeInterest\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022accounts\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rInterest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lDebt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sInternalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022allocationStrategy_\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022changeAllocationStrategy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022changeHat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022contractAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022changeHatFor\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint32[]\u0022,\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022doChangeHat\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022createHat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getAccountStats\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rInterest\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lDebt\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sInternalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rInterestPayable\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022cumulativeInterest\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct RTokenStructs.AccountStatsView\u0022,\u0022name\u0022:\u0022stats\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentAllocationStrategy\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022allocationStrategy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentSavingStrategy\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getGlobalStats\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalSupply\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalSavingsAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct RTokenStructs.GlobalStats\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getHatByAddress\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint32[]\u0022,\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getHatByID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint32[]\u0022,\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getHatStats\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022useCount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalLoans\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalSavings\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct RTokenStructs.HatStatsView\u0022,\u0022name\u0022:\u0022stats\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMaximumHatID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getSavingAssetBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022rAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022sOriginalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022hatStats\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022useCount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalLoans\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalInternalSavings\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ias\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IAllocationStrategy\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract IAllocationStrategy\u0022,\u0022name\u0022:\u0022allocationStrategy\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022name_\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022symbol_\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022decimals_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022initialize\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initialized\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022interestPayableOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mint\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022address[]\u0022,\u0022name\u0022:\u0022recipients\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022internalType\u0022:\u0022uint32[]\u0022,\u0022name\u0022:\u0022proportions\u0022,\u0022type\u0022:\u0022uint32[]\u0022}],\u0022name\u0022:\u0022mintWithNewHat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022mintAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022hatID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mintWithSelectedHat\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022payInterest\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022proxiableUUID\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022receivedLoanOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022receivedSavingsOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022redeemTokens\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022redeem\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022redeemAll\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022redeemTo\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022redeemTokens\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022redeemAndTransfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022redeemTo\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022redeemAndTransferAll\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022savingAssetConversionRate\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022savingAssetOrignalAmount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022token\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract IERC20\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferAll\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022src\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferAllFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferAllowances\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022src\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022dst\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newCode\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022updateCode\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"RToken","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8415e10175f2064617a600dfa398db7ebd81849a3f7ba6344feadba230e2ac69"}]