[{"SourceCode":"/*\r\n\r\n    Copyright 2019 The Hydro Protocol Foundation\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IPriceOracle {\r\n    /** return USD price of token */\r\n    function getPrice(\r\n        address asset\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    // Multiplies two numbers, reverts on overflow.\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022MUL_ERROR\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    // Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    function div(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b \u003E 0, \u0022DIVIDING_ERROR\u0022);\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder \u003E 0) {\r\n            return quotient \u002B 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    // Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b \u003C= a, \u0022SUB_ERROR\u0022);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b \u003C= 2**255-1, \u0022INT256_SUB_ERROR\u0022);\r\n        int256 c = a - int256(b);\r\n        require(c \u003C= a, \u0022INT256_SUB_ERROR\u0022);\r\n        return c;\r\n    }\r\n\r\n    // Adds two numbers, reverts on overflow.\r\n    function add(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022ADD_ERROR\u0022);\r\n        return c;\r\n    }\r\n\r\n    function add(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b \u003C= 2**255 - 1, \u0022INT256_ADD_ERROR\u0022);\r\n        int256 c = a \u002B int256(b);\r\n        require(c \u003E= a, \u0022INT256_ADD_ERROR\u0022);\r\n        return c;\r\n    }\r\n\r\n    // Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, \u0022MOD_ERROR\u0022);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\r\n     * do this, we check the remainder and make sure it\u0027s proportionally less than 0.1%. So we have:\r\n     *\r\n     *     ((numerator * multiple) % denominator)     1\r\n     *     -------------------------------------- \u003C ----\r\n     *              numerator * multiple            1000\r\n     *\r\n     * To avoid further division, we can move the denominators to the other sides and we get:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 \u003C numerator * multiple\r\n     *\r\n     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\r\n     * final equation becomes:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 \u003E= numerator * multiple\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return Boolean indicating if there is a rounding error when calculating the proportion\r\n     */\r\n    function isRoundingError(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // numerator.mul(multiple).mod(denominator).mul(1000) \u003E= numerator.mul(multiple)\r\n        return mul(mod(mul(numerator, multiple), denominator), 1000) \u003E= mul(numerator, multiple);\r\n    }\r\n\r\n    /**\r\n     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\r\n     * pair of values. The final value will be rounded down to the nearest integer value.\r\n     *\r\n     * This function will revert the transaction if rounding the final value down would lose more\r\n     * than 0.1% precision.\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return The final proportion of multiple rounded down\r\n     */\r\n    function getPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(!isRoundingError(numerator, denominator, multiple), \u0022ROUNDING_ERROR\u0022);\r\n        // numerator.mul(multiple).div(denominator)\r\n        return div(mul(numerator, multiple), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns the smaller integer of the two passed in.\r\n     *\r\n     * @param a Unsigned integer\r\n     * @param b Unsigned integer\r\n     * @return The smaller of the two integers\r\n     */\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a \u003C b ? a : b;\r\n    }\r\n}\r\n\r\ncontract PriceOracleProxy {\r\n    using SafeMath for uint256;\r\n\r\n    address public asset;\r\n    uint256 public decimal;\r\n    address public sourceOracleAddress;\r\n    address public sourceAssetAddress;\r\n    uint256 public sourceAssetDecimal;\r\n\r\n    constructor (\r\n        address _asset,\r\n        uint256 _decimal,\r\n        address _sourceOracleAddress,\r\n        address _sourceAssetAddress,\r\n        uint256 _sourceAssetDecimal\r\n    )\r\n        public\r\n    {\r\n        asset = _asset;\r\n        decimal = _decimal;\r\n        sourceOracleAddress = _sourceOracleAddress;\r\n        sourceAssetAddress = _sourceAssetAddress;\r\n        sourceAssetDecimal = _sourceAssetDecimal;\r\n    }\r\n\r\n    function _getPrice()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 price = IPriceOracle(sourceOracleAddress).getPrice(sourceAssetAddress);\r\n\r\n        if (decimal \u003E= sourceAssetDecimal) {\r\n            price = price.div(10 ** (decimal - sourceAssetDecimal));\r\n        } else {\r\n            price = price.mul(10 ** (sourceAssetDecimal - decimal));\r\n        }\r\n\r\n        return price;\r\n    }\r\n\r\n    function getPrice(\r\n        address _asset\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_asset == asset, \u0022ASSET_NOT_MATCH\u0022);\r\n        return _getPrice();\r\n    }\r\n\r\n    function getCurrentPrice()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getPrice();\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022sourceAssetAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022asset\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getPrice\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimal\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022sourceOracleAddress\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getCurrentPrice\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022sourceAssetDecimal\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_decimal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_sourceOracleAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_sourceAssetAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_sourceAssetDecimal\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"PriceOracleProxy","CompilerVersion":"v0.5.8\u002Bcommit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000316eb71485b0ab14103307bf65a021042c6d38000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000bde1ebe3cc81314ceeb19d41ef774f1185ca44c0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000000000000000000000000000000000000000008","Library":"","SwarmSource":"bzzr://ad442cce68ba719a325de53dc27bf1ba3f0818d06617f265ea0b255de3124909"}]