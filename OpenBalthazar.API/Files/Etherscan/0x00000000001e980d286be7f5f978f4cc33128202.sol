[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaUpgradeBeaconEnvoyInterface {\r\n  function getImplementation(address beacon) external view returns (address implementation);\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaDaiUpgradeBeaconController\r\n * @author 0age\r\n * @notice This contract has exclusive control over modifications to the stored\r\n * implementation address on controlled \u0022upgrade beacon\u0022 contracts. It is an\r\n * owned contract, where ownership can be transferred to another contract - that\r\n * way, the upgrade mechanism itself can be \u0022upgraded\u0022. Apart from the ownable\r\n * methods, this contract is deliberately simple and only has one non-view\r\n * method - \u0060upgrade\u0060. Timelocks or other upgrade conditions will be managed by\r\n * the owner of this contract.\r\n */\r\ncontract DharmaDaiUpgradeBeaconController {\r\n  // Fire an event whenever ownership of this contract changes.\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  // Fire an event any time a new implementation is set on an upgrade beacon.\r\n  event Upgraded(\r\n    address indexed upgradeBeacon,\r\n    address oldImplementation,\r\n    bytes32 oldImplementationCodeHash,\r\n    address newImplementation,\r\n    bytes32 newImplementationCodeHash\r\n  );\r\n\r\n  // Store address of owner - ownership modeled after OpenZeppelin\u0027s \u0060Ownable\u0060.\r\n  address private _owner;\r\n\r\n  // Store a mapping of the implementation code hash at the time of the last\r\n  // upgrade for each beacon. This can be used by calling contracts to verify\r\n  // that the implementation has not been altered since it was initially set.\r\n  mapping(address =\u003E bytes32) private _codeHashAtLastUpgrade;\r\n\r\n  // The Upgrade Beacon Envoy is used to check the implementation of a beacon.\r\n  DharmaUpgradeBeaconEnvoyInterface private constant _UPGRADE_BEACON_ENVOY = (\r\n    DharmaUpgradeBeaconEnvoyInterface(\r\n      0x000000000067503c398F4c9652530DBC4eA95C02\r\n    )\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, set the transaction submitter as the initial\r\n   * owner of this contract and verify the runtime code of the referenced\r\n   * upgrade beacon envoy.\r\n   */\r\n  constructor() public {\r\n    // Set the transaction submitter as the initial owner of this contract.\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), tx.origin);\r\n\r\n    // Ensure the upgrade beacon envoy has the expected runtime code.\r\n    address envoy = address(_UPGRADE_BEACON_ENVOY);\r\n    bytes32 envoyCodeHash;\r\n    assembly { envoyCodeHash := extcodehash(envoy)}\r\n    require(\r\n      envoyCodeHash == bytes32(\r\n        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\r\n      ),\r\n      \u0022Upgrade Beacon Envoy runtime code is incorrect.\u0022\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new implementation address on an upgrade beacon contract.\r\n   * This function may only be called by the owner of this contract.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function upgrade(address beacon, address implementation) external onlyOwner {\r\n    // Ensure that the implementaton contract is not the null address.\r\n    require(implementation != address(0), \u0022Must specify an implementation.\u0022);\r\n\r\n    // Ensure that the implementation contract has code via extcodesize.\r\n    uint256 implementationSize;\r\n    assembly { implementationSize := extcodesize(implementation) }\r\n    require(implementationSize \u003E 0, \u0022Implementation must have contract code.\u0022);\r\n\r\n    // Ensure that the beacon contract is not the null address.\r\n    require(beacon != address(0), \u0022Must specify an upgrade beacon.\u0022);\r\n\r\n    // Ensure that the upgrade beacon contract has code via extcodesize.\r\n    uint256 beaconSize;\r\n    assembly { beaconSize := extcodesize(beacon) }\r\n    require(beaconSize \u003E 0, \u0022Upgrade beacon must have contract code.\u0022);\r\n\r\n    // Update the upgrade beacon with the new implementation address.\r\n    _update(beacon, implementation);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n   * This function may only be called by the owner of this contract.\r\n   * @param newOwner Address of the new owner to set.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to the null account, thereby\r\n   * preventing it from being used to perform upgrades in the future. This\r\n   * function may only be called by the owner of this contract.\r\n   */\r\n  function renounceOwnership() external onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the existing implementation on a given\r\n   * beacon. This is accomplished via a staticcall to the upgrade beacon envoy,\r\n   * which in turn performs a staticcall into the given beacon and passes along\r\n   * the returned implementation address.\r\n   * @param beacon Address of the upgrade beacon to check for an implementation.\r\n   * @return implementation Address of the implementation.\r\n   */\r\n  function getImplementation(\r\n    address beacon\r\n  ) external view returns (address implementation) {\r\n    // Perform a staticcall into envoy, supplying the beacon as the argument.\r\n    implementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the runtime code hash of a beacon\u0027s\r\n   * implementation contract at the time it was last updated. This can be used\r\n   * by other callers to verify that the implementation has not been altered\r\n   * since it was last updated by comparing this value to the current runtime\r\n   * code hash of the beacon\u0027s implementation contract. Note that this function\r\n   * will return \u0060bytes32(0)\u0060 in the event the supplied beacon has not yet been\r\n   * updated.\r\n   * @param beacon Address of the upgrade beacon to check for a code hash.\r\n   * @return codeHashAtLastUpgrade Runtime code hash of the implementation\r\n   * contract when the beacon was last updated.\r\n   */\r\n  function getCodeHashAtLastUpgrade(\r\n    address beacon\r\n  ) external view returns (bytes32 codeHashAtLastUpgrade) {\r\n    // Return the code hash that was set when the given beacon was last updated.\r\n    codeHashAtLastUpgrade = _codeHashAtLastUpgrade[beacon];\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the current owner.\r\n   * @return The address of the owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the caller is the current owner.\r\n   * @return True if the caller is the current owner, else false.\r\n   */\r\n  function isOwner() external view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == _owner, \u0022Ownable: caller is not the owner\u0022);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to perform an update to a given upgrade beacon and\r\n   * determine the runtime code hash of both the old and the new implementation.\r\n   * The latest code hash for the new implementation of the given beacon will be\r\n   * updated, and an event containing the beacon, the old and new implementation\r\n   * addresses, and the old and new implementation runtime code hashes will be\r\n   * emitted.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function _update(address beacon, address implementation) private {\r\n    // Get the address of the current implementation set on the upgrade beacon.\r\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the current implementation.\r\n    bytes32 oldImplementationCodeHash;\r\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\r\n\r\n    // Call into beacon and supply address of new implementation to update it.\r\n    (bool success,) = beacon.call(abi.encode(implementation));\r\n\r\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\r\n    if (!success) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n\r\n    // Get address of the new implementation that was set on the upgrade beacon.\r\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the new implementation.\r\n    bytes32 newImplementationCodeHash;\r\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\r\n\r\n    // Set runtime code hash of the new implementation for the given beacon.\r\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\r\n\r\n    // Emit an event to signal that the upgrade beacon was updated.\r\n    emit Upgraded(\r\n      beacon,\r\n      oldImplementation,\r\n      oldImplementationCodeHash,\r\n      newImplementation,\r\n      newImplementationCodeHash\r\n    );\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022beacon\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getImplementation\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022implementation\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022beacon\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022implementation\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022upgrade\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022beacon\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getCodeHashAtLastUpgrade\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022codeHashAtLastUpgrade\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022upgradeBeacon\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022oldImplementation\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022oldImplementationCodeHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newImplementation\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022newImplementationCodeHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022Upgraded\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"DharmaDaiUpgradeBeaconController","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://446861726d6144616955706772616465426561636f6e436f6e74726f6c6c6572"}]