[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-11-23\r\n*/\r\n\r\npragma solidity ^0.5.13;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b \u003E 0);\r\n        uint c = a / b;\r\n        require(a == b * c \u002B a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b \u003C= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a \u002B b;\r\n        require(c \u003E= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a \u003E= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a \u003E= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a \u003C b ? a : b;\r\n    }\r\n}\r\n\r\ninterface GeneralERC20 {\r\n\tfunction transfer(address to, uint256 value) external;\r\n\tfunction transferFrom(address from, address to, uint256 value) external;\r\n\tfunction approve(address spender, uint256 value) external;\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tfunction checkSuccess()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 returnValue = 0;\r\n\r\n\t\tassembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don\u0027t mark as success\r\n\t\t\tdefault { }\r\n\t\t}\r\n\r\n\t\treturn returnValue != 0;\r\n\t}\r\n\r\n\tfunction transfer(address token, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transfer(to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction approve(address token, address spender, uint256 amount) internal {\r\n\t\tGeneralERC20(token).approve(spender, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n}\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// AIP: https://github.com/AdExNetwork/aips/issues/18\r\n// Quick overview:\r\n// - it\u0027s divided into pools, each pool may represent a validator; it may represent something else too (for example, we may launch staking for publishers to prove their legitimacy)\r\n// - the slasherAddr will be a multisig that will be controlled by the AdEx team - and later full control of the multisig will be given to a bridge to Polkadot, where we\u0027ll run the full on-chain slashing mechanism\r\n//   - we will clearly communicate this migration path to our community and stakers\r\n// - reward distribution is off-chain: depending on the pool, it may be done either via OUTPACE, via the Polkadot parachain, or via an auxilary contract that implements round-based reward distribution (you check into each round, the SC confirms you have a bond on Staking.sol, and you can withdraw your pro-rata earnings for the round)\r\n// - each bond will be slashed relative to the time it bonded/unbonded; e.g. if the pool is slashed 12%, you bonded, then the pool was slashed 2%, then you unbonded, you\u0027d only suffer a 2% slash\r\n\r\nlibrary BondLibrary {\r\n\tstruct Bond {\r\n\t\tuint amount;\r\n\t\tbytes32 poolId;\r\n\t\tuint nonce;\r\n\t}\r\n\r\n\tfunction hash(Bond memory bond, address sender)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encode(\r\n\t\t\taddress(this),\r\n\t\t\tsender,\r\n\t\t\tbond.amount,\r\n\t\t\tbond.poolId,\r\n\t\t\tbond.nonce\r\n\t\t));\r\n\t}\r\n}\r\n\r\ncontract Staking {\r\n\tusing SafeMath for uint;\r\n\tusing BondLibrary for BondLibrary.Bond;\r\n\r\n\tstruct BondState {\r\n\t\tbool active;\r\n\t\tuint64 slashedAtStart;\r\n\t\tuint64 willUnlock;\r\n\t}\r\n\r\n\t// could be 2**64 too, since we use uint64\r\n\tuint constant MAX_SLASH = 10 ** 18;\r\n\tuint constant TIME_TO_UNBOND = 30 days;\r\n\taddress constant BURN_ADDR = address(0xaDbeEF0000000000000000000000000000000000);\r\n\r\n\taddress public tokenAddr;\r\n\taddress public slasherAddr;\r\n\t// Addressed by poolId\r\n\tmapping (bytes32 =\u003E uint) public slashPoints;\r\n\t// Addressed by bondId\r\n\tmapping (bytes32 =\u003E BondState) public bonds;\r\n\r\n\tconstructor(address token, address slasher) public {\r\n   \t\ttokenAddr = token;\r\n   \t\tslasherAddr = slasher;\r\n\t}\r\n\r\n\tfunction slash(bytes32 poolId, uint pts) external {\r\n\t\trequire(msg.sender == slasherAddr, \u0027ONLY_SLASHER\u0027);\r\n\t\tuint newSlashPts = slashPoints[poolId].add(pts);\r\n\t\trequire(newSlashPts \u003C= MAX_SLASH, \u0027PTS_TOO_HIGH\u0027);\r\n\t\tslashPoints[poolId] = newSlashPts;\r\n\t}\r\n\r\n\tfunction addBond(BondLibrary.Bond memory bond) public {\r\n\t\tbytes32 id = bond.hash(msg.sender);\r\n\t\trequire(!bonds[id].active, \u0027BOND_ALREADY_ACTIVE\u0027);\r\n\t\trequire(slashPoints[bond.poolId] \u003C MAX_SLASH, \u0027POOL_SLASHED\u0027);\r\n\t\tbonds[id] = BondState({\r\n\t\t\tactive: true,\r\n\t\t\tslashedAtStart: uint64(slashPoints[bond.poolId]),\r\n\t\t\twillUnlock: 0\r\n\t\t});\r\n\t\tSafeERC20.transferFrom(tokenAddr, msg.sender, address(this), bond.amount);\r\n\t}\r\n\r\n\tfunction requestUnbond(BondLibrary.Bond memory bond) public {\r\n\t\tBondState storage bondState = bonds[bond.hash(msg.sender)];\r\n\t\trequire(bondState.active \u0026\u0026 bondState.willUnlock == 0, \u0027BOND_NOT_ACTIVE\u0027);\r\n\t\tbondState.willUnlock = uint64(now \u002B TIME_TO_UNBOND);\r\n\t}\r\n\r\n\tfunction unbond(BondLibrary.Bond memory bond) public {\r\n\t\tbytes32 id = bond.hash(msg.sender);\r\n\t\tBondState storage bondState = bonds[id];\r\n\t\trequire(bondState.willUnlock \u003E 0 \u0026\u0026 now \u003E bondState.willUnlock, \u0027BOND_NOT_UNLOCKED\u0027);\r\n\t\tuint amount = calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\r\n\t\tuint toBurn = bond.amount - amount;\r\n\t\tdelete bonds[id];\r\n\t\tSafeERC20.transfer(tokenAddr, msg.sender, amount);\r\n\t\tSafeERC20.transfer(tokenAddr, BURN_ADDR, toBurn);\r\n\t}\r\n\r\n\tfunction getWithdrawAmount(address owner, BondLibrary.Bond memory bond) public view returns (uint) {\r\n\t\tBondState storage bondState = bonds[bond.hash(owner)];\r\n\t\tif (!bondState.active) return 0;\r\n\t\treturn calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\r\n\t}\r\n\r\n\tfunction calcWithdrawAmount(BondLibrary.Bond memory bond, uint slashedAtStart) internal view returns (uint) {\r\n\t\treturn bond.amount\r\n\t\t\t.mul(MAX_SLASH.sub(slashPoints[bond.poolId]))\r\n\t\t\t.div(MAX_SLASH.sub(slashedAtStart));\r\n\t}\r\n}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022slasher\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct BondLibrary.Bond\u0022,\u0022name\u0022:\u0022bond\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022addBond\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022bonds\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022active\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint64\u0022,\u0022name\u0022:\u0022slashedAtStart\u0022,\u0022type\u0022:\u0022uint64\u0022},{\u0022internalType\u0022:\u0022uint64\u0022,\u0022name\u0022:\u0022willUnlock\u0022,\u0022type\u0022:\u0022uint64\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct BondLibrary.Bond\u0022,\u0022name\u0022:\u0022bond\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022getWithdrawAmount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct BondLibrary.Bond\u0022,\u0022name\u0022:\u0022bond\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022requestUnbond\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022pts\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022slash\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022slashPoints\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022slasherAddr\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenAddr\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022components\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022poolId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022internalType\u0022:\u0022struct BondLibrary.Bond\u0022,\u0022name\u0022:\u0022bond\u0022,\u0022type\u0022:\u0022tuple\u0022}],\u0022name\u0022:\u0022unbond\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"Staking","CompilerVersion":"v0.5.13\u002Bcommit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004470bb87d77b963a013db939be332f927f2b992e00000000000000000000000023c2c34f38ce66ccc10e71e9bb2a06532d52c5e9","Library":"","SwarmSource":"bzzr://c84f0c114eb7e6fe3f28a839a1d1aa010209d04ac0a687c3b8eb39c46b1c7680"}]