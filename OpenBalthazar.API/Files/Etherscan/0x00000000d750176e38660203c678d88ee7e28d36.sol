[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Timelocker\r\n * @author 0age\r\n * @notice This contract allows contracts that inherit it to implement timelocks\r\n * on functions, where the \u0060setTimelock\u0060 function must first be called, with the\r\n * same arguments that the function will be supplied with. Then, a given time\r\n * interval must first fully transpire before the timelock functions can be\r\n * successfully called. It also includes a \u0060modifyTimelockInterval\u0060 function\r\n * that is itself able to be timelocked, and that is given a function selector\r\n * and a new timelock interval for the function as arguments. To make a function\r\n * timelocked, use the \u0060_enforceTimelock\u0060 internal function. To set initial\r\n * minimum timelock intervals, use the \u0060_setInitialTimelockInterval\u0060 internal\r\n * function - it can only be used from within a constructor. Finally, there are\r\n * two public getters: \u0060getTimelock\u0060 and \u0060getTimelockInterval\u0060.\r\n */\r\ncontract Timelocker {\r\n  using SafeMath for uint256;\r\n\r\n  // Fire an event any time a timelock is initiated.\r\n  event TimelockInitiated(\r\n    bytes4 functionSelector, // selector of the function \r\n    uint256 timeComplete,    // timestamp at which the function can be called\r\n    bytes arguments          // abi-encoded function arguments to call with\r\n  );\r\n\r\n  // Fire an event any time a minimum timelock interval is modified.\r\n  event TimelockIntervalModified(\r\n    bytes4 functionSelector, // selector of the function \r\n    uint256 oldInterval,     // new minimum timelock interval for the function\r\n    uint256 newInterval      // new minimum timelock interval for the function\r\n  );\r\n\r\n  // Implement a timelock for each function and set of arguments.\r\n  mapping(bytes4 =\u003E mapping(bytes32 =\u003E uint256)) private _timelocks;\r\n\r\n  // Implement a timelock interval for each timelocked function.\r\n  mapping(bytes4 =\u003E uint256) private _timelockIntervals;\r\n\r\n  /**\r\n   * @notice Public function for setting a new timelock interval for a given \r\n   * function selector. The default for this function may also be modified, but\r\n   * excessive values will cause the \u0060modifyTimelockInterval\u0060 function to become\r\n   * unusable.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function modifyTimelockInterval(\r\n    bytes4 functionSelector,\r\n    uint256 newTimelockInterval\r\n  ) public {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(\r\n      this.modifyTimelockInterval.selector, abi.encode(newTimelockInterval)\r\n    );\r\n\r\n    // Set new timelock interval and emit a \u0060TimelockIntervalModified\u0060 event.\r\n    _setTimelockInterval(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check if a timelock for the specified function and\r\n   * arguments has completed.\r\n   * @param functionSelector function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @return A boolean indicating if the timelock exists or not and the time at\r\n   * which the timelock completes if it does exist.\r\n   */\r\n  function getTimelock(\r\n    bytes4 functionSelector,\r\n    bytes memory arguments\r\n  ) public view returns (bool exists, uint256 completionTime) {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get the current timelock, if any.\r\n    completionTime = _timelocks[functionSelector][timelockID];\r\n    exists = completionTime != 0;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the current minimum timelock interval on a\r\n   * given function.\r\n   * @param functionSelector function to retrieve the timelock interval for.\r\n   * @return The current minimum timelock interval for the given function.\r\n   */\r\n  function getTimelockInterval(\r\n    bytes4 functionSelector\r\n  ) public view returns (uint256 timelockInterval) {\r\n    timelockInterval = _timelockIntervals[functionSelector];\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function that sets a timelock so that the specified\r\n   * function can be called with the specified arguments. Note that existing\r\n   * timelocks may be extended, but not shortened - this can also be used as a\r\n   * method for \u0022cancelling\u0022 a function call by extending the timelock to an\r\n   * arbitrarily long duration. Keep in mind that new timelocks may be created\r\n   * with a shorter duration on functions that already have other timelocks on\r\n   * them, but only if they have different arguments.\r\n   * @param functionSelector selector of the function to be called.   \r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @param extraTime Additional time in seconds to add to the minimum timelock\r\n   * interval for the given function.\r\n   */\r\n  function _setTimelock(\r\n    bytes4 functionSelector,\r\n    bytes memory arguments,\r\n    uint256 extraTime\r\n  ) internal {\r\n    // Get timelock using current time, inverval for timelock ID, \u0026 extra time.\r\n    uint256 timelock = _timelockIntervals[functionSelector].add(now).add(\r\n      extraTime\r\n    );\r\n\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get the current timelock, if any.\r\n    uint256 currentTimelock = _timelocks[functionSelector][timelockID];\r\n\r\n    // Ensure that the timelock duration does not decrease. Note that a new,\r\n    // shorter timelock may still be set up on the same function in the event\r\n    // that it is provided with different arguments.\r\n    require(\r\n      currentTimelock == 0 || timelock \u003E currentTimelock,\r\n      \u0022Existing timelocks may only be extended.\u0022\r\n    );\r\n\r\n    // Set time that timelock will be complete using timelock ID and extra time.\r\n    _timelocks[functionSelector][timelockID] = timelock;\r\n\r\n    // Emit an event with all of the relevant information.\r\n    emit TimelockInitiated(functionSelector, timelock, arguments);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an initial timelock interval for a given\r\n   * function selector. Only callable during contract creation.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setInitialTimelockInterval(\r\n    bytes4 functionSelector,\r\n    uint256 newTimelockInterval\r\n  ) internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n    \r\n    // Set the timelock interval and emit a \u0060TimelockIntervalModified\u0060 event.\r\n    _setTimelockInterval(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to ensure that a timelock is complete and to\r\n   * clear the existing timelock so it cannot later be reused.\r\n   * @param functionSelector function to be called.   \r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   */\r\n  function _enforceTimelock(\r\n    bytes4 functionSelector,\r\n    bytes memory arguments\r\n  ) internal {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get the current timelock, if any.\r\n    uint256 currentTimelock = _timelocks[functionSelector][timelockID];\r\n\r\n    // Ensure that the timelock is set and has completed.\r\n    require(\r\n      currentTimelock != 0 \u0026\u0026 currentTimelock \u003C= now,\r\n      \u0022Function cannot be called until a timelock has been set and has expired.\u0022\r\n    );\r\n\r\n    // Clear out the existing timelock so that it cannot be reused.\r\n    delete _timelocks[functionSelector][timelockID];\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for setting a new timelock interval for a given \r\n   * function selector.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setTimelockInterval(\r\n    bytes4 functionSelector,\r\n    uint256 newTimelockInterval\r\n  ) private {\r\n    // Get the existing timelock interval, if any.\r\n    uint256 oldTimelockInterval = _timelockIntervals[functionSelector];\r\n    \r\n    // Update the timelock interval on the provided function.\r\n    _timelockIntervals[functionSelector] = newTimelockInterval;\r\n\r\n    // Emit a \u0060TimelockIntervalModified\u0060 event with the appropriate arguments.\r\n    emit TimelockIntervalModified(\r\n      functionSelector, oldTimelockInterval, newTimelockInterval\r\n    );\r\n  }\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletRecovery {\r\n  function recover(address newUserSigningKey) external;\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaAccountRecoveryManager\r\n * @author 0age\r\n * @notice This contract will be owned by DharmaAccountRecoveryMultisig and will\r\n * manage resets to the user\u0027s signing key. It implements a set of timelocked\r\n * functions, where the \u0060setTimelock\u0060 function must first be called, with the\r\n * same arguments that the function will be supplied with. Then, a given time\r\n * interval must first fully transpire before the timelock functions can be\r\n * successfully called.\r\n *\r\n * The timelocked functions currently implemented include:\r\n *  recover(address wallet, address newUserSigningKey)\r\n *  modifyTimelockInterval(bytes4 functionSelector, uint256 newTimelockInterval)\r\n *\r\n * Note that special care should be taken to differentiate between lost keys and\r\n * compromised keys, and that the danger of a user being impersonated is\r\n * extremely high. Account recovery should progress to a system where the user\r\n * builds their preferred account recovery procedure into a \u0022key ring\u0022 smart\r\n * contract at their signing address, reserving this \u0022hard reset\u0022 for extremely\r\n * unusual circumstances and eventually sunsetting it entirely.\r\n */\r\ncontract DharmaAccountRecoveryManager is Ownable, Timelocker {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain mapping of smart wallets that have opted out of account recovery.\r\n  mapping(address =\u003E bool) private _accountRecoveryDisabled;\r\n\r\n  /**\r\n   * @notice In the constructor, set initial minimum timelock interval values.\r\n   */\r\n  constructor() public {\r\n    // Set initial owner to the transaction submitter.\r\n    _transferOwnership(tx.origin);\r\n\r\n    // Set initial minimum timelock interval values.\r\n    _setInitialTimelockInterval(this.modifyTimelockInterval.selector, 4 weeks);\r\n    _setInitialTimelockInterval(this.recover.selector, 7 days);\r\n    _setInitialTimelockInterval(this.disableAccountRecovery.selector, 3 days);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a timelock so that the specified function can be called with\r\n   * the specified arguments. Note that existing timelocks may be extended, but\r\n   * not shortened - this can also be used as a method for \u0022cancelling\u0022 an\r\n   * account recovery by extending the timelock to an arbitrarily long duration.\r\n   * Keep in mind that new timelocks may be created with a shorter duration on\r\n   * functions that already have other timelocks on them, but only if they have\r\n   * different arguments (i.e. a new wallet or user signing key is specified).\r\n   * Only the owner may call this function.\r\n   * @param functionSelector selector of the function to be called.   \r\n   * @param arguments The abi-encoded arguments of the function to be called -\r\n   * in the case of \u0060recover\u0060, it is the smart wallet address and the new user\r\n   * signing key.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function setTimelock(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 extraTime\r\n  ) external onlyOwner {\r\n    // Set the timelock and emit a \u0060TimelockInitiated\u0060 event.\r\n    _setTimelock(functionSelector, arguments, extraTime);\r\n  }\r\n\r\n  /**\r\n   * @notice Timelocked function to set a new user signing key on a smart\r\n   * wallet. Only the owner may call this function.\r\n   * @param wallet Address of the smart wallet to recover a key on.\r\n   * @param newUserSigningKey Address of the new signing key for the user.\r\n   */\r\n  function recover(\r\n    address wallet,\r\n    address newUserSigningKey\r\n  ) external onlyOwner {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(\r\n      this.recover.selector, abi.encode(wallet, newUserSigningKey)\r\n    );\r\n\r\n    // Ensure that the wallet in question has not opted out of account recovery.\r\n    require(\r\n      !_accountRecoveryDisabled[wallet],\r\n      \u0022This wallet has elected to opt out of account recovery functionality.\u0022\r\n    );\r\n    \r\n    // Call the specified smart wallet and supply the new user signing key.\r\n    DharmaSmartWalletRecovery(wallet).recover(newUserSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Timelocked function to opt a given wallet out of account recovery.\r\n   * This action cannot be undone - any future account recovery would require an\r\n   * upgrade to the smart wallet implementation itself and is not likely to be\r\n   * supported. Only the owner may call this function.\r\n   * @param wallet Address of the smart wallet to disable account recovery for.\r\n   */\r\n  function disableAccountRecovery(address wallet) external onlyOwner {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(this.disableAccountRecovery.selector, abi.encode(wallet));\r\n\r\n    // Register the specified wallet as having opted out of account recovery.\r\n    _accountRecoveryDisabled[wallet] = true;\r\n  }\r\n\r\n  /**\r\n   * @notice External function check whether a given smart wallet has disabled\r\n   * account recovery by opting out.\r\n   * @param wallet Address of the smart wallet to check.\r\n   * @return A boolean indicating if account recovery has been disabled for the\r\n   * wallet in question.\r\n   */\r\n  function accountRecoveryDisabled(\r\n    address wallet\r\n  ) external view returns (bool hasDisabledAccountRecovery) {\r\n    // Determine if the wallet in question has opted out of account recovery.\r\n    hasDisabledAccountRecovery = _accountRecoveryDisabled[wallet];\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new timelock interval for a given function selector. The\r\n   * default for this function may also be modified, but has a maximum allowable\r\n   * value of eight weeks. Only the owner may call this function.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval The new timelock interval to set for the given\r\n   * function selector.\r\n   */\r\n  function modifyTimelockInterval(\r\n    bytes4 functionSelector,\r\n    uint256 newTimelockInterval\r\n  ) public onlyOwner {\r\n    // Ensure that a function selector is specified (no 0x00000000 selector).\r\n    require(\r\n      functionSelector != bytes4(0),\r\n      \u0022Function selector cannot be empty.\u0022\r\n    );\r\n\r\n    // Ensure a timelock interval over eight weeks is not set on this function.\r\n    if (functionSelector == this.modifyTimelockInterval.selector) {\r\n      require(\r\n        newTimelockInterval \u003C= 8 weeks,\r\n        \u0022Timelock interval of modifyTimelockInterval cannot exceed eight weeks.\u0022\r\n      );\r\n    }\r\n\r\n    // Continue via logic in the inherited \u0060modifyTimelockInterval\u0060 function.\r\n    Timelocker.modifyTimelockInterval(functionSelector, newTimelockInterval);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022disableAccountRecovery\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022extraTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setTimelock\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022accountRecoveryDisabled\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022hasDisabledAccountRecovery\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022wallet\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newUserSigningKey\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022recover\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022getTimelockInterval\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timelockInterval\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newTimelockInterval\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022modifyTimelockInterval\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022getTimelock\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022exists\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022completionTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timeComplete\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022TimelockInitiated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022oldInterval\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newInterval\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TimelockIntervalModified\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"DharmaAccountRecoveryManager","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2020446861726d614163636f756e745265636f766572794d616e616765722020"}]