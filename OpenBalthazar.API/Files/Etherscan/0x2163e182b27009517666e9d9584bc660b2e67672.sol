[{"SourceCode":"/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity 0.5.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * \u0060revert\u0060 if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /*\r\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports the {IERC165} interface,\r\n     */\r\n    function _supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) \u0026\u0026\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports the interface defined by\r\n     * \u0060interfaceId\u0060. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return _supportsERC165(account) \u0026\u0026\r\n            _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 supports all the interfaces defined in\r\n     * \u0060interfaceIds\u0060. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!_supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i \u003C interfaceIds.length; i\u002B\u002B) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with the \u0060supportsERC165\u0060 method in this library.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r\n        // success determines whether the staticcall succeeded and result determines\r\n        // whether the contract at account indicates support of _interfaceId\r\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\r\n\r\n        return (success \u0026\u0026 result);\r\n    }\r\n\r\n    /**\r\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return success true if the STATICCALL succeeded, false otherwise\r\n     * @return result true if the STATICCALL succeeded and the contract at account\r\n     * indicates support of the interface with identifier interfaceId, false otherwise\r\n     */\r\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\r\n        private\r\n        view\r\n        returns (bool success, bool result)\r\n    {\r\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let encodedParams_data := add(0x20, encodedParams)\r\n            let encodedParams_size := mload(encodedParams)\r\n\r\n            let output := mload(0x40)    // Find empty storage location using \u0022free memory pointer\u0022\r\n            mstore(output, 0x0)\r\n\r\n            success := staticcall(\r\n                30000,                   // 30k gas\r\n                account,                 // To addr\r\n                encodedParams_data,\r\n                encodedParams_size,\r\n                output,\r\n                0x20                     // Outputs are 32 bytes long\r\n            )\r\n\r\n            result := mload(output)      // Load the result\r\n        }\r\n    }\r\n}\r\n\r\ninterface TokenDecimals {\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\n/** @title TokensDecimalsView\r\n *  Utility view contract to fetch decimals from multiple token contracts at once.\r\n */\r\ncontract TokensDecimalsView {\r\n    using ERC165Checker for address;\r\n    \r\n    struct Result {\r\n        bool supportsDecimals;\r\n        uint decimals;\r\n    }\r\n    \r\n    /** @dev Fetch up to 500 tokens decimals.\r\n     *  @param _tokenAddresses The addresses of the token contracts to query.\r\n     *  @return results An array of a struct with two values: whether the address supports the decimals function and number of decimal places (if available) respectively.\r\n     */\r\n    function getDecimals(address[] calldata _tokenAddresses) external view returns (Result[500] memory results) {\r\n        bytes4 INTERFACE_ID_DECIMALS = 0x313ce567;\r\n        for (uint i = 0; i \u003C _tokenAddresses.length; i\u002B\u002B) {\r\n            if (_tokenAddresses[i]._supportsInterface(INTERFACE_ID_DECIMALS)) {\r\n                TokenDecimals token = TokenDecimals(_tokenAddresses[i]);\r\n                results[i] = Result(true, token.decimals());\r\n            } else {\r\n                results[i] = Result(false, 0);\r\n            }\r\n            \r\n        }\r\n    }\r\n   \r\n    function implementsDecimals(address _addr)\r\n        private\r\n        returns (bool _implementsDecimals)\r\n    {\r\n        bytes32 sig = bytes4(keccak256(\u0022decimals()\u0022));\r\n        bool _success = false;\r\n        assembly {\r\n            let x := mload(0x40)    // get free memory\r\n            mstore(x, sig)          // store signature into it\r\n            _success := call(\r\n                5000,   // 5k gas\r\n                _addr,  // to _addr\r\n                0,      // 0 value\r\n                x,      // input is x\r\n                4,      // input length is 4\r\n                x,      // store output to x\r\n                32      // 1 output, 32 bytes\r\n            )\r\n            // _implementsDecimals is: _success \u0026\u0026 output\r\n            _implementsDecimals := and(_success, mload(x))\r\n        }\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_tokenAddresses\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022getDecimals\u0022,\u0022outputs\u0022:[{\u0022components\u0022:[{\u0022name\u0022:\u0022supportsDecimals\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022decimals\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022results\u0022,\u0022type\u0022:\u0022tuple[500]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"TokensDecimalsView","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a590dae90cd63f88c3374eefedaf1714eef1e10ca609d6104409352fe88ccbdb"}]