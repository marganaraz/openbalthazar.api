[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0022SafeMath: subtraction overflow\u0022);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003C= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0022SafeMath: division by zero\u0022);\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003E 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0022SafeMath: modulo by zero\u0022);\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address =\u003E uint[]) lotteryMap;\r\n\r\n            mapping(uint =\u003E address) numToAddr;\r\n\r\n            mapping(address =\u003E uint) personalAmount;\r\n\r\n            mapping(uint =\u003E uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n        \r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number \u002B 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i\u002B\u002B;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract GODGame {\r\n\r\n        address owner;\r\n\r\n        address technologyAddr;\r\n\r\n        address themisAddr;\r\n\r\n        address lotteryAddr;\r\n\r\n        address[] allPlayer;\r\n\r\n        address[] temp = new address[](0);\r\n\r\n        struct GlobalShareholder {\r\n\r\n            address[] shareholdersV1;\r\n\r\n            address[] shareholdersV2;\r\n\r\n            address[] shareholdersV3;\r\n\r\n            address[] shareholdersV4;\r\n        }\r\n\r\n        uint fomoSession;\r\n\r\n        uint depositBalance;\r\n\r\n        GODThemis themis;\r\n\r\n        GODToken godToken;\r\n\r\n        TetherToken tether;\r\n\r\n        GODLottery lottery;\r\n\r\n        mapping(uint =\u003E DappDatasets.Fomo) fomoGame;  \r\n\r\n        mapping(address =\u003E DappDatasets.Player) playerMap;\r\n\r\n        mapping(address =\u003E GlobalShareholder) globalShareholder;\r\n\r\n\r\n        constructor(\r\n                address _owner,\r\n                address _tetherAddr,\r\n                address _godAddr,\r\n                address _themisAddr,\r\n                address _lotteryAddr,\r\n                address _technologyAddr\r\n        )  public {\r\n            owner = _owner;\r\n            tether = TetherToken(_tetherAddr);\r\n            godToken = GODToken(_godAddr);\r\n            themis = GODThemis(_themisAddr);\r\n            lotteryAddr = _lotteryAddr;\r\n            lottery = GODLottery(_lotteryAddr);\r\n            DappDatasets.Player memory player = DappDatasets.Player(\r\n                {\r\n                    withdrawalAmount : 0,\r\n                    wallet : 0,\r\n                    fomoTotalRevenue : 0,\r\n                    lotteryTotalRevenue : 0,\r\n                    dynamicIncome : 0,\r\n                    rechargeAmount : 0,\r\n                    staticIncome : 0,\r\n                    shareholderLevel : 0,\r\n                    underUmbrellaLevel : 0,\r\n                    subbordinateTotalPerformance : 0,\r\n                    isExist : true,\r\n                    superior : false,\r\n                    superiorAddr : address(0x0),\r\n                    subordinates : temp\r\n                }\r\n            );\r\n            playerMap[owner] = player;\r\n            allPlayer.push(owner);\r\n            technologyAddr = _technologyAddr;\r\n            themisAddr = _themisAddr;\r\n            if(owner != technologyAddr) {\r\n                playerMap[technologyAddr] = player;\r\n                allPlayer.push(technologyAddr);\r\n            }\r\n            globalShareholder[owner] = GlobalShareholder(\r\n                {\r\n                    shareholdersV1 : temp,\r\n                    shareholdersV2 : temp,\r\n                    shareholdersV3 : temp,\r\n                    shareholdersV4 : temp\r\n                }\r\n            );\r\n        }\r\n\r\n        function() public payable {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function redeemGod(uint usdtVal, address superiorAddr) external {\r\n            register(msg.sender, superiorAddr);\r\n            lottery.exchange(usdtVal, msg.sender);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function buyLotto(uint usdtVal, address superiorAddr) external {\r\n            register(msg.sender, superiorAddr);\r\n            lottery.participateLottery(usdtVal, msg.sender);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function interactive(address addr, uint amount) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(player.subordinates.length \u003E 0) {\r\n                uint length = player.subordinates.length;\r\n                if(player.subordinates.length \u003E 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(amount, length);\r\n                for(uint i = 0; i \u003C length; i\u002B\u002B) {\r\n                    playerMap[player.subordinates[i]].wallet = SafeMath.add(\r\n                        playerMap[player.subordinates[i]].wallet,\r\n                        splitEqually\r\n                    );\r\n                    playerMap[player.subordinates[i]].dynamicIncome = SafeMath.add(\r\n                        playerMap[player.subordinates[i]].dynamicIncome,\r\n                        splitEqually\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        function withdrawImpl(address addr) internal {\r\n            require(owner != addr, \u0022admin no allow withdraw\u0022);\r\n            require(playerMap[addr].wallet \u003E 0, \u0022Insufficient wallet balance\u0022);\r\n            require(lottery.getLotteryIsEnd() == false,\u0022Game over\u0022);\r\n\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[addr].staticIncome, playerMap[addr].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[addr].rechargeAmount, 3);\r\n\r\n            if(motionAndStaticAmount \u003E withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint amount = SafeMath.sub(playerMap[addr].wallet, number);\r\n            uint value = amount;\r\n            if(amount \u003E 1000 * 10 ** 6) {\r\n                value = 1000 * 10 ** 6;\r\n            }\r\n            playerMap[addr].wallet = SafeMath.sub(playerMap[addr].wallet, value);\r\n            playerMap[addr].withdrawalAmount = SafeMath.add(playerMap[addr].withdrawalAmount, value);\r\n\r\n            uint lotteryPool = SafeMath.div(value, 10);\r\n            uint count = SafeMath.div(lotteryPool, 10 ** 6);\r\n            lottery.getLottoCodeByGameAddr(addr, count);\r\n            tether.transfer(addr, SafeMath.sub(value, count * 10 ** 6));\r\n        }\r\n\r\n        function withdraw() external {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function startFomoGame() external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            fomoSession\u002B\u002B;\r\n            if(fomoSession \u003E 1) {\r\n                require(fomoGame[fomoSession - 1].whetherToEnd == true, \u0022The game is not over yet\u0022);\r\n            }\r\n            fomoGame[fomoSession] = DappDatasets.Fomo(\r\n                {\r\n                    whetherToEnd : false,\r\n                    endTime : now \u002B 48 * 60 * 60,\r\n                    fomoPrizePool : 0,\r\n                    participant : temp\r\n                }\r\n            );\r\n        }\r\n\r\n        function participateFomo(uint usdtVal, address superiorAddr) external {\r\n            require(usdtVal \u003E= 10 ** 6, \u0022Redeem at least 1USDT\u0022);\r\n            require(fomoSession \u003E 0, \u0022fomo game has not started yet\u0022);\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == false,\u0022fomo game has not started yet\u0022);\r\n            require(lottery.lotterySession() \u003E 0, \u0022Big Lotto game has not started yet\u0022);\r\n            require(lottery.getLotteryIsEnd() == false,\u0022Big Lotto game has not started yet\u0022);\r\n            register(msg.sender, superiorAddr);\r\n            depositBalance = usdtVal;\r\n\r\n            uint needGOD = godToken.calculationNeedGOD(usdtVal);\r\n            godToken.burn(msg.sender, needGOD);\r\n\r\n            fomo.participant.push(msg.sender);\r\n\r\n            DappDatasets.Player storage player = playerMap[msg.sender];\r\n            player.rechargeAmount = SafeMath.add(player.rechargeAmount, usdtVal);\r\n\r\n            uint lotteryPool = SafeMath.div(usdtVal, 10);\r\n            depositBalance = SafeMath.sub(depositBalance, lotteryPool);\r\n            lottery.updateLotteryPoolAndTodayAmountTotal(usdtVal, lotteryPool);\r\n\r\n            increasePerformance(msg.sender, usdtVal);\r\n\r\n            fomoPenny(msg.sender, usdtVal);\r\n\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(usdtVal, 8), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, fomoPool);\r\n\r\n            if(SafeMath.add(fomo.fomoPrizePool, fomoPool) \u003E 2100 * 10 ** 4 * 10 ** 6 ) {\r\n                if(fomo.fomoPrizePool \u003C 2100 * 10 ** 4 * 10 ** 6) {\r\n                    uint n = SafeMath.sub(2100 * 10 ** 4 * 10 ** 6, fomo.fomoPrizePool);\r\n                    fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, n);\r\n                    uint issue = SafeMath.sub(fomoPool, n);\r\n                    releaseStaticPoolAndV4(issue);\r\n                }else {\r\n                    releaseStaticPoolAndV4(fomoPool);\r\n                }\r\n            }else {\r\n                fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, fomoPool);\r\n            }\r\n\r\n            timeExtended(usdtVal);\r\n            themis.addStaticTotalRechargeAndStaticPool(usdtVal, depositBalance);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\t\t\r\n\r\n        function timeExtended(uint usdtVal) internal {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            uint count = SafeMath.div(usdtVal, SafeMath.mul(10, 10 ** 6));\r\n            uint nowTime = DappDatasets.getNowTime();\r\n            uint laveTime = SafeMath.sub(fomo.endTime, nowTime);\r\n            uint day = 48 * 60 * 60;\r\n            uint hour = 2 * 60 * 60;\r\n            if(count \u003E 0) {\r\n                laveTime = SafeMath.add(laveTime, SafeMath.mul(hour, count));\r\n                if(laveTime \u003C= day) {\r\n                    fomo.endTime = SafeMath.add(nowTime, laveTime);\r\n                }else {\r\n                    fomo.endTime = SafeMath.add(nowTime, day);\r\n                }\r\n            }\r\n        }\r\n\r\n        function fomoPenny(address addr, uint usdtVal) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint num = 9;\r\n            for(uint i = 0; i \u003C 3; i\u002B\u002B) {\r\n                if(player.superior) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    playerMap[player.superiorAddr].wallet = SafeMath.add(\r\n                        playerMap[player.superiorAddr].wallet,\r\n                        usdt\r\n                    );\r\n                    playerMap[player.superiorAddr].dynamicIncome = SafeMath.add(\r\n                        playerMap[player.superiorAddr].dynamicIncome,\r\n                        usdt\r\n                    );\r\n                    depositBalance = SafeMath.sub(depositBalance, usdt);\r\n                    uint reward = SafeMath.div(usdt, 10);\r\n                    interactive(player.superiorAddr, reward);\r\n                    if(playerMap[player.superiorAddr].superior) {\r\n                        playerMap[playerMap[player.superiorAddr].superiorAddr].wallet = SafeMath.add(\r\n                            playerMap[playerMap[player.superiorAddr].superiorAddr].wallet,\r\n                            reward\r\n                        );\r\n                        playerMap[playerMap[player.superiorAddr].superiorAddr].dynamicIncome = SafeMath.add(\r\n                            playerMap[playerMap[player.superiorAddr].superiorAddr].dynamicIncome,\r\n                            reward\r\n                        );\r\n                    }else {\r\n                        break;\r\n                    }\r\n                    num -= 3;\r\n                    player = playerMap[player.superiorAddr];\r\n                }else {\r\n                    break;\r\n                }\r\n                \r\n            }\r\n\r\n            uint technicalRewards = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, technicalRewards);\r\n            playerMap[technologyAddr].wallet = SafeMath.add(playerMap[technologyAddr].wallet, technicalRewards);\r\n\r\n            uint vUsdt = SafeMath.div(SafeMath.mul(usdtVal, 4), 100);\r\n            uint vUsdt4 = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, SafeMath.mul(vUsdt, 3));\r\n            depositBalance = SafeMath.sub(depositBalance, vUsdt4);\r\n            themis.addUsdtPool(vUsdt, vUsdt4);\r\n        }\r\n\r\n\r\n        function increasePerformance(address addr, uint usdtVal) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint length = 0;\r\n            while(player.superior) {\r\n                address tempAddr = player.superiorAddr;\r\n                player = playerMap[player.superiorAddr];\r\n                player.subbordinateTotalPerformance = SafeMath.add(player.subbordinateTotalPerformance, usdtVal);\r\n                promotionMechanisms(tempAddr);\r\n                length\u002B\u002B;\r\n                if(length == 50) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function promotionMechanisms(address addr) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(player.subbordinateTotalPerformance \u003E= 10 * 10 ** 4 * 10 ** 6) {\r\n                uint len = player.subordinates.length;\r\n                if(player.subordinates.length \u003E 30) {\r\n                    len = 30;\r\n                }\r\n                for(uint i = 0; i \u003C 4; i\u002B\u002B) {\r\n                    if(player.shareholderLevel == i) {\r\n                        uint levelCount = 0;\r\n                        for(uint j = 0; j \u003C len; j\u002B\u002B) {\r\n                            if(i == 0) {\r\n                                uint areaTotal = SafeMath.add(\r\n                                            playerMap[player.subordinates[j]].subbordinateTotalPerformance,\r\n                                            playerMap[player.subordinates[j]].rechargeAmount\r\n                                );\r\n                                if(areaTotal \u003E= 3 * 10 ** 4 * 10 ** 6) {\r\n                                    levelCount\u002B\u002B;\r\n                                }\r\n                            }else {\r\n                                if(playerMap[player.subordinates[j]].shareholderLevel \u003E= i || playerMap[player.subordinates[j]].underUmbrellaLevel \u003E= i) {\r\n                                    levelCount\u002B\u002B;\r\n                                }\r\n                            }\r\n\r\n                            if(levelCount \u003E= 2) {\r\n                                player.shareholderLevel = i \u002B 1;\r\n                                if(i == 0) {\r\n                                    globalShareholder[owner].shareholdersV1.push(addr);\r\n                                }else if(i == 1) {\r\n                                    globalShareholder[owner].shareholdersV2.push(addr);\r\n                                }else if(i == 2) {\r\n                                    globalShareholder[owner].shareholdersV3.push(addr);\r\n                                }else if(i == 3) {\r\n                                    globalShareholder[owner].shareholdersV4.push(addr);\r\n                                }\r\n                                \r\n                                DappDatasets.Player storage tempPlayer = player;\r\n                                uint count = 0;\r\n                                while(tempPlayer.superior) {\r\n                                    tempPlayer = playerMap[tempPlayer.superiorAddr];\r\n                                    if(tempPlayer.underUmbrellaLevel \u003C i \u002B 1) {\r\n                                        tempPlayer.underUmbrellaLevel = i \u002B 1;\r\n                                    }else {\r\n                                        break;\r\n                                    }\r\n                                    count\u002B\u002B;\r\n                                    if(count == 49) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                break;\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        function releaseStaticPoolAndV4(uint usdtVal) internal {\r\n            uint staticPool60 = SafeMath.div(SafeMath.mul(usdtVal, 6), 10);\r\n            themis.addStaticPrizePool(staticPool60);\r\n\r\n            if(globalShareholder[owner].shareholdersV4.length \u003E 0) {\r\n                uint length = globalShareholder[owner].shareholdersV4.length;\r\n                if(globalShareholder[owner].shareholdersV4.length \u003E 100) {\r\n                    length = 100;\r\n                }\r\n                uint splitEqually = SafeMath.div(SafeMath.sub(usdtVal, staticPool60), length);\r\n                for(uint i = 0; i \u003C length; i\u002B\u002B) {\r\n                    playerMap[globalShareholder[owner].shareholdersV4[i]].wallet = SafeMath.add(\r\n                        playerMap[globalShareholder[owner].shareholdersV4[i]].wallet,\r\n                        splitEqually\r\n                    );\r\n                }\r\n            }else{\r\n\t\t\t\tthemis.addStaticPrizePool(SafeMath.sub(usdtVal, staticPool60));\r\n\t\t\t}\r\n\r\n        }\r\n\r\n        function register(address addr, address superiorAddr) internal{\r\n            if(playerMap[addr].isExist == true) {\r\n                return;\r\n            }\r\n            DappDatasets.Player memory player;\r\n            if(superiorAddr == address(0x0) || playerMap[superiorAddr].isExist == false) {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : false,\r\n                        superiorAddr : address(0x0),\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                playerMap[addr] = player;\r\n            }else {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : true,\r\n                        superiorAddr : superiorAddr,\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                DappDatasets.Player storage superiorPlayer = playerMap[superiorAddr];\r\n                superiorPlayer.subordinates.push(addr);\r\n                playerMap[addr] = player;\r\n            }\r\n            allPlayer.push(addr);\r\n        }\r\n        function endFomoGame() external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            require(fomoSession \u003E 0, \u0022The game has not started\u0022);\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == false,\u0022Game over\u0022);\r\n            require(DappDatasets.getNowTime() \u003E= fomo.endTime, \u0022The game is not over\u0022);\r\n            fomo.whetherToEnd = true;\r\n        }\r\n\r\n        function getFomoParticpantLength() external view returns(uint) {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            return fomo.participant.length;\r\n        }\r\n\r\n        function fomoBatchDistribution(uint number, uint frequency, uint index) external {\r\n            require(owner == msg.sender, \u0022Insufficient permissions\u0022);\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == true,\u0022fomo is not over\u0022);\r\n            require(fomo.fomoPrizePool \u003E 0, \u0022fomo pool no bonus\u0022);\r\n\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(fomo.fomoPrizePool, number), 10);\r\n\r\n            uint length = frequency;\r\n            if(fomo.participant.length \u003C frequency) {\r\n                length = fomo.participant.length;\r\n            }\r\n            uint personalAmount = SafeMath.div(fomoPool, length);\r\n            uint num = 0;\r\n            for(uint i = fomo.participant.length - index; i \u003E 0; i--) {\r\n                DappDatasets.Player storage player = playerMap[fomo.participant[i - 1]];\r\n                player.wallet = SafeMath.add(\r\n                    player.wallet,\r\n                    personalAmount\r\n                );\r\n                player.fomoTotalRevenue = SafeMath.add(\r\n                    player.fomoTotalRevenue,\r\n                    personalAmount\r\n                );\r\n                num\u002B\u002B;\r\n                if(num == 100 || num == length) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function getFOMOInfo() external view returns(uint session, uint nowTime, uint endTime, uint prizePool, bool isEnd) {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            return (fomoSession, DappDatasets.getNowTime(), fomo.endTime, fomo.fomoPrizePool, fomo.whetherToEnd);\r\n        }\r\n\r\n        function getSubordinatesAndPerformanceByAddr(address addr) external view returns(address[], uint[], uint[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint[] memory performance = new uint[](player.subordinates.length);\r\n            uint[] memory numberArray = new uint[](player.subordinates.length);\r\n            for(uint i = 0; i \u003C player.subordinates.length; i\u002B\u002B) {\r\n                performance[i] = SafeMath.add(\r\n                    playerMap[player.subordinates[i]].subbordinateTotalPerformance,\r\n                    playerMap[player.subordinates[i]].rechargeAmount\r\n                );\r\n                numberArray[i] = playerMap[player.subordinates[i]].subordinates.length;\r\n            }\r\n            return (player.subordinates, performance, numberArray);\r\n        }\r\n\r\n        function getPlayerInfo() external view returns(address superiorAddr, address ownerAddr, uint numberOfInvitations, bool exist) {\r\n            return (playerMap[msg.sender].superiorAddr,  msg.sender, playerMap[msg.sender].subordinates.length, playerMap[msg.sender].isExist);\r\n        }\r\n\r\n        function getStatistics() external view returns(\r\n            uint level,\r\n            uint destroyedQuantity,\r\n            uint fomoTotalRevenue,\r\n            uint lotteryTotalRevenue,\r\n            uint difference\r\n        ) {\r\n            return (\r\n                playerMap[msg.sender].shareholderLevel,\r\n                godToken.balanceOf(address(0x0)),\r\n                playerMap[msg.sender].fomoTotalRevenue,\r\n                playerMap[msg.sender].lotteryTotalRevenue,\r\n                SafeMath.sub(\r\n                    SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3),\r\n                    playerMap[msg.sender].staticIncome\r\n                )\r\n            );\r\n        }\r\n\r\n        function getRevenueAndPerformance() external view returns(\r\n            uint withdrawalAmount,\r\n            uint subbordinateTotalPerformance,\r\n            uint dynamicIncome,\r\n            uint staticIncome,\r\n            uint withdrawn,\r\n            uint outboundDifference\r\n        ) {\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[msg.sender].staticIncome, playerMap[msg.sender].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3);\r\n            if(motionAndStaticAmount \u003E withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint difference = 0;\r\n            if(motionAndStaticAmount \u003C withdrawableBalance) {\r\n                difference = SafeMath.sub(withdrawableBalance, motionAndStaticAmount);\r\n            }\r\n            return (\r\n                SafeMath.sub(playerMap[msg.sender].wallet, number),\r\n                playerMap[msg.sender].subbordinateTotalPerformance,\r\n                playerMap[msg.sender].dynamicIncome,\r\n                playerMap[msg.sender].staticIncome,\r\n                playerMap[msg.sender].withdrawalAmount,\r\n                difference\r\n            );\r\n        }\r\n        function getAllPlayer() external view returns(address[]) {\r\n            return allPlayer;\r\n        }\r\n        function getAllPlayerLength() external view returns(uint) {\r\n            return allPlayer.length;\r\n        }\r\n\r\n        function getShareholder() external view returns(uint, uint, uint, uint) {\r\n            return (\r\n                globalShareholder[owner].shareholdersV1.length,\r\n                globalShareholder[owner].shareholdersV2.length,\r\n                globalShareholder[owner].shareholdersV3.length,\r\n                globalShareholder[owner].shareholdersV4.length\r\n            );\r\n        }\r\n\r\n        function getGlobalShareholder() external view returns(address[], address[], address[], address[]) {\r\n            return (\r\n                globalShareholder[owner].shareholdersV1,\r\n                globalShareholder[owner].shareholdersV2,\r\n                globalShareholder[owner].shareholdersV3,\r\n                globalShareholder[owner].shareholdersV4\r\n            );\r\n        }\r\n\r\n        function getPlayer(address addr) external view returns(uint, uint, uint, address, address[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            return(\r\n                player.rechargeAmount,\r\n                player.staticIncome,\r\n                player.dynamicIncome,\r\n                player.superiorAddr,\r\n                player.subordinates\r\n            );\r\n        }\r\n\r\n        function updatePlayer(address addr, uint amount, bool flag) external {\r\n            require(themisAddr == msg.sender, \u0022Insufficient permissions\u0022);\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            player.wallet = SafeMath.add(player.wallet, amount);\r\n            if(flag) {\r\n                player.staticIncome = SafeMath.add(player.staticIncome, amount);\r\n            }else {\r\n                player.dynamicIncome = SafeMath.add(player.dynamicIncome, amount);\r\n            }\r\n        }\r\n\r\n        function updatePlayer(address addr, uint amount) external {\r\n            require(lotteryAddr == msg.sender, \u0022Insufficient permissions\u0022);\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            player.wallet = SafeMath.add(player.wallet, amount);\r\n            player.lotteryTotalRevenue = SafeMath.add(player.lotteryTotalRevenue, amount);\r\n        }\r\n    }\r\n\r\n    contract GODThemis {\r\n        function addStaticPrizePool(uint usdtVal) external;\r\n        function addStaticTotalRechargeAndStaticPool(uint usdtVal, uint depositBalance) external;\r\n        function addUsdtPool(uint vUsdt, uint vUsdt4) external;\r\n    }\r\n\r\n    contract GODToken {\r\n        function burn(address addr, uint value) public;\r\n        function usdtPrice() public view returns(uint);\r\n        function balanceOf(address who) external view returns (uint);\r\n        function calculationNeedGOD(uint usdtVal) external view returns(uint);\r\n    }\r\n\r\n    contract TetherToken {\r\n        function transferFrom(address from, address to, uint value) public;\r\n        function transfer(address to, uint value) public;\r\n    }\r\n\r\n    contract GODLottery {\r\n        function getLottoCodeByGameAddr(address addr, uint count) external;\r\n        function lotterySession() public view returns(uint);\r\n        function getLotteryIsEnd() external view returns(bool);\r\n        function updateLotteryPoolAndTodayAmountTotal(uint usdtVal, uint lotteryPool) external;\r\n        function exchange(uint usdtVal, address addr) external;\r\n        function participateLottery(uint usdtVal, address addr) external;\r\n    }","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022superiorAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022redeemGod\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022number\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022frequency\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022fomoBatchDistribution\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getFOMOInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022session\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022nowTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022endTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022prizePool\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022isEnd\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAllPlayer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getFomoParticpantLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getStatistics\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022level\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022destroyedQuantity\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022fomoTotalRevenue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lotteryTotalRevenue\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022difference\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAllPlayerLength\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022superiorAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022participateFomo\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022usdtVal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022superiorAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022buyLotto\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022startFomoGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getSubordinatesAndPerformanceByAddr\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getPlayer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getGlobalShareholder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updatePlayer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getRevenueAndPerformance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022withdrawalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022subbordinateTotalPerformance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022dynamicIncome\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022staticIncome\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022withdrawn\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022outboundDifference\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022flag\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022updatePlayer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getShareholder\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getPlayerInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022superiorAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022ownerAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022numberOfInvitations\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022exist\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022endFomoGame\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tetherAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_godAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_themisAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_lotteryAddr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_technologyAddr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022fallback\u0022}]","ContractName":"GODGame","CompilerVersion":"v0.4.25\u002Bcommit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003b2c68f61a2c98bb0a4cf2ddc8cb0bec3957e1c1000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000004dc90fa739385848340349cf5c9efd123655a7e30000000000000000000000008e3f5172cc10f0f920f3677625056f43d47e4aea000000000000000000000000a4e973366d50e117f0f8c27353ca063d9aea0cd50000000000000000000000002e6f48e434856b1df1ab3c054de462fffc0838b4","Library":"","SwarmSource":"bzzr://beb5d11fd8cf6cdd923ca62b5bd6f73a0de6877ac799881ca5d34a1c18c6ced4"}]