[{"SourceCode":"{\u0022Address.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if \u0060account\u0060 is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * \\u003e It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an \u0060address\u0060 into \u0060address payable\u0060. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022CryptoHarborExchangeGameToken.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.1;\\r\\n\\r\\n\\r\\nimport \\\u0022./ERC223Token.sol\\\u0022;\\r\\n\\r\\ncontract  CryptoHarborExchangeGameToken is ERC223Token {\\r\\n\\r\\n    string public name = \\\u0022CryptoHarborExchangeGameToken\\\u0022;\\r\\n\\r\\n    string public symbol = \\\u0022CHEG\\\u0022;\\r\\n\\r\\n    uint public decimals = 8;\\r\\n\\r\\n    uint256 public initialSupply = 1e8 * 1e8;\\r\\n\\r\\n    uint256 public _totalSupply;\\r\\n    \\r\\n    address public owner;\\r\\n    \\r\\n    bool public mintingFinished;\\r\\n\\r\\n    mapping (address =\\u003e bool) public frozenAccount;\\r\\n    mapping (address =\\u003e uint256) public unlockUnixTime;\\r\\n    event FrozenFunds(address indexed target, bool frozen);\\r\\n    event LockedFunds(address indexed target, uint256 locked);\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Burn(address indexed from, uint256 amount);\\r\\n    event Mint(address indexed _to, uint256 _unitAmount);\\r\\n    event MintFinished();\\r\\n\\r\\n    constructor() public {\\r\\n        _totalSupply = initialSupply;\\r\\n        balances[msg.sender] = initialSupply;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns a specific amount of tokens.\\r\\n     * @param _from The address that will burn the tokens.\\r\\n     * @param _unitAmount The amount of token to be burned.\\r\\n     */\\r\\n    function burn(address _from, uint256 _unitAmount) onlyOwner public {\\r\\n        require(_unitAmount \\u003e 0\\r\\n                \\u0026\\u0026 balances[_from] \\u003e= _unitAmount);\\r\\n\\r\\n        balances[_from] = balances[_from].sub(_unitAmount);\\r\\n        _totalSupply = _totalSupply.sub(_unitAmount);\\r\\n        emit Burn(_from, _unitAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to mint tokens\\r\\n     * @param _to The address that will receive the minted tokens.\\r\\n     * @param _unitAmount The amount of tokens to mint.\\r\\n     */\\r\\n    \\r\\n    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {\\r\\n        require(_unitAmount \\u003e 0);\\r\\n        \\r\\n        _totalSupply = _totalSupply.add(_unitAmount);\\r\\n        balances[_to] = balances[_to].add(_unitAmount);\\r\\n        emit Mint(_to, _unitAmount);\\r\\n        emit Transfer(address(0), _to, _unitAmount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n        modifier canMint() {\\r\\n        require(!mintingFinished);\\r\\n        _;\\r\\n    }\\r\\n   \\r\\n       /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    } \\r\\n    \\r\\n        /**\\r\\n     * @dev Function to stop minting new tokens.\\r\\n     */\\r\\n    function finishMinting() onlyOwner canMint public returns (bool) {\\r\\n        mintingFinished = true;\\r\\n        emit MintFinished();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevent targets from sending or receiving tokens\\r\\n     * @param targets Addresses to be frozen\\r\\n     * @param isFrozen either to freeze it or not\\r\\n     */\\r\\n    function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\\r\\n        require(targets.length \\u003e 0);\\r\\n\\r\\n        for (uint j = 0; j \\u003c targets.length; j\u002B\u002B) {\\r\\n            require(targets[j] != owner);\\r\\n            frozenAccount[targets[j]] = isFrozen;\\r\\n            emit FrozenFunds(targets[j], isFrozen);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevent targets from sending or receiving tokens by setting Unix times\\r\\n     * @param targets Addresses to be locked funds\\r\\n     * @param unixTimes Unix times when locking up will be finished\\r\\n     */\\r\\n    function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\\r\\n        require(targets.length \\u003e 0\\r\\n                \\u0026\\u0026 targets.length == unixTimes.length);\\r\\n                \\r\\n        for(uint j = 0; j \\u003c targets.length; j\u002B\u002B){\\r\\n            require(unlockUnixTime[targets[j]] \\u003c unixTimes[j]);\\r\\n            unlockUnixTime[targets[j]] = unixTimes[j];\\r\\n            emit LockedFunds(targets[j], unixTimes[j]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\\r\\n        require(_value \\u003e 0\\r\\n                \\u0026\\u0026 frozenAccount[msg.sender] == false \\r\\n                \\u0026\\u0026 frozenAccount[_to] == false\\r\\n                \\u0026\\u0026 now \\u003e unlockUnixTime[msg.sender] \\r\\n                \\u0026\\u0026 now \\u003e unlockUnixTime[_to]);\\r\\n\\r\\n        if (!isContract(_to)) {\\r\\n            return transferToAddress(_to, _value, _data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Standard function transfer similar to ERC20 transfer with no _data\\r\\n     *      Added due to backwards compatibility reasons\\r\\n     */\\r\\n    function transfer(address _to, uint _value) public returns (bool success) {\\r\\n        require(_value \\u003e 0\\r\\n                \\u0026\\u0026 frozenAccount[msg.sender] == false \\r\\n                \\u0026\\u0026 frozenAccount[_to] == false\\r\\n                \\u0026\\u0026 now \\u003e unlockUnixTime[msg.sender] \\r\\n                \\u0026\\u0026 now \\u003e unlockUnixTime[_to]);\\r\\n\\r\\n        bytes memory empty;\\r\\n        if (!isContract(_to)) {\\r\\n            return transferToAddress(_to, _value, empty);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // assemble the given address bytecode. If bytecode exists then the _addr is a contract.\\r\\n    function isContract(address _addr) private view returns (bool is_contract) {\\r\\n        uint length;\\r\\n        assembly {\\r\\n            //retrieve the size of the code on target address, this needs assembly\\r\\n            length := extcodesize(_addr)\\r\\n        }\\r\\n        return (length \\u003e 0);\\r\\n    }\\r\\n\\r\\n    // function that is called when transaction target is an address\\r\\n    function transferToAddress(address _to, uint _value, bytes memory  _data) private returns (bool success) {\\r\\n        require(balances[msg.sender] \\u003e= _value);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        emit Transfer(msg.sender, _to, _value, _data);\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n}\u0022},\u0022ERC223Token.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\u0022./IERC223.sol\\\u0022;\\r\\nimport \\\u0022./IERC223Recipient.sol\\\u0022;\\r\\nimport \\\u0022./safeMath.sol\\\u0022;\\r\\nimport \\\u0022./Address.sol\\\u0022;\\r\\n\\r\\n/**\\r\\n * @title Reference implementation of the ERC223 standard token.\\r\\n */\\r\\ncontract ERC223Token is IERC223 {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    /**\\r\\n     * @dev See \u0060IERC223.totalSupply\u0060.\\r\\n     */\\r\\n     /*\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    */\\r\\n\\r\\n    mapping(address =\\u003e uint) balances; // List of user balances.\\r\\n    \\r\\n    /**\\r\\n     * @dev Transfer the specified amount of tokens to the specified address.\\r\\n     *      Invokes the \u0060tokenFallback\u0060 function if the recipient is a contract.\\r\\n     *      The token transfer fails if the recipient is a contract\\r\\n     *      but does not implement the \u0060tokenFallback\u0060 function\\r\\n     *      or the fallback function to receive funds.\\r\\n     *\\r\\n     * @param _to    Receiver address.\\r\\n     * @param _value Amount of tokens that will be transferred.\\r\\n     * @param _data  Transaction metadata.\\r\\n     */\\r\\n    function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\\r\\n        // Standard function transfer similar to ERC20 transfer with no _data .\\r\\n        // Added due to backwards compatibility reasons .\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        if(Address.isContract(_to)) {\\r\\n            IERC223Recipient receiver = IERC223Recipient(_to);\\r\\n            receiver.tokenFallback(msg.sender, _value, _data);\\r\\n        }\\r\\n        emit Transfer(msg.sender, _to, _value, _data);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Transfer the specified amount of tokens to the specified address.\\r\\n     *      This function works the same with the previous one\\r\\n     *      but doesn\\u0027t contain \u0060_data\u0060 param.\\r\\n     *      Added due to backwards compatibility reasons.\\r\\n     *\\r\\n     * @param _to    Receiver address.\\r\\n     * @param _value Amount of tokens that will be transferred.\\r\\n     */\\r\\n    function transfer(address _to, uint _value) public returns (bool success){\\r\\n        bytes memory empty = hex\\\u002200000000\\\u0022;\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        if(Address.isContract(_to)) {\\r\\n            IERC223Recipient receiver = IERC223Recipient(_to);\\r\\n            receiver.tokenFallback(msg.sender, _value, empty);\\r\\n        }\\r\\n        emit Transfer(msg.sender, _to, _value, empty);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns balance of the \u0060_owner\u0060.\\r\\n     *\\r\\n     * @param _owner   The address whose balance will be returned.\\r\\n     * @return balance Balance of the \u0060_owner\u0060.\\r\\n     */\\r\\n    function balanceOf(address _owner) public view returns (uint balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n}\\r\\n\u0022},\u0022IERC223.sol\u0022:{\u0022content\u0022:\u0022    \\r\\npragma solidity ^0.5.1;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\r\\n *\\r\\n * This contract uses the\\r\\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\\r\\n * token holders and recipients react to token movements by using setting implementers\\r\\n * for the associated interfaces in said registry. See \u0060IERC1820Registry\u0060 and\\r\\n * \u0060ERC1820Implementer\u0060.\\r\\n */\\r\\n\\r\\ncontract IERC223 {\\r\\n    /**\\r\\n     * @dev Returns the total supply of the token.\\r\\n     */\\r\\n    uint public _totalSupply;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the balance of the \u0060who\u0060 address.\\r\\n     */\\r\\n    function balanceOf(address who) public view returns (uint);\\r\\n        \\r\\n    /**\\r\\n     * @dev Transfers \u0060value\u0060 tokens from \u0060msg.sender\u0060 to \u0060to\u0060 address\\r\\n     * and returns \u0060true\u0060 on success.\\r\\n     */\\r\\n    function transfer(address to, uint value) public returns (bool success);\\r\\n        \\r\\n    /**\\r\\n     * @dev Transfers \u0060value\u0060 tokens from \u0060msg.sender\u0060 to \u0060to\u0060 address with \u0060data\u0060 parameter\\r\\n     * and returns \u0060true\u0060 on success.\\r\\n     */\\r\\n    function transfer(address to, uint value, bytes memory data) public returns (bool success);\\r\\n     \\r\\n     /**\\r\\n     * @dev Event that is fired on successful transfer.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\\r\\n}\\r\\n\u0022},\u0022IERC223Recipient.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.1;\\r\\n\\r\\n /**\\r\\n * @title Contract that will work with ERC223 tokens.\\r\\n */\\r\\n \\r\\ncontract IERC223Recipient { \\r\\n/**\\r\\n * @dev Standard ERC223 function that will handle incoming token transfers.\\r\\n *\\r\\n * @param _from  Token sender address.\\r\\n * @param _value Amount of tokens.\\r\\n * @param _data  Transaction metadata.\\r\\n */\\r\\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\\r\\n}\\r\\n\u0022},\u0022safeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\u0022}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022mintingFinished\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022initialSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_totalSupply\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_unitAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mint\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022targets\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022unixTimes\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022name\u0022:\u0022lockupAccounts\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022balance\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022finishMinting\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_unitAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022burn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022frozenAccount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022targets\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022isFrozen\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022freezeAccounts\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022unlockUnixTime\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022frozen\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022FrozenFunds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022locked\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022LockedFunds\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Burn\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_unitAmount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Mint\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MintFinished\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"CryptoHarborExchangeGameToken","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://43e1725c055063791b05087d9abcb8d338eced157cb9f4f33b79f798a2cf76c4"}]