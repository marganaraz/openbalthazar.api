[{"SourceCode":"{{\r\n  \u0022language\u0022: \u0022Solidity\u0022,\r\n  \u0022sources\u0022: {\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/MultiAssetProxy.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022./MixinAssetProxyDispatcher.sol\\\u0022;\\nimport \\\u0022./MixinAuthorizable.sol\\\u0022;\\n\\n\\ncontract MultiAssetProxy is\\n    MixinAssetProxyDispatcher,\\n    MixinAuthorizable\\n{\\n    // Id of this proxy.\\n    bytes4 constant internal PROXY_ID = bytes4(keccak256(\\\u0022MultiAsset(uint256[],bytes[])\\\u0022));\\n\\n    // solhint-disable-next-line payable-fallback\\n    function ()\\n        external\\n    {\\n        // NOTE: The below assembly assumes that clients do some input validation and that the input is properly encoded according to the AbiV2 specification.\\n        // It is technically possible for inputs with very large lengths and offsets to cause overflows. However, this would make the calldata prohibitively\\n        // expensive and we therefore do not check for overflows in these scenarios.\\n        assembly {\\n            // The first 4 bytes of calldata holds the function selector\\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n\\n            // \u0060transferFrom\u0060 will be called with the following parameters:\\n            // assetData Encoded byte array.\\n            // from Address to transfer asset from.\\n            // to Address to transfer asset to.\\n            // amount Amount of asset to transfer.\\n            // bytes4(keccak256(\\\u0022transferFrom(bytes,address,address,uint256)\\\u0022)) = 0xa85e59e4\\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\\n\\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\\n                // where k is the key left padded to 32 bytes and p is the storage slot\\n                mstore(0, caller)\\n                mstore(32, authorized_slot)\\n\\n                // Revert if authorized[msg.sender] == false\\n                if iszero(sload(keccak256(0, 64))) {\\n                    // Revert with \u0060Error(\\\u0022SENDER_NOT_AUTHORIZED\\\u0022)\u0060\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\\n                    mstore(96, 0)\\n                    revert(0, 100)\\n                }\\n\\n                // \u0060transferFrom\u0060.\\n                // The function is marked \u0060external\u0060, so no abi decoding is done for\\n                // us. Instead, we expect the \u0060calldata\u0060 memory to contain the\\n                // following:\\n                //\\n                // | Area     | Offset | Length  | Contents                            |\\n                // |----------|--------|---------|-------------------------------------|\\n                // | Header   | 0      | 4       | function selector                   |\\n                // | Params   |        | 4 * 32  | function parameters:                |\\n                // |          | 4      |         |   1. offset to assetData (*)        |\\n                // |          | 36     |         |   2. from                           |\\n                // |          | 68     |         |   3. to                             |\\n                // |          | 100    |         |   4. amount                         |\\n                // | Data     |        |         | assetData:                          |\\n                // |          | 132    | 32      | assetData Length                    |\\n                // |          | 164    | **      | assetData Contents                  |\\n                //\\n                // (*): offset is computed from start of function parameters, so offset\\n                //      by an additional 4 bytes in the calldata.\\n                //\\n                // (**): see table below to compute length of assetData Contents\\n                //\\n                // WARNING: The ABIv2 specification allows additional padding between\\n                //          the Params and Data section. This will result in a larger\\n                //          offset to assetData.\\n\\n                // Load offset to \u0060assetData\u0060\\n                let assetDataOffset := add(calldataload(4), 4)\\n\\n                // Load length in bytes of \u0060assetData\u0060\\n                let assetDataLength := calldataload(assetDataOffset)\\n\\n                // Asset data itself is encoded as follows:\\n                //\\n                // | Area     | Offset      | Length  | Contents                            |\\n                // |----------|-------------|---------|-------------------------------------|\\n                // | Header   | 0           | 4       | assetProxyId                        |\\n                // | Params   |             | 2 * 32  | function parameters:                |\\n                // |          | 4           |         |   1. offset to amounts (*)          |\\n                // |          | 36          |         |   2. offset to nestedAssetData (*)  |\\n                // | Data     |             |         | amounts:                            |\\n                // |          | 68          | 32      | amounts Length                      |\\n                // |          | 100         | a       | amounts Contents                    | \\n                // |          |             |         | nestedAssetData:                    |\\n                // |          | 100 \u002B a     | 32      | nestedAssetData Length              |\\n                // |          | 132 \u002B a     | b       | nestedAssetData Contents (offsets)  |\\n                // |          | 132 \u002B a \u002B b |         | nestedAssetData[0, ..., len]        |\\n\\n                // Assert that the length of asset data:\\n                // 1. Must be at least 68 bytes (see table above)\\n                // 2. Must be a multiple of 32 (excluding the 4-byte selector)\\n                if or(lt(assetDataLength, 68), mod(sub(assetDataLength, 4), 32)) {\\n                    // Revert with \u0060Error(\\\u0022INVALID_ASSET_DATA_LENGTH\\\u0022)\u0060\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(64, 0x00000019494e56414c49445f41535345545f444154415f4c454e475448000000)\\n                    mstore(96, 0)\\n                    revert(0, 100)\\n                }\\n\\n                // End of asset data in calldata\\n                // assetDataOffset\\n                // \u002B 32 (assetData len)\\n                let assetDataEnd := add(assetDataOffset, add(assetDataLength, 32))\\n                if gt(assetDataEnd, calldatasize()) {\\n                    // Revert with \u0060Error(\\\u0022INVALID_ASSET_DATA_END\\\u0022)\u0060\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(64, 0x00000016494e56414c49445f41535345545f444154415f454e44000000000000)\\n                    mstore(96, 0)\\n                    revert(0, 100)\\n                }\\n\\n                // In order to find the offset to \u0060amounts\u0060, we must add:\\n                // assetDataOffset\\n                // \u002B 32 (assetData len)\\n                // \u002B 4 (assetProxyId)\\n                let amountsOffset := calldataload(add(assetDataOffset, 36))\\n\\n                // In order to find the offset to \u0060nestedAssetData\u0060, we must add:\\n                // assetDataOffset\\n                // \u002B 32 (assetData len)\\n                // \u002B 4 (assetProxyId)\\n                // \u002B 32 (amounts offset)\\n                let nestedAssetDataOffset := calldataload(add(assetDataOffset, 68))\\n\\n                // In order to find the start of the \u0060amounts\u0060 contents, we must add: \\n                // assetDataOffset \\n                // \u002B 32 (assetData len)\\n                // \u002B 4 (assetProxyId)\\n                // \u002B amountsOffset\\n                // \u002B 32 (amounts len)\\n                let amountsContentsStart := add(assetDataOffset, add(amountsOffset, 68))\\n\\n                // Load number of elements in \u0060amounts\u0060\\n                let amountsLen := calldataload(sub(amountsContentsStart, 32))\\n\\n                // In order to find the start of the \u0060nestedAssetData\u0060 contents, we must add: \\n                // assetDataOffset \\n                // \u002B 32 (assetData len)\\n                // \u002B 4 (assetProxyId)\\n                // \u002B nestedAssetDataOffset\\n                // \u002B 32 (nestedAssetData len)\\n                let nestedAssetDataContentsStart := add(assetDataOffset, add(nestedAssetDataOffset, 68))\\n\\n                // Load number of elements in \u0060nestedAssetData\u0060\\n                let nestedAssetDataLen := calldataload(sub(nestedAssetDataContentsStart, 32))\\n\\n                // Revert if number of elements in \u0060amounts\u0060 differs from number of elements in \u0060nestedAssetData\u0060\\n                if sub(amountsLen, nestedAssetDataLen) {\\n                    // Revert with \u0060Error(\\\u0022LENGTH_MISMATCH\\\u0022)\u0060\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(64, 0x0000000f4c454e4754485f4d49534d4154434800000000000000000000000000)\\n                    mstore(96, 0)\\n                    revert(0, 100)\\n                }\\n\\n                // Copy \u0060transferFrom\u0060 selector, offset to \u0060assetData\u0060, \u0060from\u0060, and \u0060to\u0060 from calldata to memory\\n                calldatacopy(\\n                    0,   // memory can safely be overwritten from beginning\\n                    0,   // start of calldata\\n                    100  // length of selector (4) and 3 params (32 * 3)\\n                )\\n\\n                // Overwrite existing offset to \u0060assetData\u0060 with our own\\n                mstore(4, 128)\\n                \\n                // Load \u0060amount\u0060\\n                let amount := calldataload(100)\\n        \\n                // Calculate number of bytes in \u0060amounts\u0060 contents\\n                let amountsByteLen := mul(amountsLen, 32)\\n\\n                // Initialize \u0060assetProxyId\u0060 and \u0060assetProxy\u0060 to 0\\n                let assetProxyId := 0\\n                let assetProxy := 0\\n\\n                // Loop through \u0060amounts\u0060 and \u0060nestedAssetData\u0060, calling \u0060transferFrom\u0060 for each respective element\\n                for {let i := 0} lt(i, amountsByteLen) {i := add(i, 32)} {\\n\\n                    // Calculate the total amount\\n                    let amountsElement := calldataload(add(amountsContentsStart, i))\\n                    let totalAmount := mul(amountsElement, amount)\\n\\n                    // Revert if \u0060amount\u0060 != 0 and multiplication resulted in an overflow \\n                    if iszero(or(\\n                        iszero(amount),\\n                        eq(div(totalAmount, amount), amountsElement)\\n                    )) {\\n                        // Revert with \u0060Error(\\\u0022UINT256_OVERFLOW\\\u0022)\u0060\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                        mstore(64, 0x0000001055494e543235365f4f564552464c4f57000000000000000000000000)\\n                        mstore(96, 0)\\n                        revert(0, 100)\\n                    }\\n\\n                    // Write \u0060totalAmount\u0060 to memory\\n                    mstore(100, totalAmount)\\n\\n                    // Load offset to \u0060nestedAssetData[i]\u0060\\n                    let nestedAssetDataElementOffset := calldataload(add(nestedAssetDataContentsStart, i))\\n\\n                    // In order to find the start of the \u0060nestedAssetData[i]\u0060 contents, we must add:\\n                    // assetDataOffset \\n                    // \u002B 32 (assetData len)\\n                    // \u002B 4 (assetProxyId)\\n                    // \u002B nestedAssetDataOffset\\n                    // \u002B 32 (nestedAssetData len)\\n                    // \u002B nestedAssetDataElementOffset\\n                    // \u002B 32 (nestedAssetDataElement len)\\n                    let nestedAssetDataElementContentsStart := add(\\n                        assetDataOffset,\\n                        add(\\n                            nestedAssetDataOffset,\\n                            add(nestedAssetDataElementOffset, 100)\\n                        )\\n                    )\\n\\n                    // Load length of \u0060nestedAssetData[i]\u0060\\n                    let nestedAssetDataElementLenStart := sub(nestedAssetDataElementContentsStart, 32)\\n                    let nestedAssetDataElementLen := calldataload(nestedAssetDataElementLenStart)\\n\\n                    // Revert if the \u0060nestedAssetData\u0060 does not contain a 4 byte \u0060assetProxyId\u0060\\n                    if lt(nestedAssetDataElementLen, 4) {\\n                        // Revert with \u0060Error(\\\u0022LENGTH_GREATER_THAN_3_REQUIRED\\\u0022)\u0060\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                        mstore(64, 0x0000001e4c454e4754485f475245415445525f5448414e5f335f524551554952)\\n                        mstore(96, 0x4544000000000000000000000000000000000000000000000000000000000000)\\n                        revert(0, 100)\\n                    }\\n\\n                    // Load AssetProxy id\\n                    let currentAssetProxyId := and(\\n                        calldataload(nestedAssetDataElementContentsStart),\\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\\n                    )\\n\\n                    // Only load \u0060assetProxy\u0060 if \u0060currentAssetProxyId\u0060 does not equal \u0060assetProxyId\u0060\\n                    // We do not need to check if \u0060currentAssetProxyId\u0060 is 0 since \u0060assetProxy\u0060 is also initialized to 0\\n                    if sub(currentAssetProxyId, assetProxyId) {\\n                        // Update \u0060assetProxyId\u0060\\n                        assetProxyId := currentAssetProxyId\\n                        // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\\n                        // where k is the key left padded to 32 bytes and p is the storage slot\\n                        mstore(132, assetProxyId)\\n                        mstore(164, assetProxies_slot)\\n                        assetProxy := sload(keccak256(132, 64))\\n                    }\\n                    \\n                    // Revert if AssetProxy with given id does not exist\\n                    if iszero(assetProxy) {\\n                        // Revert with \u0060Error(\\\u0022ASSET_PROXY_DOES_NOT_EXIST\\\u0022)\u0060\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                        mstore(64, 0x0000001a41535345545f50524f58595f444f45535f4e4f545f45584953540000)\\n                        mstore(96, 0)\\n                        revert(0, 100)\\n                    }\\n    \\n                    // Copy \u0060nestedAssetData[i]\u0060 from calldata to memory\\n                    calldatacopy(\\n                        132,                                // memory slot after \u0060amounts[i]\u0060\\n                        nestedAssetDataElementLenStart,     // location of \u0060nestedAssetData[i]\u0060 in calldata\\n                        add(nestedAssetDataElementLen, 32)  // \u0060nestedAssetData[i].length\u0060 plus 32 byte length\\n                    )\\n\\n                    // call \u0060assetProxy.transferFrom\u0060\\n                    let success := call(\\n                        gas,                                    // forward all gas\\n                        assetProxy,                             // call address of asset proxy\\n                        0,                                      // don\u0027t send any ETH\\n                        0,                                      // pointer to start of input\\n                        add(164, nestedAssetDataElementLen),    // length of input  \\n                        0,                                      // write output over memory that won\u0027t be reused\\n                        0                                       // don\u0027t copy output to memory\\n                    )\\n\\n                    // Revert with reason given by AssetProxy if \u0060transferFrom\u0060 call failed\\n                    if iszero(success) {\\n                        returndatacopy(\\n                            0,                // copy to memory at 0\\n                            0,                // copy from return data at 0\\n                            returndatasize()  // copy all return data\\n                        )\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Return if no \u0060transferFrom\u0060 calls reverted\\n                return(0, 0)\\n            }\\n\\n            // Revert if undefined function is called\\n            revert(0, 0)\\n        }\\n    }\\n\\n    /// @dev Gets the proxy id associated with the proxy address.\\n    /// @return Proxy id.\\n    function getProxyId()\\n        external\\n        pure\\n        returns (bytes4)\\n    {\\n        return PROXY_ID;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/MixinAssetProxyDispatcher.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022@0x/contracts-utils/contracts/src/Ownable.sol\\\u0022;\\nimport \\\u0022./mixins/MAssetProxyDispatcher.sol\\\u0022;\\nimport \\\u0022./interfaces/IAssetProxy.sol\\\u0022;\\n\\n\\ncontract MixinAssetProxyDispatcher is\\n    Ownable,\\n    MAssetProxyDispatcher\\n{\\n    // Mapping from Asset Proxy Id\u0027s to their respective Asset Proxy\\n    mapping (bytes4 =\u003E address) public assetProxies;\\n\\n    /// @dev Registers an asset proxy to its asset proxy id.\\n    ///      Once an asset proxy is registered, it cannot be unregistered.\\n    /// @param assetProxy Address of new asset proxy to register.\\n    function registerAssetProxy(address assetProxy)\\n        external\\n        onlyOwner\\n    {\\n        // Ensure that no asset proxy exists with current id.\\n        bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\\n        address currentAssetProxy = assetProxies[assetProxyId];\\n        require(\\n            currentAssetProxy == address(0),\\n            \\\u0022ASSET_PROXY_ALREADY_EXISTS\\\u0022\\n        );\\n\\n        // Add asset proxy and log registration.\\n        assetProxies[assetProxyId] = assetProxy;\\n        emit AssetProxyRegistered(\\n            assetProxyId,\\n            assetProxy\\n        );\\n    }\\n\\n    /// @dev Gets an asset proxy.\\n    /// @param assetProxyId Id of the asset proxy.\\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\\n    function getAssetProxy(bytes4 assetProxyId)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return assetProxies[assetProxyId];\\n    }\\n\\n    /// @dev Forwards arguments to assetProxy and calls \u0060transferFrom\u0060. Either succeeds or throws.\\n    /// @param assetData Byte array encoded for the asset.\\n    /// @param from Address to transfer token from.\\n    /// @param to Address to transfer token to.\\n    /// @param amount Amount of token to transfer.\\n    function dispatchTransferFrom(\\n        bytes memory assetData,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        // Do nothing if no amount should be transferred.\\n        if (amount \u003E 0 \u0026\u0026 from != to) {\\n            // Ensure assetData length is valid\\n            require(\\n                assetData.length \u003E 3,\\n                \\\u0022LENGTH_GREATER_THAN_3_REQUIRED\\\u0022\\n            );\\n            \\n            // Lookup assetProxy. We do not use \u0060LibBytes.readBytes4\u0060 for gas efficiency reasons.\\n            bytes4 assetProxyId;\\n            assembly {\\n                assetProxyId := and(mload(\\n                    add(assetData, 32)),\\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\\n                )\\n            }\\n            address assetProxy = assetProxies[assetProxyId];\\n\\n            // Ensure that assetProxy exists\\n            require(\\n                assetProxy != address(0),\\n                \\\u0022ASSET_PROXY_DOES_NOT_EXIST\\\u0022\\n            );\\n            \\n            // We construct calldata for the \u0060assetProxy.transferFrom\u0060 ABI.\\n            // The layout of this calldata is in the table below.\\n            // \\n            // | Area     | Offset | Length  | Contents                                    |\\n            // | -------- |--------|---------|-------------------------------------------- |\\n            // | Header   | 0      | 4       | function selector                           |\\n            // | Params   |        | 4 * 32  | function parameters:                        |\\n            // |          | 4      |         |   1. offset to assetData (*)                |\\n            // |          | 36     |         |   2. from                                   |\\n            // |          | 68     |         |   3. to                                     |\\n            // |          | 100    |         |   4. amount                                 |\\n            // | Data     |        |         | assetData:                                  |\\n            // |          | 132    | 32      | assetData Length                            |\\n            // |          | 164    | **      | assetData Contents                          |\\n\\n            assembly {\\n                /////// Setup State ///////\\n                // \u0060cdStart\u0060 is the start of the calldata for \u0060assetProxy.transferFrom\u0060 (equal to free memory ptr).\\n                let cdStart := mload(64)\\n                // \u0060dataAreaLength\u0060 is the total number of words needed to store \u0060assetData\u0060\\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\\n                //  and includes 32-bytes for length.\\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\\n                // \u0060cdEnd\u0060 is the end of the calldata for \u0060assetProxy.transferFrom\u0060.\\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\\n\\n                \\n                /////// Setup Header Area ///////\\n                // This area holds the 4-byte \u0060transferFromSelector\u0060.\\n                // bytes4(keccak256(\\\u0022transferFrom(bytes,address,address,uint256)\\\u0022)) = 0xa85e59e4\\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\\n                \\n                /////// Setup Params Area ///////\\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\\n                // Notes:\\n                //   1. The offset to \u0060assetData\u0060 is the length of the Params Area (128 bytes).\\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\\n                mstore(add(cdStart, 4), 128)\\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\\n                mstore(add(cdStart, 100), amount)\\n                \\n                /////// Setup Data Area ///////\\n                // This area holds \u0060assetData\u0060.\\n                let dataArea := add(cdStart, 132)\\n                // solhint-disable-next-line no-empty-blocks\\n                for {} lt(dataArea, cdEnd) {} {\\n                    mstore(dataArea, mload(assetData))\\n                    dataArea := add(dataArea, 32)\\n                    assetData := add(assetData, 32)\\n                }\\n\\n                /////// Call \u0060assetProxy.transferFrom\u0060 using the constructed calldata ///////\\n                let success := call(\\n                    gas,                    // forward all gas\\n                    assetProxy,             // call address of asset proxy\\n                    0,                      // don\u0027t send any ETH\\n                    cdStart,                // pointer to start of input\\n                    sub(cdEnd, cdStart),    // length of input  \\n                    cdStart,                // write output over input\\n                    512                     // reserve 512 bytes for output\\n                )\\n                if iszero(success) {\\n                    revert(cdStart, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/node_modules/@0x/contracts-utils/contracts/src/Ownable.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity ^0.5.5;\\n\\nimport \\\u0022./interfaces/IOwnable.sol\\\u0022;\\n\\n\\ncontract Ownable is\\n    IOwnable\\n{\\n    address public owner;\\n\\n    constructor ()\\n        public\\n    {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == owner,\\n            \\\u0022ONLY_CONTRACT_OWNER\\\u0022\\n        );\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner)\\n        public\\n        onlyOwner\\n    {\\n        if (newOwner != address(0)) {\\n            owner = newOwner;\\n        }\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/node_modules/@0x/contracts-utils/contracts/src/interfaces/IOwnable.sol\u0022: {\r\n      \u0022content\u0022: \u0022pragma solidity ^0.5.5;\\n\\n\\ncontract IOwnable {\\n\\n    function transferOwnership(address newOwner)\\n        public;\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/mixins/MAssetProxyDispatcher.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022../interfaces/IAssetProxyDispatcher.sol\\\u0022;\\n\\n\\ncontract MAssetProxyDispatcher is\\n    IAssetProxyDispatcher\\n{\\n    // Logs registration of new asset proxy\\n    event AssetProxyRegistered(\\n        bytes4 id,              // Id of new registered AssetProxy.\\n        address assetProxy      // Address of new registered AssetProxy.\\n    );\\n\\n    /// @dev Forwards arguments to assetProxy and calls \u0060transferFrom\u0060. Either succeeds or throws.\\n    /// @param assetData Byte array encoded for the asset.\\n    /// @param from Address to transfer token from.\\n    /// @param to Address to transfer token to.\\n    /// @param amount Amount of token to transfer.\\n    function dispatchTransferFrom(\\n        bytes memory assetData,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal;\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/interfaces/IAssetProxyDispatcher.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\n\\ncontract IAssetProxyDispatcher {\\n\\n    /// @dev Registers an asset proxy to its asset proxy id.\\n    ///      Once an asset proxy is registered, it cannot be unregistered.\\n    /// @param assetProxy Address of new asset proxy to register.\\n    function registerAssetProxy(address assetProxy)\\n        external;\\n\\n    /// @dev Gets an asset proxy.\\n    /// @param assetProxyId Id of the asset proxy.\\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\\n    function getAssetProxy(bytes4 assetProxyId)\\n        external\\n        view\\n        returns (address);\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/interfaces/IAssetProxy.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022./IAuthorizable.sol\\\u0022;\\n\\n\\ncontract IAssetProxy {\\n\\n    /// @dev Transfers assets. Either succeeds or throws.\\n    /// @param assetData Byte array encoded for the respective asset proxy.\\n    /// @param from Address to transfer asset from.\\n    /// @param to Address to transfer asset to.\\n    /// @param amount Amount of asset to transfer.\\n    function transferFrom(\\n        bytes calldata assetData,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        external;\\n    \\n    /// @dev Gets the proxy id associated with the proxy address.\\n    /// @return Proxy id.\\n    function getProxyId()\\n        external\\n        pure\\n        returns (bytes4);\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/interfaces/IAuthorizable.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022@0x/contracts-utils/contracts/src/interfaces/IOwnable.sol\\\u0022;\\n\\n\\ncontract IAuthorizable is\\n    IOwnable\\n{\\n    /// @dev Authorizes an address.\\n    /// @param target Address to authorize.\\n    function addAuthorizedAddress(address target)\\n        external;\\n\\n    /// @dev Removes authorizion of an address.\\n    /// @param target Address to remove authorization from.\\n    function removeAuthorizedAddress(address target)\\n        external;\\n\\n    /// @dev Removes authorizion of an address.\\n    /// @param target Address to remove authorization from.\\n    /// @param index Index of target in authorities array.\\n    function removeAuthorizedAddressAtIndex(\\n        address target,\\n        uint256 index\\n    )\\n        external;\\n    \\n    /// @dev Gets all authorized addresses.\\n    /// @return Array of authorized addresses.\\n    function getAuthorizedAddresses()\\n        external\\n        view\\n        returns (address[] memory);\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/MixinAuthorizable.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022@0x/contracts-utils/contracts/src/Ownable.sol\\\u0022;\\nimport \\\u0022./mixins/MAuthorizable.sol\\\u0022;\\n\\n\\ncontract MixinAuthorizable is\\n    Ownable,\\n    MAuthorizable\\n{\\n    /// @dev Only authorized addresses can invoke functions with this modifier.\\n    modifier onlyAuthorized {\\n        require(\\n            authorized[msg.sender],\\n            \\\u0022SENDER_NOT_AUTHORIZED\\\u0022\\n        );\\n        _;\\n    }\\n\\n    mapping (address =\u003E bool) public authorized;\\n    address[] public authorities;\\n\\n    /// @dev Authorizes an address.\\n    /// @param target Address to authorize.\\n    function addAuthorizedAddress(address target)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            !authorized[target],\\n            \\\u0022TARGET_ALREADY_AUTHORIZED\\\u0022\\n        );\\n\\n        authorized[target] = true;\\n        authorities.push(target);\\n        emit AuthorizedAddressAdded(target, msg.sender);\\n    }\\n\\n    /// @dev Removes authorizion of an address.\\n    /// @param target Address to remove authorization from.\\n    function removeAuthorizedAddress(address target)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            authorized[target],\\n            \\\u0022TARGET_NOT_AUTHORIZED\\\u0022\\n        );\\n\\n        delete authorized[target];\\n        for (uint256 i = 0; i \u003C authorities.length; i\u002B\u002B) {\\n            if (authorities[i] == target) {\\n                authorities[i] = authorities[authorities.length - 1];\\n                authorities.length -= 1;\\n                break;\\n            }\\n        }\\n        emit AuthorizedAddressRemoved(target, msg.sender);\\n    }\\n\\n    /// @dev Removes authorizion of an address.\\n    /// @param target Address to remove authorization from.\\n    /// @param index Index of target in authorities array.\\n    function removeAuthorizedAddressAtIndex(\\n        address target,\\n        uint256 index\\n    )\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            authorized[target],\\n            \\\u0022TARGET_NOT_AUTHORIZED\\\u0022\\n        );\\n        require(\\n            index \u003C authorities.length,\\n            \\\u0022INDEX_OUT_OF_BOUNDS\\\u0022\\n        );\\n        require(\\n            authorities[index] == target,\\n            \\\u0022AUTHORIZED_ADDRESS_MISMATCH\\\u0022\\n        );\\n\\n        delete authorized[target];\\n        authorities[index] = authorities[authorities.length - 1];\\n        authorities.length -= 1;\\n        emit AuthorizedAddressRemoved(target, msg.sender);\\n    }\\n\\n    /// @dev Gets all authorized addresses.\\n    /// @return Array of authorized addresses.\\n    function getAuthorizedAddresses()\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return authorities;\\n    }\\n}\\n\u0022\r\n    },\r\n    \u0022/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/contracts/src/mixins/MAuthorizable.sol\u0022: {\r\n      \u0022content\u0022: \u0022/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\u0022License\\\u0022);\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\u0022AS IS\\\u0022 BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.5.5;\\n\\nimport \\\u0022../interfaces/IAuthorizable.sol\\\u0022;\\n\\n\\ncontract MAuthorizable is\\n    IAuthorizable\\n{\\n    // Event logged when a new address is authorized.\\n    event AuthorizedAddressAdded(\\n        address indexed target,\\n        address indexed caller\\n    );\\n\\n    // Event logged when a currently authorized address is unauthorized.\\n    event AuthorizedAddressRemoved(\\n        address indexed target,\\n        address indexed caller\\n    );\\n\\n    /// @dev Only authorized addresses can invoke functions with this modifier.\\n    modifier onlyAuthorized { revert(); _; }\\n}\\n\u0022\r\n    }\r\n  },\r\n  \u0022settings\u0022: {\r\n    \u0022optimizer\u0022: {\r\n      \u0022enabled\u0022: true,\r\n      \u0022runs\u0022: 1000000,\r\n      \u0022details\u0022: {\r\n        \u0022yul\u0022: true,\r\n        \u0022deduplicate\u0022: true,\r\n        \u0022cse\u0022: true,\r\n        \u0022constantOptimizer\u0022: true\r\n      }\r\n    },\r\n    \u0022outputSelection\u0022: {\r\n      \u0022*\u0022: {\r\n        \u0022*\u0022: [\r\n          \u0022evm.bytecode\u0022,\r\n          \u0022evm.deployedBytecode\u0022,\r\n          \u0022abi\u0022\r\n        ]\r\n      }\r\n    },\r\n    \u0022evmVersion\u0022: \u0022constantinople\u0022,\r\n    \u0022remappings\u0022: [\r\n      \u0022@0x/contracts-utils=/Users/amir/github/0xproject/0x-monorepo/contracts/asset-proxy/node_modules/@0x/contracts-utils\u0022\r\n    ]\r\n  }\r\n}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022assetProxies\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022addAuthorizedAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022authorities\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022assetProxyId\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022getAssetProxy\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeAuthorizedAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022index\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022removeAuthorizedAddressAtIndex\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getProxyId\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022authorized\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022assetProxy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022registerAssetProxy\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getAuthorizedAddresses\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022fallback\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022caller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AuthorizedAddressAdded\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022caller\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AuthorizedAddressRemoved\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022id\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022assetProxy\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AssetProxyRegistered\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"MultiAssetProxy","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e143755ff0f1173f0acd0b565f2319d8a3d4e01888552dea300b86ab9abf09e0"}]