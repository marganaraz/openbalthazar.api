[{"SourceCode":"pragma solidity \u003E=0.4.21 \u003C0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \u0022only a signer can call in MultiSigTools\u0022);\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \u0022transfer_multisig\u0022){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\u0022transfer(address,uint256)\u0022, to, balance));\r\n        require(status, \u0022call failed\u0022);\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\ncontract GTProject is MultiSigTools, TokenClaimer{\r\n  string public project_name;\r\n  string public project_intro;\r\n  string public project_logo;\r\n  string public project_reserve;\r\n\r\n  address public vote_contract;\r\n\r\n  mapping (bytes32 =\u003E address) public extra_contracts;\r\n  string[] public extra_contract_names;\r\n\r\n  event ChangeProjectInfo(string item, string old_value, string new_value);\r\n\r\n  event ChangeVoteContract(address _old_contract, address _contract);\r\n\r\n  event AddExtraContract(string _name, address _contract);\r\n  event RemoveExtraContract(string _name, address _contract);\r\n\r\n  constructor(string memory _name,\r\n              string memory _intro,\r\n              string memory _logo,\r\n              string memory _reserve,\r\n              address _multisig,\r\n              address _vote) MultiSigTools(_multisig) public{\r\n    project_name = _name;\r\n    project_intro = _intro;\r\n    project_logo = _logo;\r\n    project_reserve = _reserve;\r\n    vote_contract = _vote;\r\n  }\r\n\r\n  function strCmp(string memory s1, string memory s2) pure internal returns (bool){\r\n    return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\r\n  }\r\n\r\n  function changeProjectName(uint64 id,\r\n                             string memory _name)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \u0022changeProjectName\u0022){\r\n      if(!strCmp(project_name, _name)){\r\n        emit ChangeProjectInfo(\u0022name\u0022, project_name, _name);\r\n        project_name = _name;\r\n      }\r\n  }\r\n  function changeProjectIntro(uint64 id,\r\n                             string memory _intro)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \u0022changeProjectIntro\u0022){\r\n      if(!strCmp(project_intro, _intro)){\r\n        emit ChangeProjectInfo(\u0022intro\u0022, project_intro, _intro);\r\n        project_intro = _intro;\r\n      }\r\n  }\r\n  function changeProjectLogo(uint64 id,\r\n                             string memory _logo)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \u0022changeProjectLogo\u0022){\r\n      if(!strCmp(project_logo, _logo)){\r\n        emit ChangeProjectInfo(\u0022name\u0022, project_logo, _logo);\r\n        project_logo = _logo ;\r\n      }\r\n  }\r\n  function changeProjectReserve(uint64 id,\r\n                             string memory _reserve)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \u0022changeProjectReserve\u0022){\r\n      if(!strCmp(project_reserve, _reserve)){\r\n        emit ChangeProjectInfo(\u0022reserve\u0022, project_reserve, _reserve);\r\n        project_reserve = _reserve;\r\n      }\r\n  }\r\n\r\n  function changeVoteContract(uint64 id, address _vote) public\r\n    only_signer\r\n    is_majority_sig(id, \u0022changeVoteContract\u0022){\r\n      emit ChangeVoteContract(vote_contract, _vote);\r\n      vote_contract = _vote;\r\n  }\r\n\r\n  function addExtraContract(uint64 id, string memory _name, address _contract) public\r\n    only_signer\r\n    is_majority_sig(id, \u0022addExtraContract\u0022){\r\n      require(_contract != address(0x0), \u0022address can\u0027t be 0\u0022);\r\n      bytes32 hash = keccak256(abi.encodePacked(_name));\r\n      require(extra_contracts[hash] == address(0x0), \u0022already exist\u0022);\r\n      extra_contracts[hash] = _contract;\r\n      extra_contract_names.push(_name);\r\n      emit AddExtraContract(_name, _contract);\r\n  }\r\n\r\n  function removeExtraContract(uint64 id, string memory _name) public\r\n    only_signer\r\n    is_majority_sig(id, \u0022removeExtraContract\u0022){\r\n      bytes32 hash = keccak256(abi.encodePacked(_name));\r\n      require(extra_contracts[hash] != address(0x0), \u0022not exist\u0022);\r\n      address addr = extra_contracts[hash];\r\n      delete extra_contracts[hash];\r\n\r\n      for(uint i = 0; i \u003C extra_contract_names.length; i\u002B\u002B){\r\n        if(keccak256(abi.encodePacked(extra_contract_names[i])) == hash ){\r\n          extra_contract_names[i] = extra_contract_names[extra_contract_names.length - 1];\r\n          delete extra_contract_names[extra_contract_names.length - 1];\r\n          extra_contract_names.length -- ;\r\n          break;\r\n        }\r\n      }\r\n      emit RemoveExtraContract(_name, addr);\r\n  }\r\n\r\n  function getExtraContractNumber() public view returns (uint){\r\n    return extra_contract_names.length;\r\n  }\r\n  function getExtraContractInfo(uint i) public view returns(string memory name, address addr){\r\n    require(i \u003C extra_contract_names.length, \u0022out of range\u0022);\r\n    name = extra_contract_names[i];\r\n    addr = getExtraContractAddress(name);\r\n  }\r\n\r\n  function getExtraContractAddress(string memory _name) public view returns(address){\r\n      bytes32 hash = keccak256(abi.encodePacked(_name));\r\n      return extra_contracts[hash];\r\n  }\r\n\r\n  function claimStdTokens(uint64 id, address _token, address payable to) public only_signer is_majority_sig(id, \u0022claimStdTokens\u0022){\r\n    _claimStdTokens(_token, to);\r\n  }\r\n}\r\n\r\ncontract GTProjectFactory{\r\n\r\n  event CreateGTProject(address _addr, string _name, string _intro, string _logo, string _reserve,\r\n                       address _multisig, address _vote);\r\n\r\n  function createGTProject(string memory _name,\r\n                           string memory _intro,\r\n                           string memory _logo,\r\n                           string memory _reserve,\r\n                           address _multisig,\r\n                           address _vote) public returns(address){\r\n    GTProject gtp = new GTProject(_name, _intro, _logo, _reserve, _multisig, _vote);\r\n    emit CreateGTProject(address(gtp), _name, _intro, _logo, _reserve, _multisig, _vote);\r\n    return address(gtp);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_intro\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_logo\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_reserve\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_multisig\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_vote\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022createGTProject\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_name\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_intro\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_logo\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_reserve\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_multisig\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_vote\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CreateGTProject\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"GTProjectFactory","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ba12ab6916e1e5c6ccc8f180e276383079ba105d7ab5a8e0cbc4e6976176e4a7"}]