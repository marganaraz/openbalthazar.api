[{"SourceCode":"{\u0022EBitcoin.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\u0022./ERC20.sol\\\u0022;\\r\\nimport \\\u0022./ERC20Detailed.sol\\\u0022;\\r\\nimport \\\u0022./ERC20Pow.sol\\\u0022;\\r\\nimport \\\u0022./Ownable.sol\\\u0022;\\r\\n\\r\\n/**\\r\\n* @dev EBitcoin Token (EBT)\\r\\n*/\\r\\ncontract EBitcoin is IERC20, ERC20, ERC20Detailed, ERC20Pow, Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct BankAccount {\\r\\n        uint256 balance;\\r\\n        uint256 interestSettled;\\r\\n        uint256 lastBlockNumber;\\r\\n    }\\r\\n\\r\\n    mapping (address =\\u003e BankAccount) private _bankAccounts;\\r\\n\\r\\n    //Suppose one block in 10 minutes, one day is 144\\r\\n    uint256 private _interestInterval = 144;\\r\\n\\r\\n    /**\\r\\n    * @dev Init\\r\\n    */\\r\\n    constructor ()\\r\\n        ERC20Detailed(\\\u0022EBitcoin Token\\\u0022, \\\u0022EBT\\\u0022, 8)\\r\\n        ERC20Pow(2**16, 2**232, 210000, 5000000000, 504, 60, 144)\\r\\n    public {}\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the amount of bank balance owned by \u0060account\u0060\\r\\n    */\\r\\n    function bankBalanceOf(address account) public view returns (uint256) {\\r\\n        return _bankAccounts[account].balance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the amount of bank interes owned by \u0060account\u0060\\r\\n    */\\r\\n    function bankInterestOf(address account) public view returns (uint256) {\\r\\n\\r\\n        // No interest without deposit\\r\\n        BankAccount storage item = _bankAccounts[account];\\r\\n        if(0 == item.balance)  return 0;\\r\\n\\r\\n        // balance * day / 365 * 0.01\\r\\n        uint256 blockNumber = getBlockCount();\\r\\n        uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\\r\\n        uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\\r\\n        return interest.add(item.interestSettled);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deposit \u0060amount\u0060 tokens in the bank\\r\\n    *\\r\\n    * Returns a boolean value indicating whether the operation succeeded\\r\\n    *\\r\\n    * Emits a {Transfer} event.\\r\\n    */\\r\\n    function bankDeposit(uint256 amount) public returns (bool) {\\r\\n\\r\\n        // Deducting balance\\r\\n        uint256 balance = _getBalance(msg.sender);\\r\\n        _setBalance(msg.sender, balance.sub(amount, \\\u0022Token: bank deposit amount exceeds balance\\\u0022));\\r\\n\\r\\n        // If have a bank balance, need to calculate interest first\\r\\n        BankAccount storage item = _bankAccounts[msg.sender];\\r\\n        if (0 != item.balance) {\\r\\n\\r\\n            // balance * day / 365 * 0.01\\r\\n            uint256 blockNumber = getBlockCount();\\r\\n            uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\\r\\n            uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\\r\\n\\r\\n            // Append\\r\\n            item.balance = item.balance.add(amount);\\r\\n            item.interestSettled = item.interestSettled.add(interest);\\r\\n            item.lastBlockNumber = blockNumber;\\r\\n        }\\r\\n        else {\\r\\n\\r\\n            // Init\\r\\n            item.balance = amount;\\r\\n            item.interestSettled = 0;\\r\\n            item.lastBlockNumber = getBlockCount();\\r\\n        }\\r\\n\\r\\n        emit Transfer(msg.sender, address(0), amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Withdrawal \u0060amount\u0060 tokens in the bank\\r\\n    *\\r\\n    * Returns a boolean value indicating whether the operation succeeded\\r\\n    *\\r\\n    * Emits a {Transfer} event.\\r\\n    */\\r\\n    function bankWithdrawal(uint256 amount) public returns (bool) {\\r\\n\\r\\n        // Bank balance greater than or equal amount\\r\\n        BankAccount storage item = _bankAccounts[msg.sender];\\r\\n        require(0 == amount || 0 != item.balance, \\\u0022Token: withdrawal amount exceeds bank balance\\\u0022);\\r\\n\\r\\n        // balance * day / 365 * 0.01\\r\\n        uint256 blockNumber = getBlockCount();\\r\\n        uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\\r\\n        uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\\r\\n        interest = interest.add(item.interestSettled);\\r\\n\\r\\n        // Interest is enough to pay\\r\\n        if (interest \\u003e= amount) {\\r\\n\\r\\n            // Deducting interest\\r\\n            item.lastBlockNumber = blockNumber;\\r\\n            item.interestSettled = interest.sub(amount);\\r\\n\\r\\n            // Transfer balance and increase total supply\\r\\n            _setBalance(msg.sender, _getBalance(msg.sender).add(amount));\\r\\n            _setTotalSupply(_getTotalSupply().add(amount));\\r\\n        }\\r\\n        else {\\r\\n\\r\\n            // Deducting interest and bank balance\\r\\n            uint256 remainAmount = amount.sub(interest);\\r\\n            item.balance = item.balance.sub(remainAmount, \\\u0022Token: withdrawal amount exceeds bank balance\\\u0022);\\r\\n            item.lastBlockNumber = blockNumber;\\r\\n            item.interestSettled = 0;\\r\\n\\r\\n            // Transfer balance and increase total supply\\r\\n            _setBalance(msg.sender, _getBalance(msg.sender).add(amount));\\r\\n            _setTotalSupply(_getTotalSupply().add(interest));\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Owner can transfer out any accidentally sent ERC20 tokens\\r\\n    */\\r\\n    function transferAnyERC20Token(address tokenAddress, uint256 amount) public onlyOwner returns (bool) {\\r\\n        return IERC20(tokenAddress).transfer(getOwner(), amount);\\r\\n    }\\r\\n}\u0022},\u0022ERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\u0022./IERC20.sol\\\u0022;\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\n\\r\\n/**\\r\\n* @dev ERC20.\\r\\n*/\\r\\ncontract ERC20 is IERC20 {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-totalSupply}.\\r\\n    */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-balanceOf}.\\r\\n    */\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-transfer}.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060recipient\u0060 cannot be the zero address.\\r\\n    * - the caller must have a balance of at least \u0060amount\u0060.\\r\\n    */\\r\\n    function transfer(address recipient, uint256 amount) public returns (bool){\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-allowance}.\\r\\n    */\\r\\n    function allowance(address owner, address spender) public view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-approve}.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060spender\u0060 cannot be the zero address.\\r\\n    */\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev See {IERC20-transferFrom}.\\r\\n    *\\r\\n    * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n    * required by the EIP. See the note at the beginning of {ERC20};\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\\r\\n    * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\\r\\n    * - the caller must have allowance for \u0060sender\u0060\\u0027s tokens of at least\\r\\n    * \u0060amount\u0060.\\r\\n    */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\u0022ERC20: transfer amount exceeds allowance\\\u0022));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\\r\\n    *\\r\\n    * This is an alternative to {approve} that can be used as a mitigation for\\r\\n    * problems described in {IERC20-approve}.\\r\\n    *\\r\\n    * Emits an {Approval} event indicating the updated allowance.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060spender\u0060 cannot be the zero address.\\r\\n    */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\\r\\n    *\\r\\n    * This is an alternative to {approve} that can be used as a mitigation for\\r\\n    * problems described in {IERC20-approve}.\\r\\n    *\\r\\n    * Emits an {Approval} event indicating the updated allowance.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060spender\u0060 cannot be the zero address.\\r\\n    * - \u0060spender\u0060 must have allowance for the caller of at least\\r\\n    * \u0060subtractedValue\u0060.\\r\\n    */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\u0022ERC20: decreased allowance below zero\\\u0022));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\\r\\n    *\\r\\n    * This is internal function is equivalent to {transfer}, and can be used to\\r\\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n    *\\r\\n    * Emits a {Transfer} event.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060sender\u0060 cannot be the zero address.\\r\\n    * - \u0060recipient\u0060 cannot be the zero address.\\r\\n    * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\\r\\n    */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\u0022ERC20: transfer from the zero address\\\u0022);\\r\\n        require(recipient != address(0), \\\u0022ERC20: transfer to the zero address\\\u0022);\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\u0022ERC20: transfer amount exceeds balance\\\u0022);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\\r\\n    *\\r\\n    * This is internal function is equivalent to \u0060approve\u0060, and can be used to\\r\\n    * e.g. set automatic allowances for certain subsystems, etc.\\r\\n    *\\r\\n    * Emits an {Approval} event.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - \u0060owner\u0060 cannot be the zero address.\\r\\n    * - \u0060spender\u0060 cannot be the zero address.\\r\\n    */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\u0022ERC20: approve from the zero address\\\u0022);\\r\\n        require(spender != address(0), \\\u0022ERC20: approve to the zero address\\\u0022);\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\\r\\n    * the total supply.\\r\\n    *\\r\\n    * Emits a {Transfer} event with \u0060from\u0060 set to the zero address.\\r\\n    *\\r\\n    * Requirements\\r\\n    *\\r\\n    * - \u0060to\u0060 cannot be the zero address.\\r\\n    */\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\u0022ERC20: mint to the zero address\\\u0022);\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\\r\\n    * total supply.\\r\\n    *\\r\\n    * Emits a {Transfer} event with \u0060to\u0060 set to the zero address.\\r\\n    *\\r\\n    * Requirements\\r\\n    *\\r\\n    * - \u0060account\u0060 cannot be the zero address.\\r\\n    * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\\r\\n    */\\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\u0022ERC20: burn from the zero address\\\u0022);\\r\\n        _balances[account] = _balances[account].sub(amount, \\\u0022ERC20: burn amount exceeds balance\\\u0022);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Destroys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\\r\\n    * from the caller\\u0027s allowance.\\r\\n    *\\r\\n    * See {_burn} and {_approve}.\\r\\n    */\\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _burn(account, amount);\\r\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \\\u0022ERC20: burn amount exceeds allowance\\\u0022));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Internal method\\r\\n    */\\r\\n    function _getTotalSupply() internal view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Internal method\\r\\n    */\\r\\n    function _setTotalSupply(uint256 value) internal {\\r\\n        _totalSupply = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Internal method\\r\\n    */\\r\\n    function _getBalance(address account) internal view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Internal method\\r\\n    */\\r\\n    function _setBalance(address account, uint256 value) internal {\\r\\n        _balances[account] = value;\\r\\n    }\\r\\n}\u0022},\u0022ERC20Detailed.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\u0022./ERC20.sol\\\u0022;\\r\\n\\r\\n/**\\r\\n* @dev Optional functions from the ERC20 standard.\\r\\n*/\\r\\ncontract ERC20Detailed is ERC20 {\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n    * @dev Sets the values for \u0060name\u0060, \u0060symbol\u0060, and \u0060decimals\u0060. All three of\\r\\n    * these values are immutable: they can only be set once during\\r\\n    * construction.\\r\\n    */\\r\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n        _decimals = decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the name of the token.\\r\\n    */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n    * name.\\r\\n    */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the number of decimals used to get its user representation.\\r\\n    * For example, if \u0060decimals\u0060 equals \u00602\u0060, a balance of \u0060505\u0060 tokens should\\r\\n    * be displayed to a user as \u00605,05\u0060 (\u0060505 / 10 ** 2\u0060).\\r\\n    *\\r\\n    * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n    * Ether and Wei.\\r\\n    *\\r\\n    * NOTE: This information is only used for _display_ purposes: it in\\r\\n    * no way affects any of the arithmetic of the contract, including\\r\\n    * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n    */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n}\u0022},\u0022ERC20Pow.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\u0022./SafeMath.sol\\\u0022;\\r\\nimport \\\u0022./ERC20.sol\\\u0022;\\r\\n\\r\\n/**\\r\\n* @dev ERC20Pow\\r\\n*/\\r\\ncontract ERC20Pow is ERC20 {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // recommended value is 2**16\\r\\n    uint256 private _MINIMUM_TARGET;\\r\\n\\r\\n    // a big number is easier, bitcoin uses 2**224\\r\\n    uint256 private _MAXIMUM_TARGET;\\r\\n\\r\\n    // Reward halving interval, bitcoin uses 210000\\r\\n    uint256 private _REWARD_INTERVAL;\\r\\n\\r\\n    // Difficulty adjustment interval, bitcoin uses 2016\\r\\n    uint256 private _BLOCKS_PER_READJUSTMENT;\\r\\n\\r\\n    // Suppose the block is 10 minutes, the ETH block is 10 seconds, then the value is 600/10=60\\r\\n    uint256 private _ETHBLOCK_EXCHANGERATE;\\r\\n\\r\\n    // Urgent adjustment threshold\\r\\n    uint256 private _URGENTADJUST_THRESHOLD;\\r\\n\\r\\n    // Block count\\r\\n    uint256 private _blockCount;\\r\\n\\r\\n    // Block reward, bitcoin uses 5000000000\\r\\n    uint256 private _blockReward;\\r\\n\\r\\n    // Mining related\\r\\n    uint256 private _miningTarget;\\r\\n    bytes32 private _challengeNumber;\\r\\n\\r\\n    // Prevent duplication\\r\\n    mapping(bytes32 =\\u003e bytes32) private _solutionForChallenge;\\r\\n\\r\\n    // Calculate the time interval\\r\\n    uint256 private _latestDifficultyPeriodStarted;\\r\\n\\r\\n    /**\\r\\n    * @dev Init\\r\\n    */\\r\\n    constructor (\\r\\n        uint256 minimumTarget,\\r\\n        uint256 maximumTarget,\\r\\n        uint256 rewardInterval,\\r\\n        uint256 blockReward,\\r\\n        uint256 blocksPerReadjustment,\\r\\n        uint256 ethBlockExchangeRate,\\r\\n        uint256 urgentAdjustThreshold\\r\\n    ) public {\\r\\n        _MINIMUM_TARGET = minimumTarget;\\r\\n        _MAXIMUM_TARGET = maximumTarget;\\r\\n        _REWARD_INTERVAL = rewardInterval;\\r\\n        _BLOCKS_PER_READJUSTMENT = blocksPerReadjustment;\\r\\n        _ETHBLOCK_EXCHANGERATE = ethBlockExchangeRate;\\r\\n        _URGENTADJUST_THRESHOLD = urgentAdjustThreshold;\\r\\n        _blockReward = blockReward;\\r\\n        _miningTarget = _MAXIMUM_TARGET;\\r\\n        _latestDifficultyPeriodStarted = uint256(block.number);\\r\\n        _newMiningBlock();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Current block number\\r\\n    */\\r\\n    function getBlockCount() public view returns (uint256) {\\r\\n        return _blockCount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Current challenge number\\r\\n    */\\r\\n    function getChallengeNumber() public view returns (bytes32) {\\r\\n        return _challengeNumber;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Current mining difficulty\\r\\n    */\\r\\n    function getMiningDifficulty() public view returns (uint256) {\\r\\n        return _MAXIMUM_TARGET.div(_miningTarget);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Current mining target\\r\\n    */\\r\\n    function getMiningTarget() public view returns (uint256) {\\r\\n        return _miningTarget;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Current mining reward\\r\\n    */\\r\\n    function getMiningReward() public view returns (uint256) {\\r\\n        return _blockReward;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Submit proof\\r\\n    * Emits a {SubmitProof} event\\r\\n    */\\r\\n    function submitProof(uint256 nonce, bytes32 challengeDigest) public returns (bool) {\\r\\n\\r\\n        // Calculated hash\\r\\n        bytes32 digest = keccak256(abi.encodePacked(_challengeNumber, msg.sender, nonce));\\r\\n\\r\\n        // Verify digest\\r\\n        require(digest == challengeDigest, \\\u0022ERC20Pow: invalid params\\\u0022);\\r\\n        require(uint256(digest) \\u003c= _miningTarget, \\\u0022ERC20Pow: invalid nonce\\\u0022);\\r\\n\\r\\n        // Prevent duplication\\r\\n        bytes32 solution = _solutionForChallenge[_challengeNumber];\\r\\n        _solutionForChallenge[_challengeNumber] = digest;\\r\\n        require(solution == bytes32(0), \\\u0022ERC20Pow: already exists\\\u0022);\\r\\n\\r\\n        // Mint\\r\\n        if (0 != _blockReward) {\\r\\n            _mint(msg.sender, _blockReward);\\r\\n        }\\r\\n\\r\\n        // Next round of challenges\\r\\n        _newMiningBlock();\\r\\n\\r\\n        emit SubmitProof(msg.sender, _miningTarget, _challengeNumber);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Urgent adjust difficulty\\r\\n    * When the hash power suddenly drops sharply, the difficulty can be reduced\\r\\n    * Emits a {UrgentAdjustDifficulty} event\\r\\n    */\\r\\n    function urgentAdjustDifficulty() public returns (bool) {\\r\\n\\r\\n        // Must greatly exceed expectations\\r\\n        uint256 targetEthBlocksPerDiffPeriod = _BLOCKS_PER_READJUSTMENT.mul(_ETHBLOCK_EXCHANGERATE);\\r\\n        uint256 ethBlocksSinceLastDifficultyPeriod = uint256(block.number).sub(_latestDifficultyPeriodStarted);\\r\\n        require(ethBlocksSinceLastDifficultyPeriod.div(targetEthBlocksPerDiffPeriod) \\u003e _URGENTADJUST_THRESHOLD, \\\u0022ERC20Pow: invalid operation\\\u0022);\\r\\n\\r\\n        _reAdjustDifficulty();\\r\\n        _newChallengeNumber();\\r\\n\\r\\n        emit UrgentAdjustDifficulty(msg.sender, _miningTarget, _challengeNumber);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev internal\\r\\n    */\\r\\n    function _newChallengeNumber() internal {\\r\\n        _challengeNumber = keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev internal\\r\\n    */\\r\\n    function _newMiningBlock() internal {\\r\\n\\r\\n        // Block number \u002B 1\\r\\n        _blockCount = _blockCount.add(1);\\r\\n\\r\\n        // Block reward is cut in half\\r\\n        if (0 == _blockCount.mod(_REWARD_INTERVAL)) {\\r\\n            _blockReward = _blockReward.div(2);\\r\\n        }\\r\\n\\r\\n        // Re-Adjust difficulty\\r\\n        if(0 == _blockCount.mod(_BLOCKS_PER_READJUSTMENT)) {\\r\\n            _reAdjustDifficulty();\\r\\n        }\\r\\n\\r\\n        // Generate challenge number\\r\\n        _newChallengeNumber();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev internal\\r\\n    */\\r\\n    function _reAdjustDifficulty() internal {\\r\\n\\r\\n        uint256 targetEthBlocksPerDiffPeriod = _BLOCKS_PER_READJUSTMENT.mul(_ETHBLOCK_EXCHANGERATE);\\r\\n        uint256 ethBlocksSinceLastDifficultyPeriod = uint256(block.number).sub(_latestDifficultyPeriodStarted);\\r\\n\\r\\n        // If there were less eth blocks passed in time than expected\\r\\n        if (ethBlocksSinceLastDifficultyPeriod \\u003c targetEthBlocksPerDiffPeriod) {\\r\\n\\r\\n            // Increase difficulty\\r\\n            uint256 excessBlockPct = targetEthBlocksPerDiffPeriod.mul(100).div(ethBlocksSinceLastDifficultyPeriod);\\r\\n\\r\\n            // Range 0 - 1000\\r\\n            uint256 excessBlockPctExtra = excessBlockPct.sub(100);\\r\\n            if(excessBlockPctExtra \\u003e 1000) excessBlockPctExtra = 1000;\\r\\n\\r\\n            // Up to 50%\\r\\n            _miningTarget = _miningTarget.sub(_miningTarget.div(2000).mul(excessBlockPctExtra));\\r\\n        }\\r\\n        else if(ethBlocksSinceLastDifficultyPeriod \\u003e targetEthBlocksPerDiffPeriod) {\\r\\n\\r\\n            // Reduce difficulty\\r\\n            uint256 shortageBlockPct = ethBlocksSinceLastDifficultyPeriod.mul(100).div(targetEthBlocksPerDiffPeriod);\\r\\n\\r\\n            // Range 0 - 1000\\r\\n            uint256 shortageBlockPctExtra = shortageBlockPct.sub(100);\\r\\n            if(shortageBlockPctExtra \\u003e 1000) shortageBlockPctExtra = 1000;\\r\\n\\r\\n            // Up to 50%\\r\\n            _miningTarget = _miningTarget.add(_miningTarget.div(2000).mul(shortageBlockPctExtra));\\r\\n        }\\r\\n\\r\\n        if(_miningTarget \\u003c _MINIMUM_TARGET) _miningTarget = _MINIMUM_TARGET;\\r\\n        if(_miningTarget \\u003e _MAXIMUM_TARGET) _miningTarget = _MAXIMUM_TARGET;\\r\\n        _latestDifficultyPeriodStarted = block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Emitted when new challenge number\\r\\n    */\\r\\n    event SubmitProof(address indexed miner, uint256 newMiningTarget, bytes32 newChallengeNumber);\\r\\n    event UrgentAdjustDifficulty(address indexed miner, uint256 newMiningTarget, bytes32 newChallengeNumber);\\r\\n}\u0022},\u0022IERC20.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n* @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n* the optional functions; to access them see {ERC20Detailed}.\\r\\n*/\\r\\ninterface IERC20 {\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the amount of tokens in existence.\\r\\n    */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the amount of tokens owned by \u0060account\u0060.\\r\\n    */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @dev Moves \u0060amount\u0060 tokens from the caller\\u0027s account to \u0060recipient\u0060.\\r\\n    *\\r\\n    * Returns a boolean value indicating whether the operation succeeded.\\r\\n    *\\r\\n    * Emits a {Transfer} event.\\r\\n    */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\\r\\n    * allowed to spend on behalf of \u0060owner\u0060 through {transferFrom}. This is\\r\\n    * zero by default.\\r\\n    *\\r\\n    * This value changes when {approve} or {transferFrom} are called.\\r\\n    */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\\u0027s tokens.\\r\\n    *\\r\\n    * Returns a boolean value indicating whether the operation succeeded.\\r\\n    *\\r\\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n    * that someone may use both the old and the new allowance by unfortunate\\r\\n    * transaction ordering. One possible solution to mitigate this race\\r\\n    * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n    * desired value afterwards:\\r\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n    *\\r\\n    * Emits an {Approval} event.\\r\\n    */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n    * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\\r\\n    * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\\u0027s\\r\\n    * allowance.\\r\\n    *\\r\\n    * Returns a boolean value indicating whether the operation succeeded.\\r\\n    *\\r\\n    * Emits a {Transfer} event.\\r\\n    */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n    * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\\r\\n    * another (\u0060to\u0060).\\r\\n    *\\r\\n    * Note that \u0060value\u0060 may be zero.\\r\\n    */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n    * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\\r\\n    * a call to {approve}. \u0060value\u0060 is the new allowance.\\r\\n    */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\u0022},\u0022Ownable.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n* @dev Ownable authentication.\\r\\n*/\\r\\ncontract Ownable {\\r\\n\\r\\n    /**\\r\\n    * @dev Owner account.\\r\\n    */\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n    * @dev Init owner as the contract creator.\\r\\n    */\\r\\n    constructor() public {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Owner authentication.\\r\\n    */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == _owner, \\\u0022Ownable: authentication failed\\\u0022);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Get current owner.\\r\\n    */\\r\\n    function getOwner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer owner.\\r\\n    */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(_owner != newOwner, \\\u0022Ownable: transfer ownership new owner and old owner are the same\\\u0022);\\r\\n        address oldOwner = _owner; _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Event transfer owner.\\r\\n    */\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n}\u0022},\u0022SafeMath.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n* @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n* checks.\\r\\n*\\r\\n* Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n* in bugs, because programmers usually assume that an overflow raises an\\r\\n* error, which is the standard behavior in high level programming languages.\\r\\n* \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\\r\\n* operation overflows.\\r\\n*\\r\\n* Using this library instead of the unchecked operations eliminates an entire\\r\\n* class of bugs, so it\\u0027s recommended to use it always.\\r\\n*/\\r\\nlibrary SafeMath {\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the addition of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060\u002B\u0060 operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Addition cannot overflow.\\r\\n    */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a \u002B b;\\r\\n        require(c \\u003e= a, \\\u0022SafeMath: addition overflow\\\u0022);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n    * overflow (when the result is negative).\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Subtraction cannot overflow.\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\u0022SafeMath: subtraction overflow\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n    * overflow (when the result is negative).\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060-\u0060 operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Subtraction cannot overflow.\\r\\n    *\\r\\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n    * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060*\u0060 operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Multiplication cannot overflow.\\r\\n    */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0)  return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\u0022SafeMath: multiplication overflow\\\u0022);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n    * division by zero. The result is rounded towards zero.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n    * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\u0022SafeMath: division by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n    * division by zero. The result is rounded towards zero.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060/\u0060 operator. Note: this function uses a\\r\\n    * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\\r\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n    * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n    */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n    * Reverts when dividing by zero.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n    * invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\u0022SafeMath: modulo by zero\\\u0022);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n    * Reverts with custom message when dividing by zero.\\r\\n    *\\r\\n    * Counterpart to Solidity\\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\\r\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n    * invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    *\\r\\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\r\\n    * @dev Get it via \u0060npm install @openzeppelin/contracts@next\u0060.\\r\\n    */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\u0022}}","ABI":"[{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022oldOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022miner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newMiningTarget\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022newChallengeNumber\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022SubmitProof\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022miner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newMiningTarget\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022newChallengeNumber\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022UrgentAdjustDifficulty\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022bankBalanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022bankDeposit\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022bankInterestOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022bankWithdrawal\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022subtractedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getBlockCount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getChallengeNumber\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMiningDifficulty\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMiningReward\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getMiningTarget\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022getOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022addedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bytes32\u0022,\u0022name\u0022:\u0022challengeDigest\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022submitProof\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferAnyERC20Token\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022urgentAdjustDifficulty\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"EBitcoin","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae71d5392e9961f62d0e91dfdcdef9464b3c1ba09c7d9e049a03e3fe204ae536"}]