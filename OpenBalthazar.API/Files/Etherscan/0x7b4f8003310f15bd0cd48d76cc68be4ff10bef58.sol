[{"SourceCode":"/**\r\n *  Oracle - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n *\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see \u003Chttps://www.gnu.org/licenses/\u003E.\r\n */\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003E= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest \u002B= 32;\r\n            src \u002B= 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint(self) \u0026 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret \u002B= 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint(self) \u0026 0xffffffffffffffff == 0) {\r\n            ret \u002B= 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint(self) \u0026 0xffffffff == 0) {\r\n            ret \u002B= 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint(self) \u0026 0xffff == 0) {\r\n            ret \u002B= 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint(self) \u0026 0xff == 0) {\r\n            ret \u002B= 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for \u0060self\u0060 in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as \u0060self\u0060.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice\u0027s text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call \u0060slice.empty()\u0060 if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr \u002B self._len;\r\n        for (l = 0; ptr \u003C end; l\u002B\u002B) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b \u003C 0x80) {\r\n                ptr \u002B= 1;\r\n            } else if (b \u003C 0xE0) {\r\n                ptr \u002B= 2;\r\n            } else if (b \u003C 0xF0) {\r\n                ptr \u002B= 3;\r\n            } else if (b \u003C 0xF8) {\r\n                ptr \u002B= 4;\r\n            } else if (b \u003C 0xFC) {\r\n                ptr \u002B= 5;\r\n            } else {\r\n                ptr \u002B= 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if \u0060other\u0060 comes lexicographically after\r\n     *      \u0060self\u0060, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len \u003C self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx \u003C shortest; idx \u002B= 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if (shortest \u003C 32) {\r\n                    mask = ~(2 ** (8 * (32 - shortest \u002B idx)) - 1);\r\n                }\r\n                uint256 diff = (a \u0026 mask) - (b \u0026 mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr \u002B= 32;\r\n            otherptr \u002B= 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into \u0060rune\u0060, advancing the\r\n     *      slice to point to the next rune and returning \u0060self\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return \u0060rune\u0060.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b \u003C 0x80) {\r\n            l = 1;\r\n        } else if (b \u003C 0xE0) {\r\n            l = 2;\r\n        } else if (b \u003C 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l \u003E self._len) {\r\n            rune._len = self._len;\r\n            self._ptr \u002B= self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr \u002B= l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from \u0060self\u0060.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b \u003C 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if (b \u003C 0xE0) {\r\n            ret = b \u0026 0x1F;\r\n            length = 2;\r\n        } else if (b \u003C 0xF0) {\r\n            ret = b \u0026 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b \u0026 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length \u003E self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i \u003C length; i\u002B\u002B) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) \u0026 0xFF;\r\n            if (b \u0026 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b \u0026 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if \u0060self\u0060 starts with \u0060needle\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len \u003C needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If \u0060self\u0060 starts with \u0060needle\u0060, \u0060needle\u0060 is removed from the\r\n     *      beginning of \u0060self\u0060. Otherwise, \u0060self\u0060 is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return \u0060self\u0060\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len \u003C needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr \u002B= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with \u0060needle\u0060.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len \u003C needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr \u002B self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If \u0060self\u0060 ends with \u0060needle\u0060, \u0060needle\u0060 is removed from the\r\n     *      end of \u0060self\u0060. Otherwise, \u0060self\u0060 is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return \u0060self\u0060\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len \u003C needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr \u002B self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // \u0060needle\u0060 in \u0060self\u0060, or the first byte after \u0060self\u0060 if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen \u003C= selflen) {\r\n            if (needlelen \u003C= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr \u002B selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr \u003E= end)\r\n                        return selfptr \u002B selflen;\r\n                    ptr\u002B\u002B;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx \u003C= selflen - needlelen; idx\u002B\u002B) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr \u002B= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr \u002B selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // \u0060needle\u0060 in \u0060self\u0060, or the address of \u0060self\u0060 if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen \u003C= selflen) {\r\n            if (needlelen \u003C= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr \u002B selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr \u003C= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr \u002B needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr \u002B (selflen - needlelen);\r\n                while (ptr \u003E= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr \u002B needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies \u0060self\u0060 to contain everything from the first occurrence of\r\n     *      \u0060needle\u0060 to the end of the slice. \u0060self\u0060 is set to the empty slice\r\n     *      if \u0060needle\u0060 is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return \u0060self\u0060.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies \u0060self\u0060 to contain the part of the string from the start of\r\n     *      \u0060self\u0060 to the end of the first occurrence of \u0060needle\u0060. If \u0060needle\u0060\r\n     *      is not found, \u0060self\u0060 is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return \u0060self\u0060.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything after the first\r\n     *      occurrence of \u0060needle\u0060, and \u0060token\u0060 to everything before it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and \u0060token\u0060 is set to the entirety of \u0060self\u0060.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return \u0060token\u0060.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr \u002B self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len \u002B needle._len;\r\n            self._ptr = ptr \u002B needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything after the first\r\n     *      occurrence of \u0060needle\u0060, and returning everything before it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and the entirety of \u0060self\u0060 is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The part of \u0060self\u0060 up to the first occurrence of \u0060delim\u0060.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything before the last\r\n     *      occurrence of \u0060needle\u0060, and \u0060token\u0060 to everything after it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and \u0060token\u0060 is set to the entirety of \u0060self\u0060.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return \u0060token\u0060.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len \u002B needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting \u0060self\u0060 to everything before the last\r\n     *      occurrence of \u0060needle\u0060, and returning everything after it. If\r\n     *      \u0060needle\u0060 does not occur in \u0060self\u0060, \u0060self\u0060 is set to the empty slice,\r\n     *      and the entirety of \u0060self\u0060 is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The part of \u0060self\u0060 after the last occurrence of \u0060delim\u0060.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of \u0060needle\u0060 in \u0060self\u0060.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return The number of occurrences of \u0060needle\u0060 found in \u0060self\u0060.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) \u002B needle._len;\r\n        while (ptr \u003C= self._ptr \u002B self._len) {\r\n            cnt\u002B\u002B;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) \u002B needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if \u0060self\u0060 contains \u0060needle\u0060.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in \u0060self\u0060.\r\n     * @return True if \u0060needle\u0060 is found in \u0060self\u0060, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      \u0060self\u0060 and \u0060other\u0060.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len \u002B other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr \u002B self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using \u0060self\u0060 as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in \u0060parts\u0060,\r\n     *         joined with \u0060self\u0060.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \u0022\u0022;\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for (uint i = 0; i \u003C parts.length; i\u002B\u002B) {\r\n            length \u002B= parts[i]._len;\r\n        }\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for (uint i = 0; i \u003C parts.length; i\u002B\u002B) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr \u002B= parts[i]._len;\r\n            if (i \u003C parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr \u002B= self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\ncontract Base64 {\r\n    bytes constant BASE64_DECODE_CHAR = hex\u0022000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\u0022;\r\n\r\n    /// @return decoded array of bytes.\r\n    /// @param _encoded base 64 encoded array of bytes.\r\n    function _base64decode(bytes memory _encoded) internal pure returns (bytes memory) {\r\n        byte v1;\r\n        byte v2;\r\n        byte v3;\r\n        byte v4;\r\n        uint length = _encoded.length;\r\n        bytes memory result = new bytes(length);\r\n        uint index;\r\n\r\n        // base64 encoded strings can\u0027t be length 0 and they must be divisble by 4\r\n        require(length \u003E 0  \u0026\u0026 length % 4 == 0, \u0022invalid base64 encoding\u0022);\r\n\r\n        if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\u0022=\u0022)) {\r\n            length -= 2;\r\n        } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\u0022=\u0022)) {\r\n            length -= 1;\r\n        }\r\n\r\n        uint count = length \u003E\u003E 2 \u003C\u003C 2;\r\n        uint i;\r\n\r\n        for (i = 0; i \u003C count;) {\r\n            v1 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v2 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v3 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v4 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n\r\n            result[index\u002B\u002B] = (v1 \u003C\u003C 2 | v2 \u003E\u003E 4) \u0026 0xff;\r\n            result[index\u002B\u002B] = (v2 \u003C\u003C 4 | v3 \u003E\u003E 2) \u0026 0xff;\r\n            result[index\u002B\u002B] = (v3 \u003C\u003C 6 | v4) \u0026 0xff;\r\n        }\r\n\r\n        if (length - count == 2) {\r\n            v1 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v2 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n\r\n            result[index\u002B\u002B] = (v1 \u003C\u003C 2 | v2 \u003E\u003E 4) \u0026 0xff;\r\n        } else if (length - count == 3) {\r\n            v1 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v2 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n            v3 = BASE64_DECODE_CHAR[uint8(_encoded[i\u002B\u002B])];\r\n\r\n            result[index\u002B\u002B] = (v1 \u003C\u003C 2 | v2 \u003E\u003E 4) \u0026 0xff;\r\n            result[index\u002B\u002B] = (v2 \u003C\u003C 4 | v3 \u003E\u003E 2) \u0026 0xff;\r\n        }\r\n\r\n        // Set to correct length.\r\n        assembly {\r\n            mstore(result, index)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if \u0060account\u0060 is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract\u0027s constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * \u003E It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003E 0;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\ncontract solcChecker {\r\n/* INCOMPATIBLE SOLC: import the following instead: \u0022github.com/oraclize/ethereum-api/oraclizeAPI_0.4.sol\u0022 */ function f(bytes calldata x) external;\r\n}\r\n\r\ncontract OraclizeI {\r\n\r\n    address public cbAddress;\r\n\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function getPrice(string memory _datasource) public returns (uint _dsprice);\r\n    function randomDS_getSessionPubKeyHash() external view returns (bytes32 _sessionKeyHash);\r\n    function getPrice(string memory _datasource, uint _gasLimit) public returns (uint _dsprice);\r\n    function queryN(uint _timestamp, string memory _datasource, bytes memory _argN) public payable returns (bytes32 _id);\r\n    function query(uint _timestamp, string calldata _datasource, string calldata _arg) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) public payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string calldata _datasource, bytes calldata _argN, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2, uint _gasLimit) external payable returns (bytes32 _id);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _address);\r\n}\r\n/*\r\n\r\nBegin solidity-cborutils\r\n\r\nhttps://github.com/smartcontractkit/solidity-cborutils\r\n\r\nMIT License\r\n\r\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \u0022Software\u0022), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \u0022AS IS\u0022, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n*/\r\nlibrary Buffer {\r\n\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory _buf, uint _capacity) internal pure {\r\n        uint capacity = _capacity;\r\n        if (capacity % 32 != 0) {\r\n            capacity \u002B= 32 - (capacity % 32);\r\n        }\r\n        _buf.capacity = capacity; // Allocate space for the buffer data\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(_buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory _buf, uint _capacity) private pure {\r\n        bytes memory oldbuf = _buf.buf;\r\n        init(_buf, _capacity);\r\n        append(_buf, oldbuf);\r\n    }\r\n\r\n    function max(uint _a, uint _b) private pure returns (uint _max) {\r\n        if (_a \u003E _b) {\r\n            return _a;\r\n        }\r\n        return _b;\r\n    }\r\n    /**\r\n      * @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n      *      would exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, bytes memory _data) internal pure returns (buffer memory _buffer) {\r\n        if (_data.length \u002B _buf.buf.length \u003E _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _data.length) * 2);\r\n        }\r\n        uint dest;\r\n        uint src;\r\n        uint len = _data.length;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            dest := add(add(bufptr, buflen), 32) // Start address = buffer address \u002B buffer length \u002B sizeof(buffer length)\r\n            mstore(bufptr, add(buflen, mload(_data))) // Update buffer length\r\n            src := add(_data, 32)\r\n        }\r\n        for(; len \u003E= 32; len -= 32) { // Copy word-length chunks while possible\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest \u002B= 32;\r\n            src \u002B= 32;\r\n        }\r\n        uint mask = 256 ** (32 - len) - 1; // Copy remaining bytes\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n        return _buf;\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, uint8 _data) internal pure {\r\n        if (_buf.buf.length \u002B 1 \u003E _buf.capacity) {\r\n            resize(_buf, _buf.capacity * 2);\r\n        }\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), 32) // Address = buffer address \u002B buffer length \u002B sizeof(buffer length)\r\n            mstore8(dest, _data)\r\n            mstore(bufptr, add(buflen, 1)) // Update buffer length\r\n        }\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function appendInt(buffer memory _buf, uint _data, uint _len) internal pure returns (buffer memory _buffer) {\r\n        if (_len \u002B _buf.buf.length \u003E _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _len) * 2);\r\n        }\r\n        uint mask = 256 ** _len - 1;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), _len) // Address = buffer address \u002B buffer length \u002B sizeof(buffer length) \u002B len\r\n            mstore(dest, or(and(mload(dest), not(mask)), _data))\r\n            mstore(bufptr, add(buflen, _len)) // Update buffer length\r\n        }\r\n        return _buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory _buf, uint8 _major, uint _value) private pure {\r\n        if (_value \u003C= 23) {\r\n            _buf.append(uint8((_major \u003C\u003C 5) | _value));\r\n        } else if (_value \u003C= 0xFF) {\r\n            _buf.append(uint8((_major \u003C\u003C 5) | 24));\r\n            _buf.appendInt(_value, 1);\r\n        } else if (_value \u003C= 0xFFFF) {\r\n            _buf.append(uint8((_major \u003C\u003C 5) | 25));\r\n            _buf.appendInt(_value, 2);\r\n        } else if (_value \u003C= 0xFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003C\u003C 5) | 26));\r\n            _buf.appendInt(_value, 4);\r\n        } else if (_value \u003C= 0xFFFFFFFFFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003C\u003C 5) | 27));\r\n            _buf.appendInt(_value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory _buf, uint8 _major) private pure {\r\n        _buf.append(uint8((_major \u003C\u003C 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory _buf, uint _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_INT, _value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory _buf, int _value) internal pure {\r\n        if (_value \u003E= 0) {\r\n            encodeType(_buf, MAJOR_TYPE_INT, uint(_value));\r\n        } else {\r\n            encodeType(_buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - _value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory _buf, bytes memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_BYTES, _value.length);\r\n        _buf.append(_value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory _buf, string memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_STRING, bytes(_value).length);\r\n        _buf.append(bytes(_value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n/*\r\n\r\nEnd solidity-cborutils\r\n\r\n*/\r\ncontract usingOraclize {\r\n\r\n    using CBOR for Buffer.buffer;\r\n\r\n    OraclizeI oraclize;\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    uint constant day = 60 * 60 * 24;\r\n    uint constant week = 60 * 60 * 24 * 7;\r\n    uint constant month = 60 * 60 * 24 * 30;\r\n\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    byte constant proofType_Android = 0x40;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n\r\n    string oraclize_network_name;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    mapping(bytes32 =\u003E bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32 =\u003E bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    modifier oraclizeAPI {\r\n        if ((address(OAR) == address(0)) || (getCodeSize(address(OAR)) == 0)) {\r\n            oraclize_setNetwork(networkID_auto);\r\n        }\r\n        if (address(oraclize) != OAR.getAddress()) {\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string memory _result, bytes memory _proof) {\r\n        // RandomDS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        require((_proof[0] == \u0022L\u0022) \u0026\u0026 (_proof[1] == \u0022P\u0022) \u0026\u0026 (uint8(_proof[2]) == uint8(1)));\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        require(proofVerified);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 _networkID) internal returns (bool _networkSet) {\r\n      _networkID; // NOTE: Silence the warning and remain backwards compatible\r\n      return oraclize_setNetwork();\r\n    }\r\n\r\n    function oraclize_setNetworkName(string memory _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal view returns (string memory _networkName) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_setNetwork() internal returns (bool _networkSet) {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) \u003E 0) { //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\u0022eth_mainnet\u0022);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) \u003E 0) { //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\u0022eth_ropsten3\u0022);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) \u003E 0) { //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\u0022eth_kovan\u0022);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) \u003E 0) { //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\u0022eth_rinkeby\u0022);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) \u003E 0) { //goerli testnet\r\n            OAR = OraclizeAddrResolverI(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);\r\n            oraclize_setNetworkName(\u0022eth_goerli\u0022);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) \u003E 0) { //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) \u003E 0) { //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) \u003E 0) { //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @dev The following \u0060__callback\u0060 functions are just placeholders ideally\r\n     *      meant to be defined in child contract when proofs are used.\r\n     *      The function bodies simply silence compiler warnings.\r\n     */\r\n    function __callback(bytes32 _myid, string memory _result) public {\r\n        __callback(_myid, _result, new bytes(0));\r\n    }\r\n\r\n    function __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {\r\n      _myid; _result; _proof;\r\n      oraclize_randomDS_args[bytes32(0)] = bytes32(0);\r\n    }\r\n\r\n    function oraclize_getPrice(string memory _datasource) oraclizeAPI internal returns (uint _queryPrice) {\r\n        return oraclize.getPrice(_datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string memory _datasource, uint _gasLimit) oraclizeAPI internal returns (uint _queryPrice) {\r\n        return oraclize.getPrice(_datasource, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query.value(price)(0, _datasource, _arg);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query.value(price)(_timestamp, _datasource, _arg);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource,_gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query_withGasLimit.value(price)(_timestamp, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n           return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query_withGasLimit.value(price)(0, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2.value(price)(0, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2.value(price)(_timestamp, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2_withGasLimit.value(price)(_timestamp, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2_withGasLimit.value(price)(0, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003E 1 ether \u002B tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_setProof(byte _proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(_proofP);\r\n    }\r\n\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address _callbackAddress) {\r\n        return oraclize.cbAddress();\r\n    }\r\n\r\n    function getCodeSize(address _addr) view internal returns (uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function oraclize_setCustomGasPrice(uint _gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(_gasPrice);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32 _sessionKeyHash) {\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i \u003C 2 \u002B 2 * 20; i \u002B= 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i \u002B 1]));\r\n            if ((b1 \u003E= 97) \u0026\u0026 (b1 \u003C= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 \u003E= 65) \u0026\u0026 (b1 \u003C= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 \u003E= 48) \u0026\u0026 (b1 \u003C= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 \u003E= 97) \u0026\u0026 (b2 \u003C= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 \u003E= 65) \u0026\u0026 (b2 \u003C= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 \u003E= 48) \u0026\u0026 (b2 \u003C= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr \u002B= (b1 * 16 \u002B b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string memory _a, string memory _b) internal pure returns (int _returnCode) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length \u003C minLength) {\r\n            minLength = b.length;\r\n        }\r\n        for (uint i = 0; i \u003C minLength; i \u002B\u002B) {\r\n            if (a[i] \u003C b[i]) {\r\n                return -1;\r\n            } else if (a[i] \u003E b[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (a.length \u003C b.length) {\r\n            return -1;\r\n        } else if (a.length \u003E b.length) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function indexOf(string memory _haystack, string memory _needle) internal pure returns (int _returnCode) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if (h.length \u003C 1 || n.length \u003C 1 || (n.length \u003E h.length)) {\r\n            return -1;\r\n        } else if (h.length \u003E (2 ** 128 - 1)) {\r\n            return -1;\r\n        } else {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i \u003C h.length; i\u002B\u002B) {\r\n                if (h[i] == n[0]) {\r\n                    subindex = 1;\r\n                    while(subindex \u003C n.length \u0026\u0026 (i \u002B subindex) \u003C h.length \u0026\u0026 h[i \u002B subindex] == n[subindex]) {\r\n                        subindex\u002B\u002B;\r\n                    }\r\n                    if (subindex == n.length) {\r\n                        return int(i);\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, \u0022\u0022, \u0022\u0022, \u0022\u0022);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \u0022\u0022, \u0022\u0022);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \u0022\u0022);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length \u002B _bb.length \u002B _bc.length \u002B _bd.length \u002B _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        uint i = 0;\r\n        for (i = 0; i \u003C _ba.length; i\u002B\u002B) {\r\n            babcde[k\u002B\u002B] = _ba[i];\r\n        }\r\n        for (i = 0; i \u003C _bb.length; i\u002B\u002B) {\r\n            babcde[k\u002B\u002B] = _bb[i];\r\n        }\r\n        for (i = 0; i \u003C _bc.length; i\u002B\u002B) {\r\n            babcde[k\u002B\u002B] = _bc[i];\r\n        }\r\n        for (i = 0; i \u003C _bd.length; i\u002B\u002B) {\r\n            babcde[k\u002B\u002B] = _bd[i];\r\n        }\r\n        for (i = 0; i \u003C _be.length; i\u002B\u002B) {\r\n            babcde[k\u002B\u002B] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n\r\n    function safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return safeParseInt(_a, 0);\r\n    }\r\n\r\n    function safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003C bresult.length; i\u002B\u002B) {\r\n            if ((uint(uint8(bresult[i])) \u003E= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003C= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint \u002B= uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                require(!decimals, \u0027More than one decimal encountered in string!\u0027);\r\n                decimals = true;\r\n            } else {\r\n                revert(\u0022Non-numeral character encountered in string!\u0022);\r\n            }\r\n        }\r\n        if (_b \u003E 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003C bresult.length; i\u002B\u002B) {\r\n            if ((uint(uint8(bresult[i])) \u003E= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003C= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) {\r\n                       break;\r\n                   } else {\r\n                       _b--;\r\n                   }\r\n                }\r\n                mint *= 10;\r\n                mint \u002B= uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b \u003E 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \u00220\u0022;\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len\u002B\u002B;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 \u002B _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003C _arr.length; i\u002B\u002B) {\r\n            buf.encodeString(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003C _arr.length; i\u002B\u002B) {\r\n            buf.encodeBytes(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\r\n        require((_nbytes \u003E 0) \u0026\u0026 (_nbytes \u003C= 32));\r\n        _delay *= 10; // Convert from seconds to ledger timer ticks\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(uint8(_nbytes));\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            /*\r\n             The following variables can be relaxed.\r\n             Check the relaxed random contract at https://github.com/oraclize/ethereum-examples\r\n             for an idea on how to override and replace commit hash variables.\r\n            */\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = oraclize_query(\u0022random\u0022, args, _customGasLimit);\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n        }\r\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 _queryId, bytes32 _commitment) internal {\r\n        oraclize_randomDS_args[_queryId] = _commitment;\r\n    }\r\n\r\n    function verifySig(bytes32 _tosignh, bytes memory _dersig, bytes memory _pubkey) internal returns (bool _sigVerified) {\r\n        bool sigok;\r\n        address signer;\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4 \u002B (uint(uint8(_dersig[3])) - 0x20);\r\n        sigr_ = copyBytes(_dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset \u002B= 32 \u002B 2;\r\n        sigs_ = copyBytes(_dersig, offset \u002B (uint(uint8(_dersig[offset - 1])) - 0x20), 32, sigs_, 0);\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n        (sigok, signer) = safer_ecrecover(_tosignh, 27, sigr, sigs);\r\n        if (address(uint160(uint256(keccak256(_pubkey)))) == signer) {\r\n            return true;\r\n        } else {\r\n            (sigok, signer) = safer_ecrecover(_tosignh, 28, sigr, sigs);\r\n            return (address(uint160(uint256(keccak256(_pubkey)))) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes memory _proof, uint _sig2offset) internal returns (bool _proofVerified) {\r\n        bool sigok;\r\n        // Random DS Proof Step 6: Verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(uint8(_proof[_sig2offset \u002B 1])) \u002B 2);\r\n        copyBytes(_proof, _sig2offset, sig2.length, sig2, 0);\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(_proof, 3 \u002B 1, 64, appkey1_pubkey, 0);\r\n        bytes memory tosign2 = new bytes(1 \u002B 65 \u002B 32);\r\n        tosign2[0] = byte(uint8(1)); //role\r\n        copyBytes(_proof, _sig2offset - 65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\u0022fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\u0022;\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1 \u002B 65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n        if (!sigok) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 7: Verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\u00227fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\u0022;\r\n        bytes memory tosign3 = new bytes(1 \u002B 65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(_proof, 3, 65, tosign3, 1);\r\n        bytes memory sig3 = new bytes(uint(uint8(_proof[3 \u002B 65 \u002B 1])) \u002B 2);\r\n        copyBytes(_proof, 3 \u002B 65, sig3.length, sig3, 0);\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n        return sigok;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string memory _result, bytes memory _proof) internal returns (uint8 _returnCode) {\r\n        // Random DS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        if ((_proof[0] != \u0022L\u0022) || (_proof[1] != \u0022P\u0022) || (uint8(_proof[2]) != uint8(1))) {\r\n            return 1;\r\n        }\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (!proofVerified) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 _content, bytes memory _prefix, uint _nRandomBytes) internal pure returns (bool _matchesPrefix) {\r\n        bool match_ = true;\r\n        require(_prefix.length == _nRandomBytes);\r\n        for (uint256 i = 0; i\u003C _nRandomBytes; i\u002B\u002B) {\r\n            if (_content[i] != _prefix[i]) {\r\n                match_ = false;\r\n            }\r\n        }\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes memory _proof, bytes32 _queryId, bytes memory _result, string memory _contextName) internal returns (bool _proofVerified) {\r\n        // Random DS Proof Step 2: The unique keyhash has to match with the sha256 of (context name \u002B _queryId)\r\n        uint ledgerProofLength = 3 \u002B 65 \u002B (uint(uint8(_proof[3 \u002B 65 \u002B 1])) \u002B 2) \u002B 32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(_proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(_contextName, _queryId)))))) {\r\n            return false;\r\n        }\r\n        bytes memory sig1 = new bytes(uint(uint8(_proof[ledgerProofLength \u002B (32 \u002B 8 \u002B 1 \u002B 32) \u002B 1])) \u002B 2);\r\n        copyBytes(_proof, ledgerProofLength \u002B (32 \u002B 8 \u002B 1 \u002B 32), sig1.length, sig1, 0);\r\n        // Random DS Proof Step 3: We assume sig1 is valid (it will be verified during step 5) and we verify if \u0027_result\u0027 is the _prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), _result, uint(uint8(_proof[ledgerProofLength \u002B 32 \u002B 8])))) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 4: Commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8 \u002B 1 \u002B 32);\r\n        copyBytes(_proof, ledgerProofLength \u002B 32, 8 \u002B 1 \u002B 32, commitmentSlice1, 0);\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength \u002B 32 \u002B (8 \u002B 1 \u002B 32) \u002B sig1.length \u002B 65;\r\n        copyBytes(_proof, sig2offset - 64, 64, sessionPubkey, 0);\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[_queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))) { //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[_queryId];\r\n        } else return false;\r\n        // Random DS Proof Step 5: Validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32 \u002B 8 \u002B 1 \u002B 32);\r\n        copyBytes(_proof, ledgerProofLength, 32 \u002B 8 \u002B 1 \u002B 32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) {\r\n            return false;\r\n        }\r\n        // Verify if sessionPubkeyHash was verified already, if not.. let\u0027s do it!\r\n        if (!oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]) {\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(_proof, sig2offset);\r\n        }\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n    */\r\n    function copyBytes(bytes memory _from, uint _fromOffset, uint _length, bytes memory _to, uint _toOffset) internal pure returns (bytes memory _copiedBytes) {\r\n        uint minLength = _length \u002B _toOffset;\r\n        require(_to.length \u003E= minLength); // Buffer too small. Should be a better way?\r\n        uint i = 32 \u002B _fromOffset; // NOTE: the offset 32 is added to skip the \u0060size\u0060 field of both bytes variables\r\n        uint j = 32 \u002B _toOffset;\r\n        while (i \u003C (32 \u002B _fromOffset \u002B _length)) {\r\n            assembly {\r\n                let tmp := mload(add(_from, i))\r\n                mstore(add(_to, j), tmp)\r\n            }\r\n            i \u002B= 32;\r\n            j \u002B= 32;\r\n        }\r\n        return _to;\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n     Duplicate Solidity\u0027s ecrecover, but catching the CALL return value\r\n    */\r\n    function safer_ecrecover(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool _success, address _recoveredAddress) {\r\n        /*\r\n         We do our own memory management here. Solidity uses memory offset\r\n         0x40 to store the current end of memory. We write past it (as\r\n         writes are memory extensions), but don\u0027t update the offset so\r\n         Solidity will reuse it. The memory used here is only needed for\r\n         this context.\r\n         FIXME: inline assembly can\u0027t access return values\r\n        */\r\n        bool ret;\r\n        address addr;\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, _hash)\r\n            mstore(add(size, 32), _v)\r\n            mstore(add(size, 64), _r)\r\n            mstore(add(size, 96), _s)\r\n            ret := call(3000, 1, 0, size, 128, size, 32) // NOTE: we can reuse the request memory because we deal with the return code.\r\n            addr := mload(size)\r\n        }\r\n        return (ret, addr);\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi, use it under the terms of the MIT license\r\n    */\r\n    function ecrecovery(bytes32 _hash, bytes memory _sig) internal returns (bool _success, address _recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (_sig.length != 65) {\r\n            return (false, address(0));\r\n        }\r\n        /*\r\n         The signature format is a compact form of:\r\n           {bytes32 r}{bytes32 s}{uint8 v}\r\n         Compact means, uint8 is not padded to 32 bytes.\r\n        */\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            /*\r\n             Here we are loading the last 32 bytes. We exploit the fact that\r\n             \u0027mload\u0027 will pad with zeroes if we overread.\r\n             There is no \u0027mload8\u0027 to do this, but that would be nicer.\r\n            */\r\n            v := byte(0, mload(add(_sig, 96)))\r\n            /*\r\n              Alternative solution:\r\n              \u0027byte\u0027 is not working due to the Solidity parser, so lets\r\n              use the second best option, \u0027and\u0027\r\n              v := and(mload(add(_sig, 65)), 255)\r\n            */\r\n        }\r\n        /*\r\n         albeit non-transactional signatures are not specified by the YP, one would expect it\r\n         to match the YP range of [27, 28]\r\n         geth uses [0, 1] and some clients have followed. This might change, see:\r\n         https://github.com/ethereum/go-ethereum/issues/2053\r\n        */\r\n        if (v \u003C 27) {\r\n            v \u002B= 27;\r\n        }\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return (false, address(0));\r\n        }\r\n        return safer_ecrecover(_hash, v, r, s);\r\n    }\r\n\r\n    function safeMemoryCleaner() internal pure {\r\n        assembly {\r\n            let fmem := mload(0x40)\r\n            codecopy(fmem, codesize, sub(msize, fmem))\r\n        }\r\n    }\r\n}\r\n/*\r\n\r\nEND ORACLIZE_API\r\n\r\n*/\r\n\r\ncontract Ownable {\r\n    event TransferredOwnership(address _from, address _to);\r\n    event LockedOwnership(address _locked);\r\n\r\n    address payable private _owner;\r\n    bool private _isTransferable;\r\n\r\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\r\n    constructor(address payable _account_, bool _transferable_) internal {\r\n        _owner = _account_;\r\n        _isTransferable = _transferable_;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_isTransferable) {\r\n            emit LockedOwnership(_account_);\r\n        }\r\n        emit TransferredOwnership(address(0), _account_);\r\n    }\r\n\r\n    /// @notice Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(_isOwner(msg.sender), \u0022sender is not an owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\r\n    /// @param _account address to transfer ownership to.\r\n    /// @param _transferable indicates whether to keep the ownership transferable.\r\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \u0022ownership is not transferable\u0022);\r\n        // Require that the new owner is not the zero address.\r\n        require(_account != address(0), \u0022owner cannot be set to zero address\u0022);\r\n        // Set the transferable flag to the value _transferable passed in.\r\n        _isTransferable = _transferable;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_transferable) {\r\n            emit LockedOwnership(_account);\r\n        }\r\n        // Emit the ownership transfer event.\r\n        emit TransferredOwnership(_owner, _account);\r\n        // Set the owner to the provided address.\r\n        _owner = _account;\r\n    }\r\n\r\n    /// @notice check if the ownership is transferable.\r\n    /// @return true if the ownership is transferable.\r\n    function isTransferable() external view returns (bool) {\r\n        return _isTransferable;\r\n    }\r\n\r\n    /// @notice Allows the current owner to relinquish control of the contract.\r\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\r\n    /// @dev It will not be possible to call the functions with the \u0060onlyOwner\u0060 modifier anymore.\r\n    function renounceOwnership() external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \u0022ownership is not transferable\u0022);\r\n        // note that this could be terminal\r\n        _owner = address(0);\r\n\r\n        emit TransferredOwnership(_owner, address(0));\r\n    }\r\n\r\n    /// @notice Find out owner address\r\n    /// @return address of the owner.\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @notice Check if owner address\r\n    /// @return true if sender is the owner of the contract.\r\n    function _isOwner(address _address) internal view returns (bool) {\r\n        return _address == _owner;\r\n    }\r\n}\r\n\r\ncontract Date {\r\n\r\n    bytes32 constant private _JANUARY = keccak256(\u0022Jan\u0022);\r\n    bytes32 constant private _FEBRUARY = keccak256(\u0022Feb\u0022);\r\n    bytes32 constant private _MARCH = keccak256(\u0022Mar\u0022);\r\n    bytes32 constant private _APRIL = keccak256(\u0022Apr\u0022);\r\n    bytes32 constant private _MAY = keccak256(\u0022May\u0022);\r\n    bytes32 constant private _JUNE = keccak256(\u0022Jun\u0022);\r\n    bytes32 constant private _JULY = keccak256(\u0022Jul\u0022);\r\n    bytes32 constant private _AUGUST = keccak256(\u0022Aug\u0022);\r\n    bytes32 constant private _SEPTEMBER = keccak256(\u0022Sep\u0022);\r\n    bytes32 constant private _OCTOBER = keccak256(\u0022Oct\u0022);\r\n    bytes32 constant private _NOVEMBER = keccak256(\u0022Nov\u0022);\r\n    bytes32 constant private _DECEMBER = keccak256(\u0022Dec\u0022);\r\n\r\n    /// @return the number of the month based on its name.\r\n    /// @param _month the first three letters of a month\u0027s name e.g. \u0022Jan\u0022.\r\n    function _monthToNumber(string memory _month) internal pure returns (uint8) {\r\n        bytes32 month = keccak256(abi.encodePacked(_month));\r\n        if (month == _JANUARY) {\r\n            return 1;\r\n        } else if (month == _FEBRUARY) {\r\n            return 2;\r\n        } else if (month == _MARCH) {\r\n            return 3;\r\n        } else if (month == _APRIL) {\r\n            return 4;\r\n        } else if (month == _MAY) {\r\n            return 5;\r\n        } else if (month == _JUNE) {\r\n            return 6;\r\n        } else if (month == _JULY) {\r\n            return 7;\r\n        } else if (month == _AUGUST) {\r\n            return 8;\r\n        } else if (month == _SEPTEMBER) {\r\n            return 9;\r\n        } else if (month == _OCTOBER) {\r\n            return 10;\r\n        } else if (month == _NOVEMBER) {\r\n            return 11;\r\n        } else if (month == _DECEMBER) {\r\n            return 12;\r\n        } else {\r\n            revert(\u0022not a valid month\u0022);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract NameResolver is ResolverBase {\r\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\r\n\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    mapping(bytes32=\u003Estring) names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string calldata name) external authorised(node) {\r\n        names[node] = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory) {\r\n        return names[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract ABIResolver is ResolverBase {\r\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\r\n\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    mapping(bytes32=\u003Emapping(uint256=\u003Ebytes)) abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) \u0026 contentType) == 0);\r\n\r\n        abis[node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\r\n        mapping(uint256=\u003Ebytes) storage abiset = abis[node];\r\n\r\n        for (uint256 contentType = 1; contentType \u003C= contentTypes; contentType \u003C\u003C= 1) {\r\n            if ((contentType \u0026 contentTypes) != 0 \u0026\u0026 abiset[contentType].length \u003E 0) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\u0022\u0022));\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract ParseIntScientific {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    byte constant private _PLUS_ASCII = byte(uint8(43)); //decimal value of \u0027\u002B\u0027\r\n    byte constant private _DASH_ASCII = byte(uint8(45)); //decimal value of \u0027-\u0027\r\n    byte constant private _DOT_ASCII = byte(uint8(46)); //decimal value of \u0027.\u0027\r\n    byte constant private _ZERO_ASCII = byte(uint8(48)); //decimal value of \u00270\u0027\r\n    byte constant private _NINE_ASCII = byte(uint8(57)); //decimal value of \u00279\u0027\r\n    byte constant private _E_ASCII = byte(uint8(69)); //decimal value of \u0027E\u0027\r\n    byte constant private _LOWERCASE_E_ASCII = byte(uint8(101)); //decimal value of \u0027e\u0027\r\n    uint constant private _MAX_PARSED_UINT = 2**54; //max value returned in JSON format above which interoperability issues may be raised\r\n\r\n    /// @notice ParseIntScientific delegates the call to _parseIntScientific(string, uint) with the 2nd argument being 0.\r\n    function _parseIntScientific(string memory _inString) internal pure returns (uint) {\r\n        return _parseIntScientific(_inString, 0);\r\n    }\r\n\r\n    /// @notice ParseIntScientificWei parses a rate expressed in ETH and returns its wei denomination\r\n    function _parseIntScientificWei(string memory _inString) internal pure returns (uint) {\r\n        return _parseIntScientific(_inString, 18);\r\n    }\r\n\r\n    /// @notice ParseIntScientific parses a JSON standard - floating point number.\r\n    /// @param _inString is input string.\r\n    /// @param _magnitudeMult multiplies the number with 10^_magnitudeMult.\r\n    function _parseIntScientific(string memory _inString, uint _magnitudeMult) internal pure returns (uint) {\r\n\r\n        bytes memory inBytes = bytes(_inString);\r\n        uint mint = 0; // the final uint returned\r\n        uint mintDec = 0; // the uint following the decimal point\r\n        uint mintExp = 0; // the exponent\r\n        uint decMinted = 0; // how many decimals were \u0027minted\u0027.\r\n        uint expIndex = 0; // the position in the byte array that \u0027e\u0027 was found (if found)\r\n        bool integral = false; // indicates the existence of the integral part, it should always exist (even if 0) e.g. \u0027e\u002B1\u0027  or \u0027.1\u0027 is not valid\r\n        bool decimals = false; // indicates a decimal number, set to true if \u0027.\u0027 is found\r\n        bool exp = false; // indicates if the number being parsed has an exponential representation\r\n        bool minus = false; // indicated if the exponent is negative\r\n        bool plus = false; // indicated if the exponent is positive\r\n        uint i;\r\n        for (i = 0; i \u003C inBytes.length; i\u002B\u002B) {\r\n            if ((inBytes[i] \u003E= _ZERO_ASCII) \u0026\u0026 (inBytes[i] \u003C= _NINE_ASCII) \u0026\u0026 (!exp)) {\r\n                // \u0027e\u0027 not encountered yet, minting integer part or decimals\r\n                if (decimals) {\r\n                    // \u0027.\u0027 encountered\r\n                    // use safeMath in case there is an overflow\r\n                    mintDec = mintDec.mul(10);\r\n                    mintDec = mintDec.add(uint8(inBytes[i]) - uint8(_ZERO_ASCII));\r\n                    decMinted\u002B\u002B; //keep track of the #decimals\r\n                } else {\r\n                    // integral part (before \u0027.\u0027)\r\n                    integral = true;\r\n                    // use safeMath in case there is an overflow\r\n                    mint = mint.mul(10);\r\n                    mint = mint.add(uint8(inBytes[i]) - uint8(_ZERO_ASCII));\r\n                }\r\n            } else if ((inBytes[i] \u003E= _ZERO_ASCII) \u0026\u0026 (inBytes[i] \u003C= _NINE_ASCII) \u0026\u0026 (exp)) {\r\n                //exponential notation (e-/\u002B) has been detected, mint the exponent\r\n                mintExp = mintExp.mul(10);\r\n                mintExp = mintExp.add(uint8(inBytes[i]) - uint8(_ZERO_ASCII));\r\n            } else if (inBytes[i] == _DOT_ASCII) {\r\n                //an integral part before should always exist before \u0027.\u0027\r\n                require(integral, \u0022missing integral part\u0022);\r\n                // an extra decimal point makes the format invalid\r\n                require(!decimals, \u0022duplicate decimal point\u0022);\r\n                //the decimal point should always be before the exponent\r\n                require(!exp, \u0022decimal after exponent\u0022);\r\n                decimals = true;\r\n            } else if (inBytes[i] == _DASH_ASCII) {\r\n                // an extra \u0027-\u0027 should be considered an invalid character\r\n                require(!minus, \u0022duplicate -\u0022);\r\n                require(!plus, \u0022extra sign\u0022);\r\n                require(expIndex \u002B 1 == i, \u0022- sign not immediately after e\u0022);\r\n                minus = true;\r\n            } else if (inBytes[i] == _PLUS_ASCII) {\r\n                // an extra \u0027\u002B\u0027 should be considered an invalid character\r\n                require(!plus, \u0022duplicate \u002B\u0022);\r\n                require(!minus, \u0022extra sign\u0022);\r\n                require(expIndex \u002B 1 == i, \u0022\u002B sign not immediately after e\u0022);\r\n                plus = true;\r\n            } else if ((inBytes[i] == _E_ASCII) || (inBytes[i] == _LOWERCASE_E_ASCII)) {\r\n                //an integral part before should always exist before \u0027e\u0027\r\n                require(integral, \u0022missing integral part\u0022);\r\n                // an extra \u0027e\u0027 or \u0027E\u0027 should be considered an invalid character\r\n                require(!exp, \u0022duplicate exponent symbol\u0022);\r\n                exp = true;\r\n                expIndex = i;\r\n            } else {\r\n                revert(\u0022invalid digit\u0022);\r\n            }\r\n        }\r\n\r\n        if (minus || plus) {\r\n            // end of string e[x|-] without specifying the exponent\r\n            require(i \u003E expIndex \u002B 2);\r\n        } else if (exp) {\r\n            // end of string (e) without specifying the exponent\r\n            require(i \u003E expIndex \u002B 1);\r\n        }\r\n\r\n        if (minus) {\r\n            // e^(-x)\r\n            if (mintExp \u003E= _magnitudeMult) {\r\n                // the (negative) exponent is bigger than the given parameter for \u0022shifting left\u0022.\r\n                // use integer division to reduce the precision.\r\n                require(mintExp - _magnitudeMult \u003C 78, \u0022exponent \u003E 77\u0022); //\r\n                mint /= 10 ** (mintExp - _magnitudeMult);\r\n                return mint;\r\n\r\n            } else {\r\n                // the (negative) exponent is smaller than the given parameter for \u0022shifting left\u0022.\r\n                //no need for underflow check\r\n                _magnitudeMult = _magnitudeMult - mintExp;\r\n            }\r\n        } else {\r\n            // e^(\u002Bx), positive exponent or no exponent\r\n            // just shift left as many times as indicated by the exponent and the shift parameter\r\n            _magnitudeMult = _magnitudeMult.add(mintExp);\r\n        }\r\n\r\n        if (_magnitudeMult \u003E= decMinted) {\r\n            // the decimals are fewer or equal than the shifts: use all of them\r\n            // shift number and add the decimals at the end\r\n            // include decimals if present in the original input\r\n            require(decMinted \u003C 78, \u0022more than 77 decimal digits parsed\u0022); //\r\n            mint = mint.mul(10 ** (decMinted));\r\n            mint = mint.add(mintDec);\r\n            //// add zeros at the end if the decimals were fewer than #_magnitudeMult\r\n            require(_magnitudeMult - decMinted \u003C 78, \u0022exponent \u003E 77\u0022); //\r\n            mint = mint.mul(10 ** (_magnitudeMult - decMinted));\r\n        } else {\r\n            // the decimals are more than the #_magnitudeMult shifts\r\n            // use only the ones needed, discard the rest\r\n            decMinted -= _magnitudeMult;\r\n            require(decMinted \u003C 78, \u0022more than 77 decimal digits parsed\u0022); //\r\n            mintDec /= 10 ** (decMinted);\r\n            // shift number and add the decimals at the end\r\n            require(_magnitudeMult \u003C 78, \u0022more than 77 decimal digits parsed\u0022); //\r\n            mint = mint.mul(10 ** (_magnitudeMult));\r\n            mint = mint.add(mintDec);\r\n        }\r\n        require(mint \u003C _MAX_PARSED_UINT, \u0022number exceeded maximum allowed value for safe json decoding\u0022);\r\n        return mint;\r\n    }\r\n}\r\n\r\ncontract ContentHashResolver is ResolverBase {\r\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    mapping(bytes32=\u003Ebytes) hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        hashes[node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return hashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract TextResolver is ResolverBase {\r\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    mapping(bytes32=\u003Emapping(string=\u003Estring)) texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\r\n        texts[node][key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\r\n        return texts[node][key];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \u0022SafeERC20: approve from non-zero to non-zero allowance\u0022\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \u0022SafeERC20: call to non-contract\u0022);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \u0022SafeERC20: low-level call failed\u0022);\r\n\r\n        if (returndata.length \u003E 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \u0022SafeERC20: ERC20 operation did not succeed\u0022);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    mapping(bytes32=\u003Eaddress) addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) external authorised(node) {\r\n        addresses[node] = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return addresses[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\nlibrary BytesUtils {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev This function converts to an address\r\n    /// @param _bts bytes\r\n    /// @param _from start position\r\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\r\n\r\n        require(_bts.length \u003E= _from.add(20), \u0022slicing out of range\u0022);\r\n\r\n        bytes20 convertedAddress;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            convertedAddress := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return address(convertedAddress);\r\n    }\r\n\r\n    /// @dev This function slices bytes into bytes4\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\r\n        require(_bts.length \u003E= _from.add(4), \u0022slicing out of range\u0022);\r\n\r\n        bytes4 slicedBytes4;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            slicedBytes4 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return slicedBytes4;\r\n\r\n    }\r\n\r\n    /// @dev This function slices a uint\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\r\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\r\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\r\n        require(_bts.length \u003E= _from.add(32), \u0022slicing out of range\u0022);\r\n\r\n        uint convertedUint256;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n        \r\n        assembly {\r\n            convertedUint256 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return convertedUint256;\r\n    }\r\n}\r\n\r\ncontract PubkeyResolver is ResolverBase {\r\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\r\n\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(bytes32=\u003EPublicKey) pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\r\n        pubkeys[node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\r\n        return (pubkeys[node].x, pubkeys[node].y);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract InterfaceResolver is ResolverBase, AddrResolver {\r\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\u0022interfaceImplementer(bytes32,bytes4)\u0022));\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    mapping(bytes32=\u003Emapping(bytes4=\u003Eaddress)) interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at \u0060addr()\u0060 for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 168 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\r\n        interfaces[node][interfaceID] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at \u0060addr()\u0060. If \u0060addr()\u0060 is set, a contract exists at that address, and that\r\n     * contract implements EIP168 and returns \u0060true\u0060 for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 168 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\r\n        address implementer = interfaces[node][interfaceID];\r\n        if(implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if(a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\u0022supportsInterface(bytes4)\u0022, INTERFACE_META_ID));\r\n        if(!success || returnData.length \u003C 32 || returnData[31] == 0) {\r\n            // EIP 168 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\u0022supportsInterface(bytes4)\u0022, interfaceID));\r\n        if(!success || returnData.length \u003C 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\ncontract Transferrable {\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n\r\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\r\n    /// @dev The owner can chose the new destination address\r\n    /// @param _to is the recipient\u0027s address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount to be transferred in base units.\r\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\r\n        // address(0) is used to denote ETH\r\n        if (_asset == address(0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            ERC20(_asset).safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n\r\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    ENS ens;\r\n\r\n    /**\r\n     * A mapping of authorisations. An address that is authorised for a name\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (node, owner, caller) =\u003E isAuthorised\r\n     */\r\n    mapping(bytes32=\u003Emapping(address=\u003Emapping(address=\u003Ebool))) public authorisations;\r\n\r\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or clears an authorisation.\r\n     * Authorisations are specific to the caller. Any account can set an authorisation\r\n     * for any name, but the authorisation that is checked will be that of the\r\n     * current owner of a name. Thus, transferring a name effectively clears any\r\n     * existing authorisations, and new authorisations can be set in advance of\r\n     * an ownership transfer if desired.\r\n     *\r\n     * @param node The name to change the authorisation on.\r\n     * @param target The address that is to be authorised or deauthorised.\r\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\r\n     */\r\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\r\n        authorisations[node][msg.sender][target] = isAuthorised;\r\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool) {\r\n        address owner = ens.owner(node);\r\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\r\n    }\r\n}\r\n\r\ninterface IController {\r\n    function isController(address) external view returns (bool);\r\n    function isAdmin(address) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\r\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\r\n/// @dev Owner can change the Admins\r\n/// @dev Admins and can the Controllers\r\n/// @dev Controllers are used by the application.\r\ncontract Controller is IController, Ownable, Transferrable {\r\n\r\n    event AddedController(address _sender, address _controller);\r\n    event RemovedController(address _sender, address _controller);\r\n\r\n    event AddedAdmin(address _sender, address _admin);\r\n    event RemovedAdmin(address _sender, address _admin);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    event Stopped(address _sender);\r\n    event Started(address _sender);\r\n\r\n    mapping (address =\u003E bool) private _isAdmin;\r\n    uint private _adminCount;\r\n\r\n    mapping (address =\u003E bool) private _isController;\r\n    uint private _controllerCount;\r\n\r\n    bool private _stopped;\r\n\r\n    /// @notice Constructor initializes the owner with the provided address.\r\n    /// @param _ownerAddress_ address of the owner.\r\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if Owner or Admin\r\n    modifier onlyAdminOrOwner() {\r\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if controller is stopped\r\n    modifier notStopped() {\r\n        require(!isStopped(), \u0022controller is stopped\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Add a new admin to the list of admins.\r\n    /// @param _account address to add to the list of admins.\r\n    function addAdmin(address _account) external onlyOwner notStopped {\r\n        _addAdmin(_account);\r\n    }\r\n\r\n    /// @notice Remove a admin from the list of admins.\r\n    /// @param _account address to remove from the list of admins.\r\n    function removeAdmin(address _account) external onlyOwner {\r\n        _removeAdmin(_account);\r\n    }\r\n\r\n    /// @return the current number of admins.\r\n    function adminCount() external view returns (uint) {\r\n        return _adminCount;\r\n    }\r\n\r\n    /// @notice Add a new controller to the list of controllers.\r\n    /// @param _account address to add to the list of controllers.\r\n    function addController(address _account) external onlyAdminOrOwner notStopped {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @notice Remove a controller from the list of controllers.\r\n    /// @param _account address to remove from the list of controllers.\r\n    function removeController(address _account) external onlyAdminOrOwner {\r\n        _removeController(_account);\r\n    }\r\n\r\n    /// @notice count the Controllers\r\n    /// @return the current number of controllers.\r\n    function controllerCount() external view returns (uint) {\r\n        return _controllerCount;\r\n    }\r\n\r\n    /// @notice is an address an Admin?\r\n    /// @return true if the provided account is an admin.\r\n    function isAdmin(address _account) public view notStopped returns (bool) {\r\n        return _isAdmin[_account];\r\n    }\r\n\r\n    /// @notice is an address a Controller?\r\n    /// @return true if the provided account is a controller.\r\n    function isController(address _account) public view notStopped returns (bool) {\r\n        return _isController[_account];\r\n    }\r\n\r\n    /// @notice this function can be used to see if the controller has been stopped\r\n    /// @return true is the Controller has been stopped\r\n    function isStopped() public view returns (bool) {\r\n        return _stopped;\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new admin.\r\n    function _addAdmin(address _account) private {\r\n        require(!_isAdmin[_account], \u0022provided account is already an admin\u0022);\r\n        require(!_isController[_account], \u0022provided account is already a controller\u0022);\r\n        require(!_isOwner(_account), \u0022provided account is already the owner\u0022);\r\n        require(_account != address(0), \u0022provided account is the zero address\u0022);\r\n        _isAdmin[_account] = true;\r\n        _adminCount\u002B\u002B;\r\n        emit AddedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing admin.\r\n    function _removeAdmin(address _account) private {\r\n        require(_isAdmin[_account], \u0022provided account is not an admin\u0022);\r\n        _isAdmin[_account] = false;\r\n        _adminCount--;\r\n        emit RemovedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new controller.\r\n    function _addController(address _account) private {\r\n        require(!_isAdmin[_account], \u0022provided account is already an admin\u0022);\r\n        require(!_isController[_account], \u0022provided account is already a controller\u0022);\r\n        require(!_isOwner(_account), \u0022provided account is already the owner\u0022);\r\n        require(_account != address(0), \u0022provided account is the zero address\u0022);\r\n        _isController[_account] = true;\r\n        _controllerCount\u002B\u002B;\r\n        emit AddedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing controller.\r\n    function _removeController(address _account) private {\r\n        require(_isController[_account], \u0022provided account is not a controller\u0022);\r\n        _isController[_account] = false;\r\n        _controllerCount--;\r\n        emit RemovedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice stop our controllers and admins from being useable\r\n    function stop() external onlyAdminOrOwner {\r\n        _stopped = true;\r\n        emit Stopped(msg.sender);\r\n    }\r\n\r\n    /// @notice start our controller again\r\n    function start() external onlyOwner {\r\n        _stopped = false;\r\n        emit Started(msg.sender);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n}\r\n\r\ncontract ENSResolvable {\r\n    /// @notice _ens is an instance of ENS\r\n    ENS private _ens;\r\n\r\n    /// @notice _ensRegistry points to the ENS registry smart contract.\r\n    address private _ensRegistry;\r\n\r\n    /// @param _ensReg_ is the ENS registry used\r\n    constructor(address _ensReg_) internal {\r\n        _ensRegistry = _ensReg_;\r\n        _ens = ENS(_ensRegistry);\r\n    }\r\n\r\n    /// @notice this is used to that one can observe which ENS registry is being used\r\n    function ensRegistry() external view returns (address) {\r\n        return _ensRegistry;\r\n    }\r\n\r\n    /// @notice helper function used to get the address of a node\r\n    /// @param _node of the ENS entry that needs resolving\r\n    /// @return the address of the said node\r\n    function _ensResolve(bytes32 _node) internal view returns (address) {\r\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is ENSResolvable {\r\n    /// @dev Is the registered ENS node identifying the controller contract.\r\n    bytes32 private _controllerNode;\r\n\r\n    /// @notice Constructor initializes the controller contract object.\r\n    /// @param _controllerNode_ is the ENS node of the Controller.\r\n    constructor(bytes32 _controllerNode_) internal {\r\n        _controllerNode = _controllerNode_;\r\n    }\r\n\r\n    /// @notice Checks if message sender is a controller.\r\n    modifier onlyController() {\r\n        require(_isController(msg.sender), \u0022sender is not a controller\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin(msg.sender), \u0022sender is not an admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @return the controller node registered in ENS.\r\n    function controllerNode() external view returns (bytes32) {\r\n        return _controllerNode;\r\n    }\r\n\r\n    /// @return true if the provided account is a controller.\r\n    function _isController(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isController(_account);\r\n    }\r\n\r\n    /// @return true if the provided account is an admin.\r\n    function _isAdmin(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\r\n    }\r\n\r\n}\r\n\r\ninterface ITokenWhitelist {\r\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function tokenAddressArray() external view returns (address[] memory);\r\n    function redeemableTokens() external view returns (address[] memory);\r\n    function methodIdWhitelist(bytes4) external view returns (bool);\r\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\r\n    function stablecoin() external view returns (address);\r\n    function updateTokenRate(address, uint, uint) external;\r\n}\r\n\r\n\r\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\r\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\r\n    using strings for *;\r\n    using SafeMath for uint256;\r\n    using BytesUtils for bytes;\r\n\r\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\r\n\r\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\r\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\r\n\r\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\r\n    event RemovedToken(address _sender, address _token);\r\n\r\n    event AddedMethodId(bytes4 _methodId);\r\n    event RemovedMethodId(bytes4 _methodId);\r\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\r\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\r\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) =\u003E 0x095ea7b3\r\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) =\u003E 0x42966c68\r\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) =\u003E 0xa9059cbb\r\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) =\u003E 0x23b872dd\r\n\r\n    struct Token {\r\n        string symbol;    // Token symbol\r\n        uint magnitude;   // 10^decimals\r\n        uint rate;        // Token exchange rate in wei\r\n        bool available;   // Flags if the token is available or not\r\n        bool loadable;    // Flags if token is loadable to the TokenCard\r\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\r\n        uint lastUpdate;  // Time of the last rate update\r\n    }\r\n\r\n    mapping(address =\u003E Token) private _tokenInfoMap;\r\n\r\n    // @notice specifies whitelisted methodIds for protected tokens in wallet\u0027s excuteTranaction() e.g. keccak256(transfer(address,uint256)) =\u003E 0xa9059cbb\r\n    mapping(bytes4 =\u003E bool) private _methodIdWhitelist;\r\n\r\n    address[] private _tokenAddressArray;\r\n\r\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\r\n    uint private _redeemableCounter;\r\n\r\n    /// @notice Address of the stablecoin.\r\n    address private _stablecoin;\r\n\r\n    /// @notice is registered ENS node identifying the oracle contract.\r\n    bytes32 private _oracleNode;\r\n\r\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\r\n    /// @param _ens_ is the ENS registry address.\r\n    /// @param _oracleNode_ is the ENS node of the Oracle.\r\n    /// @param _controllerNode_ is our Controllers node.\r\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\r\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\r\n        _oracleNode = _oracleNode_;\r\n        _stablecoin = _stablecoinAddress_;\r\n        //a priori ERC20 whitelisted methods\r\n        _methodIdWhitelist[_APPROVE] = true;\r\n        _methodIdWhitelist[_BURN] = true;\r\n        _methodIdWhitelist[_TRANSFER] = true;\r\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\r\n    }\r\n\r\n    modifier onlyAdminOrOracle() {\r\n        address oracleAddress = _ensResolve(_oracleNode);\r\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \u0022either oracle or admin\u0022);\r\n        _;\r\n    }\r\n\r\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    /// @param _symbols ERC20 token names.\r\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\r\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\r\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\r\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\r\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\r\n        // Require that all parameters have the same length.\r\n        require(_tokens.length == _symbols.length \u0026\u0026 _tokens.length == _magnitude.length \u0026\u0026 _tokens.length == _loadable.length \u0026\u0026 _tokens.length == _loadable.length, \u0022parameter lengths do not match\u0022);\r\n        // Add each token to the list of supported tokens.\r\n        for (uint i = 0; i \u003C _tokens.length; i\u002B\u002B) {\r\n            // Require that the token isn\u0027t already available.\r\n            require(!_tokenInfoMap[_tokens[i]].available, \u0022token already available\u0022);\r\n            // Store the intermediate values.\r\n            string memory symbol = _symbols[i].toSliceB32().toString();\r\n            // Add the token to the token list.\r\n            _tokenInfoMap[_tokens[i]] = Token({\r\n                symbol : symbol,\r\n                magnitude : _magnitude[i],\r\n                rate : 0,\r\n                available : true,\r\n                loadable : _loadable[i],\r\n                redeemable: _redeemable[i],\r\n                lastUpdate : _lastUpdate\r\n                });\r\n            // Add the token address to the address list.\r\n            _tokenAddressArray.push(_tokens[i]);\r\n            //if the token is redeemable increase the redeemableCounter\r\n            if (_redeemable[i]){\r\n                _redeemableCounter = _redeemableCounter.add(1);\r\n            }\r\n            // Emit token addition event.\r\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\r\n        // Delete each token object from the list of supported tokens based on the addresses provided.\r\n        for (uint i = 0; i \u003C _tokens.length; i\u002B\u002B) {\r\n            // Store the token address.\r\n            address token = _tokens[i];\r\n            //token must be available, reverts on duplicates as well\r\n            require(_tokenInfoMap[token].available, \u0022token is not available\u0022);\r\n            //if the token is redeemable decrease the redeemableCounter\r\n            if (_tokenInfoMap[token].redeemable){\r\n                _redeemableCounter = _redeemableCounter.sub(1);\r\n            }\r\n            // Delete the token object.\r\n            delete _tokenInfoMap[token];\r\n            // Remove the token address from the address list.\r\n            for (uint j = 0; j \u003C _tokenAddressArray.length.sub(1); j\u002B\u002B) {\r\n                if (_tokenAddressArray[j] == token) {\r\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\r\n                    break;\r\n                }\r\n            }\r\n            _tokenAddressArray.length--;\r\n            // Emit token removal event.\r\n            emit RemovedToken(msg.sender, token);\r\n        }\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\r\n        // Require that there exist enough bytes for encoding at least a method signature \u002B data in the transaction payload:\r\n        // 4 (signature)  \u002B 32(address or uint256)\r\n        require(_data.length \u003E= 4 \u002B 32, \u0022not enough method-encoding bytes\u0022);\r\n        // Get the method signature\r\n        bytes4 signature = _data._bytesToBytes4(0);\r\n        // Check if method Id is supported\r\n        require(isERC20MethodSupported(_token, signature), \u0022unsupported method\u0022);\r\n        // returns the recipient\u0027s address and amount is the value to be transferred\r\n        if (signature == _BURN) {\r\n            // 4 (signature) \u002B 32(uint256)\r\n            return (_token, _data._bytesToUint256(4));\r\n        } else if (signature == _TRANSFER_FROM) {\r\n            // 4 (signature) \u002B 32(address) \u002B 32(address) \u002B 32(uint256)\r\n            require(_data.length \u003E= 4 \u002B 32 \u002B 32 \u002B 32, \u0022not enough data for transferFrom\u0022);\r\n            return ( _data._bytesToAddress(4 \u002B 32 \u002B 12), _data._bytesToUint256(4 \u002B 32 \u002B 32));\r\n        } else { //transfer or approve\r\n            // 4 (signature) \u002B 32(address) \u002B 32(uint)\r\n            require(_data.length \u003E= 4 \u002B 32 \u002B 32, \u0022not enough data for transfer/appprove\u0022);\r\n            return (_data._bytesToAddress(4 \u002B 12), _data._bytesToUint256(4 \u002B 32));\r\n        }\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is loadable or not.\r\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n\r\n        // this sets the loadable flag to the value passed in\r\n        _tokenInfoMap[_token].loadable = _loadable;\r\n\r\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is redeemable or not.\r\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n\r\n        // this sets the redeemable flag to the value passed in\r\n        _tokenInfoMap[_token].redeemable = _redeemable;\r\n\r\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \u0022token is not available\u0022);\r\n        // Update the token\u0027s rate.\r\n        _tokenInfoMap[_token].rate = _rate;\r\n        // Update the token\u0027s last update timestamp.\r\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\r\n        // Emit the rate update event.\r\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage tokenInfo = _tokenInfoMap[_a];\r\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our StableCoin.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\r\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns an array of all whitelisted token addresses.\r\n    /// @return address[] of whitelisted tokens.\r\n    function tokenAddressArray() external view returns (address[] memory) {\r\n        return _tokenAddressArray;\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function redeemableTokens() external view returns (address[] memory) {\r\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\r\n        uint redeemableIndex = 0;\r\n        for (uint i = 0; i \u003C _tokenAddressArray.length; i\u002B\u002B) {\r\n            address token = _tokenAddressArray[i];\r\n            if (_tokenInfoMap[token].redeemable){\r\n                redeemableAddresses[redeemableIndex] = token;\r\n                redeemableIndex \u002B= 1;\r\n            }\r\n        }\r\n        return redeemableAddresses;\r\n    }\r\n\r\n\r\n    /// @notice This returns true if a method Id is supported for the specific token.\r\n    /// @return true if _methodId is supported in general or just for the specific token.\r\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\r\n        require(_tokenInfoMap[_token].available, \u0022non-existing token\u0022);\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns true if the method is supported for all protected tokens.\r\n    /// @return true if _methodId is in the method whitelist.\r\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns the number of redeemable tokens.\r\n    /// @return current # of redeemables.\r\n    function redeemableCounter() external view returns (uint) {\r\n        return _redeemableCounter;\r\n    }\r\n\r\n    /// @notice This returns the address of our stablecoin of choice.\r\n    /// @return the address of the stablecoin contract.\r\n    function stablecoin() external view returns (address) {\r\n        return _stablecoin;\r\n    }\r\n\r\n    /// @notice this returns the node hash of our Oracle.\r\n    /// @return the oracle node registered in ENS.\r\n    function oracleNode() external view returns (bytes32) {\r\n        return _oracleNode;\r\n    }\r\n}\r\n\r\ncontract TokenWhitelistable is ENSResolvable {\r\n\r\n    /// @notice Is the registered ENS node identifying the tokenWhitelist contract\r\n    bytes32 private _tokenWhitelistNode;\r\n\r\n    /// @notice Constructor initializes the TokenWhitelistable object.\r\n    /// @param _tokenWhitelistNode_ is the ENS node of the TokenWhitelist.\r\n    constructor(bytes32 _tokenWhitelistNode_) internal {\r\n        _tokenWhitelistNode = _tokenWhitelistNode_;\r\n    }\r\n\r\n    /// @notice This shows what TokenWhitelist is being used\r\n    /// @return TokenWhitelist\u0027s node registered in ENS.\r\n    function tokenWhitelistNode() external view returns (bytes32) {\r\n        return _tokenWhitelistNode;\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function _getTokenInfo(address _a) internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our stablecoin token.\r\n    /// @return string of the token\u0027s symbol.\r\n    /// @return uint of the token\u0027s magnitude.\r\n    /// @return uint of the token\u0027s exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token\u0027s exchange rate.\r\n    function _getStablecoinInfo() internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\r\n    }\r\n\r\n    /// @notice This returns an array of our whitelisted addresses.\r\n    /// @return address[] of our whitelisted tokens.\r\n    function _tokenAddressArray() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function _redeemableTokens() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).redeemableTokens();\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\r\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function _getERC20RecipientAndAmount(address _destination, bytes memory _data) internal view returns (address, uint) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getERC20RecipientAndAmount(_destination, _data);\r\n    }\r\n\r\n    /// @notice Checks whether a token is available.\r\n    /// @return bool available or not.\r\n    function _isTokenAvailable(address _a) internal view returns (bool) {\r\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\r\n        return available;\r\n    }\r\n\r\n    /// @notice Checks whether a token is redeemable.\r\n    /// @return bool redeemable or not.\r\n    function _isTokenRedeemable(address _a) internal view returns (bool) {\r\n        ( , , , , , bool redeemable, ) = _getTokenInfo(_a);\r\n        return redeemable;\r\n    }\r\n\r\n    /// @notice Checks whether a token is loadable.\r\n    /// @return bool loadable or not.\r\n    function _isTokenLoadable(address _a) internal view returns (bool) {\r\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\r\n        return loadable;\r\n    }\r\n\r\n    /// @notice This gets the address of the stablecoin.\r\n    /// @return the address of the stablecoin contract.\r\n    function _stablecoin() internal view returns (address) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\r\n    }\r\n\r\n}\r\n\r\ncontract Oracle is ENSResolvable, usingOraclize, Transferrable, Base64, Date, Controllable, ParseIntScientific, TokenWhitelistable {\r\n    using strings for *;\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /*******************/\r\n    /*     Events     */\r\n    /*****************/\r\n\r\n    event SetGasPrice(address _sender, uint _gasPrice);\r\n\r\n    event RequestedUpdate(string _symbol, bytes32 _queryID);\r\n    event FailedUpdateRequest(string _reason);\r\n\r\n    event VerifiedProof(bytes _publicKey, string _result);\r\n\r\n    event SetCryptoComparePublicKey(address _sender, bytes _publicKey);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /**********************/\r\n    /*     Constants     */\r\n    /********************/\r\n\r\n    uint constant private _PROOF_LEN = 165;\r\n    uint constant private _ECDSA_SIG_LEN = 65;\r\n    uint constant private _ENCODING_BYTES = 2;\r\n    uint constant private _HEADERS_LEN = _PROOF_LEN - 2 * _ENCODING_BYTES - _ECDSA_SIG_LEN; // 2 bytes encoding headers length \u002B 2 for signature.\r\n    uint constant private _DIGEST_BASE64_LEN = 44; //base64 encoding of the SHA256 hash (32-bytes) of the result: fixed length.\r\n    uint constant private _DIGEST_OFFSET = _HEADERS_LEN - _DIGEST_BASE64_LEN; // the starting position of the result hash in the headers string.\r\n\r\n    uint constant private _MAX_BYTE_SIZE = 256; //for calculating length encoding\r\n\r\n    // This is how the cryptocompare json begins\r\n    bytes32 constant private _PREFIX_HASH = keccak256(\u0022{\\\u0022ETH\\\u0022:\u0022);\r\n\r\n    bytes public cryptoCompareAPIPublicKey;\r\n    mapping(bytes32 =\u003E address) private _queryToToken;\r\n\r\n    /// @notice Construct the oracle with multiple controllers, address resolver and custom gas price.\r\n    /// @param _resolver_ is the address of the oraclize resolver\r\n    /// @param _ens_ is the address of the ENS.\r\n    /// @param _controllerNode_ is the ENS node corresponding to the Controller.\r\n    /// @param _tokenWhitelistNode_ is the ENS corresponding to the Token Whitelist.\r\n    constructor(address _resolver_, address _ens_, bytes32 _controllerNode_, bytes32 _tokenWhitelistNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) TokenWhitelistable(_tokenWhitelistNode_) public {\r\n        cryptoCompareAPIPublicKey = hex\u0022a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\u0022;\r\n        OAR = OraclizeAddrResolverI(_resolver_);\r\n        oraclize_setCustomGasPrice(10000000000);\r\n        oraclize_setProof(proofType_Native);\r\n    }\r\n\r\n    /// @notice Updates the Crypto Compare public API key.\r\n    /// @param _publicKey new Crypto Compare public API key\r\n    function updateCryptoCompareAPIPublicKey(bytes calldata _publicKey) external onlyAdmin {\r\n        cryptoCompareAPIPublicKey = _publicKey;\r\n        emit SetCryptoComparePublicKey(msg.sender, _publicKey);\r\n    }\r\n\r\n    /// @notice Sets the gas price used by Oraclize query.\r\n    /// @param _gasPrice in wei for Oraclize\r\n    function setCustomGasPrice(uint _gasPrice) external onlyController {\r\n        oraclize_setCustomGasPrice(_gasPrice);\r\n        emit SetGasPrice(msg.sender, _gasPrice);\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rates for all supported tokens.\r\n    /// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\r\n    function updateTokenRates(uint _gasLimit) external payable onlyController {\r\n        _updateTokenRates(_gasLimit);\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rates for the list of tokens provided.\r\n    /// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\r\n    /// @param _tokenList the list of tokens that need to be updated\r\n    function updateTokenRatesList(uint _gasLimit, address[] calldata _tokenList) external payable onlyController {\r\n        _updateTokenRatesList(_gasLimit, _tokenList);\r\n    }\r\n\r\n    /// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice Handle Oraclize query callback and verifiy the provided origin proof.\r\n    /// @param _queryID Oraclize query ID.\r\n    /// @param _result query result in JSON format.\r\n    /// @param _proof origin proof from crypto compare.\r\n    // solium-disable-next-line mixedcase\r\n    function __callback(bytes32 _queryID, string memory _result, bytes memory _proof) public {\r\n        // Require that the caller is the Oraclize contract.\r\n        require(msg.sender == oraclize_cbAddress(), \u0022sender is not oraclize\u0022);\r\n        // Use the query ID to find the matching token address.\r\n        address token = _queryToToken[_queryID];\r\n        // Get the corresponding token object.\r\n        ( , , , bool available, , , uint256 lastUpdate) = _getTokenInfo(token);\r\n        require(available, \u0022token must be available\u0022);\r\n\r\n        bool valid;\r\n        uint timestamp;\r\n        (valid, timestamp) = _verifyProof(_result, _proof, cryptoCompareAPIPublicKey, lastUpdate);\r\n\r\n        // Require that the proof is valid.\r\n        if (valid) {\r\n            // Parse the JSON result to get the rate in wei.\r\n            uint256 parsedRate = _parseIntScientificWei(parseRate(_result));\r\n            // Set the update time of the token rate.\r\n            uint256 parsedLastUpdate = timestamp;\r\n            // Remove query from the list.\r\n            delete _queryToToken[_queryID];\r\n\r\n            _updateTokenRate(token, parsedRate, parsedLastUpdate);\r\n        }\r\n    }\r\n\r\n    /// @notice Extracts JSON rate value from the response object.\r\n    /// @param _json body of the JSON response from the CryptoCompare API.\r\n    function parseRate(string memory _json) internal pure returns (string memory) {\r\n\r\n        uint jsonLen = abi.encodePacked(_json).length;\r\n        //{\u0022ETH\u0022:}.length = 8, assuming a (maximum of) 18 digit prevision\r\n        require(jsonLen \u003E 8 \u0026\u0026 jsonLen \u003C= 28, \u0022misformatted input\u0022);\r\n\r\n        bytes memory jsonPrefix = new bytes(7);\r\n        copyBytes(abi.encodePacked(_json), 0, 7, jsonPrefix, 0);\r\n        require(keccak256(jsonPrefix) == _PREFIX_HASH, \u0022prefix mismatch\u0022);\r\n\r\n        strings.slice memory body = _json.toSlice();\r\n        body.split(\u0022:\u0022.toSlice());\r\n        //we are sure that \u0027:\u0027 is included in the string, body now contains the rate\u002B\u0027}\u0027\r\n        jsonLen = body._len;\r\n        body.until(\u0022}\u0022.toSlice());\r\n        require(body._len == jsonLen - 1, \u0022not json format\u0022);\r\n        //ensure that the json is properly terminated with a \u0027}\u0027\r\n        return body.toString();\r\n    }\r\n\r\n    /// @notice Re-usable helper function that performs the Oraclize Query.\r\n    /// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\r\n    function _updateTokenRates(uint _gasLimit) private {\r\n        address[] memory tokenAddresses = _tokenAddressArray();\r\n        // Check if there are any existing tokens.\r\n        if (tokenAddresses.length == 0) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\u0022no tokens\u0022);\r\n            // Check if the contract has enough Ether to pay for the query.\r\n        } else if (oraclize_getPrice(\u0022URL\u0022) * tokenAddresses.length \u003E address(this).balance) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\u0022insufficient balance\u0022);\r\n        } else {\r\n            // Set up the cryptocompare API query strings.\r\n            strings.slice memory apiPrefix = \u0022https://min-api.cryptocompare.com/data/price?fsym=\u0022.toSlice();\r\n            strings.slice memory apiSuffix = \u0022\u0026tsyms=ETH\u0026sign=true\u0022.toSlice();\r\n\r\n            // Create a new oraclize query for each supported token.\r\n            for (uint i = 0; i \u003C tokenAddresses.length; i\u002B\u002B) {\r\n                // Store the token symbol used in the query.\r\n                (string memory symbol, , , , , , ) = _getTokenInfo(tokenAddresses[i]);\r\n\r\n                strings.slice memory sym = symbol.toSlice();\r\n                // Create a new oraclize query from the component strings.\r\n                bytes32 queryID = oraclize_query(\u0022URL\u0022, apiPrefix.concat(sym).toSlice().concat(apiSuffix), _gasLimit);\r\n                // Store the query ID together with the associated token address.\r\n                _queryToToken[queryID] = tokenAddresses[i];\r\n                // Emit the query success event.\r\n                emit RequestedUpdate(sym.toString(), queryID);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Re-usable helper function that performs the Oraclize Query for a specific list of tokens.\r\n    /// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback.\r\n    /// @param _tokenList the list of tokens that need to be updated.\r\n    function _updateTokenRatesList(uint _gasLimit, address[] memory _tokenList) private {\r\n        // Check if there are any existing tokens.\r\n        if (_tokenList.length == 0) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\u0022empty token list\u0022);\r\n        // Check if the contract has enough Ether to pay for the query.\r\n        } else if (oraclize_getPrice(\u0022URL\u0022) * _tokenList.length \u003E address(this).balance) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\u0022insufficient balance\u0022);\r\n        } else {\r\n            // Set up the cryptocompare API query strings.\r\n            strings.slice memory apiPrefix = \u0022https://min-api.cryptocompare.com/data/price?fsym=\u0022.toSlice();\r\n            strings.slice memory apiSuffix = \u0022\u0026tsyms=ETH\u0026sign=true\u0022.toSlice();\r\n\r\n            // Create a new oraclize query for each supported token.\r\n            for (uint i = 0; i \u003C _tokenList.length; i\u002B\u002B) {\r\n                //token must exist, revert if it doesn\u0027t\r\n                (string memory tokenSymbol, , , bool available , , , ) = _getTokenInfo(_tokenList[i]);\r\n                require(available, \u0022token must be available\u0022);\r\n                // Store the token symbol used in the query.\r\n                strings.slice memory symbol = tokenSymbol.toSlice();\r\n                // Create a new oraclize query from the component strings.\r\n                bytes32 queryID = oraclize_query(\u0022URL\u0022, apiPrefix.concat(symbol).toSlice().concat(apiSuffix), _gasLimit);\r\n                // Store the query ID together with the associated token address.\r\n                _queryToToken[queryID] = _tokenList[i];\r\n                // Emit the query success event.\r\n                emit RequestedUpdate(symbol.toString(), queryID);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Verify the origin proof returned by the cryptocompare API.\r\n    /// @param _result query result in JSON format.\r\n    /// @param _proof origin proof from cryptocompare.\r\n    /// @param _publicKey cryptocompare public key.\r\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\r\n    function _verifyProof(string memory _result, bytes memory _proof, bytes memory _publicKey, uint _lastUpdate) private returns (bool, uint) {\r\n\r\n        // expecting fixed length proofs\r\n        if (_proof.length != _PROOF_LEN) {\r\n            revert(\u0022invalid proof length\u0022);\r\n        }\r\n\r\n        // proof should be 65 bytes long: R (32 bytes) \u002B S (32 bytes) \u002B v (1 byte)\r\n        if (uint(uint8(_proof[1])) != _ECDSA_SIG_LEN) {\r\n            revert(\u0022invalid signature length\u0022);\r\n        }\r\n\r\n        bytes memory signature = new bytes(_ECDSA_SIG_LEN);\r\n\r\n        signature = copyBytes(_proof, 2, _ECDSA_SIG_LEN, signature, 0);\r\n\r\n        // Extract the headers, big endian encoding of headers length\r\n        if (uint(uint8(_proof[_ENCODING_BYTES \u002B _ECDSA_SIG_LEN])) * _MAX_BYTE_SIZE \u002B uint(uint8(_proof[_ENCODING_BYTES \u002B _ECDSA_SIG_LEN \u002B 1])) != _HEADERS_LEN) {\r\n            revert(\u0022invalid headers length\u0022);\r\n        }\r\n\r\n        bytes memory headers = new bytes(_HEADERS_LEN);\r\n        headers = copyBytes(_proof, 2 * _ENCODING_BYTES \u002B _ECDSA_SIG_LEN, _HEADERS_LEN, headers, 0);\r\n\r\n        // Check if the signature is valid and if the signer address is matching.\r\n        if (!_verifySignature(headers, signature, _publicKey)) {\r\n            revert(\u0022invalid signature\u0022);\r\n        }\r\n\r\n        // Check if the date is valid.\r\n        bytes memory dateHeader = new bytes(20);\r\n        // keep only the relevant string(e.g. \u002216 Nov 2018 16:22:18\u0022)\r\n        dateHeader = copyBytes(headers, 11, 20, dateHeader, 0);\r\n\r\n        bool dateValid;\r\n        uint timestamp;\r\n        (dateValid, timestamp) = _verifyDate(string(dateHeader), _lastUpdate);\r\n\r\n        // Check whether the date returned is valid or not\r\n        if (!dateValid) {\r\n            revert(\u0022invalid date\u0022);\r\n        }\r\n\r\n        // Check if the signed digest hash matches the result hash.\r\n        bytes memory digest = new bytes(_DIGEST_BASE64_LEN);\r\n        digest = copyBytes(headers, _DIGEST_OFFSET, _DIGEST_BASE64_LEN, digest, 0);\r\n\r\n        if (keccak256(abi.encodePacked(sha256(abi.encodePacked(_result)))) != keccak256(_base64decode(digest))) {\r\n            revert(\u0022result hash not matching\u0022);\r\n        }\r\n\r\n        emit VerifiedProof(_publicKey, _result);\r\n        return (true, timestamp);\r\n    }\r\n\r\n    /// @notice Verify the HTTP headers and the signature\r\n    /// @param _headers HTTP headers provided by the cryptocompare api\r\n    /// @param _signature signature provided by the cryptocompare api\r\n    /// @param _publicKey cryptocompare public key.\r\n    function _verifySignature(bytes memory _headers, bytes memory _signature, bytes memory _publicKey) private returns (bool) {\r\n        address signer;\r\n        bool signatureOK;\r\n\r\n        // Checks if the signature is valid by hashing the headers\r\n        (signatureOK, signer) = ecrecovery(sha256(_headers), _signature);\r\n        return signatureOK \u0026\u0026 signer == address(uint160(uint256(keccak256(_publicKey))));\r\n    }\r\n\r\n    /// @notice Verify the signed HTTP date header.\r\n    /// @param _dateHeader extracted date string e.g. Wed, 12 Sep 2018 15:18:14 GMT.\r\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\r\n    function _verifyDate(string memory _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\r\n\r\n        // called by verifyProof(), _dateHeader is always a string of length = 20\r\n        assert(abi.encodePacked(_dateHeader).length == 20);\r\n\r\n        // Split the date string and get individual date components.\r\n        strings.slice memory date = _dateHeader.toSlice();\r\n        strings.slice memory timeDelimiter = \u0022:\u0022.toSlice();\r\n        strings.slice memory dateDelimiter = \u0022 \u0022.toSlice();\r\n\r\n        uint day = _parseIntScientific(date.split(dateDelimiter).toString());\r\n        require(day \u003E 0 \u0026\u0026 day \u003C 32, \u0022day error\u0022);\r\n\r\n        uint month = _monthToNumber(date.split(dateDelimiter).toString());\r\n        require(month \u003E 0 \u0026\u0026 month \u003C 13, \u0022month error\u0022);\r\n\r\n        uint year = _parseIntScientific(date.split(dateDelimiter).toString());\r\n        require(year \u003E 2017 \u0026\u0026 year \u003C 3000, \u0022year error\u0022);\r\n\r\n        uint hour = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(hour \u003C 25, \u0022hour error\u0022);\r\n\r\n        uint minute = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(minute \u003C 60, \u0022minute error\u0022);\r\n\r\n        uint second = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(second \u003C 60, \u0022second error\u0022);\r\n\r\n        uint timestamp = year * (10 ** 10) \u002B month * (10 ** 8) \u002B day * (10 ** 6) \u002B hour * (10 ** 4) \u002B minute * (10 ** 2) \u002B second;\r\n\r\n        return (timestamp \u003E _lastUpdate, timestamp);\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_myid\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_result\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022__callback\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_queryID\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_result\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_proof\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022__callback\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cryptoCompareAPIPublicKey\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022ensRegistry\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022tokenWhitelistNode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_gasLimit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_tokenList\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022name\u0022:\u0022updateTokenRatesList\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022claim\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_gasLimit\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022updateTokenRates\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:true,\u0022stateMutability\u0022:\u0022payable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_publicKey\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022updateCryptoCompareAPIPublicKey\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_gasPrice\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setCustomGasPrice\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022controllerNode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_resolver_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_ens_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_controllerNode_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_tokenWhitelistNode_\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_gasPrice\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022SetGasPrice\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_symbol\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_queryID\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022RequestedUpdate\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_reason\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022FailedUpdateRequest\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_publicKey\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_result\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022VerifiedProof\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_publicKey\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022SetCryptoComparePublicKey\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_asset\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Claimed\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Oracle","CompilerVersion":"v0.5.10\u002Bcommit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b7f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697e84f90570f13fe09f288f2411ff9cf50da611ed0c7db7f73d48053ffc974d396","Library":"","SwarmSource":"bzzr://b9c0bb5b53cea83b4431a962017f029b0d2d3db6a263b2a78f843e1dad7c8d13"}]