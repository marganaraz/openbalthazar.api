[{"SourceCode":"// File: contracts/InternalModule.sol\r\n\r\npragma solidity \u003E=0.5.0 \u003C0.6.0;\r\n\r\ncontract InternalModule {\r\n\r\n    address[] _authAddress;\r\n\r\n    address payable[] public _contractOwners = [\r\n        address(0xD04C3c9eEC7BE36d28a925598B909954b4fd83cB)   // Prod\r\n        // address(0x4ad16f3f6B4C1C48C644756979f96bcd0bfa077B)   // Truffle Develop\r\n    ];\r\n\r\n    address payable public _defaultReciver;\r\n\r\n    constructor() public {\r\n\r\n        require(_contractOwners.length \u003E 0);\r\n\r\n        _defaultReciver = _contractOwners[0];\r\n\r\n        _contractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier OwnerOnly() {\r\n\r\n        bool exist = false;\r\n        for ( uint i = 0; i \u003C _contractOwners.length; i\u002B\u002B ) {\r\n            if ( _contractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    modifier DAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \u0022DAO_Warning\u0022 );\r\n        _;\r\n    }\r\n\r\n    modifier APIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i \u003C _authAddress.length; i\u002B\u002B) {\r\n            if ( _authAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function AuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _authAddress;\r\n    }\r\n\r\n    function AddAuthAddress(address _addr) external OwnerOnly {\r\n        _authAddress.push(_addr);\r\n    }\r\n\r\n    function DelAuthAddress(address _addr) external OwnerOnly {\r\n\r\n        for (uint i = 0; i \u003C _authAddress.length; i\u002B\u002B) {\r\n            if (_authAddress[i] == _addr) {\r\n                for (uint j = 0; j \u003C _authAddress.length - 1; j\u002B\u002B) {\r\n                    _authAddress[j] = _authAddress[j\u002B1];\r\n                }\r\n                delete _authAddress[_authAddress.length - 1];\r\n                _authAddress.length--;\r\n                return ;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// File: contracts/interface/ERC20Interface.sol\r\n\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interface/RecommendInterface.sol\r\n\r\ninterface RecommendInterface {\r\n\r\n\r\n    function GetIntroducer( address _owner ) external view returns (address);\r\n\r\n\r\n    function RecommendList( address _owner, uint256 depth ) external view returns ( address[] memory list, uint256 len );\r\n\r\n\r\n    function ShortCodeToAddress( bytes6 shortCode ) external view returns (address);\r\n\r\n\r\n    function AddressToShortCode( address _addr ) external view returns (bytes6);\r\n\r\n\r\n    function TeamMemberTotal( address _addr ) external view returns (uint256);\r\n\r\n\r\n    function IsValidMember( address _addr ) external view returns (bool);\r\n\r\n\r\n    function IsValidMemberEx( address _addr ) external view returns (bool, uint256);\r\n\r\n\r\n    function DirectValidMembersCount( address _addr ) external view returns (uint256);\r\n\r\n\r\n    function RegisterShortCode( bytes6 shortCode ) external;\r\n\r\n\r\n    function BindRelation(address _recommer ) external;\r\n\r\n\r\n    function BindRelationEx(address _recommer, bytes6 shortCode ) external;\r\n\r\n\r\n    function GetSearchDepthMaxLimit() external view returns (uint256);\r\n\r\n\r\n    function API_MakeAddressToValid( address _owner ) external;\r\n}\r\n\r\n// File: contracts/library/RoundController.sol\r\n\r\nlibrary Times {\r\n    function OneDay() public pure returns (uint256) {\r\n        return 1 days;\r\n    }\r\n}\r\n\r\nlibrary TokenAssetPool {\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    struct MainDB {\r\n\r\n        mapping(address =\u003E uint256) totalAmountsMapping;\r\n\r\n        mapping(address =\u003E uint256) assetsAmountMapping;\r\n    }\r\n\r\n    function TotalAmount(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.assetsAmountMapping[owner];\r\n    }\r\n\r\n    function TotalSum(MainDB storage self, address owner ) internal view returns (uint256) {\r\n        return self.totalAmountsMapping[owner];\r\n    }\r\n\r\n    function AddAmount(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        require( amount \u003C= UINT_MAX );\r\n\r\n        self.assetsAmountMapping[owner] \u002B= amount;\r\n\r\n        self.totalAmountsMapping[owner] \u002B= amount;\r\n    }\r\n\r\n    function SubAmount(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        require( amount \u003C= UINT_MAX );\r\n        require( TotalAmount(self,owner) \u003E= amount );\r\n\r\n        self.assetsAmountMapping[owner] -= amount;\r\n    }\r\n\r\n}\r\n\r\nlibrary StaticMath {\r\n\r\n    function S(uint256 ir) internal pure returns (uint256 s) {\r\n\r\n        s = 1000 ether;\r\n\r\n        for (uint i = 0; i \u003C ir; i \u002B\u002B ) {\r\n            s = s * 1300000 / 1000000;\r\n        }\r\n\r\n        /// INT\r\n        s = s / 1 ether * 1 ether;\r\n    }\r\n\r\n    function P(uint256 ir) internal pure returns (uint256 r) {\r\n\r\n        if ( ir \u003E= 4 ) {\r\n\r\n            for ( uint ji = 0; ji \u003C ir - 3; ji\u002B\u002B ) {\r\n                r \u002B= S(ji) * 300000 / 1000000;\r\n            }\r\n\r\n            for ( uint i = ir - 3; i \u003C ir; i\u002B\u002B ) {\r\n                r \u002B= S(i) * 80000 / 1000000;\r\n            }\r\n\r\n        } else if ( ir != 0 \u0026\u0026 ir \u003C 4 ) {\r\n\r\n            for ( uint i = 0; i \u003C ir; i\u002B\u002B ) {\r\n                r \u002B= S(i) * 80000 / 1000000;\r\n            }\r\n\r\n        } else {\r\n\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function O(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n\r\n        if (ir - n == 1 ) {\r\n            return 400000;\r\n        } else if (ir - n == 2 ) {\r\n            return 350000;\r\n        } else if (ir - n == 3 ) {\r\n            return 250000;\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function T(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n        return P(ir) * O(ir, n) / 1000000;\r\n    }\r\n\r\n    function W(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n\r\n        if ( ir - n \u003C= 3 ) {\r\n\r\n            uint256 subp = T(ir, n) * 1000000 / S(n);\r\n            if ( subp != 0 ) {\r\n                subp \u002B\u002B;\r\n            }\r\n\r\n            return 1000000 - subp;\r\n\r\n        } else {\r\n\r\n            return 1100000;\r\n        }\r\n    }\r\n\r\n    function ProfitHandle(uint256 ir, bool irTimeoutable, uint256 n, uint256 ns) internal pure returns (uint256) {\r\n\r\n        if ( (ir - n \u003C= 3 \u0026\u0026 !irTimeoutable) || n \u003E ir ) {\r\n            return 0;\r\n        }\r\n\r\n        return ns * W(ir, n) / 1000000;\r\n    }\r\n}\r\n\r\nlibrary DynamicMath {\r\n\r\n    struct MainDB {\r\n\r\n        RecommendInterface RCMINC;\r\n\r\n        uint[] dyp;\r\n    }\r\n\r\n    struct Request {\r\n        address owner;\r\n        uint oid;\r\n        uint ownerDepositAmount;\r\n        uint stProfix;\r\n    }\r\n\r\n    function Init( MainDB storage self, RecommendInterface rcminc ) internal {\r\n\r\n        self.RCMINC = rcminc;\r\n\r\n        self.dyp = [20, 15, 10, 10, 10, 5, 5, 5, 5, 5];\r\n    }\r\n\r\n    function ProfitHandle(\r\n        MainDB storage self,\r\n        RoundController.MainDB storage RCDB,\r\n        Request memory req\r\n    )\r\n    internal view\r\n    returns (\r\n        uint256 len,\r\n        address [] memory addrs,\r\n        uint256 [] memory profixs\r\n    ) {\r\n        address parent = req.owner;\r\n        len = self.dyp.length;\r\n        addrs = new address[](len);\r\n        profixs = new uint256[](len);\r\n\r\n        for ( (uint i, uint j) = (0,0); i \u003C self.RCMINC.GetSearchDepthMaxLimit() \u0026\u0026 j \u003C self.dyp.length; i\u002B\u002B ) {\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n\r\n            if ( parent != address(0x0) \u0026\u0026 parent != address(0xFF) ) {\r\n\r\n\r\n                uint s = self.RCMINC.DirectValidMembersCount(parent);\r\n                if ( self.RCMINC.IsValidMember(parent) \u0026\u0026 ( s \u003E= j\u002B1 || s \u003E= 6 ) ) {\r\n\r\n\r\n                    addrs[j] = parent;\r\n                    profixs[j] = req.stProfix * self.dyp[j] / 100;\r\n\r\n\r\n                    if ( RCDB.roundList[req.oid].depositedMapping[parent].totalAmount * 2 \u003C req.ownerDepositAmount ) {\r\n\r\n                        uint bp = RCDB.roundList[req.oid].depositedMapping[parent].totalAmount * 200000 / req.ownerDepositAmount;\r\n\r\n                        profixs[j] = profixs[j] * bp / 100000;\r\n                    }\r\n\r\n                    \u002B\u002Bj;\r\n                }\r\n\r\n            } else {\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \u00220\u0022;\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length\u002B\u002B;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 \u002B i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary LevelMath {\r\n\r\n    struct MainDB {\r\n\r\n        RecommendInterface RCMINC;\r\n\r\n        uint256[] lvProfits;\r\n\r\n        mapping(uint256 =\u003E mapping(address =\u003E uint256)) achievementMapping;\r\n\r\n        uint256 searchDepth;\r\n    }\r\n\r\n    function Init( MainDB storage self, RecommendInterface _RINC ) internal {\r\n        self.RCMINC = _RINC;\r\n        self.lvProfits = [0, 10, 5, 5, 5, 5];\r\n        self.searchDepth = 1024;\r\n    }\r\n\r\n\r\n    function SetSearchDepth( MainDB storage self, uint256 d) internal {\r\n        self.searchDepth = d;\r\n    }\r\n\r\n\r\n    function AddAchievement( MainDB storage self, address owner, uint256 oid, uint256 amount) internal {\r\n\r\n\r\n        address parent = owner;\r\n\r\n        for ( uint i = 0; i \u003C self.searchDepth; i\u002B\u002B ) {\r\n\r\n            if ( parent != address(0x0) \u0026\u0026 parent != address(0xFF) ) {\r\n\r\n                self.achievementMapping[oid][parent] \u002B= amount;\r\n\r\n            } else {\r\n\r\n                return ;\r\n            }\r\n\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n        }\r\n    }\r\n\r\n\r\n    function ProfitHandle( MainDB storage self, address owner, uint256 oid, uint256 totalRoundCount, uint staticProfixAmount )\r\n    internal view\r\n    returns (\r\n        uint256 len,\r\n        address [] memory addrs,\r\n        uint [] memory profitAmounts\r\n    ) {\r\n        len = self.lvProfits.length;\r\n        addrs = new address[](len);\r\n        profitAmounts = new uint[](len);\r\n\r\n\r\n        address parent = owner;\r\n\r\n        uint256[] memory copyProfits = self.lvProfits;\r\n\r\n        for ( uint i = 0; i \u003C self.searchDepth; i\u002B\u002B ) {\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n\r\n            if ( parent == address(0x0) || parent == address(0xFF) ) {\r\n                break;\r\n            }\r\n\r\n\r\n            if ( !self.RCMINC.IsValidMember(parent) ) {\r\n                continue;\r\n            }\r\n\r\n\r\n            uint parentLv = CurrentLevelOf(self, parent, oid, totalRoundCount);\r\n\r\n\r\n            uint psum = 0;\r\n            for ( uint p = 0; p \u003C= parentLv; p\u002B\u002B ) {\r\n\r\n                psum \u002B= copyProfits[p];\r\n\r\n\r\n                copyProfits[p] = 0;\r\n            }\r\n\r\n\r\n            if ( psum \u003E 0 ) {\r\n                addrs[parentLv] = parent;\r\n                profitAmounts[parentLv] = staticProfixAmount * psum / 100;\r\n            }\r\n\r\n\r\n            if ( parentLv \u003E= self.lvProfits.length - 1 ) {\r\n                break;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    function CurrentLevelOf( MainDB storage self, address owner, uint256 oid, uint256 totalRoundCount )\r\n    internal view\r\n    returns (uint256) {\r\n\r\n\r\n        (address [] memory communityList, uint256 rlen) = self.RCMINC.RecommendList(owner, 0);\r\n\r\n\r\n        uint256 achievementSum = 0;\r\n        uint256 maxCommunityAmount = 0;\r\n\r\n        for ( uint i = 0; i \u003C rlen; i\u002B\u002B) {\r\n\r\n            uint256 communitySum = 0;\r\n\r\n            for ( uint o = oid; o \u003C oid \u002B 4 \u0026\u0026 o \u003C totalRoundCount; o\u002B\u002B ) {\r\n                communitySum \u002B= self.achievementMapping[o][communityList[i]];\r\n            }\r\n\r\n            achievementSum \u002B= communitySum;\r\n\r\n            if ( communitySum \u003E maxCommunityAmount ) {\r\n                maxCommunityAmount = communitySum;\r\n            }\r\n        }\r\n\r\n        achievementSum -= maxCommunityAmount;\r\n\r\n\r\n        uint256 lv = 0;\r\n\r\n        if ( achievementSum \u003E= 100 ether ) {\r\n            lv = 1;\r\n        }\r\n\r\n        if ( achievementSum \u003E= 300 ether ) {\r\n            lv = 2;\r\n        }\r\n\r\n        if ( achievementSum \u003E= 1000 ether ) {\r\n            lv = 3;\r\n        }\r\n\r\n        if ( achievementSum \u003E= 3000 ether ) {\r\n            lv = 4;\r\n        }\r\n\r\n        if ( achievementSum \u003E= 9000 ether ) {\r\n            lv = 5;\r\n        }\r\n\r\n        return lv;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \u00220\u0022;\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length\u002B\u002B;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 \u002B i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary LuckAssetPool {\r\n\r\n    using TokenAssetPool for TokenAssetPool.MainDB;\r\n\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    struct MainDB {\r\n\r\n\r\n        uint256 currentRoundTempAmount;\r\n\r\n\r\n        uint256 rewardAmountTotal;\r\n\r\n\r\n        uint256 currentRID;\r\n\r\n\r\n        mapping(uint256 =\u003E uint256) assetAmountMapping;\r\n\r\n\r\n        mapping(uint256 =\u003E uint256) rollbackAmountMapping;\r\n\r\n\r\n        mapping(uint256 =\u003E Invest[]) investMapping;\r\n    }\r\n\r\n    struct Invest {\r\n        address who;\r\n        uint256 when;\r\n        uint256 amount;\r\n    }\r\n\r\n    function RoundTimeOutDelegate(MainDB storage self, uint256 timeoutable_oid, TokenAssetPool.MainDB storage userPool)\r\n    internal\r\n    returns (\r\n        address[20] memory luckyOnes,\r\n        uint256[20] memory rewardAmounts\r\n    )\r\n    {\r\n        self.rollbackAmountMapping[timeoutable_oid] = self.currentRoundTempAmount;\r\n\r\n        self.currentRoundTempAmount = 0;\r\n\r\n\r\n        (luckyOnes, rewardAmounts) = winningThePrizeAtRID(self, self.currentRID, userPool);\r\n\r\n        self.currentRID \u002B\u002B;\r\n    }\r\n\r\n    function RoundSuccessDelegate(MainDB storage self) internal {\r\n\r\n\r\n        self.assetAmountMapping[self.currentRID] \u002B= self.currentRoundTempAmount;\r\n\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n\r\n    function BalanceOfRID(MainDB storage self, uint256 rid) internal view returns (uint256) {\r\n        return self.assetAmountMapping[rid];\r\n    }\r\n\r\n    function DoRollback(MainDB storage self, uint256 oid, uint256 amount) internal returns (uint256 realAmount) {\r\n\r\n        if ( self.rollbackAmountMapping[oid] \u003E= amount ) {\r\n\r\n            self.rollbackAmountMapping[oid] -= amount;\r\n\r\n            realAmount = amount;\r\n\r\n        } else {\r\n\r\n            realAmount = self.rollbackAmountMapping[oid];\r\n\r\n            self.rollbackAmountMapping[oid] = 0;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function AppendingAmount(MainDB storage self, uint256 amount) internal {\r\n        self.assetAmountMapping[self.currentRID] \u002B= amount;\r\n    }\r\n\r\n\r\n    function AddAmountAndTryGetReward(MainDB storage self, address who, uint256 amount) internal returns (uint256 reward) {\r\n\r\n        require( amount \u003C= UINT_MAX );\r\n\r\n\r\n        self.currentRoundTempAmount \u002B= (amount * 30000 / 1000000);\r\n\r\n        self.investMapping[self.currentRID].push( Invest(who, now, amount) );\r\n\r\n\r\n        reward = amount * 5 / 100;\r\n        if ( self.rewardAmountTotal \u003E= reward ) {\r\n\r\n            self.rewardAmountTotal -= reward;\r\n\r\n        } else {\r\n\r\n            reward = self.rewardAmountTotal;\r\n            self.rewardAmountTotal = 0;\r\n        }\r\n    }\r\n\r\n\r\n    function SubAmount(MainDB storage self, uint256 rid, uint256 amount) internal {\r\n\r\n        require( amount \u003C= UINT_MAX );\r\n        require( BalanceOfRID(self, rid) \u003E= amount );\r\n\r\n        self.assetAmountMapping[rid] -= amount;\r\n    }\r\n\r\n\r\n    function winningThePrizeAtRID(MainDB storage self, uint256 rid, TokenAssetPool.MainDB storage userPool )\r\n    private\r\n    returns (\r\n        address[20] memory luckyOnes,\r\n        uint256[20] memory rewardAmounts\r\n    )\r\n    {\r\n        uint256 ridTotalAmount = self.assetAmountMapping[rid];\r\n        uint256 ridTotalAmountDelta = ridTotalAmount;\r\n\r\n        Invest[] storage _investList = self.investMapping[rid];\r\n\r\n\r\n        if ( _investList.length == 0 ) {\r\n\r\n            self.assetAmountMapping[rid] = 0;\r\n\r\n            self.assetAmountMapping[rid\u002B1] \u002B= ridTotalAmountDelta;\r\n\r\n            return (luckyOnes, rewardAmounts);\r\n        }\r\n\r\n\r\n        uint8[20] memory rewardsDescProps = [\r\n            50, /// desc 1\r\n            10,10,10,10, /// desc 2 - 5\r\n            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5 /// desc 6-20\r\n        ];\r\n\r\n\r\n        uint256 descIndex = 0;\r\n\r\n        for ( int li = int(_investList.length - 1); li \u003E= 0 \u0026\u0026 descIndex \u003C 20; li-- ) {\r\n\r\n            Invest storage invest = _investList[uint(li)];\r\n\r\n\r\n            bool exist = false;\r\n            for ( uint exid = 0; exid \u003C descIndex; exid \u002B\u002B ) {\r\n\r\n                if ( luckyOnes[exid] == invest.who ) {\r\n                    exist = true;\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n\r\n            if (exist) {\r\n                continue;\r\n            }\r\n\r\n\r\n            uint256 rewardAmount = invest.amount * rewardsDescProps[descIndex];\r\n\r\n\r\n            if ( descIndex == 0 \u0026\u0026 rewardAmount \u003E ridTotalAmount * 10 / 100 ) { /// desc 1\r\n\r\n                rewardAmount = ridTotalAmount * 10 / 100;\r\n\r\n            } else if ( descIndex \u003E= 1 \u0026\u0026 descIndex \u003C= 4 \u0026\u0026 rewardAmount \u003E ridTotalAmount * 5 / 100 ) { /// desc 2-5\r\n\r\n                rewardAmount = ridTotalAmount * 5 / 100;\r\n\r\n            } else if ( descIndex \u003E= 5 \u0026\u0026 rewardAmount \u003E ridTotalAmount * 2 / 100 ) {\r\n\r\n                rewardAmount = ridTotalAmount * 2 / 100;\r\n            }\r\n\r\n\r\n            if ( rewardAmount \u003C ridTotalAmountDelta ) {\r\n\r\n                userPool.AddAmount( invest.who, rewardAmount );\r\n                ridTotalAmountDelta -= rewardAmount;\r\n\r\n\r\n                luckyOnes[descIndex] = invest.who;\r\n                rewardAmounts[descIndex] = rewardAmount;\r\n                \u002B\u002BdescIndex;\r\n            }\r\n\r\n            else {\r\n\r\n                userPool.AddAmount( invest.who, ridTotalAmountDelta );\r\n                ridTotalAmountDelta = 0;\r\n\r\n                luckyOnes[descIndex] = invest.who;\r\n                rewardAmounts[descIndex] = ridTotalAmountDelta;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n        if ( ridTotalAmountDelta \u003E 0 ) {\r\n            self.rewardAmountTotal \u002B= ridTotalAmountDelta;\r\n        }\r\n\r\n\r\n        self.assetAmountMapping[rid] = 0;\r\n    }\r\n}\r\n\r\nlibrary OwnerAssetPool {\r\n\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    address constant OwnerAddress = address(0xD04C3c9eEC7BE36d28a925598B909954b4fd83cB);\r\n\r\n    struct MainDB {\r\n\r\n        ERC20Interface ERC20Inc;\r\n\r\n\r\n        uint256 currentRoundTempAmount;\r\n    }\r\n\r\n    function Init(MainDB storage self, ERC20Interface _erc20inc) internal {\r\n        self.ERC20Inc = _erc20inc;\r\n    }\r\n\r\n    function RoundTimeOutDelegate(MainDB storage self) internal {\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n    function RoundSuccessDelegate(MainDB storage self) internal {\r\n\r\n        self.ERC20Inc.transfer( OwnerAddress, self.currentRoundTempAmount );\r\n\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n\r\n    function AddAmount(MainDB storage self, uint256 amount) internal {\r\n\r\n        require( amount \u003C= UINT_MAX );\r\n\r\n        self.currentRoundTempAmount \u002B= (amount * 50000 / 1000000);\r\n    }\r\n\r\n}\r\n\r\nlibrary RoundController {\r\n\r\n    using TokenAssetPool for TokenAssetPool.MainDB;\r\n    using LevelMath for LevelMath.MainDB;\r\n    using DynamicMath for DynamicMath.MainDB;\r\n    using LuckAssetPool for LuckAssetPool.MainDB;\r\n    using OwnerAssetPool for OwnerAssetPool.MainDB;\r\n\r\n    struct Deposited {\r\n\r\n        address owner;\r\n\r\n        uint256 totalAmount;\r\n\r\n        uint256 latestDepositedTime;\r\n\r\n        bool autoReDepostied;\r\n\r\n        uint256 toOID;\r\n\r\n        uint256 totalStProfit;\r\n\r\n        uint256 totalDyProfit;\r\n\r\n        uint256 totalMrgProfit;\r\n    }\r\n\r\n    struct Round {\r\n\r\n        uint256 rid;\r\n\r\n        uint256 internalRoundID;\r\n\r\n        uint8 status;\r\n\r\n        uint256 totalAmount;\r\n\r\n        uint256 currentAmount;\r\n\r\n        uint256 createTime;\r\n\r\n        uint256 startTime;\r\n\r\n        uint256 endTime;\r\n\r\n        mapping(address =\u003E Deposited) depositedMapping;\r\n    }\r\n\r\n    struct MainDB {\r\n\r\n\r\n        uint256 newRIDInitProp;\r\n\r\n        RecommendInterface RCMINC;\r\n        ERC20Interface ERC20INC;\r\n\r\n        LuckAssetPool.MainDB luckAssetPool;\r\n        OwnerAssetPool.MainDB ownerAssetPool;\r\n        TokenAssetPool.MainDB userTokenPool;\r\n\r\n        Round[] roundList;\r\n\r\n\r\n        mapping(uint256 =\u003E address[]) autoRedepositAddressMapping;\r\n    }\r\n\r\n    event LogsToken(\r\n        address indexed owner,\r\n        uint256 when,\r\n        int256  amount,\r\n        uint256 indexed oid,\r\n        uint16 indexed typeID\r\n    );\r\n\r\n    event LogsAmount(\r\n        address indexed owner,\r\n        uint256 when,\r\n        int256  amount,\r\n        uint256 indexed oid,\r\n        uint16 indexed typeID\r\n    );\r\n\r\n    function InitFristRound(\r\n        MainDB storage self,\r\n        uint256 atTime,\r\n        RecommendInterface _rcminc,\r\n        ERC20Interface _erc20inc\r\n\r\n    ) internal returns (bool) {\r\n\r\n        if ( self.roundList.length \u003E 0 ) {\r\n            return false;\r\n        }\r\n\r\n        self.newRIDInitProp = 10;\r\n\r\n        self.RCMINC = _rcminc;\r\n\r\n        self.ERC20INC = _erc20inc;\r\n\r\n        self.ownerAssetPool.Init(_erc20inc);\r\n\r\n        self.roundList.push(\r\n            Round(\r\n                0,///rid\r\n                0,/// internalRoundID\r\n                1,/// status\r\n                1000 ether, /// totalAmount\r\n                0, /// currentAmount\r\n                atTime, /// createTime\r\n                atTime \u002B Times.OneDay() * 1, /// startTime\r\n                atTime \u002B Times.OneDay() * 8 /// endTime\r\n            )\r\n        );\r\n    }\r\n\r\n    function EnableAutoRedeposit(MainDB storage self, address owner, uint256 fromRoundIdx) internal returns (bool) {\r\n\r\n\r\n        if ( !(self.roundList[fromRoundIdx].status == 2 || self.roundList[fromRoundIdx].status == 3) ) {\r\n            return false;\r\n        }\r\n\r\n\r\n        Deposited storage ownerDepositedRecord = self.roundList[fromRoundIdx].depositedMapping[owner];\r\n\r\n\r\n        address[] storage autoAddresses = self.autoRedepositAddressMapping[fromRoundIdx];\r\n\r\n\r\n        if ( !ownerDepositedRecord.autoReDepostied ) {\r\n\r\n            ownerDepositedRecord.autoReDepostied = true;\r\n            autoAddresses.push(owner);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function TotalCount(MainDB storage self) internal view returns (uint256) {\r\n        return self.roundList.length;\r\n    }\r\n\r\n    function RoundAt(MainDB storage self, uint i) internal view returns (Round storage) {\r\n        require( i \u003E= 0 \u0026\u0026 i \u003C self.roundList.length );\r\n        return self.roundList[i];\r\n    }\r\n\r\n    function CurrentRound(MainDB storage self) internal view returns (Round storage r) {\r\n        return self.roundList[self.roundList.length - 1];\r\n    }\r\n\r\n    function CurrentRountOID(MainDB storage self) internal view returns (uint256) {\r\n        return self.roundList.length - 1;\r\n    }\r\n\r\n    function CurrentRoundIID(MainDB storage self) internal view returns (uint256) {\r\n        return CurrentRound(self).internalRoundID;\r\n    }\r\n\r\n    function CurrentRoundRID(MainDB storage self) internal view returns (uint256) {\r\n        return CurrentRound(self).rid;\r\n    }\r\n\r\n    function InternalRoundCount(MainDB storage self, uint256 oid) internal view returns (uint256) {\r\n\r\n        uint256 iid = self.roundList[oid].internalRoundID;\r\n\r\n        for ( uint i = oid \u002B 1; i \u003C self.roundList.length; i\u002B\u002B ) {\r\n            if ( self.roundList[i].internalRoundID - iid == 1 ) {\r\n                iid = self.roundList[i].internalRoundID;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return iid \u002B 1;\r\n    }\r\n\r\n    function CurrentRoundStatus(MainDB storage self) internal view returns (uint8) {\r\n\r\n        Round storage currRound = CurrentRound(self);\r\n\r\n        if ( currRound.status == 1 ) {\r\n\r\n            if ( now \u003E= currRound.startTime \u0026\u0026 now \u003C currRound.endTime ) {\r\n                return 2;\r\n            } else if ( now \u003E= currRound.endTime ) {\r\n                return 4;\r\n            }\r\n        }\r\n        else if ( currRound.status == 2 ) {\r\n\r\n            if ( now \u003E= currRound.endTime ) {\r\n                return 4;\r\n            }\r\n\r\n            if ( currRound.currentAmount \u003E= currRound.totalAmount ) {\r\n                return 3;\r\n            }\r\n        }\r\n\r\n        return currRound.status;\r\n    }\r\n\r\n    function UpdateRoundStatus(MainDB storage self) internal {\r\n\r\n        Round memory mRound = self.roundList[self.roundList.length - 1];\r\n        Round storage sRound = self.roundList[self.roundList.length - 1];\r\n\r\n        sRound.status = CurrentRoundStatus(self);\r\n\r\n        if ( mRound.status == 2 \u0026\u0026 sRound.status == 3 ) {\r\n\r\n            sRound.endTime = now;\r\n\r\n            if ( sRound.internalRoundID \u003E= 3 ) {\r\n                self.roundList[ self.roundList.length - 1 - 3 ].status = 5;\r\n            }\r\n\r\n        }\r\n        else if ( (mRound.status == 2 || mRound.status == 1) \u0026\u0026 sRound.status == 4 ) {\r\n\r\n            uint256 internalRoundCount = InternalRoundCount( self, self.roundList.length - 1 );\r\n            uint n = 0;\r\n            if ( internalRoundCount \u003E 4 ) {\r\n                n = internalRoundCount - 4;\r\n            }\r\n            for ( uint i = n; i \u003C self.roundList.length \u0026\u0026 i \u003C n \u002B 3; i\u002B\u002B ) {\r\n                self.roundList[i].status = 6;\r\n            }\r\n\r\n        }\r\n\r\n        CheckAndCreateNewRound(self);\r\n    }\r\n\r\n    function HasPriorityabPermission(MainDB storage self, address owner) internal view returns (bool) {\r\n\r\n        if ( self.roundList[self.roundList.length - 1].internalRoundID != 0 ||\r\n             self.roundList.length \u003C 3 ) {\r\n            return false;\r\n        }\r\n\r\n        for ( int i = int(self.roundList.length) - (1 \u002B 2); i \u003E= 0 \u0026\u0026 i \u003E int(self.roundList.length) - (1 \u002B 4); i-- ) {\r\n\r\n            Round storage r = self.roundList[uint(i)];\r\n\r\n            if ( r.status == 6 \u0026\u0026 r.depositedMapping[owner].totalAmount \u003E 0 ) {\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function DepositedToCurrentRound(MainDB storage self, address owner, uint256 amount, bool priorityab) internal returns (bool) {\r\n\r\n        UpdateRoundStatus(self);\r\n\r\n        Round storage currRound = CurrentRound(self);\r\n\r\n        if ( currRound.currentAmount \u002B amount \u003E currRound.totalAmount ) {\r\n\r\n            return false;\r\n\r\n        } else if ( currRound.status != 2 \u0026\u0026 !priorityab ) {\r\n\r\n            return false;\r\n        }\r\n\r\n        currRound.depositedMapping[owner].owner = owner;\r\n        currRound.depositedMapping[owner].totalAmount \u002B= amount;\r\n        currRound.depositedMapping[owner].latestDepositedTime = now;\r\n\r\n        currRound.currentAmount \u002B= amount;\r\n\r\n        self.ownerAssetPool.AddAmount( amount );\r\n\r\n        uint256 reward = self.luckAssetPool.AddAmountAndTryGetReward( owner, amount );\r\n        if ( reward \u003E 0 ) {\r\n\r\n            self.ERC20INC.transfer(owner, reward);\r\n\r\n            emit LogsToken(owner, now, int256(reward), CurrentRountOID(self), 7);\r\n        }\r\n\r\n        UpdateRoundStatus(self);\r\n\r\n        emit LogsToken(owner, now, -int256(amount), CurrentRountOID(self), 1);\r\n\r\n        return true;\r\n    }\r\n\r\n    function SettlementRoundOf(\r\n        MainDB storage self,\r\n        DynamicMath.MainDB storage DyMath,\r\n        LevelMath.MainDB storage LVMath,\r\n        address owner,\r\n        uint256 oid\r\n    )\r\n    internal\r\n    returns (\r\n        PESResponse memory rsp\r\n    ) {\r\n        UpdateRoundStatus(self);\r\n\r\n        Round storage settRound = RoundAt(self, oid);\r\n\r\n        Deposited storage depositedRecord = settRound.depositedMapping[owner];\r\n\r\n        require( depositedRecord.totalStProfit == 0 );\r\n\r\n        require( settRound.status == 4 || settRound.status == 5 || settRound.status == 6, \u0022RoundStatusExpection\u0022);\r\n\r\n        rsp = PreExecSettlementRoundOf(self, DyMath, LVMath, owner, oid );\r\n\r\n        uint256 maxProfitLimitDelta = depositedRecord.totalAmount * 120000 / 1000000;\r\n\r\n        depositedRecord.totalStProfit = rsp.originalAmount \u002B rsp.staticProfix;\r\n\r\n        for ( uint di = 0; di \u003C rsp.dyLen; di\u002B\u002B ) {\r\n\r\n            if ( rsp.dyAddrs[di] == address(0x0) || rsp.dyProfits[di] \u003C= 0 ) {\r\n                continue;\r\n            }\r\n\r\n            settRound.depositedMapping[rsp.dyAddrs[di]].totalDyProfit \u002B= rsp.dyProfits[di];\r\n\r\n            if ( maxProfitLimitDelta \u003C rsp.dyProfits[di] ) {\r\n                maxProfitLimitDelta = 0;\r\n            } else {\r\n                maxProfitLimitDelta -= rsp.dyProfits[di];\r\n            }\r\n\r\n            if ( rsp.dyProfits[di] \u003E 0 ) {\r\n\r\n                self.userTokenPool.AddAmount(rsp.dyAddrs[di], rsp.dyProfits[di]);\r\n\r\n                /// logs\r\n                emit LogsAmount(rsp.dyAddrs[di], now, int256(rsp.dyProfits[di]), oid, uint16(200 \u002B di));\r\n            }\r\n        }\r\n\r\n        for ( uint mi = 0; mi \u003C rsp.managerLen; mi\u002B\u002B ) {\r\n\r\n            if ( rsp.managers[mi] == address(0x0) || rsp.managers[mi] == address(0xFF) || rsp.managerProfits[mi] == 0 ) {\r\n                continue;\r\n            }\r\n\r\n            settRound.depositedMapping[rsp.managers[mi]].totalMrgProfit \u002B= rsp.managerProfits[mi];\r\n\r\n            if ( maxProfitLimitDelta \u003C rsp.managerProfits[mi] ) {\r\n                maxProfitLimitDelta = 0;\r\n            } else {\r\n                maxProfitLimitDelta -= rsp.managerProfits[mi];\r\n            }\r\n\r\n            self.userTokenPool.AddAmount(rsp.managers[mi], rsp.managerProfits[mi]);\r\n\r\n            /// logs\r\n            emit LogsAmount(rsp.managers[mi], now, int256(rsp.managerProfits[mi]), oid, uint16(300 \u002B mi));\r\n        }\r\n\r\n        if ( settRound.status == 5 ) {\r\n\r\n            self.luckAssetPool.AppendingAmount( maxProfitLimitDelta );\r\n\r\n            if ( !depositedRecord.autoReDepostied ) {\r\n\r\n                self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n                /// logs\r\n                emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 2);\r\n\r\n            } else {\r\n\r\n                Round storage targetRound = CurrentRound(self);\r\n\r\n                if ((targetRound.status == 1 || targetRound.status == 2) \u0026\u0026\r\n                    targetRound.totalAmount - targetRound.currentAmount \u003E= depositedRecord.totalStProfit ) {\r\n\r\n                    depositedRecord.toOID = self.roundList.length - 1;\r\n                    DepositedToCurrentRound(self, owner, depositedRecord.totalStProfit, true);\r\n\r\n                } else {\r\n\r\n                    self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n                    depositedRecord.toOID = 1;\r\n\r\n                    /// logs\r\n                    emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 2);\r\n                }\r\n            }\r\n        }\r\n        else if ( settRound.status == 4 ) {\r\n\r\n            uint256 rollbackLuckAmount = self.luckAssetPool.DoRollback( oid, depositedRecord.totalStProfit * 30000 / 1000000 );\r\n\r\n            self.ERC20INC.transfer(owner, depositedRecord.totalStProfit * 970000 / 1000000 \u002B rollbackLuckAmount );\r\n\r\n            /// logs\r\n            emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 5);\r\n\r\n        }\r\n        else if (settRound.status == 6 ) {\r\n\r\n            self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n            /// logs\r\n            emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 6);\r\n        }\r\n\r\n    }\r\n\r\n    struct PESResponse {\r\n        uint256 originalAmount;\r\n        uint256 staticProfix;\r\n        uint256 dyLen;\r\n        address [] dyAddrs;\r\n        uint256 [] dyProfits;\r\n        uint256 managerLen;\r\n        address [] managers;\r\n        uint256 [] managerProfits;\r\n    }\r\n    function PreExecSettlementRoundOf(\r\n        MainDB storage self,\r\n        DynamicMath.MainDB storage DyMath,\r\n        LevelMath.MainDB storage LVMath,\r\n        address owner,\r\n        uint256 oid\r\n    )\r\n    internal view\r\n    returns (PESResponse memory rsp) {\r\n\r\n        Round storage settRound = RoundAt(self, oid);\r\n        // Round storage currRound = CurrentRound(self);\r\n\r\n        uint internalCount = InternalRoundCount(self, oid);\r\n        Round memory settMaxRound = self.roundList[ oid \u002B (internalCount - settRound.internalRoundID - 1) ];\r\n\r\n        rsp.originalAmount = settRound.depositedMapping[owner].totalAmount;\r\n\r\n        // ProfitHandle(uint256 ir, bool irTimeoutable, uint256 n, uint256 ns) internal pure returns (uint256) {\r\n        uint256 nowAmount = StaticMath.ProfitHandle(\r\n            settMaxRound.internalRoundID,\r\n            (settMaxRound.status == 4),\r\n            settRound.internalRoundID,\r\n            rsp.originalAmount\r\n        );\r\n\r\n        if ( nowAmount \u003C rsp.originalAmount ) {\r\n            rsp.originalAmount = nowAmount;\r\n            return rsp;\r\n        }\r\n\r\n        rsp.staticProfix = nowAmount - rsp.originalAmount;\r\n\r\n        ( rsp.dyLen, rsp.dyAddrs, rsp.dyProfits ) = DyMath.ProfitHandle(\r\n            self,\r\n            DynamicMath.Request(\r\n                owner,\r\n                oid,\r\n                settRound.depositedMapping[owner].totalAmount,\r\n                rsp.staticProfix\r\n            )\r\n        );\r\n\r\n        (rsp.managerLen, rsp.managers, rsp.managerProfits) = LVMath.ProfitHandle( owner, oid, self.roundList.length, rsp.staticProfix );\r\n    }\r\n\r\n    function CheckAndCreateNewRound(MainDB storage self) internal {\r\n\r\n        Round memory latestRound = self.roundList[self.roundList.length - 1];\r\n\r\n        if ( latestRound.status == 3 ) {\r\n\r\n            if ( latestRound.endTime - latestRound.createTime \u003C 2 * Times.OneDay() ) {\r\n\r\n                self.roundList.push(\r\n                    Round(\r\n                        latestRound.rid,\r\n                        latestRound.internalRoundID \u002B 1,\r\n                        1, /// status\r\n                        ((latestRound.totalAmount * 130) / 100) / 1 ether * 1 ether, /// totalAmount\r\n                        0, /// currentAmount\r\n                        latestRound.createTime \u002B Times.OneDay() * 2, /// createTime\r\n                        latestRound.createTime \u002B Times.OneDay() * (2 \u002B 1), /// startTime\r\n                        latestRound.createTime \u002B Times.OneDay() * (2 \u002B 8) /// endTime\r\n                    )\r\n                );\r\n\r\n            } else {\r\n\r\n                self.roundList.push(\r\n                    Round(\r\n                        latestRound.rid, /// rid\r\n                        latestRound.internalRoundID \u002B 1, ///internalRoundID\r\n                        1, /// status\r\n                        ((latestRound.totalAmount * 130) / 100) / 1 ether * 1 ether, /// totalAmount\r\n                        0, /// currentAmount\r\n                        now, /// createTime\r\n                        now \u002B Times.OneDay() * 1, /// startTime\r\n                        now \u002B Times.OneDay() * 8 /// endTime\r\n                    )\r\n                );\r\n            }\r\n\r\n            self.luckAssetPool.RoundSuccessDelegate();\r\n            self.ownerAssetPool.RoundSuccessDelegate();\r\n        }\r\n        else if ( latestRound.status == 4 ) {\r\n\r\n            uint256 totalAmount = (latestRound.totalAmount - latestRound.currentAmount) * self.newRIDInitProp / 100;\r\n\r\n            if ( totalAmount \u003C 1000 ether ) {\r\n                totalAmount = 1000 ether;\r\n            }\r\n\r\n            self.roundList.push(\r\n                Round(\r\n                    latestRound.rid \u002B 1, /// rid\r\n                    0, /// internalRoundID\r\n                    1, /// status\r\n                    totalAmount / 1 ether * 1 ether, /// totalAmount\r\n                    0, /// currentAmount\r\n                    now, /// createTime\r\n                    now \u002B Times.OneDay() * 1, /// startTime\r\n                    now \u002B Times.OneDay() * 8 /// endTime\r\n                )\r\n            );\r\n\r\n            self.ownerAssetPool.RoundTimeOutDelegate();\r\n\r\n            (address[20] memory addrs, uint256[20] memory amounts) = self.luckAssetPool.RoundTimeOutDelegate( self.roundList.length - 2, self.userTokenPool );\r\n\r\n            for ( uint s = 0; s \u003C 20; s\u002B\u002B ) {\r\n                /// logs\r\n                if ( addrs[s] != address(0x0) \u0026\u0026 addrs[s] != address(0xFF) ) {\r\n                    emit LogsAmount( addrs[s], now, int(amounts[s]), self.roundList.length - 2, 100 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function PoolBalanceOf(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.userTokenPool.TotalAmount(owner);\r\n    }\r\n\r\n    function PoolWithdraw(MainDB storage self, address owner, uint256 amount) internal returns (bool) {\r\n\r\n        if (self.userTokenPool.TotalAmount(owner) \u003C amount ) {\r\n            return false;\r\n        }\r\n\r\n        self.userTokenPool.SubAmount(owner, amount);\r\n\r\n        self.ERC20INC.transfer(owner, amount - amount / 100);\r\n\r\n        self.ERC20INC.transfer(address(0xdead), amount / 100);\r\n\r\n        /// logs\r\n        emit LogsAmount( owner, now, -int256(amount), 0, 6 );\r\n\r\n        /// logs\r\n        emit LogsToken( owner, now, int(amount), 0, 6 );\r\n\r\n        return true;\r\n    }\r\n\r\n    function TotalDyAmountSum(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.userTokenPool.TotalSum(owner);\r\n    }\r\n}\r\n\r\n// File: contracts/MainContract.sol\r\ncontract MainContract is InternalModule {\r\n\r\n    RoundController.MainDB private _controller;\r\n    using RoundController for RoundController.MainDB;\r\n\r\n    DynamicMath.MainDB private _dyMath;\r\n    using DynamicMath for DynamicMath.MainDB;\r\n\r\n    LevelMath.MainDB private _levelMath;\r\n    using LevelMath for LevelMath.MainDB;\r\n\r\n    ERC20Interface public _Token;\r\n    RecommendInterface public _RCMINC;\r\n\r\n    uint256 public _depositMinLimit = 1 ether;\r\n\r\n\r\n    uint256 public _depositMaxLimitProp = 1;\r\n\r\n    constructor( RecommendInterface rinc, ERC20Interface tinc ) public {\r\n\r\n        _RCMINC = rinc;\r\n        _Token = tinc;\r\n\r\n        _controller.InitFristRound(now, rinc, _Token);\r\n        _dyMath.Init(rinc);\r\n        _levelMath.Init(rinc);\r\n    }\r\n\r\n    function CurrentAllowance() public view returns (uint256) {\r\n        return _Token.allowance(msg.sender, address(this));\r\n    }\r\n\r\n\r\n    function HasPriorityabPermission( address owner ) external view returns (bool) {\r\n        return _controller.HasPriorityabPermission(owner);\r\n    }\r\n\r\n\r\n    function DoDeposit( uint256 amount ) external DAODefense {\r\n\r\n\r\n        require( _RCMINC.GetIntroducer( msg.sender ) != address(0x0), \u0022-0\u0022 );\r\n\r\n\r\n        require( CurrentAllowance() \u003E= amount, \u0022-1\u0022 );\r\n\r\n\r\n        require( amount % 0.001 ether == 0 );\r\n\r\n\r\n        RoundController.Round storage currRound = _controller.CurrentRound();\r\n        if ( currRound.totalAmount - currRound.currentAmount \u003E 1 ether ) {\r\n            require( amount \u003E= _depositMinLimit, \u0022Less then minlimit.\u0022 );\r\n        }\r\n\r\n\r\n        require( amount \u003C= currRound.totalAmount - currRound.currentAmount, \u0022-2\u0022 );\r\n\r\n\r\n        require( currRound.depositedMapping[msg.sender].totalAmount \u002B amount \u003C= currRound.totalAmount * _depositMaxLimitProp / 100, \u0022-3\u0022 );\r\n\r\n\r\n        require( _Token.transferFrom( msg.sender, address(this), amount ), \u0022-4\u0022 );\r\n\r\n\r\n        bool hasPriorityab = _controller.HasPriorityabPermission(msg.sender);\r\n\r\n\r\n        require( _controller.DepositedToCurrentRound(msg.sender, amount, hasPriorityab), \u0022-5\u0022 );\r\n\r\n\r\n        _levelMath.AddAchievement(msg.sender, _controller.CurrentRountOID(), amount );\r\n\r\n\r\n        if ( amount \u003E= 10 ether ) {\r\n            _RCMINC.API_MakeAddressToValid(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function DoSettlement( uint256 oid )\r\n    external DAODefense\r\n    returns (\r\n        uint256 originalAmount,\r\n        uint256 staticProfix,\r\n        address [] memory dyAddrs,\r\n        uint256 [] memory dyProfits,\r\n        address [] memory managers,\r\n        uint256 [] memory managerProfits\r\n    ) {\r\n\r\n        RoundController.PESResponse memory rsp = _controller.SettlementRoundOf(\r\n            _dyMath,\r\n            _levelMath,\r\n            msg.sender,\r\n            oid\r\n        );\r\n\r\n        return (\r\n            rsp.originalAmount,\r\n            rsp.staticProfix,\r\n            rsp.dyAddrs,\r\n            rsp.dyProfits,\r\n            rsp.managers,\r\n            rsp.managerProfits\r\n        );\r\n    }\r\n\r\n    function RoundTotalCount() external view returns (uint256) {\r\n        return _controller.TotalCount();\r\n    }\r\n\r\n    function RoundStatusAt( uint256 oid ) external view returns (\r\n        /// inside round id\r\n        uint256 iid,\r\n\r\n        uint8 status,\r\n\r\n        uint256 totalAmount,\r\n\r\n        uint256 currentAmount,\r\n\r\n        uint256 createTime,\r\n\r\n        uint256 startTime,\r\n\r\n        uint256 endTime\r\n    ) {\r\n        uint256 id = oid;\r\n\r\n        RoundController.Round memory round;\r\n\r\n        if ( id \u003E= _controller.TotalCount() ) {\r\n            id = _controller.CurrentRountOID();\r\n        }\r\n\r\n        round = _controller.RoundAt(id);\r\n\r\n        if ( id == _controller.CurrentRountOID() ) {\r\n            status = _controller.CurrentRoundStatus();\r\n        } else {\r\n            status = round.status;\r\n        }\r\n\r\n        iid = round.internalRoundID;\r\n        totalAmount = round.totalAmount;\r\n        currentAmount = round.currentAmount;\r\n        createTime = round.createTime;\r\n        startTime = round.startTime;\r\n        endTime = round.endTime;\r\n    }\r\n\r\n    function EnableAutoRedepostied( uint256 oid ) external {\r\n        require( _controller.EnableAutoRedeposit( msg.sender, oid ) );\r\n    }\r\n\r\n    function DepositedRoundOIDS( address owner ) public view returns (uint256[] memory ids, uint256 len) {\r\n\r\n        uint256[] memory tempIds = new uint256[](_controller.TotalCount());\r\n\r\n        len = 0;\r\n\r\n        for (uint i = 0; i \u003C _controller.TotalCount(); i\u002B\u002B ) {\r\n            if ( _controller.RoundAt(i).depositedMapping[owner].owner == owner ) {\r\n                tempIds[len\u002B\u002B] = i;\r\n            }\r\n        }\r\n\r\n        if (len == 0) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        ids = new uint256[](len);\r\n        for ( uint256 si = 0; si \u003C len; si\u002B\u002B ) {\r\n            ids[si] = tempIds[si];\r\n        }\r\n\r\n    }\r\n\r\n    function DepositedInfo( address owner, uint256 oid ) external view returns (\r\n\r\n        uint256 statuse,\r\n\r\n        uint256 totalAmount,\r\n\r\n        uint256 latestDepositedTime,\r\n\r\n        bool autoReDepostied,\r\n\r\n        uint256 redepositedToOID,\r\n\r\n        uint256 totalStProfit,\r\n\r\n        uint256 totalDyProfit,\r\n\r\n        uint256 totalMrgProfit,\r\n\r\n        uint256 lv\r\n    ) {\r\n        require (oid \u003C _controller.TotalCount() );\r\n\r\n        RoundController.Round storage r = _controller.RoundAt(oid);\r\n        RoundController.Deposited memory d = r.depositedMapping[owner];\r\n\r\n        statuse = r.status;\r\n        totalAmount = d.totalAmount;\r\n        latestDepositedTime = d.latestDepositedTime;\r\n        autoReDepostied = d.autoReDepostied;\r\n        totalStProfit = d.totalStProfit;\r\n        totalDyProfit = d.totalDyProfit;\r\n        totalMrgProfit = d.totalMrgProfit;\r\n        redepositedToOID = d.toOID;\r\n        lv = _levelMath.CurrentLevelOf(owner, oid, _controller.TotalCount());\r\n    }\r\n\r\n    function CurrentDepositedTotalCount(address owner) external view returns (uint256 total) {\r\n\r\n        (uint256[] memory allIDS, uint256 len) = DepositedRoundOIDS(owner);\r\n\r\n        for ( uint i = 0; i \u003C len; i\u002B\u002B ) {\r\n\r\n            RoundController.Deposited memory d = _controller.RoundAt(allIDS[i]).depositedMapping[owner];\r\n\r\n            if ( d.totalStProfit == 0 ) {\r\n                total \u002B= d.totalAmount;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /// About LuckAsset Pool\r\n    using LuckAssetPool for LuckAssetPool.MainDB;\r\n    function BalanceOfLuckAssetPoolAtRID(uint256 rid) external view returns (uint256 ridTotal, uint256 rewardTotal) {\r\n\r\n        uint i = rid;\r\n\r\n        if ( rid \u003E _controller.CurrentRoundRID() ) {\r\n            i = _controller.CurrentRoundRID();\r\n        }\r\n\r\n        return (_controller.luckAssetPool.BalanceOfRID(i), _controller.luckAssetPool.rewardAmountTotal);\r\n    }\r\n\r\n    function PoolBalanceOf(address owner) external view returns (uint256) {\r\n        return _controller.PoolBalanceOf(owner);\r\n    }\r\n\r\n    function PoolWithdraw(uint256 amount) external DAODefense {\r\n        require( _controller.PoolWithdraw(msg.sender, amount) );\r\n    }\r\n\r\n    function TotalDyAmountSum(address owner) external view returns (uint256) {\r\n        return _controller.TotalDyAmountSum(owner);\r\n    }\r\n\r\n    function Owner_SetDepositedMinLimit(uint256 a) external OwnerOnly {\r\n\r\n        require(a \u003E 0.001 ether);\r\n\r\n        _depositMinLimit = a;\r\n    }\r\n\r\n    function Owner_SetDepositedMaxLimitProp(uint256 a) external OwnerOnly {\r\n\r\n        require( a \u003C= 100 );\r\n\r\n        _depositMaxLimitProp = a;\r\n    }\r\n\r\n    function Owner_UpdateRoundStatus() external OwnerOnly {\r\n        _controller.UpdateRoundStatus();\r\n    }\r\n\r\n    function Owner_SetNewRIDProp(uint256 p) external OwnerOnly {\r\n        _controller.newRIDInitProp = p;\r\n    }\r\n\r\n    function Dev_QueryAchievement(address owner, uint256 oid) external view returns (uint256) {\r\n        return _levelMath.achievementMapping[oid][owner];\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_RCMINC\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022CurrentDepositedTotalCount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022total\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022oid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Dev_QueryAchievement\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022a\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Owner_SetDepositedMaxLimitProp\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_depositMaxLimitProp\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022a\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Owner_SetDepositedMinLimit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022HasPriorityabPermission\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022DoDeposit\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022rid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022BalanceOfLuckAssetPoolAtRID\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022ridTotal\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rewardTotal\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022oid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RoundStatusAt\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022iid\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022name\u0022:\u0022totalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022currentAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022createTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022startTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022endTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022_contractOwners\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022Owner_UpdateRoundStatus\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022PoolWithdraw\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022RoundTotalCount\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022AddAuthAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022TotalDyAmountSum\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022AuthAddresses\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022authAddr\u0022,\u0022type\u0022:\u0022address[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_depositMinLimit\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022oid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022EnableAutoRedepostied\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022oid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022DoSettlement\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022originalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022staticProfix\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022dyAddrs\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022dyProfits\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022managers\u0022,\u0022type\u0022:\u0022address[]\u0022},{\u0022name\u0022:\u0022managerProfits\u0022,\u0022type\u0022:\u0022uint256[]\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022CurrentAllowance\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022oid\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022DepositedInfo\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022statuse\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022latestDepositedTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022autoReDepostied\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022redepositedToOID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalStProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalDyProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022totalMrgProfit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022lv\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022p\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Owner_SetNewRIDProp\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_defaultReciver\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022_Token\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022DepositedRoundOIDS\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022ids\u0022,\u0022type\u0022:\u0022uint256[]\u0022},{\u0022name\u0022:\u0022len\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022PoolBalanceOf\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022DelAuthAddress\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022rinc\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tinc\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022}]","ContractName":"MainContract","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bd2aa67529d597d0910d1fbcc5b195271053e467000000000000000000000000c6cc22f88edae6667763f7745d4ecd297d535540","Library":"Times:ae71fd6a94ff89f53d00cc9cb617bbb95b0e71ad","SwarmSource":"bzzr://e69bf3fbe12f60a6837416c5c1a771f6422a9d3f697f417d79b5104dcbaa0719"}]