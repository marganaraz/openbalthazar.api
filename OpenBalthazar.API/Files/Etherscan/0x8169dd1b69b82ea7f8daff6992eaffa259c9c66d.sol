[{"SourceCode":"{\u0022HashedTimelockGXC.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.2;\\n\\nimport \\\u0022./IHashedTimelock.sol\\\u0022;\\nimport \\\u0022./Ownable.sol\\\u0022;\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\ncontract HashedTimelockGXC is IHashedTimelock {\\n    struct Htlc {\\n        address sender;\\n        address recipient;\\n        address tokenContract;\\n        uint amount;\\n        bytes32 hashlock;\\n        uint timelock;\\n        bool withdrawn;\\n        bool refunded;\\n        bytes32 preimage;\\n        bytes32 data;\\n    }\\n\\n    struct Config {\\n        address target;\\n        uint minAmount;\\n        uint minDuration;\\n    }\\n\\n    mapping(bytes32 =\\u003e Htlc) internal contracts;\\n    mapping(address =\\u003e Config) internal configs;\\n\\n    event LogHtlcNew(\\n        bytes32 indexed contractId,\\n        address sender,\\n        address recipient,\\n        address tokenContract,\\n        uint amount,\\n        bytes32 hashlock,\\n        uint timelock,\\n        bytes32 indexed data\\n    );\\n    event LogHtlcWithdraw(bytes32 indexed contractId);\\n    event LogHtlcRefund(bytes32 indexed contractId);\\n\\n    modifier configured(address tokenContract) {\\n        require(configs[tokenContract].target != address(0x0), \\\u0022not configured\\\u0022);\\n        _;\\n    }\\n\\n    function getConfig(address tokenContract) external view returns (address, uint, uint) {\\n        if (configs[tokenContract].target == address(0x0))\\n            return (address(0x0), 0, 0);\\n        return (configs[tokenContract].target, configs[tokenContract].minAmount, configs[tokenContract].minDuration);\\n    }\\n\\n    function setConfig(address tokenContract, address target, uint minAmount, uint minDuration) external {\\n        require(address(msg.sender) == Ownable(tokenContract).owner(), \\\u0022msg.sender must be token owner\\\u0022);\\n\\n        configs[tokenContract].target = target;\\n        configs[tokenContract].minAmount = minAmount;\\n        configs[tokenContract].minDuration = minDuration;\\n    }\\n\\n    modifier contractExists(bytes32 contractId) {\\n        require(haveContract(contractId), \\\u0022contractId does not exist\\\u0022);\\n        _;\\n    }\\n\\n    modifier hashlockMatches(bytes32 contractId, bytes32 preimage) {\\n        require(contracts[contractId].hashlock == sha256(abi.encodePacked(preimage)), \\\u0022hashlock does not match\\\u0022);\\n        _;\\n    }\\n\\n    modifier withdrawable(bytes32 contractId) {\\n        require(contracts[contractId].withdrawn == false, \\\u0022withdrawable: already withdrawn\\\u0022);\\n        require(contracts[contractId].timelock \\u003e now, \\\u0022withdrawable: timelock is expired\\\u0022);\\n        _;\\n    }\\n\\n    modifier refundable(bytes32 contractId) {\\n        require(contracts[contractId].refunded == false, \\\u0022refundable: already refunded\\\u0022);\\n        require(contracts[contractId].withdrawn == false, \\\u0022refundable: already withdrawn\\\u0022);\\n        require(contracts[contractId].timelock \\u003c= now, \\\u0022refundable: timelock not yet passed\\\u0022);\\n        _;\\n    }\\n\\n    function newContract(\\n        address recipient,\\n        address tokenContract,\\n        uint amount,\\n        bytes32 hashlock,\\n        uint timelock,\\n        bytes32 data\\n    )\\n        external\\n        configured(tokenContract)\\n        returns (bytes32 contractId)\\n    {\\n        Config storage c = configs[tokenContract];\\n\\n        // workaround fix \u0060Stack too deep\u0060, direct insert instead of separated modifier\\n\\n        // transferable\\n        require(amount \\u003e= c.minAmount, \\\u0022token amount must be greater than configured minAmount\\\u0022);\\n        require(IERC20(tokenContract).allowance(msg.sender, address(this)) \\u003e= amount, \\\u0022token allowance must be equal or greater than amount\\\u0022);\\n\\n        // hasEnoughDuration\\n        uint minDuration = (msg.sender == c.target) ? 0 : c.minDuration;\\n        require(timelock \\u003e= now \u002B minDuration, \\\u0022timelock expiration is too early\\\u0022);\\n\\n        // onlyTarget\\n        require(recipient == c.target || msg.sender == c.target, \\\u0022invalid target\\\u0022);\\n\\n        contractId = sha256(abi.encodePacked(msg.sender, recipient, tokenContract, amount, hashlock, timelock, data));\\n\\n        require(!haveContract(contractId), \\\u0022contractId already exists\\\u0022);\\n        require(IERC20(tokenContract).transferFrom(msg.sender, address(this), amount), \\\u0022failed to transfer token from msg.sender\\\u0022);\\n\\n        contracts[contractId] = Htlc(msg.sender, recipient, tokenContract, amount, hashlock, timelock, false, false, 0x0, data);\\n        emit LogHtlcNew(contractId, msg.sender, recipient, tokenContract, amount, hashlock, timelock, data);\\n    }\\n\\n    function withdraw(bytes32 contractId, bytes32 preimage)\\n        external\\n        contractExists(contractId)\\n        hashlockMatches(contractId, preimage)\\n        withdrawable(contractId)\\n        returns (bool)\\n    {\\n        Htlc storage c = contracts[contractId];\\n        c.preimage = preimage;\\n        c.withdrawn = true;\\n        IERC20(c.tokenContract).transfer(c.recipient, c.amount);\\n        emit LogHtlcWithdraw(contractId);\\n        return true;\\n    }\\n\\n    function refund(bytes32 contractId)\\n        external\\n        contractExists(contractId)\\n        refundable(contractId)\\n        returns (bool)\\n    {\\n        Htlc storage c = contracts[contractId];\\n        c.refunded = true;\\n        IERC20(c.tokenContract).transfer(c.sender, c.amount);\\n        emit LogHtlcRefund(contractId);\\n        return true;\\n    }\\n\\n    function getContract(bytes32 contractId)\\n        public\\n        view\\n        returns (\\n            address sender,\\n            address recipient,\\n            address tokenContract,\\n            uint amount,\\n            bytes32 hashlock,\\n            uint timelock,\\n            bool withdrawn,\\n            bool refunded,\\n            bytes32 preimage,\\n            bytes32 data\\n        )\\n    {\\n        if (haveContract(contractId) == false)\\n            return (address(0x0), address(0x0), address(0x0), 0, 0, 0, false, false, 0x0, 0x0);\\n        Htlc storage c = contracts[contractId];\\n        return (c.sender, c.recipient, c.tokenContract, c.amount, c.hashlock, c.timelock, c.withdrawn, c.refunded, c.preimage, c.data);\\n    }\\n\\n    function haveContract(bytes32 contractId) public view returns (bool exists) {\\n        exists = (contracts[contractId].sender != address(0x0));\\n    }\\n}\\n\u0022},\u0022IHashedTimelock.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.2;\\n\\ninterface IHashedTimelock {\\n    function newContract(\\n        address recipient,\\n        address tokenContract,\\n        uint amount,\\n        bytes32 hashlock,\\n        uint timelock,\\n        bytes32 data\\n    ) external returns (bytes32);\\n\\n    function withdraw(bytes32 contractId, bytes32 preimage) external returns (bool);\\n\\n    function refund(bytes32 contractId) external returns (bool);\\n}\\n\u0022},\u0022Ownable.sol\u0022:{\u0022content\u0022:\u0022pragma solidity ^0.5.2;\\n\\ncontract Ownable {\\n  address public owner;\\n  address public admin;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev The Ownable constructor sets the original \u0060owner\u0060 of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  modifier onlyOwnerOrAdmin() {\\n    require(msg.sender != address(0) \\u0026\\u0026 (msg.sender == owner || msg.sender == admin));\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) onlyOwner public {\\n    require(newOwner != address(0));\\n    require(newOwner != owner);\\n    require(newOwner != admin);\\n\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n  function setAdmin(address newAdmin) onlyOwner public {\\n    require(admin != newAdmin);\\n    require(owner != newAdmin);\\n\\n    admin = newAdmin;\\n  }\\n}\\n\u0022}}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022haveContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022exists\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022preimage\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022withdraw\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022refund\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022tokenContract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022target\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022minAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022minDuration\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setConfig\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022getContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tokenContract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022hashlock\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022timelock\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022withdrawn\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022refunded\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022name\u0022:\u0022preimage\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022tokenContract\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getConfig\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022tokenContract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022hashlock\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022timelock\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022newContract\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022recipient\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022tokenContract\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022hashlock\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022timelock\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022data\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022LogHtlcNew\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022LogHtlcWithdraw\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022contractId\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022LogHtlcRefund\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"HashedTimelockGXC","CompilerVersion":"v0.5.2\u002Bcommit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://05be4286a42cd44600dd9a95cf427785fbecd966371daff0e9099e0a1e16a573"}]