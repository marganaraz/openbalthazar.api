[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface TimelockerModifiersInterface {\r\n  function initiateModifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval, uint256 extraTime\r\n  ) external;\r\n\r\n  function modifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) external;\r\n\r\n  function initiateModifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration, uint256 extraTime\r\n  ) external;\r\n\r\n  function modifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a \u002B b;\r\n    require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call \u0060acceptOwnership\u0060 and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initialize contract by setting transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \u0022TwoStepOwnable: caller is not the owner.\u0022);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a new account (\u0060newOwner\u0060) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \u0022TwoStepOwnable: new potential owner is the zero address.\u0022\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() public onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() public {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \u0022TwoStepOwnable: current owner must set caller as new potential owner.\u0022\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Timelocker\r\n * @author 0age\r\n * @notice This contract allows contracts that inherit it to implement timelocks\r\n * on functions, where the \u0060_setTimelock\u0060 internal function must first be called\r\n * and passed the target function selector and arguments. Then, a given time\r\n * interval must first fully transpire before the timelock functions can be\r\n * successfully called. Furthermore, once a timelock is complete, it will expire\r\n * after a period of time. In order to change timelock intervals or expirations,\r\n * the inheriting contract needs to implement \u0060modifyTimelockInterval\u0060 and\r\n * \u0060modifyTimelockExpiration\u0060 functions, respectively, as well as functions that\r\n * call \u0060_setTimelock\u0060 in order to initiate the timelocks for those functions.\r\n * To make a function timelocked, use the \u0060_enforceTimelock\u0060 internal function.\r\n * To set initial defult minimum timelock intervals and expirations, use the\r\n * \u0060_setInitialTimelockInterval\u0060 and \u0060_setInitialTimelockExpiration\u0060 internal\r\n * functions - they can only be used during contract creation. Finally, there\r\n * are three public getters: \u0060getTimelock\u0060, \u0060getDefaultTimelockInterval\u0060, and\r\n * \u0060getDefaultTimelockExpiration\u0060.\r\n */\r\ncontract Timelocker {\r\n  using SafeMath for uint256;\r\n\r\n  // Fire an event any time a timelock is initiated.\r\n  event TimelockInitiated(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 timeComplete,    // timestamp at which the function can be called\r\n    bytes arguments,         // abi-encoded function arguments to call with\r\n    uint256 timeExpired      // timestamp where function can no longer be called\r\n  );\r\n\r\n  // Fire an event any time a minimum timelock interval is modified.\r\n  event TimelockIntervalModified(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 oldInterval,     // old minimum timelock interval for the function\r\n    uint256 newInterval      // new minimum timelock interval for the function\r\n  );\r\n\r\n  // Fire an event any time a default timelock expiration is modified.\r\n  event TimelockExpirationModified(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 oldExpiration,   // old default timelock expiration for the function\r\n    uint256 newExpiration    // new default timelock expiration for the function\r\n  );\r\n\r\n  // Each timelock has timestamps for when it is complete and when it expires.\r\n  struct Timelock {\r\n    uint128 complete;\r\n    uint128 expires;\r\n  }\r\n\r\n  // Functions have a timelock interval and time from completion to expiration.\r\n  struct TimelockDefaults {\r\n    uint128 interval;\r\n    uint128 expiration;\r\n  }\r\n\r\n  // Implement a timelock for each function and set of arguments.\r\n  mapping(bytes4 =\u003E mapping(bytes32 =\u003E Timelock)) private _timelocks;\r\n\r\n  // Implement default timelock intervals and expirations for each function.\r\n  mapping(bytes4 =\u003E TimelockDefaults) private _timelockDefaults;\r\n\r\n  // Only allow one new interval or expiration change at a time per function.\r\n  mapping(bytes4 =\u003E mapping(bytes4 =\u003E bytes32)) private _protectedTimelockIDs;\r\n\r\n  // Store modifyTimelockInterval function selector as a constant.\r\n  bytes4 private constant _MODIFY_TIMELOCK_INTERVAL_SELECTOR = bytes4(\r\n    0xe950c085\r\n  );\r\n\r\n  // Store modifyTimelockExpiration function selector as a constant.\r\n  bytes4 private constant _MODIFY_TIMELOCK_EXPIRATION_SELECTOR = bytes4(\r\n    0xd7ce3c6f\r\n  );\r\n\r\n  // Set a ridiculously high duration in order to protect against overflows.\r\n  uint256 private constant _A_TRILLION_YEARS = 365000000000000 days;\r\n\r\n  /**\r\n   * @notice In the constructor, confirm that selectors specified as constants\r\n   * are correct.\r\n   */\r\n  constructor() internal {\r\n    TimelockerModifiersInterface modifiers;\r\n\r\n    bytes4 targetModifyInterval = modifiers.modifyTimelockInterval.selector;\r\n    require(\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR == targetModifyInterval,\r\n      \u0022Incorrect modify timelock interval selector supplied.\u0022\r\n    );\r\n\r\n    bytes4 targetModifyExpiration = modifiers.modifyTimelockExpiration.selector;\r\n    require(\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR == targetModifyExpiration,\r\n      \u0022Incorrect modify timelock expiration selector supplied.\u0022\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check if a timelock for the specified function and\r\n   * arguments has completed.\r\n   * @param functionSelector function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @return A boolean indicating if the timelock exists or not and the time at\r\n   * which the timelock completes if it does exist.\r\n   */\r\n  function getTimelock(\r\n    bytes4 functionSelector, bytes memory arguments\r\n  ) public view returns (\r\n    bool exists,\r\n    bool completed,\r\n    bool expired,\r\n    uint256 completionTime,\r\n    uint256 expirationTime\r\n  ) {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get information on the current timelock, if one exists.\r\n    completionTime = uint256(_timelocks[functionSelector][timelockID].complete);\r\n    exists = completionTime != 0;\r\n    expirationTime = uint256(_timelocks[functionSelector][timelockID].expires);\r\n    completed = exists \u0026\u0026 now \u003E completionTime;\r\n    expired = exists \u0026\u0026 now \u003E expirationTime;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the current minimum timelock interval on a\r\n   * given function.\r\n   * @param functionSelector function to retrieve the timelock interval for.\r\n   * @return The current minimum timelock interval for the given function.\r\n   */\r\n  function getDefaultTimelockInterval(\r\n    bytes4 functionSelector\r\n  ) public view returns (uint256 defaultTimelockInterval) {\r\n    defaultTimelockInterval = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the current default timelock expiration on a\r\n   * given function.\r\n   * @param functionSelector function to retrieve the timelock expiration for.\r\n   * @return The current default timelock expiration for the given function.\r\n   */\r\n  function getDefaultTimelockExpiration(\r\n    bytes4 functionSelector\r\n  ) public view returns (uint256 defaultTimelockExpiration) {\r\n    defaultTimelockExpiration = uint256(\r\n      _timelockDefaults[functionSelector].expiration\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function that sets a timelock so that the specified\r\n   * function can be called with the specified arguments. Note that existing\r\n   * timelocks may be extended, but not shortened - this can also be used as a\r\n   * method for \u0022cancelling\u0022 a function call by extending the timelock to an\r\n   * arbitrarily long duration. Keep in mind that new timelocks may be created\r\n   * with a shorter duration on functions that already have other timelocks on\r\n   * them, but only if they have different arguments.\r\n   * @param functionSelector selector of the function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @param extraTime Additional time in seconds to add to the minimum timelock\r\n   * interval for the given function.\r\n   */\r\n  function _setTimelock(\r\n    bytes4 functionSelector, bytes memory arguments, uint256 extraTime\r\n  ) internal {\r\n    // Ensure that the specified extra time will not cause an overflow error.\r\n    require(extraTime \u003C _A_TRILLION_YEARS, \u0022Supplied extra time is too large.\u0022);\r\n\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // For timelock interval or expiration changes, first drop any existing\r\n    // timelock for the function being modified if the argument has changed.\r\n    if (\r\n      functionSelector == _MODIFY_TIMELOCK_INTERVAL_SELECTOR ||\r\n      functionSelector == _MODIFY_TIMELOCK_EXPIRATION_SELECTOR\r\n    ) {\r\n      // Determine the function that will be modified by the timelock.\r\n      (bytes4 modifiedFunction, uint256 duration) = abi.decode(\r\n        arguments, (bytes4, uint256)\r\n      );\r\n\r\n      // Ensure that the new timelock duration will not cause an overflow error.\r\n      require(\r\n        duration \u003C _A_TRILLION_YEARS,\r\n        \u0022Supplied default timelock duration to modify is too large.\u0022\r\n      );\r\n\r\n      // Determine the current timelockID, if any, for the modified function.\r\n      bytes32 currentTimelockID = (\r\n        _protectedTimelockIDs[functionSelector][modifiedFunction]\r\n      );\r\n\r\n      // Determine if current timelockID differs from what is currently set.\r\n      if (currentTimelockID != timelockID) {\r\n        // Drop existing timelock if one exists and has a different timelockID.\r\n        if (currentTimelockID != bytes32(0)) {\r\n          delete _timelocks[functionSelector][currentTimelockID];\r\n        }\r\n\r\n        // Register the new timelockID as the current protected timelockID.\r\n        _protectedTimelockIDs[functionSelector][modifiedFunction] = timelockID;\r\n      }\r\n    }\r\n\r\n    // Get timelock using current time, inverval for timelock ID, \u0026 extra time.\r\n    uint256 timelock = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    ).add(now).add(extraTime);\r\n\r\n    // Get expiration time using timelock duration plus default expiration time.\r\n    uint256 expiration = timelock.add(\r\n      uint256(_timelockDefaults[functionSelector].expiration)\r\n    );\r\n\r\n    // Get the current timelock, if one exists.\r\n    Timelock storage timelockStorage = _timelocks[functionSelector][timelockID];\r\n\r\n    // Determine the duration of the current timelock.\r\n    uint256 currentTimelock = uint256(timelockStorage.complete);\r\n\r\n    // Ensure that the timelock duration does not decrease. Note that a new,\r\n    // shorter timelock may still be set up on the same function in the event\r\n    // that it is provided with different arguments. Also note that this can be\r\n    // circumvented when modifying intervals or expirations by setting a new\r\n    // timelock (removing the old one), then resetting the original timelock but\r\n    // with a shorter duration.\r\n    require(\r\n      currentTimelock == 0 || timelock \u003E currentTimelock,\r\n      \u0022Existing timelocks may only be extended.\u0022\r\n    );\r\n\r\n    // Set timelock completion and expiration using timelock ID and extra time.\r\n    timelockStorage.complete = uint128(timelock);\r\n    timelockStorage.expires = uint128(expiration);\r\n\r\n    // Emit an event with all of the relevant information.\r\n    emit TimelockInitiated(functionSelector, timelock, arguments, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting a new timelock interval for a given\r\n   * function selector. The default for this function may also be modified, but\r\n   * excessive values will cause the \u0060modifyTimelockInterval\u0060 function to become\r\n   * unusable.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _modifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) internal {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelockPrivate(\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR,\r\n      abi.encode(functionSelector, newTimelockInterval)\r\n    );\r\n\r\n    // Clear out the existing timelockID protection for the given function.\r\n    delete _protectedTimelockIDs[\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR\r\n    ][functionSelector];\r\n\r\n    // Set new timelock interval and emit a \u0060TimelockIntervalModified\u0060 event.\r\n    _setTimelockIntervalPrivate(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting a new timelock expiration for a given\r\n   * function selector. Once the minimum interval has elapsed, the timelock will\r\n   * expire once the specified expiration time has elapsed. Setting this value\r\n   * too low will result in timelocks that are very difficult to execute\r\n   * correctly. Be sure to override the public version of this function with\r\n   * appropriate access controls.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration the new minimum timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _modifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) internal {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelockPrivate(\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR,\r\n      abi.encode(functionSelector, newTimelockExpiration)\r\n    );\r\n\r\n    // Clear out the existing timelockID protection for the given function.\r\n    delete _protectedTimelockIDs[\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR\r\n    ][functionSelector];\r\n\r\n    // Set new default expiration and emit a \u0060TimelockExpirationModified\u0060 event.\r\n    _setTimelockExpirationPrivate(functionSelector, newTimelockExpiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an initial timelock interval for a given\r\n   * function selector. Only callable during contract creation.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setInitialTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Set the timelock interval and emit a \u0060TimelockIntervalModified\u0060 event.\r\n    _setTimelockIntervalPrivate(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an initial timelock expiration for a given\r\n   * function selector. Only callable during contract creation.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration the new minimum timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _setInitialTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Set the timelock interval and emit a \u0060TimelockExpirationModified\u0060 event.\r\n    _setTimelockExpirationPrivate(functionSelector, newTimelockExpiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to ensure that a timelock is complete or expired\r\n   * and to clear the existing timelock if it is complete so it cannot later be\r\n   * reused. The function to enforce the timelock on is inferred from \u0060msg.sig\u0060.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   */\r\n  function _enforceTimelock(bytes memory arguments) internal {\r\n    // Enforce the relevant timelock.\r\n    _enforceTimelockPrivate(msg.sig, arguments);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to ensure that a timelock is complete or expired\r\n   * and to clear the existing timelock if it is complete so it cannot later be\r\n   * reused.\r\n   * @param functionSelector function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   */\r\n  function _enforceTimelockPrivate(\r\n    bytes4 functionSelector, bytes memory arguments\r\n  ) private {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get the current timelock, if one exists.\r\n    Timelock memory timelock = _timelocks[functionSelector][timelockID];\r\n\r\n    uint256 currentTimelock = uint256(timelock.complete);\r\n    uint256 expiration = uint256(timelock.expires);\r\n\r\n    // Ensure that the timelock is set and has completed.\r\n    require(\r\n      currentTimelock != 0 \u0026\u0026 currentTimelock \u003C= now, \u0022Timelock is incomplete.\u0022\r\n    );\r\n\r\n    // Ensure that the timelock has not expired.\r\n    require(expiration \u003E now, \u0022Timelock has expired.\u0022);\r\n\r\n    // Clear out the existing timelock so that it cannot be reused.\r\n    delete _timelocks[functionSelector][timelockID];\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for setting a new timelock interval for a given\r\n   * function selector.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setTimelockIntervalPrivate(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) private {\r\n    // Ensure that the new timelock interval will not cause an overflow error.\r\n    require(\r\n      newTimelockInterval \u003C _A_TRILLION_YEARS,\r\n      \u0022Supplied minimum timelock interval is too large.\u0022\r\n    );\r\n\r\n    // Get the existing timelock interval, if any.\r\n    uint256 oldTimelockInterval = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    );\r\n\r\n    // Update the timelock interval on the provided function.\r\n    _timelockDefaults[functionSelector].interval = uint128(newTimelockInterval);\r\n\r\n    // Emit a \u0060TimelockIntervalModified\u0060 event with the appropriate arguments.\r\n    emit TimelockIntervalModified(\r\n      functionSelector, oldTimelockInterval, newTimelockInterval\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for setting a new timelock expiration for a given\r\n   * function selector.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockExpiration the new default timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _setTimelockExpirationPrivate(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) private {\r\n    // Ensure that the new timelock expiration will not cause an overflow error.\r\n    require(\r\n      newTimelockExpiration \u003C _A_TRILLION_YEARS,\r\n      \u0022Supplied default timelock expiration is too large.\u0022\r\n    );\r\n\r\n    // Ensure that the new timelock expiration is not too short.\r\n    require(\r\n      newTimelockExpiration \u003E 1 minutes,\r\n      \u0022New timelock expiration is too short.\u0022\r\n    );\r\n\r\n    // Get the existing timelock expiration, if any.\r\n    uint256 oldTimelockExpiration = uint256(\r\n      _timelockDefaults[functionSelector].expiration\r\n    );\r\n\r\n    // Update the timelock expiration on the provided function.\r\n    _timelockDefaults[functionSelector].expiration = uint128(\r\n      newTimelockExpiration\r\n    );\r\n\r\n    // Emit a \u0060TimelockExpirationModified\u0060 event with the appropriate arguments.\r\n    emit TimelockExpirationModified(\r\n      functionSelector, oldTimelockExpiration, newTimelockExpiration\r\n    );\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title TimelockTwoStepOwnableTestContract\r\n * @author 0age\r\n * @notice This contract implements the TwoStepOwnable and timelocker contracts\r\n * (the timelock parameters themselves are not modifiable) and additionally a\r\n * single timelocked function, \u0060test\u0060 (as well as \u0060initiateTest\u0060 to trigger the\r\n * timelock for it). The timelock has a fixed five-second minimum interval and a\r\n * thirty-minute expiration time, and will emit a \u0060Test\u0060 event.\r\n */\r\ncontract TimelockTwoStepOwnableTestContract is TwoStepOwnable, Timelocker {\r\n  // Fires a test event with an address parameter.\r\n  event Test(address addressTest);\r\n\r\n  /**\r\n   * @notice In the constructor, set the initial owner to the transaction\r\n   * submitter and initial minimum timelock interval and default timelock\r\n   * expiration values.\r\n   */\r\n  constructor() public {\r\n    // Set initial minimum timelock interval values.\r\n    _setInitialTimelockInterval(this.test.selector, 5); // 5 seconds\r\n\r\n    // Set initial default timelock expiration values.\r\n    _setInitialTimelockExpiration(this.test.selector, 30 minutes);\r\n  }\r\n\r\n  /**\r\n   * @notice Initiates a timelocked test transaction. Only the owner may call\r\n   * this function. Once the timelock period is complete (and before it has\r\n   * expired) the owner may call \u0060test\u0060 to complete the process.\r\n   * @param addressTest an address that will be logged.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function initiateTest(\r\n    address addressTest, uint256 extraTime\r\n  ) external onlyOwner {\r\n    require(addressTest != address(0), \u0022No test address provided.\u0022);\r\n\r\n    // Set the timelock and emit a \u0060TimelockInitiated\u0060 event.\r\n    _setTimelock(this.test.selector, abi.encode(addressTest), extraTime);\r\n  }\r\n\r\n  /**\r\n   * @notice Timelocked function to perform a test transaction. Only the owner\r\n   * may call this function.\r\n   * @param addressTest an address that will be logged.\r\n   */\r\n  function test(address addressTest) external onlyOwner {\r\n    require(addressTest != address(0), \u0022No test address provided.\u0022);\r\n\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(abi.encode(addressTest));\r\n\r\n    // Emit the test event.\r\n    emit Test(addressTest);\r\n  }\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022cancelOwnershipTransfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022getDefaultTimelockInterval\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022defaultTimelockInterval\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addressTest\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022extraTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022initiateTest\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022acceptOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022getDefaultTimelockExpiration\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022defaultTimelockExpiration\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addressTest\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022test\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022getTimelock\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022exists\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022completed\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022expired\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022completionTime\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022expirationTime\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addressTest\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Test\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timeComplete\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes\u0022,\u0022name\u0022:\u0022arguments\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timeExpired\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TimelockInitiated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022oldInterval\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newInterval\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TimelockIntervalModified\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bytes4\u0022,\u0022name\u0022:\u0022functionSelector\u0022,\u0022type\u0022:\u0022bytes4\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022oldExpiration\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022newExpiration\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022TimelockExpirationModified\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"TimelockTwoStepOwnableTestContract","CompilerVersion":"v0.5.11\u002Bcommit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5012b4ca137fb3faeb49ade8829ed1d65b8f58983802226bcf55196c9ef9d4a3"}]