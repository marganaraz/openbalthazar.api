[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * \u0060onlyOwner\u0060, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \u0022Ownable: caller is not the owner\u0022);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * \u0060onlyOwner\u0060 functions anymore. Can only be called by the current owner.\r\n     *\r\n     * \u003E Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u0060newOwner\u0060).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \u0022Ownable: new owner is the zero address\u0022);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: truffle/contracts/ECDSA.sol\r\n\r\n/*\r\n**  Blockdemy Certifications | A library to recover signature addresses with ECDSA\r\n**  Authors: Blockchain Academy M\u00E9xico @blockdemy, Ernesto Garc\u00EDa @ernestognw\r\n**  22-July-2019\r\n**  blockchainacademy.mx\r\n*/\r\n\r\n\r\npragma solidity ^0.5.1;\r\n\r\nlibrary ECDSA {\r\n    /**\r\n    * @dev Recovers the address of who signed the hash sent to the function\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\r\n    */\r\n    function recoverAddress(bytes32 _fingerprint, bytes memory _signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        require(_signature.length == 65, \u0022Invalid signature\u0022);\r\n\r\n        // Divide the signature in r, s and v variables with inline assembly.\r\n        assembly {\r\n          r := mload(add(_signature, 0x20))\r\n          s := mload(add(_signature, 0x40))\r\n          v := byte(0, mload(add(_signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v \u003C 27) {\r\n          v \u002B= 27;\r\n        }\r\n        \r\n        require(v == 27 || v == 28, \u0022Invalid signature\u0022);\r\n        return ecrecover(toEthSignedMessageHash(_fingerprint), v, r, s);\r\n    }\r\n    \r\n    /**\r\n    * toEthSignedMessageHash\r\n    * @dev prefix a bytes32 value with \u0022\\x19Ethereum Signed Message:\u0022 and hash the result\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    */\r\n    function toEthSignedMessageHash(bytes32 _fingerprint) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\u0022\\x19Ethereum Signed Message:\\n32\u0022, _fingerprint)\r\n        );\r\n    } \r\n}\r\n\r\n// File: truffle/contracts/Certifications.sol\r\n\r\n/*\r\n**  Blockdemy Certifications | A contract to store digital documents certifications\r\n**  Authors: Blockchain Academy M\u00E9xico @blockdemy, Ernesto Garc\u00EDa @ernestognw\r\n**  22-July-2019\r\n**  blockchainacademy.mx\r\n*/\r\n\r\npragma solidity 0.5.1;\r\n\r\n\r\n\r\ncontract Certifications is Ownable {\r\n    using ECDSA for bytes32;\r\n    \r\n    mapping(bytes32 =\u003E Certificate) public fingerprints; \r\n    \r\n    struct Certificate {\r\n        address owner;\r\n        mapping(address =\u003E bytes) signatures;\r\n        uint issued;\r\n        uint expires;\r\n        bool exists;\r\n    }\r\n    \r\n    constructor() public {}\r\n    \r\n    /**\r\n    * @dev Certificate a document fingerprint into blockchain\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _owner address. The address of who is being certificated. The owner of document.\r\n    * @param _issued uint. The unix miliseconds date of certificate issuing.\r\n    * @param _expires uint. The unix miliseconds date of certificate expiration.\r\n    */\r\n    function addCertificate(\r\n        bytes32 _fingerprint,\r\n        address _owner,\r\n        uint _issued,\r\n        uint _expires\r\n    ) onlyOwner() public returns(bool) {\r\n        require(_issued \u003C _expires, \u0022Issuing date can not be less than expiring date\u0022);\r\n        require(_expires \u003E now, \u0022This certificate has already expired\u0022);\r\n        require(!fingerprints[_fingerprint].exists, \u0022File has already been certified\u0022);\r\n        fingerprints[_fingerprint].owner = _owner;\r\n        fingerprints[_fingerprint].issued = _issued;\r\n        fingerprints[_fingerprint].expires = _expires;\r\n        fingerprints[_fingerprint].exists = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Function to sign a previously generated certificate\r\n    * @param _signer address. The address of who is signing the certificate.\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\r\n    */\r\n    function addSignatureToCertificate(address _signer, bytes32 _fingerprint, bytes memory _signature) onlyOwner() public returns(bool) {\r\n       address signer = _fingerprint.recoverAddress(_signature);\r\n       require(fingerprints[_fingerprint].exists, \u0022Certificate does not exists\u0022);\r\n       require(_signer == signer, \u0022Signature does not corresponds to signer\u0022);\r\n       fingerprints[_fingerprint].signatures[_signer] = _signature;\r\n       return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Returns the corresponding signature to a certificate and signer, used to verify signatures\r\n    * @param _signer address. The address of who supposedly signed the certificate.\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    */\r\n    function getSignature(address _signer, bytes32 _fingerprint) public view returns(bytes memory) {\r\n        return fingerprints[_fingerprint].signatures[_signer];\r\n    }\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_signer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_fingerprint\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022getSignature\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022fingerprints\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022issued\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022expires\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022exists\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_signer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_fingerprint\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_signature\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022addSignatureToCertificate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022renounceOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022owner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isOwner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_fingerprint\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_issued\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_expires\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022addCertificate\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022transferOwnership\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022previousOwner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022name\u0022:\u0022newOwner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022OwnershipTransferred\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"Certifications","CompilerVersion":"v0.5.1\u002Bcommit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://69ed30fa65481cca4a4f6bc302651c9aed22d126d1ded7af5f65187dd88a7f76"}]