[{"SourceCode":"// File: ../../mosaic-contracts/contracts/lib/EIP20Interface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// \r\n// ----------------------------------------------------------------------------\r\n// Common: Standard EIP20 Interface\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n// ----------------------------------------------------------------------------\r\n// Based on the \u0027final\u0027 EIP20 token standard as specified at:\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n * @title EIP20Interface.\r\n *\r\n * @notice Provides EIP20 token interface.\r\n */\r\ncontract EIP20Interface {\r\n\r\n\r\n    /* Events */\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n\r\n\r\n    /* Public functions */\r\n\r\n    /**\r\n     * @notice Public function to get the name of the token.\r\n     *\r\n     * @return tokenName_ Name of the token.\r\n     */\r\n    function name() public view returns (string memory tokenName_);\r\n\r\n    /**\r\n     * @notice Public function to get the symbol of the token.\r\n     *\r\n     * @return tokenSymbol_ Symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory tokenSymbol_);\r\n\r\n    /**\r\n     * @notice Public function to get the decimals of the token.\r\n     *\r\n     * @return tokenDecimals Decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8 tokenDecimals_);\r\n\r\n    /**\r\n     * @notice Public function to get the total supply of the tokens.\r\n     *\r\n     * @return totalTokenSupply_ Total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256 totalTokenSupply_);\r\n\r\n    /**\r\n     * @notice Get the balance of an account.\r\n     *\r\n     * @param _owner Address of the owner account.\r\n     *\r\n     * @return balance_ Account balance of the owner account.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance_);\r\n\r\n    /**\r\n     * @notice Public function to get the allowance.\r\n     *\r\n     * @param _owner Address of the owner account.\r\n     * @param _spender Address of the spender account.\r\n     *\r\n     * @return allowance_ Remaining allowance for the spender to spend from\r\n     *                    owner\u0027s account.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 allowance_);\r\n\r\n\r\n    /**\r\n     * @notice Public function to transfer the token.\r\n     *\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens to be transferred.\r\n     *\r\n     * @return success_ \u0060true\u0060 for a successful transfer, \u0060false\u0060 otherwise.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n    /**\r\n     * @notice Public function transferFrom.\r\n     *\r\n     * @param _from Address from which tokens are transferred.\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens transferred.\r\n     *\r\n     * @return success_ \u0060true\u0060 for a successful transfer, \u0060false\u0060 otherwise.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n    /**\r\n     * @notice Public function to approve an account for transfer.\r\n     *\r\n     * @param _spender Address authorized to spend from the function caller\u0027s\r\n     *                 address.\r\n     * @param _value Amount up to which spender is authorized to spend.\r\n     *\r\n     * @return bool \u0060true\u0060 for a successful approval, \u0060false\u0060 otherwise.\r\n     */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// \r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// Based on the SafeMath library by the OpenZeppelin team.\r\n// Copyright (c) 2018 Smart Contract Solutions, Inc.\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n// The MIT License.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title SafeMath library.\r\n *\r\n * @notice Based on the SafeMath library by the OpenZeppelin team.\r\n *\r\n * @dev Math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n\r\n    /* Internal Functions */\r\n\r\n    /**\r\n     * @notice Multiplies two numbers, reverts on overflow.\r\n     *\r\n     * @param a Unsigned integer multiplicand.\r\n     * @param b Unsigned integer multiplier.\r\n     *\r\n     * @return uint256 Product.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        /*\r\n         * Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero,\r\n         * but the benefit is lost if \u0027b\u0027 is also tested.\r\n         * See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n         */\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(\r\n            c / a == b,\r\n            \u0022Overflow when multiplying.\u0022\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Integer division of two numbers truncating the quotient, reverts\r\n     *         on division by zero.\r\n     *\r\n     * @param a Unsigned integer dividend.\r\n     * @param b Unsigned integer divisor.\r\n     *\r\n     * @return uint256 Quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0.\r\n        require(\r\n            b \u003E 0,\r\n            \u0022Cannot do attempted division by less than or equal to zero.\u0022\r\n        );\r\n        uint256 c = a / b;\r\n\r\n        // There is no case in which the following doesn\u0027t hold:\r\n        // assert(a == b * c \u002B a % b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two numbers, reverts on underflow (i.e. if subtrahend\r\n     *         is greater than minuend).\r\n     *\r\n     * @param a Unsigned integer minuend.\r\n     * @param b Unsigned integer subtrahend.\r\n     *\r\n     * @return uint256 Difference.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(\r\n            b \u003C= a,\r\n            \u0022Underflow when subtracting.\u0022\r\n        );\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two numbers, reverts on overflow.\r\n     *\r\n     * @param a Unsigned integer augend.\r\n     * @param b Unsigned integer addend.\r\n     *\r\n     * @return uint256 Sum.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(\r\n            c \u003E= a,\r\n            \u0022Overflow when adding.\u0022\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Divides two numbers and returns the remainder (unsigned integer\r\n     *         modulo), reverts when dividing by zero.\r\n     *\r\n     * @param a Unsigned integer dividend.\r\n     * @param b Unsigned integer divisor.\r\n     *\r\n     * @return uint256 Remainder.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(\r\n            b != 0,\r\n            \u0022Cannot do attempted division by zero (in \u0060mod()\u0060).\u0022\r\n        );\r\n\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/gateway/SimpleStake.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n/**\r\n *  @title SimpleStake contract\r\n *\r\n *  @notice This holds staked EIP20 tokens for a gateway.\r\n */\r\ncontract SimpleStake {\r\n\r\n    /* Usings */\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Events */\r\n\r\n    /* Emitted when amount is un-staked */\r\n    event ReleasedStake(\r\n        address indexed _gateway,\r\n        address indexed _to,\r\n        uint256 _amount\r\n    );\r\n\r\n\r\n    /* Storage */\r\n\r\n    /** EIP20 token contract that can be staked. */\r\n    EIP20Interface public token;\r\n\r\n    /** EIP20 gateway address. */\r\n    address public gateway;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    /** Checks that only gateway can call a particular function. */\r\n    modifier onlyGateway() {\r\n        require(\r\n            msg.sender == gateway,\r\n            \u0022Only gateway can call the function.\u0022\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     *  @notice Contract constructor.\r\n     *\r\n     *  @param _token EIP20 token that will be staked.\r\n     *  @param _gateway EIP20Gateway contract that governs staking.\r\n     */\r\n    constructor(\r\n        EIP20Interface _token,\r\n        address _gateway\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            address(_token) != address(0),\r\n            \u0022Token contract address must not be zero.\u0022\r\n        );\r\n        require(\r\n            _gateway != address(0),\r\n            \u0022Gateway contract address must not be zero.\u0022\r\n        );\r\n\r\n        token = _token;\r\n        gateway = _gateway;\r\n    }\r\n\r\n\r\n    /* External functions */\r\n\r\n    /**\r\n     *  @notice This allows gateway to release staked amount to provided address.\r\n     *          Only gateway contract can call this method which defines set of rules\r\n     *          on how the stake can be released and to who. Beneficiary address\r\n     *          can be zero address in order to burn tokens.\r\n     *\r\n     *  @param _to Beneficiary of the amount of the stake.\r\n     *  @param _amount Amount of stake to release to beneficiary.\r\n     *\r\n     *  @return success_ \u0060true\u0060 if stake is released to beneficiary, \u0060false\u0060 otherwise.\r\n     */\r\n    function releaseTo(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyGateway\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            token.transfer(_to, _amount) == true,\r\n            \u0022Token transfer must success.\u0022\r\n        );\r\n\r\n        emit ReleasedStake(msg.sender, _to, _amount);\r\n\r\n        success_ = true;\r\n    }\r\n\r\n    /**\r\n     *  @notice This function returns total staked amount.\r\n     *\r\n     *  @dev Total stake is the balance of the staking contract\r\n     *       accidental transfers directly to SimpleStake bypassing\r\n     *       the gateway will not mint new utility tokens,\r\n     *       but will add to the total stake,\r\n     *       (accidental) donations can not be prevented.\r\n     *\r\n     *  @return stakedAmount_ Total staked amount.\r\n     */\r\n    function getTotalStake()\r\n        external\r\n        view\r\n        returns (uint256 stakedAmount_)\r\n    {\r\n        stakedAmount_ = token.balanceOf(address(this));\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure returns (bytes memory bytes_)\r\n    {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            // Get a location of some free memory and store it in bytes_ as\r\n            // Solidity does for memory variables.\r\n            bytes_ := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for bytes_.\r\n            let length := mload(_preBytes)\r\n            mstore(bytes_, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(bytes_, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the bytes_ memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of bytes_\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // bytes_ memory.\r\n            length := mload(_postBytes)\r\n            mstore(bytes_, add(length, mload(bytes_)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of bytes_ to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(\r\n        bytes memory _bytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory padded_)\r\n    {\r\n        bytes memory padding = new bytes(32 - _bytes.length);\r\n        padded_ = concat(padding, _bytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert bytes32 to bytes\r\n     *\r\n     * @param _inBytes32 bytes32 value\r\n     *\r\n     * @return bytes value\r\n     */\r\n    function bytes32ToBytes(bytes32 _inBytes32)\r\n        internal\r\n        pure\r\n        returns (bytes memory bytes_)\r\n    {\r\n        bytes_ = new bytes(32);\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            mstore(add(32, bytes_), _inBytes32)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/RLP.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n    /** Constants */\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n    uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n    /** Storage */\r\n    struct RLPItem {\r\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafe_item;   // Item that\u0027s being iterated over.\r\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* Internal Functions */\r\n\r\n    /** Iterator */\r\n\r\n    function next(\r\n        Iterator memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        require(hasNext(self));\r\n        uint ptr = self._unsafe_nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        subItem_._unsafe_memPtr = ptr;\r\n        subItem_._unsafe_length = itemLength;\r\n        self._unsafe_nextPtr = ptr \u002B itemLength;\r\n    }\r\n\r\n    function next(\r\n        Iterator memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        subItem_ = next(self);\r\n        require(!(strict \u0026\u0026 !_validate(subItem_)));\r\n    }\r\n\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self._unsafe_item;\r\n        return self._unsafe_nextPtr \u003C item._unsafe_memPtr \u002B item._unsafe_length;\r\n    }\r\n\r\n    /** RLPItem */\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        uint len = self.length;\r\n        if (len == 0) {\r\n            return RLPItem(0, 0);\r\n        }\r\n        uint memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *  @param strict Will throw if the data is not RLP encoded.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        RLPItem memory item = toRLPItem(self);\r\n        if(strict) {\r\n            uint len = self.length;\r\n            require(_payloadOffset(item) \u003C= len);\r\n            require(_itemLength(item._unsafe_memPtr) == len);\r\n            require(_validate(item));\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is null.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return \u0027true\u0027 if the item is null.\r\n    */\r\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\r\n        return self._unsafe_length == 0;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is a list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return \u0027true\u0027 if the item is a list.\r\n    */\r\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is data.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return \u0027true\u0027 if the item is data.\r\n    */\r\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is empty (string or list).\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return \u0027true\u0027 if the item is null.\r\n    */\r\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\r\n        if(isNull(self)) {\r\n            return false;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the number of items in an RLP encoded list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return The number of items.\r\n    */\r\n    function items(RLPItem memory self) internal pure returns (uint) {\r\n        if (!isList(self)) {\r\n            return 0;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        uint pos = memPtr \u002B _payloadOffset(self);\r\n        uint last = memPtr \u002B self._unsafe_length - 1;\r\n        uint itms;\r\n        while(pos \u003C= last) {\r\n            pos \u002B= _itemLength(pos);\r\n            itms\u002B\u002B;\r\n        }\r\n        return itms;\r\n    }\r\n\r\n    /**\r\n    *  @dev Create an iterator.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return An \u0027Iterator\u0027 over the item.\r\n    */\r\n    function iterator(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (Iterator memory it_)\r\n    {\r\n        require (isList(self));\r\n        uint ptr = self._unsafe_memPtr \u002B _payloadOffset(self);\r\n        it_._unsafe_item = self;\r\n        it_._unsafe_nextPtr = ptr;\r\n    }\r\n\r\n    /**\r\n    *  @dev Return the RLP encoded bytes.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The bytes.\r\n    */\r\n    function toBytes(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        uint len = self._unsafe_length;\r\n        if (len == 0) {\r\n            return bts_;\r\n        }\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(self._unsafe_memPtr, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into bytes. This will not work if the RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toData(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(rStartPos, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the list of sub-items from an RLP encoded list.\r\n    *       Warning: This is inefficient, as it requires that the list is read twice.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return Array of RLPItems.\r\n    */\r\n    function toList(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem[] memory list_)\r\n    {\r\n        require(isList(self));\r\n        uint numItems = items(self);\r\n        list_ = new RLPItem[](numItems);\r\n        Iterator memory it = iterator(self);\r\n        uint idx = 0;\r\n        while(hasNext(it)) {\r\n            list_[idx] = next(it);\r\n            idx\u002B\u002B;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an ascii string. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAscii(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (string memory str_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bytes memory bts = new bytes(len);\r\n        _copyToBytes(rStartPos, bts, len);\r\n        str_ = string(bts);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a uint. This will not work if the\r\n    *  RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toUint(RLPItem memory self) internal pure returns (uint data_) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        if (len \u003E 32 || len == 0) {\r\n            revert();\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data_ := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a boolean. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n        require (temp \u003C= 1);\r\n\r\n        return temp == 1 ? true : false;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a byte. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toByte(RLPItem memory self) internal pure returns (byte data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n\r\n        return byte(uint8(temp));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an int. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toInt(RLPItem memory self) internal pure returns (int data) {\r\n        return int(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a bytes32. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBytes32(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 data)\r\n    {\r\n        return bytes32(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAddress(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (address data)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require (len == 20);\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the payload offset.\r\n    */\r\n    function _payloadOffset(RLPItem memory self) private pure returns (uint) {\r\n        if(self._unsafe_length == 0)\r\n            return 0;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if(b0 \u003C DATA_SHORT_START)\r\n            return 0;\r\n        if(b0 \u003C DATA_LONG_START || (b0 \u003E= LIST_SHORT_START \u0026\u0026 b0 \u003C LIST_LONG_START))\r\n            return 1;\r\n        if(b0 \u003C LIST_SHORT_START)\r\n            return b0 - DATA_LONG_OFFSET \u002B 1;\r\n        return b0 - LIST_LONG_OFFSET \u002B 1;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param memPtr Memory pointer.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _itemLength(uint memPtr) private pure returns (uint len) {\r\n        uint b0;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 \u003C DATA_SHORT_START) {\r\n            len = 1;\r\n        } else if (b0 \u003C DATA_LONG_START) {\r\n            len = b0 - DATA_SHORT_START \u002B 1;\r\n        } else if (b0 \u003C LIST_SHORT_START) {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        } else if (b0 \u003C LIST_LONG_START) {\r\n            len = b0 - LIST_SHORT_START \u002B 1;\r\n        } else {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _decode(\r\n        RLPItem memory self\r\n    )\r\n        private\r\n        pure\r\n        returns (uint memPtr_, uint len_)\r\n    {\r\n        require(isData(self));\r\n        uint b0;\r\n        uint start = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 \u003C DATA_SHORT_START) {\r\n            memPtr_ = start;\r\n            len_ = 1;\r\n\r\n            return (memPtr_, len_);\r\n        }\r\n        if (b0 \u003C DATA_LONG_START) {\r\n            len_ = self._unsafe_length - 1;\r\n            memPtr_ = start \u002B 1;\r\n        } else {\r\n            uint bLen;\r\n\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len_ = self._unsafe_length - 1 - bLen;\r\n            memPtr_ = start \u002B bLen \u002B 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Assumes that enough memory has been allocated to store in target.\r\n    *       Gets the full length of an RLP item.\r\n    *\r\n    *  @param btsPtr Bytes pointer.\r\n    *  @param tgt Last item to be allocated.\r\n    *  @param btsLen Bytes length.\r\n    */\r\n    function _copyToBytes(\r\n        uint btsPtr,\r\n        bytes memory tgt,\r\n        uint btsLen\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // Exploiting the fact that \u0027tgt\u0027 was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n                let i := 0 // Start at arr \u002B 0x20\r\n                let stopOffset := add(btsLen, 31)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 32)\r\n                for {} lt(i, stopOffset) { i := add(i, 32) }\r\n                {\r\n                    mstore(add(wOffset, i), mload(add(rOffset, i)))\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check that an RLP item is valid.\r\n    *\r\n    *  @param self The RLPItem.\r\n    */\r\n    function _validate(RLPItem memory self) private pure returns (bool ret) {\r\n        // Check that RLP is well-formed.\r\n        uint b0;\r\n        uint b1;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n            b1 := byte(1, mload(memPtr))\r\n        }\r\n        if(b0 == DATA_SHORT_START \u002B 1 \u0026\u0026 b1 \u003C DATA_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/MerklePatriciaProof.sol\r\n\r\npragma solidity ^0.5.0;\r\n/**\r\n * @title MerklePatriciaVerifier\r\n * @author Sam Mayo (sammayo888@gmail.com)\r\n *\r\n * @dev Library for verifing merkle patricia proofs.\r\n */\r\n\r\n\r\nlibrary MerklePatriciaProof {\r\n    /**\r\n     * @dev Verifies a merkle patricia proof.\r\n     * @param value The terminating value in the trie.\r\n     * @param encodedPath The path in the trie leading to value.\r\n     * @param rlpParentNodes The rlp encoded stack of nodes.\r\n     * @param root The root hash of the trie.\r\n     * @return The boolean validity of the proof.\r\n     */\r\n    function verify(\r\n        bytes32 value,\r\n        bytes calldata encodedPath,\r\n        bytes calldata rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(encodedPath);\r\n        if(path.length == 0) {return false;}\r\n\r\n        for (uint i=0; i\u003CparentNodes.length; i\u002B\u002B) {\r\n            if(pathPtr \u003E path.length) {return false;}\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {return false;}\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble \u003E 16) {return false;}\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr \u002B= 1;\r\n            } else if(currentNodeList.length == 2) {\r\n\r\n                // Count of matching node key nibbles in path starting from pathPtr.\r\n                uint traverseLength = _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr \u002B traverseLength == path.length) { //leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } else if (traverseLength == 0) { // error: couldn\u0027t traverse path\r\n                    return false;\r\n                } else { // extension node\r\n                    pathPtr \u002B= traverseLength;\r\n                    nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n                }\r\n\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function verifyDebug(\r\n        bytes32 value,\r\n        bytes memory not_encodedPath,\r\n        bytes memory rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        public\r\n        pure\r\n        returns (bool res_, uint loc_, bytes memory path_debug_)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(not_encodedPath);\r\n        path_debug_ = path;\r\n        if(path.length == 0) {\r\n            loc_ = 0;\r\n            res_ = false;\r\n            return (res_, loc_, path_debug_);\r\n        }\r\n\r\n        for (uint i=0; i\u003CparentNodes.length; i\u002B\u002B) {\r\n            if(pathPtr \u003E path.length) {\r\n                loc_ = 1;\r\n                res_ = false;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {\r\n                res_ = false;\r\n                loc_ = 100 \u002B i;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            loc_ = currentNodeList.length;\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 3;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble \u003E 16) {\r\n                    loc_ = 4;\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr \u002B= 1;\r\n            } else if(currentNodeList.length == 2) {\r\n                pathPtr \u002B= _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr == path.length) {//leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 5;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n                //extension node\r\n                if(_nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr) == 0) {\r\n                    loc_ = 6;\r\n                    res_ = (keccak256(abi.encodePacked()) == value);\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n\r\n                nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n            } else {\r\n                loc_ = 7;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n        }\r\n\r\n        loc_ = 8;\r\n    }\r\n\r\n    function _nibblesToTraverse(\r\n        bytes memory encodedPartialPath,\r\n        bytes memory path,\r\n        uint pathPtr\r\n    )\r\n        private\r\n        pure\r\n        returns (uint len_)\r\n    {\r\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n        // and slicedPath have elements that are each one hex character (1 nibble)\r\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n        bytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n        // pathPtr counts nibbles in path\r\n        // partialPath.length is a number of nibbles\r\n        for(uint i=pathPtr; i\u003CpathPtr\u002BpartialPath.length; i\u002B\u002B) {\r\n            byte pathNibble = path[i];\r\n            slicedPath[i-pathPtr] = pathNibble;\r\n        }\r\n\r\n        if(keccak256(abi.encodePacked(partialPath)) == keccak256(abi.encodePacked(slicedPath))) {\r\n            len_ = partialPath.length;\r\n        } else {\r\n            len_ = 0;\r\n        }\r\n    }\r\n\r\n    // bytes b must be hp encoded\r\n    function _getNibbleArray(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        if(b.length\u003E0) {\r\n            uint8 offset;\r\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0,b));\r\n            if(hpNibble == 1 || hpNibble == 3) {\r\n                nibbles_ = new bytes(b.length*2-1);\r\n                byte oddNibble = _getNthNibbleOfBytes(1,b);\r\n                nibbles_[0] = oddNibble;\r\n                offset = 1;\r\n            } else {\r\n                nibbles_ = new bytes(b.length*2-2);\r\n                offset = 0;\r\n            }\r\n\r\n            for(uint i=offset; i\u003Cnibbles_.length; i\u002B\u002B) {\r\n                nibbles_[i] = _getNthNibbleOfBytes(i-offset\u002B2,b);\r\n            }\r\n        }\r\n    }\r\n\r\n    // normal byte array, no encoding used\r\n    function _getNibbleArray2(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        nibbles_ = new bytes(b.length*2);\r\n        for (uint i = 0; i \u003C nibbles_.length; i\u002B\u002B) {\r\n            nibbles_[i] = _getNthNibbleOfBytes(i, b);\r\n        }\r\n    }\r\n\r\n    function _getNthNibbleOfBytes(\r\n        uint n,\r\n        bytes memory str\r\n    )\r\n        private\r\n        pure returns (byte)\r\n    {\r\n        return byte(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/GatewayLib.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n\r\n\r\n\r\nlibrary GatewayLib {\r\n\r\n    /* Constants */\r\n\r\n    bytes32 constant public STAKE_INTENT_TYPEHASH = keccak256(\r\n        abi.encode(\r\n            \u0022StakeIntent(uint256 amount,address beneficiary,address gateway)\u0022\r\n        )\r\n    );\r\n\r\n    bytes32 constant public REDEEM_INTENT_TYPEHASH = keccak256(\r\n        abi.encode(\r\n            \u0022RedeemIntent(uint256 amount,address beneficiary,address gateway)\u0022\r\n        )\r\n    );\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     * @notice Merkle proof verification of account.\r\n     *\r\n     * @param _rlpAccount RLP encoded data of account.\r\n     * @param _rlpParentNodes Path from root node to leaf in merkle tree.\r\n     * @param _encodedPath Encoded path to search account node in merkle tree.\r\n     * @param _stateRoot State root for given block height.\r\n     *\r\n     * @return bytes32 Storage path of the variable.\r\n     */\r\n    function proveAccount(\r\n        bytes calldata _rlpAccount,\r\n        bytes calldata _rlpParentNodes,\r\n        bytes calldata _encodedPath,\r\n        bytes32 _stateRoot\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes32 storageRoot_)\r\n    {\r\n        // Decode RLP encoded account value.\r\n        RLP.RLPItem memory accountItem = RLP.toRLPItem(_rlpAccount);\r\n\r\n        // Convert to list.\r\n        RLP.RLPItem[] memory accountArray = RLP.toList(accountItem);\r\n\r\n        // Array 3rd position is storage root.\r\n        storageRoot_ = RLP.toBytes32(accountArray[2]);\r\n\r\n        // Hash the rlpValue value.\r\n        bytes32 hashedAccount = keccak256(\r\n            abi.encodePacked(_rlpAccount)\r\n        );\r\n\r\n        /*\r\n         * Verify the remote OpenST contract against the committed state\r\n         * root with the state trie Merkle proof.\r\n         */\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                hashedAccount,\r\n                _encodedPath,\r\n                _rlpParentNodes,\r\n                _stateRoot\r\n            ),\r\n            \u0022Account proof is not verified.\u0022\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Creates the hash of a stake intent struct based on its fields.\r\n     *\r\n     * @param _amount Stake amount.\r\n     * @param _beneficiary The beneficiary address on the auxiliary chain.\r\n     * @param _gateway The address of the  gateway where the staking took place.\r\n     *\r\n     * @return stakeIntentHash_ The hash that represents this stake intent.\r\n     */\r\n    function hashStakeIntent(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        address _gateway\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes32 stakeIntentHash_)\r\n    {\r\n        stakeIntentHash_ = keccak256(\r\n            abi.encode(\r\n                STAKE_INTENT_TYPEHASH,\r\n                _amount,\r\n                _beneficiary,\r\n                _gateway\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Creates the hash of a redeem intent struct based on its fields.\r\n     *\r\n     * @param _amount Redeem amount.\r\n     * @param _beneficiary The beneficiary address on the origin chain.\r\n     * @param _gateway The address of the  gateway where the redeeming happened.\r\n     *\r\n     * @return redeemIntentHash_ The hash that represents this stake intent.\r\n     */\r\n    function hashRedeemIntent(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        address _gateway\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes32 redeemIntentHash_)\r\n    {\r\n        redeemIntentHash_ = keccak256(\r\n            abi.encode(\r\n                REDEEM_INTENT_TYPEHASH,\r\n                _amount,\r\n                _beneficiary,\r\n                _gateway\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/MessageBus.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\nlibrary MessageBus {\r\n\r\n    /* Usings */\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Enums */\r\n\r\n    /** Status of the message state machine. */\r\n    enum MessageStatus {\r\n        Undeclared,\r\n        Declared,\r\n        Progressed,\r\n        DeclaredRevocation,\r\n        Revoked\r\n    }\r\n\r\n    /** Status of the message state machine. */\r\n    enum MessageBoxType {\r\n        Outbox,\r\n        Inbox\r\n    }\r\n\r\n\r\n    /* Structs */\r\n\r\n    /** MessageBox stores the inbox and outbox mapping. */\r\n    struct MessageBox {\r\n\r\n        /** Maps message hash to the MessageStatus. */\r\n        mapping(bytes32 =\u003E MessageStatus) outbox;\r\n\r\n        /** Maps message hash to the MessageStatus. */\r\n        mapping(bytes32 =\u003E MessageStatus) inbox;\r\n    }\r\n\r\n    /** A Message is sent between gateways. */\r\n    struct Message {\r\n\r\n        /** Intent hash of specific request type. */\r\n        bytes32 intentHash;\r\n\r\n        /** Nonce of the sender. */\r\n        uint256 nonce;\r\n\r\n        /** Gas price that sender will pay for reward. */\r\n        uint256 gasPrice;\r\n\r\n        /** Gas limit that sender will pay. */\r\n        uint256 gasLimit;\r\n\r\n        /** Address of the message sender. */\r\n        address sender;\r\n\r\n        /** Hash lock provided by the facilitator. */\r\n        bytes32 hashLock;\r\n\r\n        /**\r\n         * The amount of the gas consumed, this is used for reward\r\n         * calculation.\r\n         */\r\n        uint256 gasConsumed;\r\n    }\r\n\r\n\r\n    /* Constants */\r\n\r\n    bytes32 public constant MESSAGE_TYPEHASH = keccak256(\r\n        abi.encode(\r\n            \u0022Message(bytes32 intentHash,uint256 nonce,uint256 gasPrice,uint256 gasLimit,address sender,bytes32 hashLock)\u0022\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Position of outbox in struct MessageBox.\r\n     * This is used to generate storage merkel proof.\r\n     */\r\n    uint8 public constant OUTBOX_OFFSET = 0;\r\n\r\n    /**\r\n     * Position of inbox in struct MessageBox.\r\n     * This is used to generate storage merkel proof.\r\n     */\r\n    uint8 public constant INBOX_OFFSET = 1;\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     * @notice Declare a new message. This will update the outbox status to\r\n     *         \u0060Declared\u0060 for the given message hash.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     *\r\n     * @return messageHash_ Message hash\r\n     */\r\n    function declareMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Undeclared,\r\n            \u0022Message on source must be Undeclared.\u0022\r\n        );\r\n\r\n        // Update the outbox message status to \u0060Declared\u0060.\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Declared;\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a new message that is declared in outbox on the source\r\n     *         chain. Merkle proof will be performed to verify the declared\r\n     *         status in source chains outbox. This will update the inbox\r\n     *         status to \u0060Declared\u0060 for the given message hash.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function confirmMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Undeclared,\r\n            \u0022Message on target must be Undeclared.\u0022\r\n        );\r\n\r\n        // Get the storage path to verify proof.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Verify the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(MessageStatus.Declared)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \u0022Merkle proof verification failed.\u0022\r\n        );\r\n\r\n        // Update the message box inbox status to \u0060Declared\u0060.\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Declared;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the outbox message hash status to \u0060Progressed\u0060.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _unlockSecret Unlock secret for the hash lock provided while\r\n     *                      declaration.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutbox(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _message.hashLock == keccak256(abi.encode(_unlockSecret)),\r\n            \u0022Invalid unlock secret.\u0022\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Declared,\r\n            \u0022Message on source must be Declared.\u0022\r\n        );\r\n\r\n        // Update the outbox message status to \u0060Progressed\u0060.\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the outbox for a given message hash to\r\n     *         \u0060Progressed\u0060. Merkle proof is used to verify status of inbox in\r\n     *         source chain. This is an alternative approach to hashlocks.\r\n     *\r\n     * @dev The messsage status for the message hash in the inbox should be\r\n     *      either \u0060Declared\u0060 or \u0060Progresses\u0060. Either of this status will be\r\n     *      verified with the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox inbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the inbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutboxWithProof(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n\r\n        if(_messageBox.outbox[messageHash_] == MessageStatus.Declared) {\r\n\r\n            /*\r\n             * The inbox message status of target must be either \u0060Declared\u0060 or\r\n             * \u0060Progressed\u0060 when outbox message status at source is \u0060Declared\u0060.\r\n             */\r\n            require(\r\n                _messageStatus == MessageStatus.Declared ||\r\n                _messageStatus == MessageStatus.Progressed,\r\n                \u0022Message on target must be Declared or Progressed.\u0022\r\n            );\r\n\r\n        } else if (_messageBox.outbox[messageHash_] == MessageStatus.DeclaredRevocation) {\r\n\r\n            /*\r\n             * The inbox message status of target must be either \u0060Progressed\u0060\r\n             * when outbox message status at source is \u0060DeclaredRevocation\u0060.\r\n             */\r\n            require(\r\n                _messageStatus == MessageStatus.Progressed,\r\n                \u0022Message on target must be Progressed.\u0022\r\n            );\r\n\r\n        } else {\r\n            revert(\u0022Status of message on source must be Declared or DeclareRevocation.\u0022);\r\n        }\r\n\r\n        bytes memory storagePath = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                INBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Verify the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                storagePath,\r\n                _rlpParentNodes,\r\n                _storageRoot),\r\n            \u0022Merkle proof verification failed.\u0022\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the inbox for a given message hash to\r\n     *         \u0060Progressed\u0060\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _unlockSecret Unlock secret for the hash lock provided while\r\n     *                      declaration.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressInbox(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _message.hashLock == keccak256(abi.encode(_unlockSecret)),\r\n            \u0022Invalid unlock secret.\u0022\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \u0022Message on target status must be Declared.\u0022\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the inbox for a given message hash to\r\n     *         \u0060Progressed\u0060. Merkle proof is used to verify status of outbox in\r\n     *         source chain. This is an alternative approach to hashlocks.\r\n     *\r\n     * @dev The messsage status for the message hash in the outbox should be\r\n     *      either \u0060Declared\u0060 or \u0060Progresses\u0060. Either of this status will be\r\n     *      verified in the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the outbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressInboxWithProof(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        // Outbox message status must be either \u0060Declared\u0060 or \u0060Progressed\u0060.\r\n        require(\r\n            _messageStatus == MessageStatus.Declared ||\r\n            _messageStatus == MessageStatus.Progressed,\r\n            \u0022Message on source must be Declared or Progressed.\u0022\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \u0022Message on target must be Declared.\u0022\r\n        );\r\n\r\n        // The outbox is at location OUTBOX_OFFSET of the MessageBox struct.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \u0022Merkle proof verification failed.\u0022\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Declare a new revocation message. This will update the outbox\r\n     *         status to \u0060DeclaredRevocation\u0060 for the given message hash.\r\n     *\r\n     * @dev In order to declare revocation the existing message status for the\r\n     *      given message hash should be \u0060Declared\u0060.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function declareRevocationMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Declared,\r\n            \u0022Message on source must be Declared.\u0022\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.DeclaredRevocation;\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a revocation message that is declared in the outbox of\r\n     *         source chain. This will update the outbox status to\r\n     *         \u0060Revoked\u0060 for the given message hash.\r\n     *\r\n     * @dev In order to declare revocation the existing message status for the\r\n     *      given message hash should be \u0060Declared\u0060.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function confirmRevocation(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \u0022Message on target must be Declared.\u0022\r\n        );\r\n\r\n        // Get the path.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(MessageStatus.DeclaredRevocation)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \u0022Merkle proof verification failed.\u0022\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Revoked;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the outbox for a given message hash to\r\n     *         \u0060Revoked\u0060. Merkle proof is used to verify status of inbox in\r\n     *         source chain.\r\n     *\r\n     * @dev The messsage status in the inbox should be\r\n     *      either \u0060DeclaredRevocation\u0060 or \u0060Revoked\u0060. Either of this status\r\n     *      will be verified in the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox inbox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the inbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutboxRevocation(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        uint8 _messageBoxOffset,\r\n        bytes calldata _rlpParentNodes,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _messageStatus == MessageStatus.Revoked,\r\n            \u0022Message on target status must be Revoked.\u0022\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] ==\r\n            MessageStatus.DeclaredRevocation,\r\n            \u0022Message status on source must be DeclaredRevocation.\u0022\r\n        );\r\n\r\n        // The inbox is at location INBOX_OFFSET of the MessageBox struct.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                INBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \u0022Merkle proof verification failed.\u0022\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Revoked;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the type hash of the type \u0022Message\u0022.\r\n     *\r\n     * @return messageTypehash_ The type hash of the \u0022Message\u0022 type.\r\n     */\r\n    function messageTypehash() public pure returns(bytes32 messageTypehash_) {\r\n        messageTypehash_ = MESSAGE_TYPEHASH;\r\n    }\r\n\r\n\r\n    /* Public Functions */\r\n\r\n    /**\r\n     * @notice Generate message hash from the input params\r\n     *\r\n     * @param _intentHash Intent hash.\r\n     * @param _nonce Nonce of the message sender.\r\n     * @param _gasPrice Gas price.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function messageDigest(\r\n        bytes32 _intentHash,\r\n        uint256 _nonce,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        address _sender,\r\n        bytes32 _hashLock\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = keccak256(\r\n            abi.encode(\r\n                MESSAGE_TYPEHASH,\r\n                _intentHash,\r\n                _nonce,\r\n                _gasPrice,\r\n                _gasLimit,\r\n                _sender,\r\n                _hashLock\r\n            )\r\n        );\r\n    }\r\n\r\n\r\n    /* Private Functions */\r\n\r\n    /**\r\n     * @notice Creates a hash from a message struct.\r\n     *\r\n     * @param _message The message to hash.\r\n     *\r\n     * @return messageHash_ The hash that represents this message.\r\n     */\r\n    function messageDigest(\r\n        Message storage _message\r\n    )\r\n        private\r\n        view\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(\r\n            _message.intentHash,\r\n            _message.nonce,\r\n            _message.gasPrice,\r\n            _message.gasLimit,\r\n            _message.sender,\r\n            _message.hashLock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the storage path of the variable inside the struct.\r\n     *\r\n     * @param _structPosition Position of struct variable.\r\n     * @param _offset Offset of variable inside the struct.\r\n     * @param _key Key of variable in case of mapping\r\n     *\r\n     * @return storagePath_ Storage path of the variable.\r\n     */\r\n    function storageVariablePathForStruct(\r\n        uint8 _structPosition,\r\n        uint8 _offset,\r\n        bytes32 _key\r\n    )\r\n        private\r\n        pure\r\n        returns(bytes32 storagePath_)\r\n    {\r\n        if(_offset \u003E 0){\r\n            _structPosition = _structPosition \u002B _offset;\r\n        }\r\n\r\n        bytes memory indexBytes = BytesLib.leftPad(\r\n            BytesLib.bytes32ToBytes(bytes32(uint256(_structPosition)))\r\n        );\r\n\r\n        bytes memory keyBytes = BytesLib.leftPad(BytesLib.bytes32ToBytes(_key));\r\n        bytes memory path = BytesLib.concat(keyBytes, indexBytes);\r\n\r\n        storagePath_ = keccak256(\r\n            abi.encodePacked(keccak256(abi.encodePacked(path)))\r\n        );\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/OrganizationInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n *  @title OrganizationInterface provides methods to check if an address is\r\n *         currently registered as an active participant in the organization.\r\n */\r\ninterface OrganizationInterface {\r\n\r\n    /**\r\n     * @notice Checks if an address is currently registered as the organization.\r\n     *\r\n     * @param _organization Address to check.\r\n     *\r\n     * @return isOrganization_ True if the given address represents the\r\n     *                         organization. Returns false otherwise.\r\n     */\r\n    function isOrganization(\r\n        address _organization\r\n    )\r\n        external\r\n        view\r\n        returns (bool isOrganization_);\r\n\r\n    /**\r\n     * @notice Checks if an address is currently registered as an active worker.\r\n     *\r\n     * @param _worker Address to check.\r\n     *\r\n     * @return isWorker_ True if the given address is a registered, active\r\n     *                   worker. Returns false otherwise.\r\n     */\r\n    function isWorker(address _worker) external view returns (bool isWorker_);\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/Organized.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title Organized contract.\r\n *\r\n * @notice The Organized contract facilitates integration of\r\n *         organization administration keys with different contracts.\r\n */\r\ncontract Organized {\r\n\r\n\r\n    /* Storage */\r\n\r\n    /** Organization which holds all the keys needed to administer the economy. */\r\n    OrganizationInterface public organization;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyOrganization()\r\n    {\r\n        require(\r\n            organization.isOrganization(msg.sender),\r\n            \u0022Only the organization is allowed to call this method.\u0022\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWorker()\r\n    {\r\n        require(\r\n            organization.isWorker(msg.sender),\r\n            \u0022Only whitelisted workers are allowed to call this method.\u0022\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     * @notice Sets the address of the organization contract.\r\n     *\r\n     * @param _organization A contract that manages worker keys.\r\n     */\r\n    constructor(OrganizationInterface _organization) public {\r\n        require(\r\n            address(_organization) != address(0),\r\n            \u0022Organization contract address must not be zero.\u0022\r\n        );\r\n\r\n        organization = _organization;\r\n    }\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/StateRootInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n/** @title An interface to an get state root. */\r\ninterface StateRootInterface {\r\n\r\n    /**\r\n     * @notice Gets the block number of latest committed state root.\r\n     *\r\n     * @return height_ Block height of the latest committed state root.\r\n     */\r\n    function getLatestStateRootBlockHeight()\r\n        external\r\n        view\r\n        returns (uint256 height_);\r\n\r\n    /**\r\n     * @notice Get the state root for the given block height.\r\n     *\r\n     * @param _blockHeight The block height for which the state root is fetched.\r\n     *\r\n     * @return bytes32 State root at the given height.\r\n     */\r\n    function getStateRoot(uint256 _blockHeight)\r\n        external\r\n        view\r\n        returns (bytes32 stateRoot_);\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/gateway/GatewayBase.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  @title GatewayBase is the base contract for EIP20Gateway and EIP20CoGateway.\r\n */\r\ncontract GatewayBase is Organized {\r\n\r\n    /* Usings */\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Events */\r\n\r\n    /**\r\n     * Emitted whenever a Gateway/CoGateway contract is proven.\r\n     * wasAlreadyProved parameter differentiates between first call and replay\r\n     * call of proveGateway method for same block height.\r\n     */\r\n    event GatewayProven(\r\n        address _gateway,\r\n        uint256 _blockHeight,\r\n        bytes32 _storageRoot,\r\n        bool _wasAlreadyProved\r\n    );\r\n\r\n    event BountyChangeInitiated(\r\n        uint256 _currentBounty,\r\n        uint256 _proposedBounty,\r\n        uint256 _unlockHeight\r\n    );\r\n\r\n    event BountyChangeConfirmed(\r\n        uint256 _currentBounty,\r\n        uint256 _changedBounty\r\n    );\r\n\r\n\r\n    /* Constants */\r\n\r\n    /** Position of message bus in the storage. */\r\n    uint8 constant MESSAGE_BOX_OFFSET = 7;\r\n\r\n    /**\r\n     * Penalty in bounty amount percentage charged to staker on revert stake.\r\n     */\r\n    uint8 constant REVOCATION_PENALTY = 150;\r\n\r\n    //todo identify how to get block time for both chains\r\n    /**\r\n     * Unlock period of 7-days for change bounty in block height.\r\n     * Considering aux block generation time per block is 3-secs.\r\n     */\r\n    uint256 public constant BOUNTY_CHANGE_UNLOCK_PERIOD = 201600;\r\n\r\n\r\n    /* Public Variables */\r\n\r\n    /**\r\n     *  Address of contract which implements StateRootInterface.\r\n     */\r\n    StateRootInterface public stateRootProvider;\r\n\r\n    /** Path to make Merkle account proof for Gateway/CoGateway contract. */\r\n    bytes public encodedGatewayPath;\r\n\r\n    /**\r\n     * Remote gateway contract address. If this is a gateway contract, then the\r\n     * remote gateway is a CoGateway and vice versa.\r\n     */\r\n    address public remoteGateway;\r\n\r\n    /** Amount of ERC20 which is staked by facilitator. */\r\n    uint256 public bounty;\r\n\r\n    /** Proposed new bounty amount for bounty change. */\r\n    uint256 public proposedBounty;\r\n\r\n    /** Bounty proposal block height. */\r\n    uint256 public proposedBountyUnlockHeight;\r\n\r\n\r\n    /* Internal Variables */\r\n\r\n    /**\r\n     * Message box.\r\n     * @dev Keep this is at location 1, in case this is changed then update\r\n     *      constant MESSAGE_BOX_OFFSET accordingly.\r\n     */\r\n    MessageBus.MessageBox internal messageBox;\r\n\r\n    /** Maps messageHash to the Message object. */\r\n    mapping(bytes32 =\u003E MessageBus.Message) public messages;\r\n\r\n    /** Maps blockHeight to storageRoot. */\r\n    mapping(uint256 =\u003E bytes32) internal storageRoots;\r\n\r\n\r\n    /* Private Variables */\r\n\r\n    /**\r\n     * Maps address to message hash.\r\n     *\r\n     * Once the inbox process is started the corresponding\r\n     * message hash is stored against the address starting process.\r\n     * This is used to restrict simultaneous/multiple process\r\n     * for a particular address. This is also used to determine the\r\n     * nonce of the particular address. Refer getNonce for the details.\r\n     */\r\n    mapping(address =\u003E bytes32) private inboxActiveProcess;\r\n\r\n    /**\r\n     * Maps address to message hash.\r\n     *\r\n     * Once the outbox process is started the corresponding\r\n     * message hash is stored  against the address starting process.\r\n     * This is used to restrict simultaneous/multiple process\r\n     * for a particular address. This is also used to determine the\r\n     * nonce of the particular address. Refer getNonce for the details.\r\n     */\r\n    mapping(address =\u003E bytes32) private outboxActiveProcess;\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     * @notice Initialize the contract and set default values.\r\n     *\r\n     * @param _stateRootProvider Contract address which implements\r\n     *                           StateRootInterface.\r\n     * @param _bounty The amount that facilitator will stakes to initiate the\r\n     *                message transfers.\r\n     * @param _organization Address of an organization contract.\r\n     */\r\n    constructor(\r\n        StateRootInterface _stateRootProvider,\r\n        uint256 _bounty,\r\n        OrganizationInterface _organization\r\n    )\r\n        Organized(_organization)\r\n        public\r\n    {\r\n        require(\r\n            address(_stateRootProvider) != address(0),\r\n            \u0022State root provider contract address must not be zero.\u0022\r\n        );\r\n\r\n        stateRootProvider = _stateRootProvider;\r\n        bounty = _bounty;\r\n\r\n        // The following variables are not known at construction:\r\n        messageBox = MessageBus.MessageBox();\r\n        encodedGatewayPath = \u0027\u0027;\r\n        remoteGateway = address(0);\r\n    }\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     *  @notice This can be called by anyone to verify merkle proof of\r\n     *          gateway/co-gateway contract address. Trust factor is brought by\r\n     *          state roots of the contract which implements StateRootInterface.\r\n     *          It\u0027s important to note that in replay calls of proveGateway\r\n     *          bytes _rlpParentNodes variable is not validated. In this case\r\n     *          input storage root derived from merkle proof account nodes is\r\n     *          verified with stored storage root of given blockHeight.\r\n     *          GatewayProven event has parameter wasAlreadyProved to\r\n     *          differentiate between first call and replay calls.\r\n     *\r\n     *  @param _blockHeight Block height at which Gateway/CoGateway is to be\r\n     *                      proven.\r\n     *  @param _rlpAccount RLP encoded account node object.\r\n     *  @param _rlpParentNodes RLP encoded value of account proof parent nodes.\r\n     *\r\n     *  @return \u0060true\u0060 if Gateway account is proved\r\n     */\r\n    function proveGateway(\r\n        uint256 _blockHeight,\r\n        bytes calldata _rlpAccount,\r\n        bytes calldata _rlpParentNodes\r\n    )\r\n        external\r\n        returns (bool /* success */)\r\n    {\r\n        // _rlpAccount should be valid\r\n        require(\r\n            _rlpAccount.length != 0,\r\n            \u0022Length of RLP account must not be 0.\u0022\r\n        );\r\n\r\n        // _rlpParentNodes should be valid\r\n        require(\r\n            _rlpParentNodes.length != 0,\r\n            \u0022Length of RLP parent nodes is 0\u0022\r\n        );\r\n\r\n        bytes32 stateRoot = stateRootProvider.getStateRoot(_blockHeight);\r\n\r\n        // State root should be present for the block height\r\n        require(\r\n            stateRoot != bytes32(0),\r\n            \u0022State root must not be zero\u0022\r\n        );\r\n\r\n        // If account already proven for block height\r\n        bytes32 provenStorageRoot = storageRoots[_blockHeight];\r\n\r\n        if (provenStorageRoot != bytes32(0)) {\r\n\r\n            // wasAlreadyProved is true here since proveOpenST is replay call\r\n            // for same block height\r\n            emit GatewayProven(\r\n                remoteGateway,\r\n                _blockHeight,\r\n                provenStorageRoot,\r\n                true\r\n            );\r\n\r\n            // return true\r\n            return true;\r\n        }\r\n\r\n        bytes32 storageRoot = GatewayLib.proveAccount(\r\n            _rlpAccount,\r\n            _rlpParentNodes,\r\n            encodedGatewayPath,\r\n            stateRoot\r\n        );\r\n\r\n        storageRoots[_blockHeight] = storageRoot;\r\n\r\n        // wasAlreadyProved is false since Gateway is called for the first time\r\n        // for a block height\r\n        emit GatewayProven(\r\n            remoteGateway,\r\n            _blockHeight,\r\n            storageRoot,\r\n            false\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the nonce for the given account address\r\n     *\r\n     * @param _account Account address for which the nonce is to fetched\r\n     *\r\n     * @return nonce\r\n     */\r\n    function getNonce(address _account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // call the private method\r\n        return _getOutboxNonce(_account);\r\n    }\r\n\r\n    /**\r\n     * @notice Method allows organization to propose new bounty amount.\r\n     *\r\n     * @param _proposedBounty proposed bounty amount.\r\n     *\r\n     * @return uint256 proposed bounty amount.\r\n     */\r\n    function initiateBountyAmountChange(uint256 _proposedBounty)\r\n        external\r\n        onlyOrganization\r\n        returns(uint256)\r\n    {\r\n        return initiateBountyAmountChangeInternal(_proposedBounty, BOUNTY_CHANGE_UNLOCK_PERIOD);\r\n    }\r\n\r\n    /**\r\n     * @notice Method allows organization to confirm proposed bounty amount\r\n     *         after unlock period.\r\n     *\r\n     * @return changedBountyAmount_  updated bounty amount.\r\n     * @return previousBountyAmount_ previous bounty amount.\r\n     */\r\n    function confirmBountyAmountChange()\r\n        external\r\n        onlyOrganization\r\n        returns (\r\n            uint256 changedBountyAmount_,\r\n            uint256 previousBountyAmount_\r\n        )\r\n    {\r\n        require(\r\n            proposedBounty != bounty,\r\n            \u0022Proposed bounty should be different from existing bounty.\u0022\r\n        );\r\n        require(\r\n            proposedBountyUnlockHeight \u003C block.number,\r\n            \u0022Confirm bounty amount change can only be done after unlock period.\u0022\r\n        );\r\n\r\n        changedBountyAmount_ = proposedBounty;\r\n        previousBountyAmount_ = bounty;\r\n\r\n        bounty = proposedBounty;\r\n\r\n        proposedBounty = 0;\r\n        proposedBountyUnlockHeight = 0;\r\n\r\n        emit BountyChangeConfirmed(previousBountyAmount_, changedBountyAmount_);\r\n    }\r\n\r\n    /**\r\n     * @notice Method to get the outbox message status for the given message\r\n     *         hash. If message hash does not exist then it will return\r\n     *         undeclared status.\r\n     *\r\n     * @param _messageHash Message hash to get the status.\r\n     *\r\n     * @return status_ Message status.\r\n     */\r\n    function getOutboxMessageStatus(\r\n        bytes32 _messageHash\r\n    )\r\n        external\r\n        view\r\n        returns (MessageBus.MessageStatus status_)\r\n    {\r\n        status_ = messageBox.outbox[_messageHash];\r\n    }\r\n\r\n    /**\r\n     * @notice Method to get the inbox message status for the given message\r\n     *         hash. If message hash does not exist then it will return\r\n     *         undeclared status.\r\n     *\r\n     * @param _messageHash Message hash to get the status.\r\n     *\r\n     * @return status_ Message status.\r\n     */\r\n    function getInboxMessageStatus(\r\n        bytes32 _messageHash\r\n    )\r\n        external\r\n        view\r\n        returns (MessageBus.MessageStatus status_)\r\n    {\r\n        status_ = messageBox.inbox[_messageHash];\r\n    }\r\n\r\n    /**\r\n     * @notice Method to get the active message hash and its status from inbox\r\n     *         for the given account address. If message hash does not exist\r\n     *         for the given account address then it will return zero hash and\r\n     *         undeclared status.\r\n     *\r\n     * @param _account Account address.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     * @return status_ Message status.\r\n     */\r\n    function getInboxActiveProcess(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 messageHash_,\r\n            MessageBus.MessageStatus status_\r\n        )\r\n    {\r\n        messageHash_ = inboxActiveProcess[_account];\r\n        status_ = messageBox.inbox[messageHash_];\r\n    }\r\n\r\n    /**\r\n     * @notice Method to get the active message hash and its status from outbox\r\n     *         for the given account address. If message hash does not exist\r\n     *         for the given account address then it will return zero hash and\r\n     *         undeclared status.\r\n     *\r\n     * @param _account Account address.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     * @return status_ Message status.\r\n     */\r\n    function getOutboxActiveProcess(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 messageHash_,\r\n            MessageBus.MessageStatus status_\r\n        )\r\n    {\r\n        messageHash_ = outboxActiveProcess[_account];\r\n        status_ = messageBox.outbox[messageHash_];\r\n    }\r\n\r\n\r\n    /* Internal Functions */\r\n\r\n    /**\r\n     * @notice Calculate the fee amount which is rewarded to facilitator for\r\n     *         performing message transfers.\r\n     *\r\n     * @param _gasConsumed Gas consumption during message confirmation.\r\n     * @param _gasLimit Maximum amount of gas can be used for reward.\r\n     * @param _gasPrice Gas price at which reward is calculated.\r\n     * @param _initialGas Initial gas at the start of the process.\r\n     *\r\n     * @return fee_ Fee amount.\r\n     * @return totalGasConsumed_ Total gas consumed during message transfer.\r\n     */\r\n    function feeAmount(\r\n        uint256 _gasConsumed,\r\n        uint256 _gasLimit,\r\n        uint256 _gasPrice,\r\n        uint256 _initialGas\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 fee_,\r\n            uint256 totalGasConsumed_\r\n        )\r\n    {\r\n        totalGasConsumed_ = _initialGas.add(\r\n            _gasConsumed\r\n        ).sub(\r\n            gasleft()\r\n        );\r\n\r\n        if (totalGasConsumed_ \u003C _gasLimit) {\r\n            fee_ = totalGasConsumed_.mul(_gasPrice);\r\n        } else {\r\n            fee_ = _gasLimit.mul(_gasPrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Create and return Message object.\r\n     *\r\n     * @dev This function is to avoid stack too deep error.\r\n     *\r\n     * @param _intentHash Intent hash\r\n     * @param _accountNonce Nonce for the account address\r\n     * @param _gasPrice Gas price\r\n     * @param _gasLimit Gas limit\r\n     * @param _account Account address\r\n     * @param _hashLock Hash lock\r\n     *\r\n     * @return Message object\r\n     */\r\n    function getMessage(\r\n        bytes32 _intentHash,\r\n        uint256 _accountNonce,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        address _account,\r\n        bytes32 _hashLock\r\n    )\r\n        internal\r\n        pure\r\n        returns (MessageBus.Message memory)\r\n    {\r\n        return MessageBus.Message({\r\n            intentHash : _intentHash,\r\n            nonce : _accountNonce,\r\n            gasPrice : _gasPrice,\r\n            gasLimit : _gasLimit,\r\n            sender : _account,\r\n            hashLock : _hashLock,\r\n            gasConsumed : 0\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to get the outbox nonce for the given account\r\n     *         address\r\n     *\r\n     * @param _account Account address for which the nonce is to fetched\r\n     *\r\n     * @return nonce\r\n     */\r\n    function _getOutboxNonce(address _account)\r\n        internal\r\n        view\r\n        returns (uint256 /* nonce */)\r\n    {\r\n\r\n        bytes32 previousProcessMessageHash = outboxActiveProcess[_account];\r\n        return getMessageNonce(previousProcessMessageHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to get the inbox nonce for the given account\r\n     *         address.\r\n     *\r\n     * @param _account Account address for which the nonce is to fetched\r\n     *\r\n     * @return nonce\r\n     */\r\n    function _getInboxNonce(address _account)\r\n        internal\r\n        view\r\n        returns (uint256 /* nonce */)\r\n    {\r\n\r\n        bytes32 previousProcessMessageHash = inboxActiveProcess[_account];\r\n        return getMessageNonce(previousProcessMessageHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Stores a message at its hash in the messages mapping.\r\n     *\r\n     * @param _message The message to store.\r\n     *\r\n     * @return messageHash_ The hash that represents the given message.\r\n     */\r\n    function storeMessage(\r\n        MessageBus.Message memory _message\r\n    )\r\n        internal\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = MessageBus.messageDigest(\r\n            _message.intentHash,\r\n            _message.nonce,\r\n            _message.gasPrice,\r\n            _message.gasLimit,\r\n            _message.sender,\r\n            _message.hashLock\r\n        );\r\n\r\n        messages[messageHash_] = _message;\r\n    }\r\n\r\n    /**\r\n     * @notice Clears the previous outbox process. Validates the\r\n     *         nonce. Updates the process with new process\r\n     *\r\n     * @param _account Account address\r\n     * @param _nonce Nonce for the account address\r\n     * @param _messageHash Message hash\r\n     */\r\n    function registerOutboxProcess(\r\n        address _account,\r\n        uint256 _nonce,\r\n        bytes32 _messageHash\r\n\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _nonce == _getOutboxNonce(_account),\r\n            \u0022Invalid nonce.\u0022\r\n        );\r\n\r\n        bytes32 previousMessageHash = outboxActiveProcess[_account];\r\n\r\n        if (previousMessageHash != bytes32(0)) {\r\n\r\n            MessageBus.MessageStatus status =\r\n                messageBox.outbox[previousMessageHash];\r\n\r\n            require(\r\n                status == MessageBus.MessageStatus.Progressed ||\r\n                status == MessageBus.MessageStatus.Revoked,\r\n                \u0022Previous process is not completed.\u0022\r\n            );\r\n\r\n            delete messages[previousMessageHash];\r\n        }\r\n\r\n        // Update the active process.\r\n        outboxActiveProcess[_account] = _messageHash;\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Clears the previous outbox process. Validates the\r\n     *         nonce. Updates the process with new process.\r\n     *\r\n     * @param _account Account address.\r\n     * @param _nonce Nonce for the account address.\r\n     * @param _messageHash Message hash.\r\n     */\r\n    function registerInboxProcess(\r\n        address _account,\r\n        uint256 _nonce,\r\n        bytes32 _messageHash\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _nonce == _getInboxNonce(_account),\r\n            \u0022Invalid nonce\u0022\r\n        );\r\n\r\n        bytes32 previousMessageHash = inboxActiveProcess[_account];\r\n\r\n        if (previousMessageHash != bytes32(0)) {\r\n\r\n            MessageBus.MessageStatus status =\r\n                messageBox.inbox[previousMessageHash];\r\n\r\n            require(\r\n                status == MessageBus.MessageStatus.Progressed ||\r\n                status == MessageBus.MessageStatus.Revoked,\r\n                \u0022Previous process is not completed\u0022\r\n            );\r\n\r\n            delete messages[previousMessageHash];\r\n        }\r\n\r\n        // Update the active process.\r\n        inboxActiveProcess[_account] = _messageHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the penalty amount for reverting a message transfer.\r\n     *\r\n     * @param _bounty The amount that facilitator has staked to initiate the\r\n     *                message transfers.\r\n     *\r\n     * @return penalty_ Amount of penalty needs to be paid by message initiator\r\n     *                  to revert message transfers.\r\n     */\r\n    function penaltyFromBounty(uint256 _bounty)\r\n        internal\r\n        pure\r\n        returns(uint256 penalty_)\r\n    {\r\n        penalty_ = _bounty.mul(REVOCATION_PENALTY).div(100);\r\n    }\r\n\r\n    /**\r\n     * Internal method to propose new bounty. This is added for large block\r\n     * heights value for unlocking bounty change.\r\n     *\r\n     * @param _proposedBounty proposed bounty amount.\r\n     * @param _bountyChangePeriod  Unlock period for change bounty in\r\n     *                             block height.\r\n     *\r\n     * @return uint256 proposed bounty amount.\r\n     */\r\n    function initiateBountyAmountChangeInternal(\r\n        uint256 _proposedBounty,\r\n        uint256 _bountyChangePeriod\r\n    )\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        proposedBounty = _proposedBounty;\r\n        proposedBountyUnlockHeight = block.number.add(_bountyChangePeriod);\r\n\r\n        emit BountyChangeInitiated(\r\n            bounty,\r\n            _proposedBounty,\r\n            proposedBountyUnlockHeight\r\n        );\r\n\r\n        return _proposedBounty;\r\n    }\r\n\r\n    /* Private Functions */\r\n\r\n    /**\r\n     * @notice Returns the next nonce of inbox or outbox process\r\n     *\r\n     * @param _messageHash Message hash\r\n     *\r\n     * @return _nonce nonce of next inbox or outbox process\r\n     */\r\n    function getMessageNonce(bytes32 _messageHash)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (_messageHash == bytes32(0)) {\r\n            return 1;\r\n        }\r\n\r\n        MessageBus.Message storage message =\r\n        messages[_messageHash];\r\n\r\n        return message.nonce.add(1);\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/gateway/EIP20Gateway.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n// Origin Chain: Gateway Contract\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/*\r\n\r\n           Origin chain      |       Auxiliary chain\r\n-------------------------------------------------------------------------------\r\n           EIP20Gateway - - - - - - - - - - - EIP20CoGateway\r\n-------------------------------------------------------------------------------\r\n\r\n1. Stake and Mint: Normal flow\r\n\r\n           stake             ---\u003E   confirmStakeIntent\r\n             |\r\n      progressStake (HL)     ---\u003E   progressMint (HL)\r\n-------------------------------------------------------------------------------\r\n2. Stake and Mint (Revert): Normal flow\r\n\r\n           stake             ---\u003E   confirmStakeIntent\r\n             |\r\n        revertStake          ---\u003E   confirmRevertStakeIntent\r\n                                            |\r\n      progressRevertStake    \u003C---   progressRevertStake\r\n-------------------------------------------------------------------------------\r\n3. Stake and Mint: Incase the facilitator is not able to progress\r\n\r\n    stake (by facilitator)    ---\u003E   confirmStakeIntent (by facilitator)\r\n                               |\r\n                        facilitator (offline)\r\n             |\r\n     progressStakeWithProof   ---\u003E   progressMintWithProof\r\n-------------------------------------------------------------------------------\r\n*/\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EIP20Gateway Contract\r\n *\r\n * @notice EIP20Gateway act as medium to send messages from origin chain to\r\n *         auxiliary chain. Currently gateway supports stake and revert stake message.\r\n */\r\ncontract EIP20Gateway is GatewayBase {\r\n\r\n    /* Events */\r\n\r\n    /** Emitted whenever a stake process is initiated. */\r\n    event StakeIntentDeclared(\r\n        bytes32 indexed _messageHash,\r\n        address _staker,\r\n        uint256 _stakerNonce,\r\n        address _beneficiary,\r\n        uint256 _amount\r\n    );\r\n\r\n    /** Emitted whenever a stake is completed. */\r\n    event StakeProgressed(\r\n        bytes32 indexed _messageHash,\r\n        address _staker,\r\n        uint256 _stakerNonce,\r\n        uint256 _amount,\r\n        bool _proofProgress,\r\n        bytes32 _unlockSecret\r\n    );\r\n\r\n    /** Emitted whenever a process is initiated to revert stake. */\r\n    event RevertStakeIntentDeclared(\r\n        bytes32 indexed _messageHash,\r\n        address _staker,\r\n        uint256 _stakerNonce,\r\n        uint256 _amount\r\n    );\r\n\r\n    /** Emitted whenever a stake is reverted. */\r\n    event StakeReverted(\r\n        bytes32 indexed _messageHash,\r\n        address _staker,\r\n        uint256 _stakerNonce,\r\n        uint256 _amount\r\n    );\r\n\r\n    /** Emitted whenever a redeem intent is confirmed. */\r\n    event RedeemIntentConfirmed(\r\n        bytes32 indexed _messageHash,\r\n        address _redeemer,\r\n        uint256 _redeemerNonce,\r\n        address _beneficiary,\r\n        uint256 _amount,\r\n        uint256 _blockHeight,\r\n        bytes32 _hashLock\r\n    );\r\n\r\n    /** Emitted whenever a unstake process is complete. */\r\n    event UnstakeProgressed(\r\n        bytes32 indexed _messageHash,\r\n        address _redeemer,\r\n        address _beneficiary,\r\n        uint256 _redeemAmount,\r\n        uint256 _unstakeAmount,\r\n        uint256 _rewardAmount,\r\n        bool _proofProgress,\r\n        bytes32 _unlockSecret\r\n    );\r\n\r\n    /** Emitted whenever a revert redeem intent is confirmed. */\r\n    event RevertRedeemIntentConfirmed(\r\n        bytes32 indexed _messageHash,\r\n        address _redeemer,\r\n        uint256 _redeemerNonce,\r\n        uint256 _amount\r\n    );\r\n\r\n    /** Emitted whenever revert redeem is completed. */\r\n    event RevertRedeemComplete(\r\n        bytes32 indexed _messageHash,\r\n        address _redeemer,\r\n        uint256 _redeemerNonce,\r\n        uint256 _amount\r\n    );\r\n\r\n\r\n    /* Struct */\r\n\r\n    /**\r\n     * Stake stores the stake amount, beneficiary address, message data and\r\n     * facilitator address.\r\n     */\r\n    struct Stake {\r\n\r\n        /** Amount that will be staked. */\r\n        uint256 amount;\r\n\r\n        /**\r\n         * Address where the utility tokens will be minted in the\r\n         * auxiliary chain.\r\n         */\r\n        address beneficiary;\r\n\r\n        /** Bounty kept by facilitator for stake message transfer. */\r\n        uint256 bounty;\r\n    }\r\n\r\n    /**\r\n     * Unstake stores the unstake/redeem information\r\n     * like unstake/redeem amount, beneficiary address, message data.\r\n     */\r\n    struct Unstake {\r\n\r\n        /** Amount that will be unstaked. */\r\n        uint256 amount;\r\n\r\n        /** Address that will receive the unstaked token. */\r\n        address beneficiary;\r\n    }\r\n\r\n\r\n    /* Public Variables */\r\n\r\n    /** Specifies if the Gateway is activated for any new process. */\r\n    bool public activated;\r\n\r\n    /** Escrow address to lock staked fund. */\r\n    SimpleStake public stakeVault;\r\n\r\n    /** Address of EIP20 token. */\r\n    EIP20Interface public token;\r\n\r\n    /**\r\n     * Address of ERC20 token in which the facilitator will stake(bounty)\r\n     * for a process.\r\n     */\r\n    EIP20Interface public baseToken;\r\n\r\n    /** Address where token will be burned. */\r\n    address public burner;\r\n\r\n    /** Maps messageHash to the Stake object. */\r\n    mapping(bytes32 /*messageHash*/ =\u003E Stake) stakes;\r\n\r\n    /** Maps messageHash to the Unstake object. */\r\n    mapping(bytes32 /*messageHash*/ =\u003E Unstake) unstakes;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    /** Checks that contract is active. */\r\n    modifier isActive() {\r\n        require(\r\n            activated == true,\r\n            \u0022Gateway is not activated.\u0022\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     * @notice Initialize the contract by providing the ERC20 token address\r\n     *         for which the gateway will enable facilitation of stake and\r\n     *         mint.\r\n     *\r\n     * @param _token The ERC20 token contract address that will be\r\n     *               staked and corresponding utility tokens will be minted\r\n     *               in auxiliary chain.\r\n     * @param _baseToken The ERC20 token address that will be used for\r\n     *                     staking bounty from the facilitators.\r\n     * @param _stateRootProvider Contract address which implements\r\n     *                           StateRootInterface.\r\n     * @param _bounty The amount that facilitator will stakes to initiate the\r\n     *                stake process.\r\n     * @param _organization Address of an organization contract.\r\n     * @param _burner Address where tokens will be burned.\r\n     */\r\n    constructor(\r\n        EIP20Interface _token,\r\n        EIP20Interface _baseToken,\r\n        StateRootInterface _stateRootProvider,\r\n        uint256 _bounty,\r\n        OrganizationInterface _organization,\r\n        address _burner\r\n    )\r\n        GatewayBase(\r\n            _stateRootProvider,\r\n            _bounty,\r\n            _organization\r\n        )\r\n        public\r\n    {\r\n        require(\r\n            address(_token) != address(0),\r\n            \u0022Token contract address must not be zero.\u0022\r\n        );\r\n        require(\r\n            address(_baseToken) != address(0),\r\n            \u0022Base token contract address for bounty must not be zero\u0022\r\n        );\r\n        token = _token;\r\n        baseToken = _baseToken;\r\n        burner = _burner;\r\n        // gateway is in-active initially.\r\n        activated = false;\r\n        // deploy simpleStake contract that will keep the staked amounts.\r\n        stakeVault = new SimpleStake(_token, address(this));\r\n    }\r\n\r\n\r\n    /* External functions */\r\n\r\n    /**\r\n     * @notice Initiates the stake process.  In order to stake the staker\r\n     *         needs to approve Gateway contract for stake amount.\r\n     *         Staked amount is transferred from staker address to\r\n     *         Gateway contract. Bounty amount is also transferred from staker.\r\n     *\r\n     * @param _amount Stake amount that will be transferred from the staker\r\n     *                account.\r\n     * @param _beneficiary The address in the auxiliary chain where the utility\r\n     *                     tokens will be minted.\r\n     * @param _gasPrice Gas price that staker is ready to pay to get the stake\r\n     *                  and mint process done.\r\n     * @param _gasLimit Gas limit that staker is ready to pay.\r\n     * @param _nonce Nonce of the staker address.\r\n     * @param _hashLock Hash Lock provided by the facilitator.\r\n     *\r\n     * @return messageHash_ Message hash is unique for each request.\r\n     */\r\n    function stake(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        uint256 _nonce,\r\n        bytes32 _hashLock\r\n    )\r\n        external\r\n        isActive\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        address staker = msg.sender;\r\n\r\n        require(\r\n            _amount \u003E uint256(0),\r\n            \u0022Stake amount must not be zero.\u0022\r\n        );\r\n\r\n        require(\r\n            _beneficiary != address(0),\r\n            \u0022Beneficiary address must not be zero.\u0022\r\n        );\r\n\r\n        /*\r\n         * Maximum reward possible is _gasPrice * _gasLimit, we check this\r\n         * upfront in this function to make sure that after minting of the\r\n         * tokens it is possible to give the reward to the facilitator.\r\n         */\r\n        require(\r\n            _amount \u003E _gasPrice.mul(_gasLimit),\r\n            \u0022Maximum possible reward must be less than the stake amount.\u0022\r\n        );\r\n\r\n        // Get the stake intent hash.\r\n        bytes32 intentHash = GatewayLib.hashStakeIntent(\r\n            _amount,\r\n            _beneficiary,\r\n            address(this)\r\n        );\r\n\r\n        MessageBus.Message memory message = getMessage(\r\n            intentHash,\r\n            _nonce,\r\n            _gasPrice,\r\n            _gasLimit,\r\n            staker,\r\n            _hashLock\r\n        );\r\n\r\n        messageHash_ = storeMessage(message);\r\n\r\n        registerOutboxProcess(\r\n            staker,\r\n            _nonce,\r\n            messageHash_\r\n        );\r\n\r\n        // New stake object\r\n        stakes[messageHash_] = Stake({\r\n            amount : _amount,\r\n            beneficiary : _beneficiary,\r\n            bounty : bounty\r\n        });\r\n\r\n        // Declare message in outbox\r\n        MessageBus.declareMessage(\r\n            messageBox,\r\n            messages[messageHash_]\r\n        );\r\n\r\n        // Transfer staker amount to the gateway.\r\n        require(\r\n            token.transferFrom(staker, address(this), _amount),\r\n            \u0022Stake amount must be transferred to gateway\u0022\r\n        );\r\n\r\n        // Transfer the bounty amount to the gateway.\r\n        require(\r\n            baseToken.transferFrom(staker, address(this), bounty),\r\n            \u0022Bounty amount must be transferred to gateway\u0022\r\n        );\r\n\r\n        emit StakeIntentDeclared(\r\n            messageHash_,\r\n            staker,\r\n            _nonce,\r\n            _beneficiary,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Completes the stake process.\r\n     *\r\n     * @dev Message bus ensures correct execution sequence of methods and also\r\n     *      provides safety mechanism for any possible re-entrancy attack.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _unlockSecret Unlock secret for the hashLock provide by the\r\n     *                      staker while initiating the stake.\r\n     *\r\n     * @return staker_ Staker address.\r\n     * @return stakeAmount_ Stake amount.\r\n     */\r\n    function progressStake(\r\n        bytes32 _messageHash,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (\r\n            address staker_,\r\n            uint256 stakeAmount_\r\n        )\r\n    {\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero\u0022\r\n        );\r\n\r\n        // Get the message object\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        // Progress outbox\r\n        MessageBus.progressOutbox(\r\n            messageBox,\r\n            message,\r\n            _unlockSecret\r\n        );\r\n\r\n        (staker_, stakeAmount_) = progressStakeInternal(\r\n            _messageHash,\r\n            message,\r\n            _unlockSecret,\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Completes the stake process by providing the merkle proof\r\n     *         instead of unlockSecret. In case the facilitator process is not\r\n     *         able to complete the stake and mint process then this is an\r\n     *         alternative approach to complete the process\r\n     *\r\n     * @dev This can be called to prove that the inbox status of messageBox on\r\n     *      CoGateway is either declared or progressed.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox of CoGateway.\r\n     * @param _blockHeight Block number for which the proof is valid.\r\n     * @param _messageStatus Message status i.e. Declared or Progressed that\r\n     *                       will be proved.\r\n     *\r\n     * @return staker_ Staker address\r\n     * @return stakeAmount_ Stake amount\r\n     */\r\n    function progressStakeWithProof(\r\n        bytes32 _messageHash,\r\n        bytes calldata _rlpParentNodes,\r\n        uint256 _blockHeight,\r\n        uint256 _messageStatus\r\n    )\r\n        external\r\n        returns (\r\n            address staker_,\r\n            uint256 stakeAmount_\r\n        )\r\n    {\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n        require(\r\n            _rlpParentNodes.length \u003E 0,\r\n            \u0022RLP encoded parent nodes must not be zero.\u0022\r\n        );\r\n\r\n        bytes32 storageRoot = storageRoots[_blockHeight];\r\n\r\n        require(\r\n            storageRoot != bytes32(0),\r\n            \u0022Storage root must not be zero.\u0022\r\n        );\r\n\r\n        // Get the message object\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        MessageBus.progressOutboxWithProof(\r\n            messageBox,\r\n            message,\r\n            _rlpParentNodes,\r\n            MESSAGE_BOX_OFFSET,\r\n            storageRoot,\r\n            MessageBus.MessageStatus(_messageStatus)\r\n        );\r\n\r\n        (staker_, stakeAmount_) = progressStakeInternal(\r\n            _messageHash,\r\n            message,\r\n            bytes32(0),\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Revert stake process and get the stake\r\n     *         amount back. Only staker can revert stake by providing\r\n     *         penalty i.e. 1.5 times of bounty amount. On progress revert stake\r\n     *         penalty and facilitator bounty will be burned.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     *\r\n     * @return staker_ Staker address\r\n     * @return stakerNonce_ Staker nonce\r\n     * @return amount_ Stake amount\r\n     */\r\n    function revertStake(\r\n        bytes32 _messageHash\r\n    )\r\n        external\r\n        returns (\r\n            address staker_,\r\n            uint256 stakerNonce_,\r\n            uint256 amount_\r\n        )\r\n    {\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        require(\r\n            message.sender == msg.sender,\r\n            \u0022Only staker can revert stake.\u0022\r\n        );\r\n\r\n        // Declare stake revocation.\r\n        MessageBus.declareRevocationMessage(\r\n            messageBox,\r\n            message\r\n        );\r\n\r\n        staker_ = message.sender;\r\n        stakerNonce_ = message.nonce;\r\n        amount_ = stakes[_messageHash].amount;\r\n\r\n        // Penalty charged to staker for revert stake.\r\n        uint256 penalty = penaltyFromBounty(stakes[_messageHash].bounty);\r\n\r\n        // Transfer the penalty amount to burner.\r\n        require(\r\n            baseToken.transferFrom(msg.sender, burner, penalty),\r\n            \u0022Staker must approve gateway for penalty amount.\u0022\r\n        );\r\n\r\n        emit RevertStakeIntentDeclared(\r\n            _messageHash,\r\n            staker_,\r\n            stakerNonce_,\r\n            amount_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Complete revert stake by providing the merkle proof.\r\n     *         This method will return stake amount to staker and burn\r\n     *         facilitator bounty.\r\n     *\r\n     * @dev Message bus ensures correct execution sequence of methods and also\r\n     *      provides safety mechanism for any possible re-entrancy attack.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _blockHeight Block number for which the proof is valid\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove\r\n     *                        DeclaredRevocation in messageBox inbox of\r\n     *                        CoGateway.\r\n     *\r\n     * @return staker_ Staker address.\r\n     * @return stakerNonce_ Staker nonce.\r\n     * @return amount_ Stake amount.\r\n     */\r\n    function progressRevertStake(\r\n        bytes32 _messageHash,\r\n        uint256 _blockHeight,\r\n        bytes calldata _rlpParentNodes\r\n    )\r\n        external\r\n        returns (\r\n            address staker_,\r\n            uint256 stakerNonce_,\r\n            uint256 amount_\r\n        )\r\n    {\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n        require(\r\n            _rlpParentNodes.length \u003E 0,\r\n            \u0022RLP parent nodes must not be zero.\u0022\r\n        );\r\n\r\n        // Get the message object.\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n        require(\r\n            message.intentHash != bytes32(0),\r\n            \u0022StakeIntentHash must not be zero.\u0022\r\n        );\r\n\r\n        // Get the storageRoot for the given block height.\r\n        bytes32 storageRoot = storageRoots[_blockHeight];\r\n        require(\r\n            storageRoot != bytes32(0),\r\n            \u0022Storage root must not be zero.\u0022\r\n        );\r\n\r\n        amount_ = stakes[_messageHash].amount;\r\n\r\n        require(\r\n            amount_ \u003E 0,\r\n            \u0022Stake request must exist.\u0022\r\n        );\r\n\r\n        staker_ = message.sender;\r\n        stakerNonce_ = message.nonce;\r\n        uint256 stakeBounty = stakes[_messageHash].bounty;\r\n\r\n        // Progress with revocation message.\r\n        MessageBus.progressOutboxRevocation(\r\n            messageBox,\r\n            message,\r\n            MESSAGE_BOX_OFFSET,\r\n            _rlpParentNodes,\r\n            storageRoot,\r\n            MessageBus.MessageStatus.Revoked\r\n        );\r\n\r\n        delete stakes[_messageHash];\r\n\r\n        // Transfer the staked amount to the staker.\r\n        token.transfer(message.sender, amount_);\r\n\r\n        // Burn facilitator bounty.\r\n        baseToken.transfer(burner, stakeBounty);\r\n\r\n        emit StakeReverted(\r\n            _messageHash,\r\n            staker_,\r\n            stakerNonce_,\r\n            amount_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Declare redeem intent.\r\n     *\r\n     * @param _redeemer Redeemer address.\r\n     * @param _redeemerNonce Redeemer nonce.\r\n     * @param _beneficiary Address where the redeemed tokens will be\r\n     *                     transferred.\r\n     * @param _amount Redeem amount.\r\n     * @param _gasPrice Gas price that redeemer is ready to pay to get the\r\n     *                  redeem and unstake process done.\r\n     * @param _gasLimit Gas limit that redeemer is ready to pay.\r\n     * @param _blockHeight Block number for which the proof is valid.\r\n     * @param _hashLock Hash lock.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove\r\n     *                        Declared in messageBox outbox of\r\n     *                        CoGateway.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function confirmRedeemIntent(\r\n        address _redeemer,\r\n        uint256 _redeemerNonce,\r\n        address _beneficiary,\r\n        uint256 _amount,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        uint256 _blockHeight,\r\n        bytes32 _hashLock,\r\n        bytes calldata _rlpParentNodes\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        // Get the initial gas.\r\n        uint256 initialGas = gasleft();\r\n\r\n        require(\r\n            _redeemer != address(0),\r\n            \u0022Redeemer address must not be zero.\u0022\r\n        );\r\n        require(\r\n            _beneficiary != address(0),\r\n            \u0022Beneficiary address must not be zero.\u0022\r\n        );\r\n        require(\r\n            _amount != 0,\r\n            \u0022Redeem amount must not be zero.\u0022\r\n        );\r\n        require(\r\n            _rlpParentNodes.length \u003E 0,\r\n            \u0022RLP encoded parent nodes must not be zero.\u0022\r\n        );\r\n\r\n        /*\r\n         * Maximum reward possible is _gasPrice * _gasLimit, we check this\r\n         * upfront in this function to make sure that after unstake of the\r\n         * tokens it is possible to give the reward to the facilitator.\r\n         */\r\n        require(\r\n            _amount \u003E _gasPrice.mul(_gasLimit),\r\n            \u0022Maximum possible reward must be less than the redeem amount.\u0022\r\n        );\r\n\r\n        bytes32 intentHash = hashRedeemIntent(\r\n            _amount,\r\n            _beneficiary\r\n        );\r\n\r\n        MessageBus.Message memory message = MessageBus.Message(\r\n            intentHash,\r\n            _redeemerNonce,\r\n            _gasPrice,\r\n            _gasLimit,\r\n            _redeemer,\r\n            _hashLock,\r\n            0 // Gas consumed will be updated at the end of this function.\r\n        );\r\n        messageHash_ = storeMessage(message);\r\n\r\n        registerInboxProcess(\r\n            message.sender,\r\n            message.nonce,\r\n            messageHash_\r\n        );\r\n\r\n        unstakes[messageHash_] = Unstake({\r\n            amount : _amount,\r\n            beneficiary : _beneficiary\r\n        });\r\n\r\n        confirmRedeemIntentInternal(\r\n            messages[messageHash_],\r\n            _blockHeight,\r\n            _rlpParentNodes\r\n        );\r\n\r\n        // Emit RedeemIntentConfirmed event.\r\n        emit RedeemIntentConfirmed(\r\n            messageHash_,\r\n            _redeemer,\r\n            _redeemerNonce,\r\n            _beneficiary,\r\n            _amount,\r\n            _blockHeight,\r\n            _hashLock\r\n        );\r\n\r\n        // Update the gas consumed for this function.\r\n        messages[messageHash_].gasConsumed = initialGas.sub(gasleft());\r\n    }\r\n\r\n    /**\r\n     * @notice Complete unstake.\r\n     *\r\n     * @dev Message bus ensures correct execution sequence of methods and also\r\n     *      provides safety mechanism for any possible re-entrancy attack.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _unlockSecret Unlock secret for the hashLock provide by the\r\n     *                      facilitator while initiating the redeem.\r\n     *\r\n     * @return redeemer_ Redeemer address.\r\n     * @return redeemAmount_ Total amount for which the redeem was\r\n     *                       initiated. The reward amount is deducted from the\r\n     *                       total redeem amount and is given to the\r\n     *                       facilitator.\r\n     * @return unstakeAmount_ Actual unstake amount, after deducting the reward\r\n     *                        from the total redeem amount.\r\n     * @return rewardAmount_ Reward amount that is transferred to facilitator.\r\n     */\r\n    function progressUnstake(\r\n        bytes32 _messageHash,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (\r\n            uint256 redeemAmount_,\r\n            uint256 unstakeAmount_,\r\n            uint256 rewardAmount_\r\n        )\r\n    {\r\n        // Get the inital gas.\r\n        uint256 initialGas = gasleft();\r\n\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        MessageBus.progressInbox(\r\n            messageBox,\r\n            message,\r\n            _unlockSecret\r\n        );\r\n        (redeemAmount_, unstakeAmount_, rewardAmount_) =\r\n        progressUnstakeInternal(_messageHash, initialGas, _unlockSecret, false);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the penalty amount. If the message hash does not exist in\r\n     *         stakes mapping it will return zero amount. If the message is\r\n     *         already progressed or revoked then the penalty amount will be\r\n     *         zero.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     *\r\n     * @return penalty_ Penalty amount.\r\n     */\r\n    function penalty(bytes32 _messageHash)\r\n        external\r\n        view\r\n        returns (uint256 penalty_)\r\n    {\r\n        penalty_ = super.penaltyFromBounty(stakes[_messageHash].bounty);\r\n    }\r\n\r\n    /**\r\n     * @notice Completes the redeem process by providing the merkle proof\r\n     *         instead of unlockSecret. In case the facilitator process is not\r\n     *         able to complete the redeem and unstake process then this is an\r\n     *         alternative approach to complete the process\r\n     *\r\n     * @dev This can be called to prove that the outbox status of messageBox on\r\n     *      CoGateway is either declared or progressed.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox inbox of CoGateway.\r\n     * @param _blockHeight Block number for which the proof is valid.\r\n     * @param _messageStatus Message status i.e. Declared or Progressed that\r\n     *                       will be proved.\r\n     *\r\n     * @return redeemAmount_ Total amount for which the redeem was\r\n     *                       initiated. The reward amount is deducted from the\r\n     *                       total redeem amount and is given to the\r\n     *                       facilitator.\r\n     * @return unstakeAmount_ Actual unstake amount, after deducting the reward\r\n     *                        from the total redeem amount.\r\n     * @return rewardAmount_ Reward amount that is transferred to facilitator.\r\n     */\r\n    function progressUnstakeWithProof(\r\n        bytes32 _messageHash,\r\n        bytes calldata _rlpParentNodes,\r\n        uint256 _blockHeight,\r\n        uint256 _messageStatus\r\n    )\r\n        external\r\n        returns (\r\n            uint256 redeemAmount_,\r\n            uint256 unstakeAmount_,\r\n            uint256 rewardAmount_\r\n        )\r\n    {\r\n        // Get the initial gas.\r\n        uint256 initialGas = gasleft();\r\n\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n        require(\r\n            _rlpParentNodes.length \u003E 0,\r\n            \u0022RLP parent nodes must not be zero\u0022\r\n        );\r\n\r\n        // Get the storage root for the given block height.\r\n        bytes32 storageRoot = storageRoots[_blockHeight];\r\n        require(\r\n            storageRoot != bytes32(0),\r\n            \u0022Storage root must not be zero\u0022\r\n        );\r\n\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        MessageBus.progressInboxWithProof(\r\n            messageBox,\r\n            message,\r\n            _rlpParentNodes,\r\n            MESSAGE_BOX_OFFSET,\r\n            storageRoot,\r\n            MessageBus.MessageStatus(_messageStatus)\r\n        );\r\n\r\n        (redeemAmount_, unstakeAmount_, rewardAmount_) =\r\n        progressUnstakeInternal(_messageHash, initialGas, bytes32(0), true);\r\n    }\r\n\r\n    /**\r\n     * @notice Declare redeem revert intent.\r\n     *         This will set message status to revoked. This method will also\r\n     *         clear unstakes mapping storage.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _blockHeight Block number for which the proof is valid.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove\r\n     *                        DeclaredRevocation in messageBox outbox of\r\n     *                        CoGateway.\r\n     *\r\n     * @return redeemer_ Redeemer address.\r\n     * @return redeemerNonce_ Redeemer nonce.\r\n     * @return amount_ Redeem amount.\r\n     */\r\n    function confirmRevertRedeemIntent(\r\n        bytes32 _messageHash,\r\n        uint256 _blockHeight,\r\n        bytes calldata _rlpParentNodes\r\n    )\r\n        external\r\n        returns (\r\n            address redeemer_,\r\n            uint256 redeemerNonce_,\r\n            uint256 amount_\r\n        )\r\n    {\r\n\r\n        require(\r\n            _messageHash != bytes32(0),\r\n            \u0022Message hash must not be zero.\u0022\r\n        );\r\n        require(\r\n            _rlpParentNodes.length \u003E 0,\r\n            \u0022RLP parent nodes must not be zero.\u0022\r\n        );\r\n\r\n        amount_ = unstakes[_messageHash].amount;\r\n\r\n        require(\r\n            amount_ \u003E uint256(0),\r\n            \u0022Unstake amount must not be zero.\u0022\r\n        );\r\n\r\n        delete unstakes[_messageHash];\r\n\r\n        // Get the message object.\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n        require(\r\n            message.intentHash != bytes32(0),\r\n            \u0022RevertRedeem intent hash must not be zero.\u0022\r\n        );\r\n\r\n        // Get the storage root\r\n        bytes32 storageRoot = storageRoots[_blockHeight];\r\n        require(\r\n            storageRoot != bytes32(0),\r\n            \u0022Storage root must not be zero.\u0022\r\n        );\r\n\r\n        // Confirm revocation\r\n        MessageBus.confirmRevocation(\r\n            messageBox,\r\n            message,\r\n            _rlpParentNodes,\r\n            MESSAGE_BOX_OFFSET,\r\n            storageRoot\r\n        );\r\n\r\n        redeemer_ = message.sender;\r\n        redeemerNonce_ = message.nonce;\r\n\r\n        emit RevertRedeemIntentConfirmed(\r\n            _messageHash,\r\n            redeemer_,\r\n            redeemerNonce_,\r\n            amount_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Activate Gateway contract. Can be set only by the\r\n     *         Organization address only once by passing co-gateway address.\r\n     *\r\n     * @param _coGatewayAddress Address of cogateway.\r\n     *\r\n     * @return success_ \u0060true\u0060 if value is set\r\n     */\r\n    function activateGateway(\r\n            address _coGatewayAddress\r\n    )\r\n        external\r\n        onlyOrganization\r\n        returns (bool success_)\r\n    {\r\n\r\n        require(\r\n            _coGatewayAddress != address(0),\r\n            \u0022Co-gateway address must not be zero.\u0022\r\n        );\r\n        require(\r\n            remoteGateway == address(0),\r\n            \u0022Gateway was already activated once.\u0022\r\n        );\r\n\r\n        remoteGateway = _coGatewayAddress;\r\n\r\n        // update the encodedGatewayPath\r\n        encodedGatewayPath = BytesLib.bytes32ToBytes(\r\n            keccak256(abi.encodePacked(remoteGateway))\r\n        );\r\n        activated = true;\r\n        success_ = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Deactivate Gateway contract. Can be set only by the\r\n     *         organization address\r\n     *\r\n     * @return success_  \u0060true\u0060 if value is set\r\n     */\r\n    function deactivateGateway()\r\n        external\r\n        onlyOrganization\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            activated == true,\r\n            \u0022Gateway is already deactivated.\u0022\r\n        );\r\n        activated = false;\r\n        success_ = true;\r\n    }\r\n\r\n\r\n    /* Private functions */\r\n\r\n    /**\r\n     * @notice Private function to execute confirm redeem intent.\r\n     *\r\n     * @dev This function is to avoid stack too deep error in\r\n     *      confirmRedeemIntent function.\r\n     *\r\n     * @param _message Message object.\r\n     * @param _blockHeight Block number for which the proof is valid.\r\n     * @param _rlpParentNodes RLP encoded parent nodes.\r\n     *\r\n     * @return \u0060true\u0060 if executed successfully.\r\n     */\r\n    function confirmRedeemIntentInternal(\r\n        MessageBus.Message storage _message,\r\n        uint256 _blockHeight,\r\n        bytes memory _rlpParentNodes\r\n    )\r\n        private\r\n        returns (bool)\r\n    {\r\n        // Get storage root.\r\n        bytes32 storageRoot = storageRoots[_blockHeight];\r\n        require(\r\n            storageRoot != bytes32(0),\r\n            \u0022Storage root must not be zero.\u0022\r\n        );\r\n\r\n        // Confirm message.\r\n        MessageBus.confirmMessage(\r\n            messageBox,\r\n            _message,\r\n            _rlpParentNodes,\r\n            MESSAGE_BOX_OFFSET,\r\n            storageRoot\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Private function contains logic for process stake.\r\n     *\r\n     * @param _messageHash Message hash.\r\n     * @param _message Message object.\r\n     * @param _unlockSecret For process with hash lock, proofProgress event\r\n     *                      param is set to false otherwise set to true.\r\n     *\r\n     * @return staker_ Staker address\r\n     * @return stakeAmount_ Stake amount\r\n     */\r\n    function progressStakeInternal(\r\n        bytes32 _messageHash,\r\n        MessageBus.Message storage _message,\r\n        bytes32 _unlockSecret,\r\n        bool _proofProgress\r\n    )\r\n        private\r\n        returns (\r\n            address staker_,\r\n            uint256 stakeAmount_\r\n        )\r\n    {\r\n\r\n        // Get the staker address\r\n        staker_ = _message.sender;\r\n\r\n        // Get the stake amount.\r\n        stakeAmount_ = stakes[_messageHash].amount;\r\n\r\n        require(\r\n            stakeAmount_ \u003E 0,\r\n            \u0022Stake request must exist.\u0022\r\n        );\r\n\r\n        uint256 stakedBounty = stakes[_messageHash].bounty;\r\n\r\n        delete stakes[_messageHash];\r\n\r\n        // Transfer the staked amount to stakeVault.\r\n        token.transfer(address(stakeVault), stakeAmount_);\r\n\r\n        baseToken.transfer(msg.sender, stakedBounty);\r\n\r\n        emit StakeProgressed(\r\n            _messageHash,\r\n            staker_,\r\n            _message.nonce,\r\n            stakeAmount_,\r\n            _proofProgress,\r\n            _unlockSecret\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This is internal method for process unstake called from external\r\n     *         methods which processUnstake(with hashlock) and\r\n     *         processUnstakeWithProof\r\n     *\r\n     * @param _messageHash hash to identify message\r\n     * @param _initialGas initial available gas during process unstake call.\r\n     * @param _unlockSecret Block number for which the proof is valid\r\n     * @param _proofProgress true if progress with proof and false if\r\n     *                       progress with unlock secret.\r\n     *\r\n     * @return redeemAmount_ Total amount for which the redeem was\r\n     *                       initiated. The reward amount is deducted from the\r\n     *                       total redeem amount and is given to the\r\n     *                       facilitator.\r\n     * @return unstakeAmount_ Actual unstake amount, after deducting the reward\r\n     *                        from the total redeem amount.\r\n     * @return rewardAmount_ Reward amount that is transferred to facilitator\r\n     */\r\n    function progressUnstakeInternal(\r\n        bytes32 _messageHash,\r\n        uint256 _initialGas,\r\n        bytes32 _unlockSecret,\r\n        bool _proofProgress\r\n    )\r\n        private\r\n        returns (\r\n            uint256 redeemAmount_,\r\n            uint256 unstakeAmount_,\r\n            uint256 rewardAmount_\r\n        )\r\n    {\r\n\r\n        Unstake storage unStake = unstakes[_messageHash];\r\n        // Get the message object.\r\n        MessageBus.Message storage message = messages[_messageHash];\r\n\r\n        redeemAmount_ = unStake.amount;\r\n\r\n        require(\r\n            redeemAmount_ \u003E 0,\r\n            \u0022Unstake request must exist.\u0022\r\n        );\r\n        /*\r\n         * Reward calculation depends upon\r\n         *  - the gas consumed in target chain for confirmation and progress steps.\r\n         *  - gas price and gas limit provided in the message.\r\n         */\r\n        (rewardAmount_, message.gasConsumed) = feeAmount(\r\n            message.gasConsumed,\r\n            message.gasLimit,\r\n            message.gasPrice,\r\n            _initialGas\r\n        );\r\n\r\n        unstakeAmount_ = redeemAmount_.sub(rewardAmount_);\r\n\r\n        address beneficiary = unstakes[_messageHash].beneficiary;\r\n\r\n        delete unstakes[_messageHash];\r\n\r\n        // Release the amount to beneficiary, but with reward subtracted.\r\n        stakeVault.releaseTo(beneficiary, unstakeAmount_);\r\n\r\n        // Reward facilitator with the reward amount.\r\n        stakeVault.releaseTo(msg.sender, rewardAmount_);\r\n\r\n        emit UnstakeProgressed(\r\n            _messageHash,\r\n            message.sender,\r\n            beneficiary,\r\n            redeemAmount_,\r\n            unstakeAmount_,\r\n            rewardAmount_,\r\n            _proofProgress,\r\n            _unlockSecret\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Private function to calculate redeem intent hash.\r\n     *\r\n     * @dev This function is to avoid stack too deep error in\r\n     *      confirmRedeemIntent function.\r\n     *\r\n     * @param _amount Redeem amount.\r\n     * @param _beneficiary Unstake account.\r\n     *\r\n     * @return bytes32 Redeem intent hash.\r\n     */\r\n    function hashRedeemIntent(\r\n        uint256 _amount,\r\n        address _beneficiary\r\n    )\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return GatewayLib.hashRedeemIntent(\r\n            _amount,\r\n            _beneficiary,\r\n            remoteGateway\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022proposedBountyUnlockHeight\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_proposedBounty\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022initiateBountyAmountChange\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getOutboxActiveProcess\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022messageHash_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022status_\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022activated\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022revertStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staker_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022stakerNonce_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022amount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_rlpAccount\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022proveGateway\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022organization\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022penalty\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022penalty_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022burner\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022messages\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022intentHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022gasPrice\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022gasLimit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022sender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022hashLock\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022gasConsumed\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022deactivateGateway\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022success_\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getNonce\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022confirmRevertRedeemIntent\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022redeemer_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022redeemerNonce_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022amount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022stakeVault\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022getInboxMessageStatus\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022status_\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_unlockSecret\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022progressStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staker_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022stakeAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_redeemerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_gasPrice\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_gasLimit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_hashLock\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022confirmRedeemIntent\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022messageHash_\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022remoteGateway\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_gasPrice\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_gasLimit\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_nonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_hashLock\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022stake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022messageHash_\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022BOUNTY_CHANGE_UNLOCK_PERIOD\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022bounty\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022proposedBounty\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getInboxActiveProcess\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022messageHash_\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022status_\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022getOutboxMessageStatus\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022status_\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022encodedGatewayPath\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022baseToken\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_messageStatus\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022progressUnstakeWithProof\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022redeemAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022unstakeAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rewardAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_unlockSecret\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022progressUnstake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022redeemAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022unstakeAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022rewardAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022stateRootProvider\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022confirmBountyAmountChange\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022changedBountyAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022previousBountyAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022},{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_messageStatus\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022progressStakeWithProof\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staker_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022stakeAmount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_coGatewayAddress\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022activateGateway\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022success_\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022token\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_rlpParentNodes\u0022,\u0022type\u0022:\u0022bytes\u0022}],\u0022name\u0022:\u0022progressRevertStake\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022staker_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022stakerNonce_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022amount_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022inputs\u0022:[{\u0022name\u0022:\u0022_token\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_baseToken\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_stateRootProvider\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_bounty\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022name\u0022:\u0022_organization\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_burner\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_stakerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022StakeIntentDeclared\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_stakerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_proofProgress\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_unlockSecret\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022StakeProgressed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_stakerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RevertStakeIntentDeclared\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_staker\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_stakerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022StakeReverted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_hashLock\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022RedeemIntentConfirmed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_beneficiary\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_unstakeAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_rewardAmount\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_proofProgress\u0022,\u0022type\u0022:\u0022bool\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_unlockSecret\u0022,\u0022type\u0022:\u0022bytes32\u0022}],\u0022name\u0022:\u0022UnstakeProgressed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RevertRedeemIntentConfirmed\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022name\u0022:\u0022_messageHash\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemer\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_redeemerNonce\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_amount\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022RevertRedeemComplete\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_gateway\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_blockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_storageRoot\u0022,\u0022type\u0022:\u0022bytes32\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_wasAlreadyProved\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022GatewayProven\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_currentBounty\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_proposedBounty\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_unlockHeight\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022BountyChangeInitiated\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_currentBounty\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_changedBounty\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022BountyChangeConfirmed\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"EIP20Gateway","CompilerVersion":"v0.5.3\u002Bcommit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008d3d262fb1139d5d55d9ccbe7fff5fc45f2421840000000000000000000000002c4e8f2d746113d0696ce89b35f0d8bf88e0aeca000000000000000000000000981884d4369f7b7892d8c279d2125daf7422d9e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000377cecea5900b9483320dff639ca49a7e2df15d10000000000000000000000000000000000000000000000000000000000000000","Library":"MessageBus:0b71bb83d2814633f7dfeb9cb5c4c2e63be215ed;GatewayLib:1c9e18c8ab156753f7eca95d8c042f7842aaf09e","SwarmSource":"bzzr://1398521340a46f26b3ae7a7c96182dd2ccac69772131d4910ecfcf5a0fa16880"}]