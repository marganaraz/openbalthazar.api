[{"SourceCode":"// File: contracts/ITransferRules.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\ncontract ITransferRules {\r\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n    /// @param from Sending address\r\n    /// @param to Receiving address\r\n    /// @param value Amount of tokens being transferred\r\n    /// @return Code by which to reference message for rejection reasoning\r\n    function detectTransferRestriction(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external view returns (uint8);\r\n\r\n    /// @notice Returns a human-readable message for a given restriction code\r\n    /// @param restrictionCode Identifier for looking up a message\r\n    /// @return Text showing the restriction\u0027s reasoning\r\n    function messageForTransferRestriction(uint8 restrictionCode)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function checkSuccess(uint8 restrictionCode) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address =\u003E bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \u0022Roles: account already has role\u0022);\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account\u0027s access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \u0022Roles: account does not have role\u0022);\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \u0022Roles: account is the zero address\u0022);\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see \u0060ERC20Detailed\u0060.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by \u0060account\u0060.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from the caller\u0027s account to \u0060recipient\u0060.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that \u0060spender\u0060 will be\r\n     * allowed to spend on behalf of \u0060owner\u0060 through \u0060transferFrom\u0060. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when \u0060approve\u0060 or \u0060transferFrom\u0060 are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003E Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves \u0060amount\u0060 tokens from \u0060sender\u0060 to \u0060recipient\u0060 using the\r\n     * allowance mechanism. \u0060amount\u0060 is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when \u0060value\u0060 tokens are moved from one account (\u0060from\u0060) to\r\n     * another (\u0060to\u0060).\r\n     *\r\n     * Note that \u0060value\u0060 may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a \u0060spender\u0060 for an \u0060owner\u0060 is set by\r\n     * a call to \u0060approve\u0060. \u0060value\u0060 is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * \u0060SafeMath\u0060 restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060\u002B\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a \u002B b;\r\n        require(c \u003E= a, \u0022SafeMath: addition overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060-\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003C= a, \u0022SafeMath: subtraction overflow\u0022);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060*\u0060 operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0022SafeMath: multiplication overflow\u0022);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060/\u0060 operator. Note: this function uses a\r\n     * \u0060revert\u0060 opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003E 0, \u0022SafeMath: division by zero\u0022);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c \u002B a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s \u0060%\u0060 operator. This function uses a \u0060revert\u0060\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0022SafeMath: modulo by zero\u0022);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the \u0060IERC20\u0060 interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using \u0060_mint\u0060.\r\n * For a generic mechanism see \u0060ERC20Mintable\u0060.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning \u0060false\u0060 on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an \u0060Approval\u0060 event is emitted on calls to \u0060transferFrom\u0060.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard \u0060decreaseAllowance\u0060 and \u0060increaseAllowance\u0060\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See \u0060IERC20.approve\u0060.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003E uint256) private _balances;\r\n\r\n    mapping (address =\u003E mapping (address =\u003E uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.totalSupply\u0060.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.balanceOf\u0060.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.transfer\u0060.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - the caller must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.allowance\u0060.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.approve\u0060.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See \u0060IERC20.transferFrom\u0060.\r\n     *\r\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of \u0060ERC20\u0060;\r\n     *\r\n     * Requirements:\r\n     * - \u0060sender\u0060 and \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060value\u0060.\r\n     * - the caller must have allowance for \u0060sender\u0060\u0027s tokens of at least\r\n     * \u0060amount\u0060.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to \u0060approve\u0060 that can be used as a mitigation for\r\n     * problems described in \u0060IERC20.approve\u0060.\r\n     *\r\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to \u0060spender\u0060 by the caller.\r\n     *\r\n     * This is an alternative to \u0060approve\u0060 that can be used as a mitigation for\r\n     * problems described in \u0060IERC20.approve\u0060.\r\n     *\r\n     * Emits an \u0060Approval\u0060 event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 must have allowance for the caller of at least\r\n     * \u0060subtractedValue\u0060.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens \u0060amount\u0060 from \u0060sender\u0060 to \u0060recipient\u0060.\r\n     *\r\n     * This is internal function is equivalent to \u0060transfer\u0060, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060sender\u0060 cannot be the zero address.\r\n     * - \u0060recipient\u0060 cannot be the zero address.\r\n     * - \u0060sender\u0060 must have a balance of at least \u0060amount\u0060.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \u0022ERC20: transfer from the zero address\u0022);\r\n        require(recipient != address(0), \u0022ERC20: transfer to the zero address\u0022);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates \u0060amount\u0060 tokens and assigns them to \u0060account\u0060, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event with \u0060from\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060to\u0060 cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \u0022ERC20: mint to the zero address\u0022);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys \u0060amount\u0060 tokens from \u0060account\u0060, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a \u0060Transfer\u0060 event with \u0060to\u0060 set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - \u0060account\u0060 cannot be the zero address.\r\n     * - \u0060account\u0060 must have at least \u0060amount\u0060 tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \u0022ERC20: burn from the zero address\u0022);\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets \u0060amount\u0060 as the allowance of \u0060spender\u0060 over the \u0060owner\u0060s tokens.\r\n     *\r\n     * This is internal function is equivalent to \u0060approve\u0060, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an \u0060Approval\u0060 event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - \u0060owner\u0060 cannot be the zero address.\r\n     * - \u0060spender\u0060 cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \u0022ERC20: approve from the zero address\u0022);\r\n        require(spender != address(0), \u0022ERC20: approve to the zero address\u0022);\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys \u0060amount\u0060 tokens from \u0060account\u0060.\u0060amount\u0060 is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See \u0060_burn\u0060 and \u0060_approve\u0060.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: contracts/RestrictedToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title Restricted Token\r\n/// @author CoMakery, Inc.\r\n/// @notice An ERC-20 token with ERC-1404 transfer restrictions for managing security tokens, etc.\r\ncontract RestrictedToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  string public symbol;\r\n  string public name;\r\n  uint8 public decimals;\r\n  ITransferRules public transferRules;\r\n\r\n  using Roles for Roles.Role;\r\n  Roles.Role private _contractAdmins;\r\n  Roles.Role private _transferAdmins;\r\n\r\n  uint256 public maxTotalSupply;\r\n  uint256 public contractAdminCount;\r\n\r\n  // Transfer restriction \u0022eternal storage\u0022 mappings that can be used by future TransferRules contract upgrades\r\n  // They are accessed through getter and setter methods\r\n  mapping(address =\u003E uint256) private _maxBalances;\r\n  mapping(address =\u003E uint256) private _lockUntil; // unix timestamp to lock funds until\r\n  mapping(address =\u003E uint256) private _transferGroups; // restricted groups like Reg D Accredited US, Reg CF Unaccredited US and Reg S Foreign\r\n  mapping(uint256 =\u003E mapping(uint256 =\u003E uint256)) private _allowGroupTransfers; // approve transfers between groups: from =\u003E to =\u003E TimeLockUntil\r\n  mapping(address =\u003E bool) private _frozenAddresses;\r\n\r\n  bool public isPaused = false;\r\n\r\n  uint256 public constant MAX_UINT256 = ((2 ** 255 - 1) * 2) \u002B 1; // get max uint256 without overflow\r\n\r\n  event RoleChange(address indexed grantor, address indexed grantee, string role, bool indexed status);\r\n  event AddressMaxBalance(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressTimeLock(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressTransferGroup(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressFrozen(address indexed admin, address indexed addr, bool indexed status);\r\n  event AllowGroupTransfer(address indexed admin, uint256 indexed fromGroup, uint256 indexed toGroup, uint256 lockedUntil);\r\n\r\n  event Pause(address admin, bool status);\r\n  event Upgrade(address admin, address oldRules, address newRules);\r\n\r\n  constructor(\r\n    address transferRules_,\r\n    address contractAdmin_,\r\n    address tokenReserveAdmin_,\r\n    string memory symbol_,\r\n    string memory name_,\r\n    uint8 decimals_,\r\n    uint256 totalSupply_,\r\n    uint256 maxTotalSupply_\r\n  ) public {\r\n    require(transferRules_ != address(0), \u0022Transfer rules address cannot be 0x0\u0022);\r\n    require(contractAdmin_ != address(0), \u0022Token owner address cannot be 0x0\u0022);\r\n    require(tokenReserveAdmin_ != address(0), \u0022Token reserve admin address cannot be 0x0\u0022);\r\n\r\n    // Transfer rules can be swapped out for a new contract inheriting from the ITransferRules interface\r\n    // The \u0022eternal storage\u0022 for rule data stays in this RestrictedToken contract for use by TransferRules contract upgrades\r\n    transferRules = ITransferRules(transferRules_);\r\n    symbol = symbol_;\r\n    name = name_;\r\n    decimals = decimals_;\r\n    maxTotalSupply = maxTotalSupply_;\r\n\r\n    _contractAdmins.add(contractAdmin_);\r\n    contractAdminCount = 1;\r\n\r\n    _mint(tokenReserveAdmin_, totalSupply_);\r\n  }\r\n\r\n  modifier onlyContractAdmin() {\r\n    require(_contractAdmins.has(msg.sender), \u0022DOES NOT HAVE CONTRACT OWNER ROLE\u0022);\r\n    _;\r\n  }\r\n\r\n   modifier onlyTransferAdmin() {\r\n    require(_transferAdmins.has(msg.sender), \u0022DOES NOT HAVE TRANSFER ADMIN ROLE\u0022);\r\n    _;\r\n  }\r\n\r\n  modifier onlyTransferAdminOrContractAdmin() {\r\n    require((_contractAdmins.has(msg.sender) || _transferAdmins.has(msg.sender)),\r\n    \u0022DOES NOT HAVE TRANSFER ADMIN OR CONTRACT ADMIN ROLE\u0022);\r\n    _;\r\n  }\r\n\r\n  modifier validAddress(address addr) {\r\n    require(addr != address(0), \u0022Address cannot be 0x0\u0022);\r\n    _;\r\n  }\r\n\r\n  /// @dev Authorizes an address holder to write transfer restriction rules\r\n  /// @param addr The address to grant transfer admin rights to\r\n  function grantTransferAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    _transferAdmins.add(addr);\r\n    emit RoleChange(msg.sender, addr, \u0022TransferAdmin\u0022, true);\r\n  }\r\n\r\n  /// @dev Revokes authorization to write transfer restriction rules\r\n  /// @param addr The address to grant transfer admin rights to\r\n  function revokeTransferAdmin(address addr) external validAddress(addr) onlyContractAdmin  {\r\n    _transferAdmins.remove(addr);\r\n    emit RoleChange(msg.sender, addr, \u0022TransferAdmin\u0022, false);\r\n  }\r\n\r\n  /// @dev Checks if an address is an authorized transfer admin.\r\n  /// @param addr The address to check for transfer admin privileges.\r\n  /// @return hasPermission returns true if the address has transfer admin permission and false if not.\r\n  function checkTransferAdmin(address addr) external view returns(bool hasPermission) {\r\n    return _transferAdmins.has(addr);\r\n  }\r\n\r\n  /// @dev Authorizes an address holder to be a contract admin. Contract admins grant privileges to accounts.\r\n  /// Contract admins can mint/burn tokens and freeze accounts.\r\n  /// @param addr The address to grant transfer admin rights to.\r\n  function grantContractAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    _contractAdmins.add(addr);\r\n    contractAdminCount = contractAdminCount.add(1);\r\n    emit RoleChange(msg.sender, addr, \u0022ContractAdmin\u0022, true);\r\n  }\r\n\r\n  /// @dev Revokes authorization as a contract admin.\r\n  /// The contract requires there is at least 1 Contract Admin to avoid locking the Contract Admin functionality.\r\n  /// @param addr The address to remove contract admin rights from\r\n  function revokeContractAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    require(contractAdminCount \u003E 1, \u0022Must have at least one contract admin\u0022);\r\n    _contractAdmins.remove(addr);\r\n    contractAdminCount = contractAdminCount.sub(1);\r\n    emit RoleChange(msg.sender, addr, \u0022ContractAdmin\u0022, false);\r\n  }\r\n\r\n  /// @dev Checks if an address is an authorized contract admin.\r\n  /// @param addr The address to check for contract admin privileges.\r\n  /// @return hasPermission returns true if the address has contract admin permission and false if not.\r\n  function checkContractAdmin(address addr) external view returns(bool hasPermission) {\r\n    return _contractAdmins.has(addr);\r\n  }\r\n\r\n  /// @dev Enforces transfer restrictions managed using the ERC-1404 standard functions.\r\n  /// The TransferRules contract defines what the rules are. The data inputs to those rules remains in the RestrictedToken contract.\r\n  /// TransferRules is a separate contract so its logic can be upgraded.\r\n  /// @param from The address the tokens are transferred from\r\n  /// @param to The address the tokens would be transferred to\r\n  /// @param value the quantity of tokens to be transferred\r\n  function enforceTransferRestrictions(address from, address to, uint256 value) private view {\r\n    uint8 restrictionCode = detectTransferRestriction(from, to, value);\r\n    require(transferRules.checkSuccess(restrictionCode), messageForTransferRestriction(restrictionCode));\r\n  }\r\n\r\n  /// @dev Calls the TransferRules detectTransferRetriction function to determine if tokens can be transferred.\r\n  /// detectTransferRestriction returns a status code.\r\n  /// @param from The address the tokens are transferred from\r\n  /// @param to The address the tokens would be transferred to\r\n  /// @param value The quantity of tokens to be transferred\r\n  function detectTransferRestriction(address from, address to, uint256 value) public view returns(uint8) {\r\n    return transferRules.detectTransferRestriction(address(this), from, to, value);\r\n  }\r\n\r\n  /// @dev Calls TransferRules to lookup a human readable error message that goes with an error code.\r\n  /// @param restrictionCode is an error code to lookup an error code for\r\n  function messageForTransferRestriction(uint8 restrictionCode) public view returns(string memory) {\r\n    return transferRules.messageForTransferRestriction(restrictionCode);\r\n  }\r\n\r\n  /// @dev Sets the maximum number of tokens an address will be allowed to hold.\r\n  /// Addresses can hold 0 tokens by default.\r\n  /// @param addr The address to restrict\r\n  /// @param updatedValue the maximum number of tokens the address can hold\r\n  function setMaxBalance(address addr, uint256 updatedValue) public validAddress(addr) onlyTransferAdmin {\r\n    _maxBalances[addr] = updatedValue;\r\n    emit AddressMaxBalance(msg.sender, addr, updatedValue);\r\n  }\r\n\r\n  /// @dev Gets the maximum number of tokens an address is allowed to hold\r\n  /// @param addr The address to check restrictions for\r\n  function getMaxBalance(address addr) external view returns(uint256) {\r\n    return _maxBalances[addr];\r\n  }\r\n\r\n  /// @dev Lock tokens in the address from being transfered until the specified time\r\n  /// @param addr The address to restrict\r\n  /// @param timestamp The time the tokens will be locked until as a Unix timetsamp.\r\n  /// Unix timestamp is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function setLockUntil(address addr, uint256 timestamp) public validAddress(addr)  onlyTransferAdmin {\r\n    _lockUntil[addr] = timestamp;\r\n    emit AddressTimeLock(msg.sender, addr, timestamp);\r\n  }\r\n  /// @dev A convenience method to remove an addresses timelock. It sets the lock date to 0 which corresponds to the\r\n  /// earliest possible timestamp in the past 00:00:00 UTC on 1 January 1970.\r\n  /// @param addr The address to remove the timelock for.\r\n  function removeLockUntil(address addr) external validAddress(addr) onlyTransferAdmin {\r\n    _lockUntil[addr] = 0;\r\n    emit AddressTimeLock(msg.sender, addr, 0);\r\n  }\r\n\r\n  /// @dev Check when the address will be locked for transfers until\r\n  /// @param addr The address to check\r\n  /// @return timestamp The time the address will be locked until.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getLockUntil(address addr) external view returns(uint256 timestamp) {\r\n    return _lockUntil[addr];\r\n  }\r\n\r\n  /// @dev Set the one group that the address belongs to, such as a US Reg CF investor group.\r\n  /// @param addr The address to set the group for.\r\n  /// @param groupID The uint256 numeric ID of the group.\r\n  function setTransferGroup(address addr, uint256 groupID) public validAddress(addr) onlyTransferAdmin {\r\n    _transferGroups[addr] = groupID;\r\n    emit AddressTransferGroup(msg.sender, addr, groupID);\r\n  }\r\n\r\n  /// @dev Gets the transfer group the address belongs to. The default group is 0.\r\n  /// @param addr The address to check.\r\n  /// @return groupID The group id of the address.\r\n  function getTransferGroup(address addr) external view returns(uint256 groupID) {\r\n    return _transferGroups[addr];\r\n  }\r\n\r\n  /// @dev Freezes or unfreezes an address.\r\n  /// Tokens in a frozen address cannot be transferred from until the address is unfrozen.\r\n  /// @param addr The address to be frozen.\r\n  /// @param status The frozenAddress status of the address. True means frozen false means not frozen.\r\n  function freeze(address addr, bool status) public validAddress(addr)  onlyTransferAdminOrContractAdmin {\r\n    _frozenAddresses[addr] = status;\r\n    emit AddressFrozen(msg.sender, addr, status);\r\n  }\r\n\r\n  /// @dev Checks the status of an address to see if its frozen\r\n  /// @param addr The address to check\r\n  /// @return status Returns true if the address is frozen and false if its not frozen.\r\n  function getFrozenStatus(address addr) external view returns(bool status) {\r\n    return _frozenAddresses[addr];\r\n  }\r\n\r\n  /// @dev A convenience method for updating the transfer group, lock until, max balance, and freeze status.\r\n  /// The convenience method also helps to reduce gas costs.\r\n  /// @param addr The address to set permissions for.\r\n  /// @param groupID The ID of the address\r\n  /// @param timeLockUntil The unix timestamp that the address should be locked until. Use 0 if it\u0027s not locked.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  /// @param maxBalance Is the maximum number of tokens the account can hold.\r\n  /// @param status The frozenAddress status of the address. True means frozen false means not frozen.\r\n  function setAddressPermissions(address addr, uint256 groupID, uint256 timeLockUntil,\r\n    uint256 maxBalance, bool status) public validAddress(addr) onlyTransferAdmin {\r\n    setTransferGroup(addr, groupID);\r\n    setLockUntil(addr, timeLockUntil);\r\n    setMaxBalance(addr, maxBalance);\r\n    freeze(addr, status);\r\n  }\r\n\r\n  /// @dev Sets an allowed transfer from a group to another group beginning at a specific time.\r\n  /// There is only one definitive rule per from and to group.\r\n  /// @param from The group the transfer is coming from.\r\n  /// @param to The group the transfer is going to.\r\n  /// @param lockedUntil The unix timestamp that the transfer is locked until. 0 is a special number. 0 means the transfer is not allowed.\r\n  /// This is because in the smart contract mapping all pairs are implicitly defined with a default lockedUntil value of 0.\r\n  /// But no transfers should be authorized until explicitly allowed. Thus 0 must mean no transfer is allowed.\r\n  function setAllowGroupTransfer(uint256 from, uint256 to, uint256 lockedUntil) external onlyTransferAdmin {\r\n    _allowGroupTransfers[from][to] = lockedUntil;\r\n    emit AllowGroupTransfer(msg.sender, from, to, lockedUntil);\r\n  }\r\n\r\n  /// @dev Checks to see when a transfer between two addresses would be allowed.\r\n  /// @param from The address the transfer is coming from\r\n  /// @param to The address the transfer is going to\r\n  /// @return timestamp The Unix timestamp of the time the transfer would be allowed. A 0 means never.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getAllowTransferTime(address from, address to) external view returns(uint timestamp) {\r\n    return _allowGroupTransfers[_transferGroups[from]][_transferGroups[to]];\r\n  }\r\n\r\n  /// @dev Checks to see when a transfer between two groups would be allowed.\r\n  /// @param from The group id the transfer is coming from\r\n  /// @param to The group id the transfer is going to\r\n  /// @return timestamp The Unix timestamp of the time the transfer would be allowed. A 0 means never.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getAllowGroupTransferTime(uint from, uint to) external view returns(uint timestamp) {\r\n    return _allowGroupTransfers[from][to];\r\n  }\r\n\r\n  /// @dev Destroys tokens and removes them from the total supply. Can only be called by an address with a Contract Admin role.\r\n  /// @param from The address to destroy the tokens from.\r\n  /// @param value The number of tokens to destroy from the address.\r\n  function burn(address from, uint256 value) external validAddress(from) onlyContractAdmin {\r\n    require(value \u003C= balanceOf(from), \u0022Insufficent tokens to burn\u0022);\r\n    _burn(from, value);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to create new tokens in a specified address.\r\n  /// The total number of tokens cannot exceed the maxTotalSupply (the \u0022Hard Cap\u0022).\r\n  /// @param to The addres to mint tokens into.\r\n  /// @param value The number of tokens to mint.\r\n  function mint(address to, uint256 value) external validAddress(to) onlyContractAdmin  {\r\n    require(SafeMath.add(totalSupply(), value) \u003C= maxTotalSupply, \u0022Cannot mint more than the max total supply\u0022);\r\n    _mint(to, value);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to pause transfers.\r\n  function pause() external onlyContractAdmin() {\r\n    isPaused = true;\r\n    emit Pause(msg.sender, true);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to unpause transfers.\r\n  function unpause() external onlyContractAdmin() {\r\n    isPaused = false;\r\n    emit Pause(msg.sender, false);\r\n  }\r\n\r\n  /// @dev Allows the contrac admin to upgrade the transfer rules.\r\n  /// The upgraded transfer rules must implement the ITransferRules interface which conforms to the ERC-1404 token standard.\r\n  /// @param newTransferRules The address of the deployed TransferRules contract.\r\n  function upgradeTransferRules(ITransferRules newTransferRules) external onlyContractAdmin {\r\n    require(address(newTransferRules) != address(0x0), \u0022Address cannot be 0x0\u0022);\r\n    address oldRules = address(transferRules);\r\n    transferRules = newTransferRules;\r\n    emit Upgrade(msg.sender, oldRules, address(newTransferRules));\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public validAddress(to) returns(bool success) {\r\n    require(value \u003C= balanceOf(msg.sender), \u0022Insufficent tokens\u0022);\r\n    enforceTransferRestrictions(msg.sender, to, value);\r\n    super.transfer(to, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public validAddress(from) validAddress(to) returns(bool success) {\r\n    require(value \u003C= allowance(from, to), \u0022The approved allowance is lower than the transfer amount\u0022);\r\n    require(value \u003C= balanceOf(from), \u0022Insufficent tokens\u0022);\r\n    enforceTransferRestrictions(from, to, value);\r\n    super.transferFrom(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function safeApprove(address spender, uint256 value) public {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n    require((value == 0) || (allowance(address(msg.sender), spender) == 0),\r\n        \u0022Cannot approve from non-zero to non-zero allowance\u0022\r\n    );\r\n    approve(spender, value);\r\n  }\r\n}\r\n\r\n// File: contracts/TransferRules.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\ncontract TransferRules is ITransferRules {\r\n    using SafeMath for uint256;\r\n    mapping(uint8 =\u003E string) internal errorMessage;\r\n\r\n    uint8 public constant SUCCESS = 0;\r\n    uint8 public constant GREATER_THAN_RECIPIENT_MAX_BALANCE = 1;\r\n    uint8 public constant SENDER_TOKENS_TIME_LOCKED = 2;\r\n    uint8 public constant DO_NOT_SEND_TO_TOKEN_CONTRACT = 3;\r\n    uint8 public constant DO_NOT_SEND_TO_EMPTY_ADDRESS = 4;\r\n    uint8 public constant SENDER_ADDRESS_FROZEN = 5;\r\n    uint8 public constant ALL_TRANSFERS_PAUSED = 6;\r\n    uint8 public constant TRANSFER_GROUP_NOT_APPROVED = 7;\r\n    uint8 public constant TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER = 8;\r\n\r\n  constructor() public {\r\n    errorMessage[SUCCESS] = \u0022SUCCESS\u0022;\r\n    errorMessage[GREATER_THAN_RECIPIENT_MAX_BALANCE] = \u0022GREATER THAN RECIPIENT MAX BALANCE\u0022;\r\n    errorMessage[SENDER_TOKENS_TIME_LOCKED] = \u0022SENDER TOKENS LOCKED\u0022;\r\n    errorMessage[DO_NOT_SEND_TO_TOKEN_CONTRACT] = \u0022DO NOT SEND TO TOKEN CONTRACT\u0022;\r\n    errorMessage[DO_NOT_SEND_TO_EMPTY_ADDRESS] = \u0022DO NOT SEND TO EMPTY ADDRESS\u0022;\r\n    errorMessage[SENDER_ADDRESS_FROZEN] = \u0022SENDER ADDRESS IS FROZEN\u0022;\r\n    errorMessage[ALL_TRANSFERS_PAUSED] = \u0022ALL TRANSFERS PAUSED\u0022;\r\n    errorMessage[TRANSFER_GROUP_NOT_APPROVED] = \u0022TRANSFER GROUP NOT APPROVED\u0022;\r\n    errorMessage[TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER] = \u0022TRANSFER GROUP NOT ALLOWED UNTIL LATER\u0022;\r\n  }\r\n\r\n  /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n  /// @param from Sending address\r\n  /// @param to Receiving address\r\n  /// @param value Amount of tokens being transferred\r\n  /// @return Code by which to reference message for rejection reason\r\n  function detectTransferRestriction(address _token, address from, address to, uint256 value) external view returns(uint8) {\r\n    RestrictedToken token = RestrictedToken(_token);\r\n    if (token.isPaused()) return ALL_TRANSFERS_PAUSED;\r\n    if (to == address(0)) return DO_NOT_SEND_TO_EMPTY_ADDRESS;\r\n    if (to == address(token)) return DO_NOT_SEND_TO_TOKEN_CONTRACT;\r\n\r\n    if (token.balanceOf(to).add(value) \u003E token.getMaxBalance(to)) return GREATER_THAN_RECIPIENT_MAX_BALANCE;\r\n    if (now \u003C token.getLockUntil(from)) return SENDER_TOKENS_TIME_LOCKED;\r\n    if (token.getFrozenStatus(from)) return SENDER_ADDRESS_FROZEN;\r\n\r\n    uint256 lockedUntil = token.getAllowTransferTime(from, to);\r\n    if (0 == lockedUntil) return TRANSFER_GROUP_NOT_APPROVED;\r\n    if (now \u003C lockedUntil) return TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER;\r\n\r\n    return SUCCESS;\r\n  }\r\n\r\n  /// @notice Returns a human-readable message for a given restriction code\r\n  /// @param restrictionCode Identifier for looking up a message\r\n  /// @return Text showing the restriction\u0027s reasoning\r\n  function messageForTransferRestriction(uint8 restrictionCode) external view returns(string memory) {\r\n    return errorMessage[restrictionCode];\r\n  }\r\n\r\n  /// @notice a method for checking a response code to determine if a transfer was succesful.\r\n  /// Defining this separately from the token contract allows it to be upgraded.\r\n  /// For instance this method would need to be upgraded if the SUCCESS code was changed to 1\r\n  /// as specified in ERC-1066 instead of 0 as specified in ERC-1404.\r\n  /// @param restrictionCode The code to check.\r\n  /// @return isSuccess A boolean indicating if the code is the SUCCESS code.\r\n  function checkSuccess(uint8 restrictionCode) external view returns(bool isSuccess) {\r\n    return restrictionCode == SUCCESS;\r\n  }\r\n}","ABI":"[{\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022transferRules_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022contractAdmin_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022tokenReserveAdmin_\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022symbol_\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022name_\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022decimals_\u0022,\u0022type\u0022:\u0022uint8\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022totalSupply_\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022maxTotalSupply_\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022constructor\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022AddressFrozen\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AddressMaxBalance\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AddressTimeLock\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AddressTransferGroup\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022fromGroup\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022toGroup\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lockedUntil\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022AllowGroupTransfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Approval\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022Pause\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022grantor\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022grantee\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022role\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022RoleChange\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:true,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transfer\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022admin\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022oldRules\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022newRules\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022Upgrade\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022MAX_UINT256\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022owner\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022allowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022approve\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022account\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022balanceOf\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022burn\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022checkContractAdmin\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022hasPermission\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022checkTransferAdmin\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022hasPermission\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022contractAdminCount\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022decimals\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022subtractedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022decreaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022detectTransferRestriction\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022freeze\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022getAllowGroupTransferTime\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getAllowTransferTime\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getFrozenStatus\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getLockUntil\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getMaxBalance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022getTransferGroup\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022groupID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022grantContractAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022grantTransferAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022addedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022increaseAllowance\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022isPaused\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022maxTotalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint8\u0022,\u0022name\u0022:\u0022restrictionCode\u0022,\u0022type\u0022:\u0022uint8\u0022}],\u0022name\u0022:\u0022messageForTransferRestriction\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022mint\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022name\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022pause\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022removeLockUntil\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022revokeContractAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022revokeTransferAdmin\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022spender\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022safeApprove\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022groupID\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timeLockUntil\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022maxBalance\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022status\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022name\u0022:\u0022setAddressPermissions\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022lockedUntil\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setAllowGroupTransfer\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022timestamp\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setLockUntil\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022updatedValue\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setMaxBalance\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022addr\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022groupID\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022setTransferGroup\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022symbol\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022string\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022totalSupply\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transfer\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022from\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022address\u0022,\u0022name\u0022:\u0022to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022internalType\u0022:\u0022uint256\u0022,\u0022name\u0022:\u0022value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022transferFrom\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022bool\u0022,\u0022name\u0022:\u0022success\u0022,\u0022type\u0022:\u0022bool\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[],\u0022name\u0022:\u0022transferRules\u0022,\u0022outputs\u0022:[{\u0022internalType\u0022:\u0022contract ITransferRules\u0022,\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022view\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[],\u0022name\u0022:\u0022unpause\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022internalType\u0022:\u0022contract ITransferRules\u0022,\u0022name\u0022:\u0022newTransferRules\u0022,\u0022type\u0022:\u0022address\u0022}],\u0022name\u0022:\u0022upgradeTransferRules\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022}]","ContractName":"RestrictedToken","CompilerVersion":"v0.5.12\u002Bcommit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005b097a5f2d5579912494dbbeef8c0c1c8e1fe170000000000000000000000000fb87c53b7770b451a5f193fe9e954d87d2872855000000000000000000000000a153dd6e4725c94066a7aa3425a3a737cfaf7c1200000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000758595a546573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000155265737472696374656420546f6b656e20546573740000000000000000000000","Library":"","SwarmSource":"bzzr://ccfbc6e4dd4827747e21570ea618016582b01d4b9bb253a408ff0135733064a9"}]