[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\ncontract RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n\r\n    function encodeBytes(bytes memory self) internal  returns (bytes memory) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 \u0026\u0026 uint8(self[0]) \u003C 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal  returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private  returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        bytes memory encoded;\r\n        uint encodedPtr;\r\n\r\n        uint len = self.length;\r\n        uint lenLen;\r\n        uint i = 0x1;\r\n        while(len/i != 0) {\r\n            lenLen\u002B\u002B;\r\n            i *= 0x100;\r\n        }\r\n\r\n        if(len \u003C= 55) {\r\n            encoded = new bytes(len\u002B1);\r\n\r\n            // length encoding byte\r\n            encoded[0] = byte(uint8(prefix1\u002Blen));\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        } else {\r\n            // 1 is the length of the length of the length\r\n            encoded = new bytes(1\u002BlenLen\u002Blen);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(uint8(prefix2\u002BlenLen));\r\n\r\n            // length bytes\r\n            for(i=1; i\u003C=lenLen; i\u002B\u002B) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    function flatten(bytes[] memory self) private  returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i\u003Cself.length; i\u002B\u002B) {\r\n            len \u002B= self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i\u003Cself.length; i\u002B\u002B) {\r\n            bytes memory item = self[i];\r\n\r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr \u002B= self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson\u0027s string utils library\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003E= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest \u002B= 32;\r\n            src \u002B= 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function strToBytes(string memory data)internal pure returns (bytes memory){\r\n        uint _ascii_0 = 48;\r\n        uint _ascii_A = 65;\r\n        uint _ascii_a = 97;\r\n\r\n        bytes memory a = bytes(data);\r\n        uint[] memory b = new uint[](a.length);\r\n\r\n        for (uint i = 0; i \u003C a.length; i\u002B\u002B) {\r\n            uint _a = uint8(a[i]);\r\n\r\n            if (_a \u003E 96) {\r\n                b[i] = _a - 97 \u002B 10;\r\n            }\r\n            else if (_a \u003E 66) {\r\n                b[i] = _a - 65 \u002B 10;\r\n            }\r\n            else {\r\n                b[i] = _a - 48;\r\n            }\r\n        }\r\n\r\n        bytes memory c = new bytes(b.length / 2);\r\n        for (uint _i = 0; _i \u003C b.length; _i \u002B= 2) {\r\n            c[_i / 2] = byte(uint8(b[_i] * 16 \u002B b[_i \u002B 1]));\r\n        }\r\n\r\n        return c;\r\n    }\r\n\r\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i\u003Cb.length;i\u002B\u002B){\r\n            number = number \u002B uint8(b[i])*(2**(8*(b.length-(i\u002B1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function stringToUint(string memory s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i \u003C b.length; i\u002B\u002B) {\r\n           if (uint8(b[i]) \u003E= 48 \u0026\u0026 uint8(b[i]) \u003C= 57){\r\n                result = result * 16 \u002B (uint8(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n            else if(uint8(b[i]) \u003E= 97 \u0026\u0026 uint8(b[i]) \u003C= 122)\r\n            {\r\n                result = result * 16 \u002B (uint8(b[i]) - 87);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function subString(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i \u003C endIndex; i\u002B\u002B) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length \u002B _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i \u003C _ba.length; i\u002B\u002B) bab[k\u002B\u002B] = _ba[i];\r\n            for (uint i = 0; i \u003C _bb.length; i\u002B\u002B) bab[k\u002B\u002B] = _bb[i];\r\n                return string(bab);\r\n        }\r\n\r\n    function stringToAddr(string memory _input) internal pure returns (address){\r\n        string memory _a = strConcat(\u00220x\u0022,_input);\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i\u003C2\u002B2*20; i\u002B=2){\r\n            iaddr *= 256;\r\n            b1 = uint8(tmp[i]);\r\n            b2 = uint8(tmp[i\u002B1]);\r\n            if ((b1 \u003E= 97)\u0026\u0026(b1 \u003C= 102)) b1 -= 87;\r\n            else if ((b1 \u003E= 48)\u0026\u0026(b1 \u003C= 57)) b1 -= 48;\r\n            if ((b2 \u003E= 97)\u0026\u0026(b2 \u003C= 102)) b2 -= 87;\r\n            else if ((b2 \u003E= 48)\u0026\u0026(b2 \u003C= 57)) b2 -= 48;\r\n            iaddr \u002B= (b1*16\u002Bb2);\r\n        }\r\n            return address(iaddr);\r\n    }\r\n\r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \u00220123456789abcdef\u0022;\r\n\r\n        bytes memory str = new bytes(40);\r\n\r\n        for (uint i = 0; i \u003C 20; i\u002B\u002B) {\r\n            str[i*2] = alphabet[uint8(value[i \u002B 12] \u003E\u003E 4)];\r\n            str[1\u002Bi*2] = alphabet[uint8(value[i \u002B 12] \u0026 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function toHexDigit(uint8 d) pure internal returns (byte) {                                                                                      \r\n        if (0 \u003C= d \u0026\u0026 d \u003C= 9) {                                                                                                                      \r\n            return byte(uint8(byte(\u00270\u0027)) \u002B d);                                                                                                       \r\n        } else if (10 \u003C= uint8(d) \u0026\u0026 uint8(d) \u003C= 15) {                                                                                               \r\n            return byte(uint8(byte(\u0027a\u0027)) \u002B d - 10);                                                                                                  \r\n        }                                                                                                                                            \r\n    }   \r\n    \r\n    function fromCode(bytes4 code) public pure returns (string memory) {                                                                                    \r\n        bytes memory result = new bytes(8);                                                                                                         \r\n        //result[0] = byte(\u00270\u0027);\r\n        //result[1] = byte(\u0027x\u0027);\r\n        for (uint i=0; i\u003C4; \u002B\u002Bi) {\r\n            result[2*i\u002B0] = toHexDigit(uint8(code[i])/16);\r\n            result[2*i\u002B1] = toHexDigit(uint8(code[i])%16);\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    \r\n    function getMsgHash(address _destination, string memory _value, string memory _strTransactionData)  internal returns (bytes32){\r\n\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        bytes[] memory bytesArray = new bytes[](9);\r\n\r\n        rawTx[0] = hex\u002209\u0022;\r\n        rawTx[1] = hex\u002209502f9000\u0022;\r\n        rawTx[2] = hex\u00225208\u0022;\r\n        rawTx[3] = addressToBytes(_destination);\r\n        rawTx[4] = strToBytes(_value);\r\n        rawTx[5] = strToBytes(_strTransactionData);\r\n        rawTx[6] = hex\u002201\u0022; //03=testnet,01=mainnet\r\n\r\n        for(uint8 i = 0; i \u003C 9; i\u002B\u002B){\r\n            bytesArray[i] = encodeBytes(rawTx[i]);\r\n        }\r\n\r\n        bytes memory bytesList = encodeList(bytesArray);\r\n\r\n        return keccak256(bytesList);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IVTImplementation\r\n * @dev Contract for Implementation applications.\r\n */\r\ncontract IVTImplementation is RLPEncode {\r\n    event Transacted(address _to, address _tokenContractAddress, uint256 _value);\r\n    event Errorlog(uint256 _type, string  _msg);\r\n    \r\n/**\r\n * @dev    ETH\u8F6C\u8D26\u903B\u8F91\u5904\u7406\uFF0C \u5916\u90E8\u51FD\u6570\r\n * @param  _destination \u6700\u7EC8\u8F6C\u8D26\u76EE\u6807\u5730\u5740\r\n * @param  _value \u6700\u7EC8\u8F6C\u8D26\u91D1\u989D\uFF0C\u5982\u002203e8\u0022\r\n * @param  _strTransactionData \u7B7E\u540D\u6570\u636E\uFF0Cv4\u7248\u672C\u6570\u636E\u7ED3\u6784 [User\u5730\u5740]\u002B[\u65F6\u95F4\u6233]\r\n * @param  _v v\u6570\u7EC4\uFF0C\u5982[27,28,28]\r\n * @param  _r r\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @param  _s s\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @return {[type]}\r\n */\r\n    function submitTransaction(address payable _destination, string memory _value, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s)  public {\r\n        IVTUserInterface userTemp = IVTUserInterface(address(this)); \r\n\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s, userTemp);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(userTemp, _msgHash, _v, _r, _s);\r\n\r\n        _destination.transfer(transactionValue); //\u6B64\u65F6\u7684\u4E0A\u4E0B\u6587\u4ECD\u4E3Auser\u5408\u7EA6\r\n\r\n        emit Transacted(_destination, address(0), transactionValue);\r\n    }\r\n\r\n/**\r\n * @dev Token\u8F6C\u8D26\u903B\u8F91\u5904\u7406\r\n * @param _destination \u6700\u7EC8\u8F6C\u8D26\u76EE\u6807\u5730\u5740\r\n * @param  _tokenAddress  Token\u5408\u7EA6\u5730\u5740\r\n * @param  _value \u6700\u7EC8\u8F6C\u8D26\u91D1\u989D\uFF0C\u5982\u002203e8\u0022\r\n * @param  _strTransactionData \u7B7E\u540D\u6570\u636E\uFF0Cv4\u7248\u672C\u6570\u636E\u7ED3\u6784 [User\u5730\u5740]\u002B[\u65F6\u95F4\u6233]\r\n * @param  _v v\u6570\u7EC4\uFF0C\u5982[27,28,28]\r\n * @param  _r r\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @param  _s s\u6570\u7EC4\uFF0C\u5982[\u0022\u0022,\u0022\u0022,\u0022\u0022]\r\n * @param  _tokenType Token\u7248\u672C\uFF0Cv4\u4F7F\u7528\u4E24\u79CD\u89C4\u8303\r\n * @return {[type]}\r\n */\r\n    function submitTransactionToken(address _destination, address _tokenAddress, string memory _value, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s, uint256  _tokenType)  public {\r\n        IVTUserInterface userTemp = IVTUserInterface(address(this)); \r\n\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s, userTemp);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        _strTransactionData = RLPEncode.strConcat(_strTransactionData, RLPEncode.addressToString(_tokenAddress));\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(userTemp, _msgHash, _v, _r, _s);\r\n\r\n        //\u6B64\u65F6\u7684\u4E0A\u4E0B\u6587\u4ECD\u4E3Auser\u5408\u7EA6--enum update to uint8 param by shitao. 10001 is ERC20_STANDARD ,10002 is ERC20_NONSTANDARD;\r\n        if(10001 == _tokenType){\r\n            ERC20StandardInterface instanceStandard = ERC20StandardInterface(_tokenAddress);\r\n            require(instanceStandard.transfer(_destination, transactionValue));\r\n        }else if(10002 == _tokenType){\r\n            ERC20NonStandardInterface instanceNonStandard = ERC20NonStandardInterface(_tokenAddress);\r\n            instanceNonStandard.transfer(_destination, transactionValue);\r\n        }else{\r\n            emit Errorlog(_tokenType, \u0022unknownType\u0022);\r\n        }\r\n\r\n        emit Transacted(_tokenAddress , _destination, transactionValue);\r\n    }\r\n\r\n/**\r\n * @dev    \u6821\u9A8C\u53C2\u6570\uFF0C\u5185\u90E8\u51FD\u6570\r\n * @param  _destination \u6700\u7EC8\u8F6C\u8D26\u76EE\u6807\u5730\u5740\r\n * @param  _strTransactionData \u7B7E\u540D\u6570\u636E\uFF0Cv4\u7248\u672C\u6570\u636E\u7ED3\u6784\u4E3A [user\u5408\u7EA6\u5730\u5740]\u002B[\u65F6\u95F4\u6233]\r\n * @param  _v \u5982\u4E0A\r\n * @param  _r \u5982\u4E0A\r\n * @param  _s \u5982\u4E0A\r\n * @return \r\n */\r\n    function processAndCheckParam(address _destination, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s, IVTUserInterface _userTemp) internal {\r\n        require(_destination != address(0)  \u0026\u0026 _v.length == _r.length \u0026\u0026 _v.length == _s.length \u0026\u0026 _v.length \u003E 0);\r\n\r\n        string memory strTransactionId = RLPEncode.subString(_strTransactionData, 40, 48);\r\n        uint256 transactionId = RLPEncode.stringToUint(strTransactionId);\r\n        require(!_userTemp.hasTransactionId(transactionId));\r\n\r\n\r\n        string memory strTransactionAddress = RLPEncode.subString(_strTransactionData, 0, 40);\r\n        address contractAddress = RLPEncode.stringToAddr(strTransactionAddress);\r\n\r\n        //\u591A\u7B7E\u5730\u5740 == user\u5730\u5740\r\n        require(contractAddress == address(_userTemp));\r\n\r\n        _userTemp.setTransactionId(transactionId);\r\n    }\r\n\r\n/**\r\n * @dev   \u5185\u90E8\u51FD\u6570\uFF0C\u6821\u9A8C\u7B7E\u540D\r\n * @param _msgHash \u7B7E\u540D\u6D88\u606FHash\r\n * @param  _v  \u5982\u4E0A\r\n * @param  _r  \u5982\u4E0A\r\n * @param  _s  \u5982\u4E0A\r\n * @return \r\n */\r\n    function verifySignatures(IVTUserInterface _userTemp, bytes32 _msgHash, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s) view internal {\r\n        uint8 hasConfirmed = 0;\r\n        address[] memory tempAddresses = new address[](_v.length);\r\n      \r\n        for (uint8 i = 0; i \u003C _v.length; i\u002B\u002B){\r\n            tempAddresses[i] = ecrecover(_msgHash, _v[i], _r[i], _s[i]);\r\n         \r\n            require(_userTemp.hasSigner(tempAddresses[i]));      \r\n            hasConfirmed\u002B\u002B;\r\n        }\r\n\r\n\r\n        for (uint8 m = 0; m \u003C _v.length; m\u002B\u002B){\r\n            for (uint8 n = m \u002B 1; n\u003C _v.length; n\u002B\u002B){\r\n                require(tempAddresses[m] != tempAddresses[n]);\r\n            }\r\n        }\r\n        require(hasConfirmed \u003E= _userTemp.getRequired());\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20StandardInterface {\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract ERC20NonStandardInterface {\r\n    function transfer(address _to, uint256 _value) public;\r\n}\r\n\r\ncontract IVTUserInterface {\r\n    function setTransactionId(uint256 _time) public;\r\n    function getRequired() public view returns (uint256);\r\n    function hasSigner(address _signer)public view returns(bool);\r\n    function hasTransactionId(uint256 _transactionId)public view returns(bool);\r\n}","ABI":"[{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_destination\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_tokenAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_strTransactionData\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_v\u0022,\u0022type\u0022:\u0022uint8[]\u0022},{\u0022name\u0022:\u0022_r\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022name\u0022:\u0022_s\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022name\u0022:\u0022_tokenType\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022submitTransactionToken\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:true,\u0022inputs\u0022:[{\u0022name\u0022:\u0022code\u0022,\u0022type\u0022:\u0022bytes4\u0022}],\u0022name\u0022:\u0022fromCode\u0022,\u0022outputs\u0022:[{\u0022name\u0022:\u0022\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022pure\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022constant\u0022:false,\u0022inputs\u0022:[{\u0022name\u0022:\u0022_destination\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_strTransactionData\u0022,\u0022type\u0022:\u0022string\u0022},{\u0022name\u0022:\u0022_v\u0022,\u0022type\u0022:\u0022uint8[]\u0022},{\u0022name\u0022:\u0022_r\u0022,\u0022type\u0022:\u0022bytes32[]\u0022},{\u0022name\u0022:\u0022_s\u0022,\u0022type\u0022:\u0022bytes32[]\u0022}],\u0022name\u0022:\u0022submitTransaction\u0022,\u0022outputs\u0022:[],\u0022payable\u0022:false,\u0022stateMutability\u0022:\u0022nonpayable\u0022,\u0022type\u0022:\u0022function\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_to\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_tokenContractAddress\u0022,\u0022type\u0022:\u0022address\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_value\u0022,\u0022type\u0022:\u0022uint256\u0022}],\u0022name\u0022:\u0022Transacted\u0022,\u0022type\u0022:\u0022event\u0022},{\u0022anonymous\u0022:false,\u0022inputs\u0022:[{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_type\u0022,\u0022type\u0022:\u0022uint256\u0022},{\u0022indexed\u0022:false,\u0022name\u0022:\u0022_msg\u0022,\u0022type\u0022:\u0022string\u0022}],\u0022name\u0022:\u0022Errorlog\u0022,\u0022type\u0022:\u0022event\u0022}]","ContractName":"IVTImplementation","CompilerVersion":"v0.5.2\u002Bcommit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dd8cf2bad448a310c3414ac7a65eaa63d1e423d442015408f85f574d8ca91c4c"}]